<rrxdescription hide="self">
<rrx4app>

<rrx namespace="PageID" v="8.0.1.07">
	<i ref="rrunner">
	</i>
	<i ref="barcode_x">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['*********************************]]>
<![CDATA[
]]>
<![CDATA['Page Identification Actions]]>
<![CDATA[
]]>
<![CDATA['PageID.rrx]]>
<![CDATA[
]]>
<![CDATA['Datacap Inc. (c)2006-2010.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version ]]>
<![CDATA[
]]>
<![CDATA['  8.0.0.0 - Tom Stuart 11/26/09]]>
<![CDATA[
]]>
<![CDATA['  8.0.0.1 - 03/31/10 RFerin Added smart parameter support to PageIDByBCSep.]]>
<![CDATA[
]]>
<![CDATA['  8.0.4   - 08/02/10 RFerin & Tom Stuart]]>
<![CDATA[
]]>
<![CDATA['          - Added g tags to make the XML format more compliant and help with editing.  Requires buildvbs.rls 1.0.2.2.]]>
<![CDATA[
]]>
<![CDATA['          - 28188 Added help text to actions.]]>
<![CDATA[
]]>
<![CDATA['  8.0.5   - 09/02/10 Tom Stuart]]>
<![CDATA[
]]>
<![CDATA['          - fixed bug in ProcessVarChangeBatch SPR 29521]]>
<![CDATA[
]]>
<![CDATA['  8.0.6   - 09/02/10 RFerin 29521 minor DStudio help updates]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.07"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/07/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA['   8.1.0 - Tom Stuart - 5/10/12 33801 Added help text to PageIDBySeqTypes]]>
<![CDATA[
]]>
<![CDATA['   8.1.1 - Tom Stuart - 5/12/12  Enhanced help text on PageIDByVariableChange]]>
<![CDATA[
]]>
<![CDATA['*********************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
	<af name="PageIDByBCSep" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Separates pages using barcode separator sheets.">
		<ap>
<![CDATA[
]]>
<![CDATA[    Two comma separated input parameters]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    1. The path and location of the settings file.  Smart Parameters are supported.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    2. The barcode page type to locate.  Smart Parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action processes all pages with a type of "Other", looking for barcodes that match the]]>
<![CDATA[
]]>
<![CDATA[    input page type, indicating the start of a document.  The settings file is]]>
<![CDATA[
]]>
<![CDATA[    required to have a "PageID_LastType-ThisType" Section.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[PageIDByBCSep("@APPPATH(dco_APT)+\settings.ini,Main_Page")]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following is a sample Settings.INI file entry:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      [PageID_LastType-ThisType]]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      Document_Separator=Main_Page]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      Attachment_Separator=Attachment]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      Main_Page=Trailing_Page]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      Trailing_Page=Trailing_Page]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      Attachment=Attachment]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[
]]>
<![CDATA[    Batch level.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[Dim SettingsFile]]>
<![CDATA[
]]>
<![CDATA[Dim DefaultPageType]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   PageIDByBCSep = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = SPLIT(strParam,",")]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Wrong number of parameters.  Expecting (INIFileName,DefaultPageType).  Exiting")]]>
<![CDATA[
]]>
<![CDATA[	  Exit Function]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      SettingsFile = MetaWord(Trim(ParamAr(0)))]]>
<![CDATA[
]]>
<![CDATA[      DefaultPageType = MetaWord(Trim(ParamAr(1)))]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   if Not oFS.FileExists(SettingsFile) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Settings file: " & SettingsFile & " , was not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[	else]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Settings file found: " & SettingsFile)	]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Call ProcessBCSepBatch(DCO,SettingsFile,DefaultPageType,false,"None")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="PageIDBySeqTypes" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="">
		<ap>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action processes all pages with a type of "Other".  The parameter is the serial list of page types to assign to the batch.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[          PageIDBySeqTypes(Front,Back)]]>
<![CDATA[
]]>
<![CDATA[          The action will set the page types of the batch to Front, Back, Front, Back, Front, etc.     ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[
]]>
<![CDATA[    Batch level.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[Dim SettingsFile]]>
<![CDATA[
]]>
<![CDATA[Dim DefaultPageType]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   PageIDBySeqTypes = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[   Call ProcessSeqTypesBatch(DCO,ParamAr,0)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="PageIDByVariableChange" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="">
		<ap>
<![CDATA[
]]>
<![CDATA[    Three comma separated variables:]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    1. The variable that will change when a new document starts]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    2. The page type of the first page of the new document.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    3. The page type that will be assigned to any trailing page in the document.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action processes all pages with a type set according to the input parameters.  When pages are for PageID, a variable can be "watched" so that when it changes ]]>
<![CDATA[
]]>
<![CDATA[a new page type will be triggered.  This method is popular in restoring document structure from multi-page TIFFs or PDFs that went through a VScan process and have ]]>
<![CDATA[
]]>
<![CDATA[been split into single images.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[PageIDByVariableChange("ScanSrcPath,Main_Page,Trailing_Page")]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[     These variables will watch the variable containing the source image set by vScan.  When the variable changes, the first page will be set to Main_Page, and any ]]>
<![CDATA[
]]>
<![CDATA[other pages that have the same value in ScanSrcPath that immediately follow will be set to Trailing_Page.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[
]]>
<![CDATA[    Batch level.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[Dim SettingsFile]]>
<![CDATA[
]]>
<![CDATA[Dim DefaultPageType]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   PageIDByVariableChange = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Wrong number of parameters.  Expecting (PageLevelVarName,MainPageType,TrailingPageType)")]]>
<![CDATA[
]]>
<![CDATA[      ' TOM SHOULD THERE BE AN EXIT FUNCTION HERE?]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   Call ProcessVarChangeBatch(DCO,ParamAr,"")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
		</g>
	</af>
</rrx></rrx4app><rrx4all>

<rrx namespace="Barcode_P" v="8.1.0.24">
	<i ref="rrunner">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' Barcode_p.rrx       ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' "Restricted Materials of IBM"]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' (c) Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.0.14" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/29/2007 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   - RRX help text]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 1/20/2009 NSK]]>
<![CDATA[
]]>
<![CDATA[' Search full page if no POSITION specified at page level, explicitly set Text variable at page level]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.3"]]>
<![CDATA[
]]>
<![CDATA[' Updated 1/21/2009 NSK]]>
<![CDATA[
]]>
<![CDATA[' Changed name of ReadBarcode (private function) to ReadBarcodeP to avoid conflict with Bar/X]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 1/28/2009 NSK]]>
<![CDATA[
]]>
<![CDATA[' Lowered default confidence required from 81 to 75]]>
<![CDATA[
]]>
<![CDATA[' Pays attention to DCO variable ReqConf it is exists - maps 0-9 to 1-91 required]]>
<![CDATA[
]]>
<![CDATA[' DCO variable settings added: or, value 0-3 for orientations 0-both, 1-horiz, 2-vert, 3-both+diag,]]>
<![CDATA[
]]>
<![CDATA['		enhance=0 to disable image enhancement]]>
<![CDATA[
]]>
<![CDATA[' Successful read now sets DCO variables Confidence (%), Height (pixels), Width, Left, Top, Skew, Retry]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/23/2009 Rferin]]>
<![CDATA[
]]>
<![CDATA['   SPR 24821 - Added help to bc2d_ReadDataMatrixCode, bc2d_Read2DCode & bc2d_ReadBarcode]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/30/2009 Rferin]]>
<![CDATA[
]]>
<![CDATA['   SPR 27055 - Log message update for missing variable in bc2d_ReadBarcode.]]>
<![CDATA[
]]>
<![CDATA['   Added G tags to make the XML format more compliant and help with editing.  Requires buildvbs.rls 1.0.2.2.]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/29/2010 MSchlachter]]>
<![CDATA[
]]>
<![CDATA['   SPR 25177 - When called on the page level the result is saved to a variable called GetBarCode.]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/7/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   SPR 29414 - Barcode2D.rrx renamed to barcode_p.rrx ]]>
<![CDATA[
]]>
<![CDATA['               All internal functions have been updated to contain the suffix BP]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['               Following actions have been renamed:]]>
<![CDATA[
]]>
<![CDATA['               bc2d_ReadBarcode -> GetBarcodeBP]]>
<![CDATA[
]]>
<![CDATA['               bc2d_Read2DCode -> Get2DCodeBP]]>
<![CDATA[
]]>
<![CDATA['               bc2d_ReadDataMatrixCode -> GetDataMatrixCode]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['               Following actions have been added:]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['               ReadBarcodeBP(text to match) - compares the value of the first barcode with the value of the passed parameter, returns true only if a match is found.]]>
<![CDATA[
]]>
<![CDATA['               MatchBarcodeBP(text to match) - compares the value of all barcodes with the value of the passed parameter, returns true only if a match is found.]]>
<![CDATA[
]]>
<![CDATA['               GetAllBarcodesBP(separator) - stores all the barcodes found in variable GetBarcodeList, using the paramater as separator]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.3"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/08/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Internal function GetBarcodeIDBP (which logs which barcodes are enabled based on the bp_tp variable) has been updated to include missing "DATALOGIC 2 OF 5" barcode type.]]>
<![CDATA[
]]>
<![CDATA[' Added new (hidden) action MatchBarcodePrefixBP which looks for barcodes starting with the prefix specified in the parameter. Works the same as MatchBarcodeBP, except]]>
<![CDATA[
]]>
<![CDATA[' it matches a barcode prefix instead of the entire barcode text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/04/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes issue where the variable "NumBarcodes" would not get saved in the calling object when a barcode is read with high confidence]]>
<![CDATA[
]]>
<![CDATA[' in the first pass, causing ReadBarcode and MatchBarcode to incorrectly return a false when there is a match.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/06/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes issue where action GetAllBarcodesBP would only store the last barcode in the variable GetBarcodeList]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/08/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' GetAllBarcodesBP returns true in cases where a barcode is not found.]]>
<![CDATA[
]]>
<![CDATA[' Update action ReadBarcodeBP to cleanup bp_su variable]]>
<![CDATA[
]]>
<![CDATA[' Solves issue where not all barcodes would be read when the barcode type was set to "unknown" (when runtime/setup variable bp_tp did not exist at the calling object's level)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/08/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated documentation to remove the statement that implied that the "bp_tp" variable is required when the action GetBarcodeBP is used.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/08/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Rolled back change in version 8.0.0.6 where barcode unknown was translated to turn on all barcode types.]]>
<![CDATA[
]]>
<![CDATA[' Updated documentation to state that when the barcode is "Unknown", the barcode types PatchCode and PDF417 are not automatically detected and have to be explicitly]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/11/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes script error that would cause abort in Get2DCodeBP and GetDataMatrixCodeBP. ]]>
<![CDATA[
]]>
<![CDATA[' Updated documentation for ReadBarcdeoBP and GetBarcodeBP actions]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/07/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Uses the ScanFix object exposed in dcbc2dNet.dll]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/08/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Solves script error caused by newlines]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/08/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' BarcodeX, ImgXPress, and ScanFix objects are now instantiated and disposed in the fReadBarcodeBP helper function in barcode_p.rrx]]>
<![CDATA[
]]>
<![CDATA[' When the first barcode recognition has failed, we now pass the direct image HDIB to ScanFix instead of making a copy, to perform smoothZoom (cleaning) and retyuing barcode recognition.]]>
<![CDATA[
]]>
<![CDATA[' Solves issue with memory leak with the use of ScanFix 6 in the barcode actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/08/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated the GetBarcodeBP action help to list the possible string values returned by the engine when the barcode type is set to Patch Code.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/07/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/12/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' When the first barcode recognition attempt returns empty results, the second attempt logic now saves a temporary copy of the image to disk]]>
<![CDATA[
]]>
<![CDATA[' (this image could be an image snippet or the full image depending on the level where recognition is run -zonal or full page). The logic]]>
<![CDATA[
]]>
<![CDATA[' then calls the new SmoothZoom method from the dcbc2d.net.dll wrapper and passes the temporary image for image processing. On the second attempt to read]]>
<![CDATA[
]]>
<![CDATA[' a barcode, the temporary image is used. If a barcode is not found, the action exits. At the end of the action the temporary file is deleted. The second ]]>
<![CDATA[
]]>
<![CDATA[' barcode recognition attempt no longer passes an image HDIB pointer to the wrapper as this was causing the wrapper to behave abnormally.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/13/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated the barcode recognition retry logic to abort if the Scanfix object cannot be created or throws an exception while enhancing the image. The]]>
<![CDATA[
]]>
<![CDATA[' error coming from the dcbc2d.net.dll is logged for debugging purposes.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/08/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes abug where barcodes with a confidence smaller than the minimum required would not be filtered out of the final results.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/13/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Instances to objects from dc2bc.dll have been replaced by instances of objects from the Unicode compatible dc2bc.net.dll]]>
<![CDATA[
]]>
<![CDATA[' Added IBM Copyright Notice]]>
<![CDATA[
]]>
<![CDATA[' Replaced instances of CHR by CHRW to support Unicode.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.19" ]]>
<![CDATA[
]]>
<![CDATA[' JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated barcode recognition action to abort only if the helper DLL dcbc2d.net.dll contains an error status after a barcode ]]>
<![CDATA[
]]>
<![CDATA[' ImageXpress object is now queried from the dcbc2d.net.dll object]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.20" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/15/11 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Made necessary changes to integrate with the latest BarcodeXPress (v7.0) and ImageXPress (v10.0) libraries. Requires dcbc2d.net.dll v8.1.0.4 or above.]]>
<![CDATA[
]]>
<![CDATA[' - The feature to perform smooth zoom on an image and retry barcode recognition when the first pass of barcode recognition does not return results, is now OFF by default. Can be ]]>
<![CDATA[
]]>
<![CDATA[' turned ON by setting the variable "bp_enhance" to "1". ]]>
<![CDATA[
]]>
<![CDATA[' - Added logging for the following new barcode types supported in BarcodeXPress v7.0: QRCode, IntelligentMail, RoyalPost4State, AustralianPost4State, and TypeAztec.]]>
<![CDATA[
]]>
<![CDATA[' - Cleaned logging]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.21" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/17/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Implemented the following changes to speed up barcode recognition:]]>
<![CDATA[
]]>
<![CDATA['   - Zonal barcode recognition not longer creates a cropped image from the parent image, instead the zone positions are set explicitly via the BarcodeXpress object.]]>
<![CDATA[
]]>
<![CDATA['   - The BarcodeXpress and ImagXpress engines are loaded once per batch.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.22" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/18/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated action help for GetBarcodeBP to list additional barcodes supported by BarcodeXpress 7.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.23" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/13/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Solves issue where barcode detection at the page level would return different results (not the same number of barcodes detected) when run at the field level. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.24" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/03/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Removed duplicate call to barcode recognition.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' LOG THE VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("barcode_p.rrx Version " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['********************************************************************]]>
<![CDATA[
]]>
<![CDATA[Const BC2OF5 = 1]]>
<![CDATA[
]]>
<![CDATA[Const BCI2OF5 = 2]]>
<![CDATA[
]]>
<![CDATA[Const BCIATA2OF5 = 4]]>
<![CDATA[
]]>
<![CDATA[Const BCDATA2OF5 = 8]]>
<![CDATA[
]]>
<![CDATA[Const BCIN2OF5 = 16]]>
<![CDATA[
]]>
<![CDATA[Const BCMATRIX = 32]]>
<![CDATA[
]]>
<![CDATA[Const BCMATRIX2OF5 = 64]]>
<![CDATA[
]]>
<![CDATA[Const BC32 = 128]]>
<![CDATA[
]]>
<![CDATA[Const BC39 = 256]]>
<![CDATA[
]]>
<![CDATA[Const BCCODABAR2 = 512]]>
<![CDATA[
]]>
<![CDATA[Const BC93 = 1024]]>
<![CDATA[
]]>
<![CDATA[Const BC128 = 2048]]>
<![CDATA[
]]>
<![CDATA[Const BCEAN13 = 4096]]>
<![CDATA[
]]>
<![CDATA[Const BCEAN8 = 8192]]>
<![CDATA[
]]>
<![CDATA[Const BCUPCA = 16384]]>
<![CDATA[
]]>
<![CDATA[Const BCUPCE = 32768]]>
<![CDATA[
]]>
<![CDATA[Const BCADD5 = 65536]]>
<![CDATA[
]]>
<![CDATA[Const BCADD2 = 131072]]>
<![CDATA[
]]>
<![CDATA[Const BCUCC128EAN128 = 262144]]>
<![CDATA[
]]>
<![CDATA[Const BCPATCH = 524288]]>
<![CDATA[
]]>
<![CDATA[Const BCPOSTNET = 1045876]]>
<![CDATA[
]]>
<![CDATA[Const BCPDF417 = 2097152]]>
<![CDATA[
]]>
<![CDATA[Const BCDATAMATRIX = 4194304]]>
<![CDATA[
]]>
<![CDATA[Const BC39EXT = 8388608]]>
<![CDATA[
]]>
<![CDATA[Const BC93EXT = 16777216]]>
<![CDATA[
]]>
<![CDATA['the following are new barcode types exposed in BarcodeXpress 7.0, there is no current UI in DStudio for these (as of 12/15/2011)]]>
<![CDATA[
]]>
<![CDATA[Const QRCode = 33554432]]>
<![CDATA[
]]>
<![CDATA[Const IntelligentMail = 67108864]]>
<![CDATA[
]]>
<![CDATA[Const RoyalPost4State = 134217728]]>
<![CDATA[
]]>
<![CDATA[Const AustralianPost4State = 268435456]]>
<![CDATA[
]]>
<![CDATA[Const TypeAztec = 536870912]]>
<![CDATA[
]]>
<![CDATA[Dim oDC2DBC]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<af name="GetAllBarcodesBP" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Searches all the barcodes on the current page and writes them to the calling object's GetBarcodeList variable.">
		<ap>
<![CDATA[The sepator to use when storing multiple barcodes. The default separator is a comma.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Searches all the barcodes on the current page and stores them in the calling object's GetBarcodeList variable. Each barcode value is separated using the string separator value entered as a parameter.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If the engine does not detect any barcodes, then the variable GetBarcodeList is not populated nor created.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[GetAllBarcodesBP(",")]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page and field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the action is called at the page level or field level. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      In addition the calling object's value and variable "GetBarcode" will be filled with the bar code value. This action also]]>
<![CDATA[
]]>
<![CDATA[      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than]]>
<![CDATA[
]]>
<![CDATA[      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarcodeX" where "X" is the index of]]>
<![CDATA[
]]>
<![CDATA[      the barcode found.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<see>
<![CDATA[GetAllBarcodesBP]]>
		</see>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    GetAllBarcodesBP = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		  Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	  End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Trim(strParam) = "" Then strParam = ","]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	  l_bRet = GetBarcodeBP(true,true)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If l_bRet = False Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("NumBarcodes") = "0" OR CurrentObj.Variable("NumBarcodes") = "" Then Exit Function ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_iBarcodes = CInt(CurrentObj.Variable("NumBarcodes"))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    For l_iIndex = 0 to l_iBarcodes - 1]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("GetBarCode" & l_iIndex) <> "" Then ]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("GetBarCodeList")  = CurrentObj.Variable("GetBarCodeList") & CurrentObj.Variable("GetBarCode" & l_iIndex) & strParam]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Right(CurrentObj.Variable("GetBarCodeList"),1) = strParam Then]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Variable("GetBarCodeList") = Left(CurrentObj.Variable("GetBarCodeList"), Len(CurrentObj.Variable("GetBarCodeList"))-1)]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    GetAllBarcodesBP = true]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="GetBarcodeBP" access="public" bInter="bInter" bDebug="bDebug" qi="Recognizes arbitrary 1D or 2D codes.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<lvl>
<![CDATA[Page or Field level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the action is called at the page level or field level. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      In addition the calling object's value and variable "GetBarcode" will be filled with the bar code value. This action also]]>
<![CDATA[
]]>
<![CDATA[      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than]]>
<![CDATA[
]]>
<![CDATA[      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarcodeX" where "X" is the index of]]>
<![CDATA[
]]>
<![CDATA[      the barcode found.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Use this action if your page has 1D or 2D barcodes.  Any field must have a Position assigned]]>
<![CDATA[
]]>
<![CDATA[      when bar code reading is performed.  For example the application would invoke the]]>
<![CDATA[
]]>
<![CDATA[      CreateFields action, and if the field has Position defined in the Document Hierarchy,]]>
<![CDATA[
]]>
<![CDATA[      it is ready for barcode reading.  If anchors or fingerprint matching are used,]]>
<![CDATA[
]]>
<![CDATA[      ReadZones or other registration may be required to align the fields correctly.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      To explictly tell the engine which barcode type(s) to be read, the field/page being recognized]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      should contain a variable (or setup property) called ]]>
			<b>
<![CDATA[bp_tp]]>
			</b>
<![CDATA[. If the "bp_tp" variable is empty or does not exist,]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      the engine detaults to "Unknown" (please see notes for "Unknown" below).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The value of this variable must be a combination of the barcode types shown below (this variable is automatically ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      set when choosing the barcode types through DStudio's Zones tab, under the BAR/P recognition settings).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Multiple types can be read by adding the values of their codes together. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When the barcode type is set to ]]>
			<b>
<![CDATA[Patch Code]]>
			</b>
<![CDATA[, the following string values may be returned by the engine (the string value depends on the type of Patch Code]]>
<![CDATA[
]]>
<![CDATA[      that is found): ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[Patch 1: ]]>
			<b>
<![CDATA[1100]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[Patch 2: ]]>
			<b>
<![CDATA[1001]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[Patch 3: ]]>
			<b>
<![CDATA[1010]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[Patch 4 / Toggle Patch: ]]>
			<b>
<![CDATA[0110]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[Patch 6: ]]>
			<b>
<![CDATA[0011]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[Patch T / Transfer patch: ]]>
			<b>
<![CDATA[0101]]>
			</b>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Valid barcode types:]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      0        : Unknown. Detects all barcode types automtically, in the exception of PatchCode and PDF417. These have to be set explicitly to be detected.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      1        : INDUSTRY 2 OF 5]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      2        : INTERLEAVED 2 OF 5]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      4        : IATA 2 OF 5]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      8        : DATALOGIC 2 OF 5]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      16       : INVERT 2 OF 5]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      32       : BCD MATRIX]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      64       : MATRIX 2 OF 5]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      128      : CODE 32]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      256      : CODE 39]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      512      : CODABAR 2]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      1024     : CODE 93]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      2048     : CODE 128]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      4096     : EAN-13]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      8192     : EAN-8]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      16384    : UPC-A]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      32768    : UPC-E]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      65536    : ADD 5]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      131072   : ADD 2]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      262144   : UCC128/EAN-128]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      524288   : Patch Code]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      1048576  : PostNet]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      2097152  : PDF417]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      4194304  : DataMatrix]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      8388608  : Code 39 Extended]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      16777216 : Code 93 Extended]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      33554432 : QRCode]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      67108864 : IntelligentMail]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      134217728: Royal Mail (RM4SCC)]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      268435456: Australian Post 4-State Code]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      536870912: Aztec]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[GetBarcodeBP()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[	GetBarcodeBP = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  fReadBarcodeBP(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  GetBarcodeBP = True]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="GetDataMatrixCodeBP" access="public" bInter="bInter" bDebug="bDebug" qi="Recognizes Data Matrix codes">
		<ap>
<![CDATA[None.]]>
		</ap>
		<lvl>
<![CDATA[Page or Field level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the action is called at the page level or field level. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      In addition the calling object's value and variable "GetBarcode" will be filled with the bar code value. This action also]]>
<![CDATA[
]]>
<![CDATA[      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than]]>
<![CDATA[
]]>
<![CDATA[      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarcodeX" where "X" is the index of]]>
<![CDATA[
]]>
<![CDATA[      the barcode found.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Use this action if your page or field has Data Matrix codes.  Any field must have a Position assigned]]>
<![CDATA[
]]>
<![CDATA[      when bar code reading is performed.  For example the application would invoke the]]>
<![CDATA[
]]>
<![CDATA[      CreateFields action, and if the field has Position defined in the Document Hierarchy,]]>
<![CDATA[
]]>
<![CDATA[      it is ready for barcode reading.  If anchors or fingerprint matching are used,]]>
<![CDATA[
]]>
<![CDATA[      ReadZones or other registration may be required to align the fields correctly.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[GetDataMatrixCodeBP()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	GetDataMatrixCodeBP = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("bp_tp") = "4194304"]]>
<![CDATA[
]]>
<![CDATA[	GetDataMatrixCodeBP = fReadBarcodeBP(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.DeleteVariable("bp_tp")]]>
<![CDATA[
]]>
<![CDATA[  GetDataMatrixCodeBP = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="Get2DCodeBP" access="public" bInter="bInter" bDebug="bDebug" qi="Recognizes PDF-417 codes.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<lvl>
<![CDATA[Page or Field level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the action is called at the page level or field level. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      In addition the calling object's value and variable "GetBarcode" will be filled with the bar code value. This action also]]>
<![CDATA[
]]>
<![CDATA[      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than]]>
<![CDATA[
]]>
<![CDATA[      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarcodeX" where "X" is the index of]]>
<![CDATA[
]]>
<![CDATA[      the barcode found.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Use this action if your page has PDF-417 codes.  Any field must have a Position assigned]]>
<![CDATA[
]]>
<![CDATA[      when bar code reading is performed.  For example the application would invoke the]]>
<![CDATA[
]]>
<![CDATA[      CreateFields action, and if the field has Position defined in the Document Hierarchy,]]>
<![CDATA[
]]>
<![CDATA[      it is ready for barcode reading.  If anchors or fingerprint matching are used,]]>
<![CDATA[
]]>
<![CDATA[      ReadZones or other registration may be required to align the fields correctly.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Get2DCodeBP()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Get2DCodeBP = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("bp_tp") = "2097152"]]>
<![CDATA[
]]>
<![CDATA[	Get2DCodeBP = fReadBarcodeBP(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.DeleteVariable("bp_tp")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Get2DCodeBP = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="MatchBarcodeBP" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Searches all the barcodes on the current page and checks if one matches the value you enter as a parameter.">
		<ap>
<![CDATA[The String value of the barcode.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Searches all the barcodes on the current page and checks if one of the barcodes matches the parameter value.]]>
<![CDATA[
]]>
<![CDATA[      If a match occurs, the barcode's value is placed into a page level variable called 'GetBarCode'.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Refer to action GetBarCode for information regarding barcode configuration in Datacap Studio.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MatchBarcodeBP("2008")]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level and field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the action is called at the page level or field level and one of the barcode values on the page]]>
<![CDATA[
]]>
<![CDATA[      matches the parameter value (parameter value must not be empty).  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[ ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      In addition the calling object's value and variable "GetBarcode" will be filled with the bar code value. This action also]]>
<![CDATA[
]]>
<![CDATA[      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than]]>
<![CDATA[
]]>
<![CDATA[      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarcodeX" where "X" is the index of]]>
<![CDATA[
]]>
<![CDATA[      the barcode found.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<see>
<![CDATA[GetBarCodeBP]]>
		</see>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    MatchBarcodeBP = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		  Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	  End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Trim(strParam) = "" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "This action requires a parameter with the barcode text value to match. None has been specified, exiting."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	  l_bRet = GetBarcodeBP(true,true)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If l_bRet = False Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("NumBarcodes") = "0" OR CurrentObj.Variable("NumBarcodes") = "" Then Exit Function ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_iBarcodes = CInt(CurrentObj.Variable("NumBarcodes"))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    For l_iIndex = 0 to l_iBarcodes - 1]]>
<![CDATA[
]]>
<![CDATA[      If strParam = CurrentObj.Variable("GetBarCode" & l_iIndex) Then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "'" & strParam & "' match found in '" & CurrentObj.Variable("GetBarCode" & l_iIndex) & "'"]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("GetBarCode") =  CurrentObj.Variable("GetBarCode" & l_iIndex)]]>
<![CDATA[
]]>
<![CDATA[        MatchBarcodeBP = True]]>
<![CDATA[
]]>
<![CDATA[        Exit For]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not MatchBarcodeBP Then Writelog "A barcode matching the text '" & strParam & "' was not found."]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="ReadBarCodeBP" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Tests the first barcode found with the value specified by the parameter.">
		<ap>
<![CDATA[A single string value of the barcode.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Checks if the current page contains a barcode with the value specified by the parameter.]]>
<![CDATA[
]]>
<![CDATA[      This action uses the first barcode it encounters.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      One possible use of this action is to identify a document's Separator page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Refer to action GetBarCode for information regarding barcode configuration in Datacap Studio.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ReadBarCodeBP("Separator")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        SetPageType("Separator")]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This example looks for a barcode with the value "Separator". If found, the second action,]]>
<![CDATA[
]]>
<![CDATA[        a DCO action, establishes the page as a Separator page.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the first barcode on the page has a value that matches the parameter.]]>
<![CDATA[
]]>
<![CDATA[      Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<see>
<![CDATA[GetBarCodeBP]]>
		</see>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ReadBarCodeBP = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		  Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Trim(strParam) = "" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "This action requires a parameter with the barcode text value to match. None has bee specified, exiting."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("bp_su") = "1"]]>
<![CDATA[
]]>
<![CDATA[	ReadBarCodeBP = MatchBarcodeBP(true,true,strParam)]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.DeleteVariable("bp_su")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
</rrx>
<rrx namespace="Barcode_X" v="8.1.0.18">
	<i ref="rrunner">
	</i>
	<i ref="recog_shared">
	</i>
	<i ref="barcode_p">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' barcode_x.rrx - Recognition Actions]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.02" ]]>
<![CDATA[
]]>
<![CDATA['Updated 03/08/2007 EKuzmin]]>
<![CDATA[
]]>
<![CDATA['	- SearchOrder implemented, MatchBarcode - checks for equivalence]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.03" ]]>
<![CDATA[
]]>
<![CDATA['Updated 01/29/2008 TScholl]]>
<![CDATA[
]]>
<![CDATA['	- Updated action Information]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.01"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/29/2008 NSK ]]>
<![CDATA[
]]>
<![CDATA[' Get setup parameters from runtime DCO if present]]>
<![CDATA[
]]>
<![CDATA[' MatchBarCode enhanced to use setup parameters, previously was using defaults]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.02"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/3/2008 NSK ]]>
<![CDATA[
]]>
<![CDATA[' Removed reference of rrunner and recog_shared - not needed]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.03"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/17/2008 NSK ]]>
<![CDATA[
]]>
<![CDATA[' Put back reference to rrunner - needed]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.04"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/24/2009 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added option to call ReadBarCode via DCOProcessor, if it is enabled]]>
<![CDATA[
]]>
<![CDATA[' Added InitBarCodeX function for initialization]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.05"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/27/2009 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added reference to recog_shared.rrx file]]>
<![CDATA[
]]>
<![CDATA[' The rrx now uses the more ]]>
<![CDATA[
]]>
<![CDATA[' robust "IsAlive" helper function to determine if the DCOprocessor object is valid or not (replacing "IsObject").]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.06"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/30/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 19745 Added G tags to make the XML format more compliant.  Standardized help formatting and modified some help text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.07"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/03/2009 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 25276. Added creation of the goBarCodeX object if it doesn't exist to MatchBarcode action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.08"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/9/2009 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 25276. Added global synchronization object to MatchBarCode action to protect call to barcode.dll from simultaneous use]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.09"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/06/2010 Rferin]]>
<![CDATA[
]]>
<![CDATA[' SPR 26966.  Changed function BarCodeX to read from oDCO instead of CurrentObj. ]]>
<![CDATA[
]]>
<![CDATA[' Fixed documented return value and text descriptions for ReadBarCode, MatchBarcode and GetBarCode.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/16/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 27332 (Isuue #6). Fixed bug in BarCodeX function not to set default values (they are defined in barcode.dll).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/12/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 27224 Change GetBarCode so it always returns True.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/16/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 28124 Adeed 'Set ogSemaphore = Nothing' to MatchBarcode action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/13/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 28337 Renamed ogSemaphore to oSemaphore. As it is not a global object.]]>
<![CDATA[
]]>
<![CDATA[' Changed the semaphore to be used from "DCSync.GlobalSingleSemaphore" to "DCSync.NamedSingleSemaphore"]]>
<![CDATA[
]]>
<![CDATA[' Now requires version of dcsync.dll v 8.0.0.2 or newer]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/18/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 27215 Added help text regarding Datacap Studio Barcode_x zones tab settings.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/21/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Changed the semaphore to be used from "DCSync.NamedSingleSemaphore" to "DCSync.NamedSemaphore"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/14/2010]]>
<![CDATA[
]]>
<![CDATA[' All barcode recognition actions now make direct calls to the corresponding actions in barcode_p.rrx. This solves a backwards compatibility issue ]]>
<![CDATA[
]]>
<![CDATA[' when barcode_x.rrx actions are used.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.17" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/04/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes abort in action GetBarcode]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.18" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/26/2011 Rferin]]>
<![CDATA[
]]>
<![CDATA[' 32032 Updated copyright.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.19" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/15/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' LOG RRA VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("Barcode_X " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['********************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Global entries ---------------------------------------------------->]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim goBarCodeX]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
	<af name="ReadBarCode" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Tests the first barcode found with the value specified by the parameter.">
		<ap>
<![CDATA[A single string value of the barcode.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[  Checks if the current page contains a barcode with the value specified by the parameter.  ]]>
<![CDATA[
]]>
<![CDATA[  This action uses the first barcode it encounters.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  One possible use of this action is to identify a document's Separator page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Refer to action GetBarCode for information regarding barcode configuration in Datacap Studio.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
			<e>
<![CDATA[
]]>
<![CDATA[    ]]>
				<b>
<![CDATA[ReadBarCode("Separator")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    SetPageType("Separator")]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    This example looks for a barcode with the value "Separator". If found, the second action, ]]>
<![CDATA[
]]>
<![CDATA[    a DCO action, establishes the page as a Separator page.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
			</e>
<![CDATA[
]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[  ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the first barcode on the page has a value that matches the parameter.  ]]>
<![CDATA[
]]>
<![CDATA[  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
		</ret>
		<see>
<![CDATA[GetBarCode]]>
		</see>
		<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ReadBarCode = ReadBarCodeBP(true,true,StrParam)]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="GetBarCode" access="public" bInter="bInter" bDebug="bDebug" qi="Returns the value of any barcode within a zone.">
		<ap>
<![CDATA[None]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Returns the value of any ]]>
			<b>
<![CDATA[barcode]]>
			</b>
<![CDATA[ within a zone. A RuleSet with this action can be applied ]]>
<![CDATA[
]]>
<![CDATA[    to a Page object or Field object of the Document Hierarchy.]]>
			<p>
<![CDATA[ When applied to a ]]>
<![CDATA[
]]>
<![CDATA[    Page object, the action reads the first barcode it encounters on the page and creates a ]]>
<![CDATA[
]]>
<![CDATA[    Page-level variable called 'GetBarCode', and places the barcode's value in the variable.]]>
			</p>
<![CDATA[
]]>
<![CDATA[    ]]>
			<p>
<![CDATA[When applied to the Field object of a zoned field, the action assigns the barcode's ]]>
<![CDATA[
]]>
<![CDATA[    value to the field.]]>
			</p>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Barcode_X Datacap Studio Information:]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    Datacap Studio's Zones tab should be used to adjust the BAR/X properties of each barcode zone for optimal recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Barcode Type:]]>
			</b>
<![CDATA[ It is very important to set this property to the specific type ]]>
<![CDATA[
]]>
<![CDATA[    of barcode that is expected.   The default "All" searches for any 3of9, CODABAR, ]]>
<![CDATA[
]]>
<![CDATA[    I2of5, Code 128, and Code 93 symbols, and returns spurious data in some cases.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Orientation:]]>
			</b>
<![CDATA[ Configures the expected orientation of the barcode.  ]]>
<![CDATA[
]]>
<![CDATA[    Horizontal is the "normal" orientation where the bars are vertical within the ]]>
<![CDATA[
]]>
<![CDATA[    overall symbol which is wider than it is tall, and the printed text (if any) is below.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Quality:]]>
			</b>
<![CDATA[ This property is no longer used.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Height / Width:]]>
			</b>
<![CDATA[ This property is no longer used.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Search Up To:]]>
			</b>
<![CDATA[ The maximum number of barcodes expected within the field.  Default is 1.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Remove Spaces:]]>
			</b>
<![CDATA[ If set to “Yes”, any white space characters are removed from the final recognized string.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Skip Recognition:]]>
			</b>
<![CDATA[ If set to “Yes”, this field will be skipped when performing recognition.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[GetBarCode()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      rr_Compare_Not("@VALUE, @EMPTY")]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If you need to test that a barcode was read, you can use the action rr_Compare_Not().]]>
<![CDATA[
]]>
<![CDATA[      This example shows how to perform that test on the field level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page or Field Level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<see>
<![CDATA[rr_Compare, rr_Compare_Not]]>
		</see>
		<g>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Call GetBarcodeBP(true,true)]]>
<![CDATA[
]]>
<![CDATA[   WriteLog("GetBarCode returns: True") ]]>
<![CDATA[
]]>
<![CDATA[   GetBarCode = True  ' Return True even if a barcode is not found on the page.]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="MatchBarcode" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Searches all the barcodes on the current page and checks if one matches the value you enter as a parameter.">
		<ap>
<![CDATA[The String value of the barcode.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[  Searches all the barcodes on the current page and checks if one of the barcodes matches the parameter value.]]>
<![CDATA[
]]>
<![CDATA[  If a match occurs, the barcode's value is placed into a page level variable called 'GetBarCode'.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Refer to action GetBarCode for information regarding barcode configuration in Datacap Studio.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
			<e>
<![CDATA[
]]>
<![CDATA[    ]]>
				<b>
<![CDATA[MatchBarCode("2008")]]>
				</b>
<![CDATA[
]]>
<![CDATA[  ]]>
			</e>
<![CDATA[
]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[  ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the action is called at the page level and one of the barcode values on the page]]>
<![CDATA[
]]>
<![CDATA[  matches the parameter value.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
		</ret>
		<see>
<![CDATA[GetBarCode]]>
		</see>
		<g>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MatchBarcode = MatchBarcodeBP(true,true,StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
		</g>
	</af>
</rrx>
<rrx namespace="CC" v="8.1.0.5">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA['IBM Content Classification Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' "Restricted Materials of IBM"]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/05/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Replaces ICM.rrx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/06/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version ="8.1.0.3"]]>
<![CDATA[
]]>
<![CDATA['Updated 03/07/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Changed Datacap.Libraries.ICM namespace to Datacap.Libraries.CC and updated help text for action FindFingerprintCC to remove extra carriage return.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version ="8.1.0.4"]]>
<![CDATA[
]]>
<![CDATA['Updated 06/05/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Updated help text for action FindFingerprintCC]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version ="8.1.0.5"]]>
<![CDATA[
]]>
<![CDATA['Updated 06/07/2012 CMcGhee]]>
<![CDATA[
]]>
<![CDATA['Updated help text for action SetProblemValueCC]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
	<com ref="Datacap.Libraries.CC.Actions" qi="IBM Content Classification Actions.">
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="FindFingerprintCC" qi="Finds the closest matching fingerprint and assigns the page type to the page.">
			<h>
<![CDATA[
]]>
<![CDATA[        This action identifies a page using the IBM Content Classification technology. This technology analyzes the full text of pages and attempts to find match within ]]>
<![CDATA[
]]>
<![CDATA[        the Knowledge Base specified in the SetKnowledgeBaseCC action. If a match is found, the Page type is populated with the ID of the category that was matched.]]>
				<br>
				</br>
<![CDATA[ If a match is not]]>
<![CDATA[
]]>
<![CDATA[        found, the page type is set to "Other". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Because the matching relies on a page's full text, a full page recognition action must be called prior to using the FindFingerprintCC action. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          RecognizePageOCR_S() ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[FindFingerprintCC()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the fingerprint is found. Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetKnowledgeBaseCC" qi="Sets the name of the CC Knowledge Base to use to classify documents.">
			<p name="KnowledgeBaseName" type="string" qi="Knowledge Base name.  Smart parameters are supported.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        The name of the IBM Content Classification Knowledge Base. This parameter is required and cannot be empty.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the name of the IBM Content Classification Knowledge Base to use to classify documents in an application. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action must be called after the SetListenerURLCC action.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the actions: SetProblemValueCC, FindFingerprintCC, and UpdateKnowledgeBaseCC.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetKnowledgeBaseCC("Mortgage")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          UpdateKnowledgeBaseCC()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All. ]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[, if the parameter is empty. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetProblemValueCC" qi="Sets the minimum score for fingerprint matching.">
			<p name="MinScore" type="double" qi="Minimum score for fingerprint matching. Valid values are fractional values between zero and one (for example: 0.0 and 1.0) ">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        When FindFingerprintCC searches for a fingerprint match, a score between zero (no match) and one (a]]>
<![CDATA[
]]>
<![CDATA[        positive match) is calculated. This action sets the minimum score that a match must have]]>
<![CDATA[
]]>
<![CDATA[        to be considered a match. Any matches with a score less than the value specified is rejected.]]>
<![CDATA[
]]>
<![CDATA[        With this action, you can control the tolerance for documents matching an existing example. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        When setting up the parameter in your application, use the decimal character from the system locale defined]]>
<![CDATA[
]]>
<![CDATA[        for the application in the Taskmaster Application Manager.  For example, when the decimal character is]]>
<![CDATA[
]]>
<![CDATA[        a period, use a value from 0.0 to 1.0.  When the decimal character is a comma, use a value from 0,0 to 1,0.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the FindFingerprintCC action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetProblemValueCC(0.9)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          FindFingerprintCC()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True ]]>
				</b>
<![CDATA[if the parameter value is between the valid range of zero to one (0.0 and 1.0) Otherwise, ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[. ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetLanguageCC" qi="Sets the language used in the specified Knowledge Base.">
			<p name="LanguageName" type="string" qi="The name of the language used in the specified Knowledge Base">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        This action sets the language of the specified Knowledge Base. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the FindFingerprintCC action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetLanguageCC("English")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetKnowledgeBaseCC("Mortgage")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetProblemValueCC(0.9)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          FindFingerprintCC()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetListenerURLCC" qi="Sets the URL of the CC Listener that will be used for classification.">
			<p name="URL" type="string" qi="The URL of the CC Listener that will be used for classification. Smart parameters are supported.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        This action configures the URL of the IBM Content Classification Listener that will be used for classification, and opens the connection to the IBM Content Classification Listener. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the actions: FindFingerprintCC, SetKnowledgeBaseCC, and UpdateKnowledgeBaseCC.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetListenerURLCC("http://localhost:18087") ]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetKnowledgeBaseCC("Mortgage")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetProblemValueCC(0.9)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          FindFingerprintCC()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the service URL is successfully set.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[  Note that]]>
<![CDATA[
]]>
<![CDATA[        this action does not test that the CC Listener exists and is running.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UpdateKnowledgeBaseCC" qi="Updates the CC Knowledge Base.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Updates the IBM Content Classification Knowledge Base by associating the current document's text and its type to enhance]]>
<![CDATA[
]]>
<![CDATA[        the classification results of the same type of document the next time that it is encountered.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetKnowledgeBaseCC("Mortgage")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[UpdateKnowledgeBaseCC()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ if the IBM Content Classification Knowledge Base is successfully updated.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="Cco2cco" v="8.1.0.22">
	<i ref="rrunner">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' Cco to cco recreate lines action]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' The purpose of CCO normalization is to organize the characters returned from OCR/ICR into words and lines,]]>
<![CDATA[
]]>
<![CDATA[' reading left to right and top to bottom.  This is primarily to enable locate actions to work on the geometry]]>
<![CDATA[
]]>
<![CDATA[' but in general to make the CCO useful for text finding, fingerprint matching, etc. we must have lines organized]]>
<![CDATA[
]]>
<![CDATA[' top to bottom.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Part of this process involves filtering out objects that are taller than normal text.]]>
<![CDATA[
]]>
<![CDATA[' These objects interfere with the algorithm for organizing lines, since they typically span multiple lines.]]>
<![CDATA[
]]>
<![CDATA[' Functions are provided to set the maximum height to allow (SetMaxCharacterHeightTMM, SetMaxCharacterHeightAVG)]]>
<![CDATA[
]]>
<![CDATA[' MinHt PX (min pixel height to filter out) is logged in the RRS log, along with any "words" which are filtered]]>
<![CDATA[
]]>
<![CDATA[' "Words" might contain some smaller characters, this is normal - think about words with punctuation marks.]]>
<![CDATA[
]]>
<![CDATA[' Unfortunately this means that large objects in close proximity (horizontally next to) a regular word]]>
<![CDATA[
]]>
<![CDATA[' will create one large word that will be filtered out.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' CCO normalization (cco2cco) is typically called directly from the full page recognition engine actions unless]]>
<![CDATA[
]]>
<![CDATA[' explicitly suppressed by calling ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/25/2008 NSK]]>
<![CDATA[
]]>
<![CDATA[' pass through special characters <>& which were previously deleted]]>
<![CDATA[
]]>
<![CDATA[' also log if any nonprinting characters are deleted]]>
<![CDATA[
]]>
<![CDATA[' the above change affects both cco2cco() and Normalizecco() actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/26/2009 Juan Martinez]]>
<![CDATA[
]]>
<![CDATA[' Filtering in CCO normalization now allows for special decimal 128, which corresponding to the Euro symbol. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 2/25/09 NSK]]>
<![CDATA[
]]>
<![CDATA[' Adjust for image resolution - default height filter was 50 pixels now .25 inches]]>
<![CDATA[
]]>
<![CDATA[' New action SetMaxCharacterHeightTMM to set maximum character height for filtering]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/30/09 RFERIN]]>
<![CDATA[
]]>
<![CDATA[' 19745 Added G tags to make the XML format more compliant and help with editing.  Minor help ]]>
<![CDATA[
]]>
<![CDATA[' formatting fixes and modified some help text.  Requires the new buildvbs.rls 1.0.2.2.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 8/28/09 PHofle]]>
<![CDATA[
]]>
<![CDATA[' New action SetMaxCharacterHeightAVG to set maximum percent over average character height for filtering]]>
<![CDATA[
]]>
<![CDATA[' NOTE: Code merged from cco2cco.rrx version 7.5.12]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 2/8/10]]>
<![CDATA[
]]>
<![CDATA[' require 1/2 line overlap (previously 2/3 line) to keep text on the same line - SPR 27069]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/07/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/20/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 32032 Changed one occurance of Asc to Ascw and Chr to Chrw for unicode support.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/7/2011 NSK]]>
<![CDATA[
]]>
<![CDATA[' * Convert msxml4 -> msxml6]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/1/2011 NSK]]>
<![CDATA[
]]>
<![CDATA[' * SPR 33040 fix: Do NOT filter out character values above 128 in TransFix function, include them "as is" in the XML file]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/7/2012 NSK]]>
<![CDATA[
]]>
<![CDATA[' * SPR 31791 - debug issue of words out of order on line with large text]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/20/2012 NSK]]>
<![CDATA[
]]>
<![CDATA[' * SPR 35138 - cco2cco was aborting - now hidden/deprecated]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.22"]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/31/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * SPR 35138 - Updated help text for action NormalizeCCO]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' LOG RRA VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("CCO to CCO " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['********************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim CCOMaxHeightTMM]]>
<![CDATA[
]]>
<![CDATA[Dim CCOMaxHeightPixels]]>
<![CDATA[
]]>
<![CDATA[Dim g_CCOMaxHeightAVG ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[CCOMaxHeightTMM = 64	' max character height in 1/10 mm units = slightly more than 1/4 inch (larger chars will be filtered out)]]>
<![CDATA[
]]>
<![CDATA[CCOMaxHeightPixels = 50	' this will be recalculated at runtime based on image resolution]]>
<![CDATA[
]]>
<![CDATA[g_CCOMaxHeightAVG  = 0  ' this defaults to zero = OFF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['------------HELPER FUNCTIONS-------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
	<af name="NormalizeCCO" access="public" bInter="bInter" bDebug="bDebug" qi="Sorts and filters the words and lines in a Fingerprint file (.cco)created by a Recognition engine, for use by navigation and pattern match actions. This action is only required after full page recognition by an OCR or ICR action that does NOT automatically normalize the CCO.  OCR/S, OCR/A, ICR/C full page recogntiion do NOT require this action.">
		<lvl>
<![CDATA[Page.]]>
		</lvl>
		<ret>
<![CDATA[Always True.]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[	This action sorts the words and lines in a Fingerprint file (.cco) created by a recognition engine, ]]>
<![CDATA[
]]>
<![CDATA[   for use by navigation and pattern match actions. The action is called by full-page recognition]]>
<![CDATA[
]]>
<![CDATA[   actions for ICR/C, OCR/S, and OCR/A.  This action should always be called before using ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
			<b>
<![CDATA[Locate]]>
			</b>
<![CDATA[actions or the ]]>
			<b>
<![CDATA[pat_RecogMatch_ID]]>
			</b>
<![CDATA[action to find recognized text on a page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    In this context, the fingerprint is calculated for a particular image in a batch, as opposed to ]]>
<![CDATA[
]]>
<![CDATA[    the Fingerprint database, which contains fingerprints for various page types and layout variations ]]>
<![CDATA[
]]>
<![CDATA[    that have been defined for a particular application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    There are two types of Fingerprint files.  One type is based on the image geometry.  The second]]>
<![CDATA[
]]>
<![CDATA[    type is based on recognized text.  The ]]>
			<b>
<![CDATA[AnalyzeImage]]>
			</b>
<![CDATA[action creates a geometric]]>
<![CDATA[
]]>
<![CDATA[    fingerprint containing lines and "words" based only on the black pixels in the image. Full-page]]>
<![CDATA[
]]>
<![CDATA[    recognition actions (]]>
			<b>
<![CDATA[RecognizePageOCR_S, RecognizePageICR_C, RecognizePageOCR_A ]]>
			</b>
<![CDATA[etc.) create a]]>
<![CDATA[
]]>
<![CDATA[    fingerprint based on the results of recognition, i.e. both geometry and text of the]]>
<![CDATA[
]]>
<![CDATA[    recognized characters, words and lines.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    In Recognition-based fingerprints, the order of lines and words may appear to be arbitrary,]]>
<![CDATA[
]]>
<![CDATA[    especially if the page contains images, tables, stamps, or blocks of text with varying font sizes.]]>
<![CDATA[
]]>
<![CDATA[    This can cause unpredictable results from ]]>
			<b>
<![CDATA[Locate]]>
			</b>
<![CDATA[actions that navigate geometrically. ]]>
<![CDATA[
]]>
<![CDATA[    The word-matching and phrase-matching action ]]>
			<b>
<![CDATA[pat_RecogMatch_ID]]>
			</b>
<![CDATA[also requires ]]>
<![CDATA[
]]>
<![CDATA[    well-ordered text to work reliably.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    The ]]>
			<b>
<![CDATA[NormalizeCCO ]]>
			</b>
<![CDATA[action re-orders the words of text in a Recognition-based fingerprint into ]]>
<![CDATA[
]]>
<![CDATA[    lines and words in "standard" reading order, from top to bottom and left to right.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[IMPORTANT NOTE: NormalizeCCO ]]>
			</b>
<![CDATA[discards any "words" or blocks containing characters taller than 1/4 inch, or the height set by SetMaxCharacterHeightTMM().]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[NOTE:]]>
			</b>
<![CDATA[ If the ]]>
			<b>
<![CDATA[AnalyzeImage]]>
			</b>
<![CDATA[ action is called before full-page recognition, ]]>
<![CDATA[
]]>
<![CDATA[    the recognized text is placed into the geometry created by ]]>
			<b>
<![CDATA[AnalyzeImage.]]>
			</b>
<![CDATA[This hybrid ]]>
<![CDATA[
]]>
<![CDATA[    Fingerprint file is not always suitable for ]]>
			<b>
<![CDATA[cco2cco.]]>
			</b>
<![CDATA[ To force creation of a pure ]]>
<![CDATA[
]]>
<![CDATA[    recognition-based fingerprint, call ]]>
			<b>
<![CDATA[SetFingerprintRecogPriority(True)]]>
			</b>
<![CDATA[
]]>
<![CDATA[    before full-page recognition. This guarantees that any existing geometric fingerprint will be ignored, ]]>
<![CDATA[
]]>
<![CDATA[    and it applies to ]]>
			<b>
<![CDATA[OCR_S]]>
			</b>
<![CDATA[and ]]>
			<b>
<![CDATA[ICR_C]]>
			</b>
<![CDATA[only.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[NOTE:]]>
			</b>
<![CDATA[ The full page recognition actions from the ]]>
			<b>
<![CDATA[ICR_C]]>
			</b>
<![CDATA[, ]]>
			<b>
<![CDATA[OCR_A]]>
			</b>
<![CDATA[, and ]]>
			<b>
<![CDATA[OCR_S]]>
			</b>
<![CDATA[ libraries call NormalizeCCO() automatically unless the action ]]>
<![CDATA[
]]>
<![CDATA[    CCONormalization_OFF (from the ]]>
			<b>
<![CDATA[Recog_Shared]]>
			</b>
<![CDATA[ library) is called prior to recognition. The full page recognition from the ]]>
			<b>
<![CDATA[OCR_SR]]>
			</b>
<![CDATA[ library, however, requires that]]>
<![CDATA[
]]>
<![CDATA[    NormalizeCCO() to be called manually post recognition. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[ ]]>
			<e>
<![CDATA[
]]>
<![CDATA[    SetFingerprintRecogPriority(True)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[		RecognizePageOCR_S()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[		]]>
				<b>
<![CDATA[NormalizeCCO()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[		pat_RecogMatch_ID()]]>
<![CDATA[
]]>
<![CDATA[	]]>
			</e>
<![CDATA[
]]>
		</h>
		<g>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	NormalizeCCO=False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[wleft="<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">" & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:output method=""xml"" indent=""yes"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:template match=""P|L""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   <xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""@*"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""W""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["       <xsl:sort select=""@l"" data-type=""number"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     </xsl:apply-templates> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   </xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:template> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:template match=""@* | node()""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   <xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""@* | node()"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   </xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:template> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:stylesheet> " & vbCrLf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[wbottom="<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:output method=""xml"" indent=""yes"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:template match=""CCO""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   <xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""@*"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""W""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["       <xsl:sort select=""@b"" data-type=""number"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     </xsl:apply-templates> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   </xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:template> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:template match=""@* | node()""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   <xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""@* | node()"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   </xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:template> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:stylesheet> " & vbCrLf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	sPath=CurrentObj.Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.FileName = sPath]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.GetRes xDPI, yDPI]]>
<![CDATA[
]]>
<![CDATA[	CCOMaxHeightPixels = CCOMaxHeightTMM * yDPI / 254]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("MaxHt TMM = " & CCOMaxHeightTMM & " yDPI = " & CStr(yDPI) & " MaxHt PX = " & CCOMaxHeightPixels)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	sPath=Replace(sPath, ".tif", ".cco")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set pObj=Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set xDoc=CCO2XML(sPath, pObj)	' extract CCO to XML doc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call SortXML2(xDoc, wbottom)	' sort XML by text baseline]]>
<![CDATA[
]]>
<![CDATA[	'sXPath=Replace(sPath, ".cco", "sortv.xml")	]]>
<![CDATA[
]]>
<![CDATA[	'xDoc.Save(sXPath)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Split2LinesDiscret(xDoc)		' organize into lines]]>
<![CDATA[
]]>
<![CDATA[	'sXPath=Replace(sPath, ".cco", "split.xml")	]]>
<![CDATA[
]]>
<![CDATA[	'xDoc.Save(sXPath)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call SortXML2(xDoc, wleft)		' sort within line by left to right]]>
<![CDATA[
]]>
<![CDATA[	'sXPath=Replace(sPath, ".cco", "sorth.xml")	]]>
<![CDATA[
]]>
<![CDATA[	'xDoc.Save(sXPath)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' now build up the full structure of lines and words]]>
<![CDATA[
]]>
<![CDATA[	Set xNodes=xDoc.selectNodes(".//W")]]>
<![CDATA[
]]>
<![CDATA[	For Each oNode In xNodes]]>
<![CDATA[
]]>
<![CDATA[		xDoc.documentElement.appendChild(oNode)]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set xNodes=xDoc.selectNodes(".//L")]]>
<![CDATA[
]]>
<![CDATA[	For Each oNode In xNodes]]>
<![CDATA[
]]>
<![CDATA[		oNode.parentNode.removeChild(oNode)]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	' now join together "phrases" that were previously split but belong together in a line]]>
<![CDATA[
]]>
<![CDATA[	Split2Lines(xDoc)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call RecreateCCO(xDoc, sPath, pObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sXPath=Replace(sPath, ".cco", "c.xml")	]]>
<![CDATA[
]]>
<![CDATA[	xDoc.Save(sXPath)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set xDoc=Nothing]]>
<![CDATA[
]]>
<![CDATA[	NormalizeCCO=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SetMaxCharacterHeightTMM" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Sets the maximum height of characters permitted by cco2cco and NormalizeCCO actions.">
		<ap>
<![CDATA[
]]>
<![CDATA[		]]>
			<i>
<![CDATA[Integer]]>
			</i>
<![CDATA[ maximum height of characters to permit in the CCO, in 1/10 mm units.  Default is 64, or approx 1/4 inch (50 pixels at 200 DPI).]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<lvl>
<![CDATA[Page.]]>
		</lvl>
		<ret>
<![CDATA[Always True.]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[	  ]]>
			<e>
<![CDATA[
]]>
<![CDATA[		]]>
				<b>
<![CDATA[SetMaxCharacterHeightTMM(75)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      NormalizeCCO()]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
		</h>
		<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CCOMaxHeightTMM = CInt(strParam)]]>
<![CDATA[
]]>
<![CDATA[	if CCOMaxHeightTMM <= 1 then CCOMaxHeightTMM = 64	' restore default]]>
<![CDATA[
]]>
<![CDATA[	SetMaxCharacterHeightTMM=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SetMaxCharacterHeightAVG" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Sets the maximum height of characters permitted by cco2cco and NormalizeCCO actions.">
		<ap>
<![CDATA[
]]>
<![CDATA[		One or two digit ]]>
			<i>
<![CDATA[Integer]]>
			</i>
<![CDATA[ value sets the percent maximum height of characters over the average to permit in the CCO.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[	      Off by default. Parameter of zero (0) or less turns off this functionality.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<lvl>
<![CDATA[Page.]]>
		</lvl>
		<ret>
<![CDATA[Always True.]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[	  ]]>
			<e>
<![CDATA[
]]>
<![CDATA[		]]>
				<b>
<![CDATA[SetMaxCharacterHeightAVG(15)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[		NormalizeCCO()]]>
<![CDATA[
]]>
<![CDATA[	]]>
			</e>
<![CDATA[
]]>
		</h>
		<g>
<![CDATA[
]]>
<![CDATA[	SetMaxCharacterHeightAVG=False]]>
<![CDATA[
]]>
<![CDATA[	strParam=trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[	strParam=replace(strParam,".","")]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(strParam) or len(strParam)>2 then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	g_CCOMaxHeightAVG = CInt(strParam)]]>
<![CDATA[
]]>
<![CDATA[	if g_CCOMaxHeightAVG <= 1 then g_CCOMaxHeightAVG = 0	' restore to default OFF]]>
<![CDATA[
]]>
<![CDATA[	SetMaxCharacterHeightAVG=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
		</g>
	</af>
</rrx>
<rrx namespace="Convert" v="8.1.0.25">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' Document Convertion Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2012 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/04/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 26123 Added Datacap Studio help for all actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/21/2009 SM]]>
<![CDATA[
]]>
<![CDATA[' * 25927 Added ExcelPrintQuality(int dpi) - helper action (default is 200 dpi)]]>
<![CDATA[
]]>
<![CDATA['         Added ExcelTiffCompression(string tiffCompression) - helper action (default is CCITT4)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/02/2009 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Added Images class support:]]>
<![CDATA[
]]>
<![CDATA['   Action Image2Tiff - converts images to tiff format]]>
<![CDATA[
]]>
<![CDATA['   Set_ImageMonoType - Sets the method to use when converting Image to Black and White tiffs]]>
<![CDATA[
]]>
<![CDATA['   Set_MonoThreshold - Sets the threshold value when converting Image to 1 bit tiff using threshold type conversion.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/05/2009 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Added Images class support for setting file extensions to convert.]]>
<![CDATA[
]]>
<![CDATA['   Action Set_FileTypesToConvert limits the image files to converts based on the source file extension. Action parameter]]>
<![CDATA[
]]>
<![CDATA['   accepts a CSV of valid file extensions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/23/2010 SM]]>
<![CDATA[
]]>
<![CDATA[' * Removed 'RLE' & 'CCITT3' from DStudio Help:]]>
<![CDATA[
]]>
<![CDATA['   WordTiffCompression()]]>
<![CDATA[
]]>
<![CDATA['   ExcelTiffCompression()]]>
<![CDATA[
]]>
<![CDATA['   OutlookTiffCompression()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/10/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 27523 Updated help for Image2Tiff, PDFDocumentToImage, Set_FileTypesToConvert, OutlookMessageToImageAndAttachment,]]>
<![CDATA[
]]>
<![CDATA['   OutlookMessageToImageAndAttachment, WordPrintQuality, lPrintQuality, OutlookPrintQuality and Set_MonoThreshold.]]>
<![CDATA[
]]>
<![CDATA['   27893 ExcelWorkbookToImage for G4 now converts text to black and removes background shading.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/06/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' *  27746 Updated help for actions that will set the batch to abort if the input file limit is exceeded.]]>
<![CDATA[
]]>
<![CDATA['    27962 Updated help SplitMultipageTiff to state the output compression type.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/27/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' *  28222 Updated help to say that if a conversion fails, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/28/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' *  28152 Changed action names for Image, PDF and ZIP conversions to make them consistent with the other action names.]]>
<![CDATA[
]]>
<![CDATA['    Old action names are deprecated but still can be called by existing applications.]]>
<![CDATA[
]]>
<![CDATA['    Image2Tiff -> ImageToTiff, Set_ImageMonoType -> ImageMonoType, Set_MonoThreshold -> ImageMonoThreshold, ]]>
<![CDATA[
]]>
<![CDATA['    Set_FileTypesToConvert -> ImageFileTypesToConvert, SetBitcount -> PDFBitDepth, SetCompression -> PDFCompression, ]]>
<![CDATA[
]]>
<![CDATA['    SetConversionMethod -> PDFConversionMethod, SetGrayscale -> PDFGrayscale, SetHorizontalResolution -> PDFHorizontalResolution, ]]>
<![CDATA[
]]>
<![CDATA['    SetVerticalResolution -> PDFVerticalResolution, SetQuality -> PDFQuality, UnPack -> ZipUnPack, ]]>
<![CDATA[
]]>
<![CDATA['    SetPassword -> ZipPassword, SetOverwrite -> ZipOverwrite.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/29/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' *  28152 Changed action name PDFBitdepth to PDFBitDepth.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/01/2010 SM]]>
<![CDATA[
]]>
<![CDATA[' * 28464 Added OutlookMessageToAttachmentOnly() action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/04/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 28464 Added help for OutlookMessageToAttachmentOnly() action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/29/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 29072 Added overview help to each of the types of conversions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/20/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 29586 Removed all of the ZIP actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/04/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 29588 Reinstated the ZIP actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/09/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 31014 Added smart parmater support to ZipPassword.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.22"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/09/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 31022 Moved parameter information from the qi= tag to the standard parameter section.]]>
<![CDATA[
]]>
<![CDATA['   Removed actions that were deprecated in the previous release: UnPack, SetPassword, SetOverwrite, SetBitcount, ]]>
<![CDATA[
]]>
<![CDATA['   SetCompression, SetConversionMethod, SetHorizontalResolution, SetGrayscale, SetQuality, SetVerticalResolution, ]]>
<![CDATA[
]]>
<![CDATA['   Image2Tiff, Set_ImageMonoType, Set_MonoThreshold, SetFileTypesToConvert]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.23"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/18/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 31572 Added help information about using the convert actions and skipping processed pages.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.24"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/18/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 31572 Additional help text tweak regarding skipping deleted pages.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.25"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/21/2011 SM]]>
<![CDATA[
]]>
<![CDATA[' * 27307 Added HtmlToImage(), HtmlPrintQuality(), HtmlTiffCompression() actions]]>
<![CDATA[
]]>
<![CDATA[' * 29761 Added RtfToImage(), RtfPrintQuality(), RtfTiffCompression() actions]]>
<![CDATA[
]]>
<![CDATA[' * 29761 Added TxtToImage(), TxtPrintQuality(), TxtTiffCompression() actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.Convert.Word" qi="Convert Word Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Word Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Word conversion will convert electronic DOC and DOCX documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Word]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the WordDocumentToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  An application could skip processing of these pages, as needed, by first calling ChkDCOStatus("49")]]>
<![CDATA[
]]>
<![CDATA[      and the following actions in the function will only be run on pages that have that status.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      As a general rule, subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      is performed on the TIFF files that were created at run time, such as the TIFF created from DOC file, not the parent DOC file.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="WordDocumentToImage" qi="Converts a page with *.doc or *.docx file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a Word Document, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Document, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Word actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          WordPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          WordTiffCompression("CCITT4")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[WordDocumentToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a Word Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="WordPrintQuality" qi="Adjusts the resolution of the image output by WordDocumentToImage.">
			<p name="dpi" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dpi : A single positive numeric value for the dots per inch (dpi) of the output image." ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for WordDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[WordPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          WordDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="WordTiffCompression" qi="Sets the compression used in the TIFF output by WordDocumentToImage.">
			<p name="tiffCompression" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tiffCompression is one of the following values to set the TIFF compression:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from WordDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[WordTiffCompression(CCITT4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          WordDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Excel" qi="Convert Excel Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Excel Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Excel conversion will convert electronic XLS and XLXS documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Excel]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the ExcelWorkbookToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  An application could skip processing of these pages, as needed, by first calling ChkDCOStatus("49")]]>
<![CDATA[
]]>
<![CDATA[      and the following actions in the function will only be run on pages that have that status.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      As a general rule, subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      is performed on the TIFF files that were created at run time, such as the TIFF created from DOC file, not the parent DOC file.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelWorkbookToImage" qi="Converts a page with *.xls or *.xlsx file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Excel Workbook, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Workbook, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Excel actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black and background shading will be set to white.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ExcelPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelTiffCompression(CCITT4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelPrintBlankPage(False)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelWorkbookToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Excel Workbook or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelPrintQuality" qi="Adjusts the resolution of the image output by ExcelWorkbookToImage.">
			<p name="dpi" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dpi : A single positive numeric value for the dots per inch (dpi) of the output image.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for ExcelWorkbookToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelTiffCompression" qi="Sets the compression used in the TIFF output by ExcelWorkbookToImage.">
			<p name="tiffCompression" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tiffCompression is one of the following values to set the TIFF compression:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from ExcelWorkbookToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelTiffCompression("CCITT4")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelPrintBlankPage" qi="Determines if blank pages are created when converting Excel Workbook to TIFF.">
			<p name="blankPage" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        blankPage : A Boolean value that enables or disables creation of blank TIFFs when there is a blank Excel page.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ A blank TIFF will be created if the page is blank.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ A blank TIFF will not be created if the page is blank.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When printing an Excel Workbook, it is typical to have overflow pages that sometimes]]>
<![CDATA[
]]>
<![CDATA[        have data and sometimes are blank.  Setting the value to true will create a TIFF]]>
<![CDATA[
]]>
<![CDATA[        for the blank overflow pages in this process.  If this action is not called before]]>
<![CDATA[
]]>
<![CDATA[        ExcelWorkbookToImage, then the default of False will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelPrintBlankPage("False")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelOrientationToPortrait" qi="Forces the orientation of Excel files to portrait for ExcelWorkbookToImage.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The TIFF files created from ExcelWorkbookToImage will all be created with a portrait orientation.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the portrait / landscape setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelOrientationToPortrait()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelOrientationToLandscape" qi="Forces the orientation of Excel files to landscape for ExcelWorkbookToImage.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The TIFF files created from ExcelWorkbookToImage will all be created with a landscape orientation.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the portrait / landscape setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelOrientationToLandscape()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelScalingFactor" qi="Forces the print scaling of Excel Workbook to a specific value for ExcelWorkbookToImage.">
			<p name="percent" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[percent]]>
				</b>
<![CDATA[ : A positive integer that controls the scaling by percentage used when converting an Excel Workbook to TIFF.  ]]>
<![CDATA[
]]>
<![CDATA[        For example, a value of 100 means to print at 100%.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The TIFF files created from ExcelWorkbookToImage will all use the specified printing]]>
<![CDATA[
]]>
<![CDATA[        scale value when converted to TIFF.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the scaling factor that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelScalingFactor(100)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelPrintGridlines" qi="Enables or disables gridlines when converting Excel files to TIFF.">
			<p name="gridlines" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        gridlines : A Boolean value that determines if gridlines are displayed in Excel files converted to TIFF.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Gridlines will be included in the converted image.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Gridlines will not be shown in the converted image.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The TIFF files created from ExcelWorkbookToImage will all use the specified grid]]>
<![CDATA[
]]>
<![CDATA[        setting when converted to TIFF.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the gridline setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelPrintGridlines("False")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelAutoFitColumns" qi="Sets the automatic sizing of all columns for Excel Workbook converted to TIFF.">
			<p name="autoFitColumns" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        autoFitColumns : A Boolean value that enables and disables the automatic sizing of columns in an Excel file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ The columns will be set to automatically adjust the size based on the content.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ The columns will not have their size adjusted.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This enables the auto sizing of columns to shrink or increase the size of the column]]>
<![CDATA[
]]>
<![CDATA[        to fit all of the data within the column.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelAutoFitColumns("False")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelAutoFitRows" qi="Sets the automatic sizing of all rows for Excel Workbook converted to TIFF.">
			<p name="autoFitRows" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        autoFitRows : A Boolean value that enables and disables the automatic sizing of rows in an Excel file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ The rows will be set to automatically adjust the size based on the content.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ The rows will not have their size adjusted.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This enables the auto sizing of rows to shrink or increase the size of the row]]>
<![CDATA[
]]>
<![CDATA[        to fit all of the data within the row.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelAutoFitRows("False")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Outlook" qi="Convert Outlook Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Outlook Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Outlook conversion will convert electronic MSG and EML documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Outlook]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the OutlookMessageToImageAndAttachment]]>
<![CDATA[
]]>
<![CDATA[      or OutlookMessageToAttachmentOnly to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  An application could skip processing of these pages, as needed, by first calling ChkDCOStatus("49")]]>
<![CDATA[
]]>
<![CDATA[      and the following actions in the function will only be run on pages that have that status.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      As a general rule, subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      is performed on the TIFF files that were created at run time, such as the TIFF created from DOC file, not the parent DOC file.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="OutlookMessageToImageAndAttachment" qi="Converts a *.msg or *.eml file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Outlook Message, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Message, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Outlook actions that configure the conversion settings.]]>
<![CDATA[
]]>
<![CDATA[        A copy of the original MSG file without attachments is created and converted to TIFF as well.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each attachment or embedded image within the e-mail will be removed from the e-mail and placed on disk.  A new page]]>
<![CDATA[
]]>
<![CDATA[        entry will be created for each attachment that can be processed by rules.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          OutlookPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookTiffCompression("CCITT4")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookMessageToImageAndAttachment()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Outlook Message or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="OutlookMessageToAttachmentOnly" qi="Extracts attachments from *.msg or *.eml to pages without converting the MSG to a TIFF.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Outlook Message, the attachments within the message]]>
<![CDATA[
]]>
<![CDATA[        will be saved as separate files.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each attachment or embedded image within the e-mail will be removed from the e-mail and placed on disk.  A new page]]>
<![CDATA[
]]>
<![CDATA[        entry will be created for each attachment that can be processed by subsequent rules.  ]]>
<![CDATA[
]]>
<![CDATA[        The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookMessageToAttachmentOnly()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the attachments are successfully extracted from the message, or if the message contains no attachments.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Outlook Message or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        OutlookMessageToImageAndAttachment]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="OutlookPrintQuality" qi="Adjusts the resolution of the image output by OutlookMessageToImageAndAttachment.">
			<p name="dpi" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dpi : A single positive numeric value for the dots per inch (dpi) of the output image.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for OutlookMessageToImageAndAttachment.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookMessageToImageAndAttachment()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="OutlookTiffCompression" qi="Sets the compression used in the TIFF output by OutlookMessageToImageAndAttachment.">
			<p name="tiffCompression" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tiffCompression : A parameter of one of the following values to set the TIFF compression:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from OutlookMessageToImageAndAttachment.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookTiffCompression("CCITT4")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookMessageToImageAndAttachment()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Zip" qi="Convert Zip Archive Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[ZIP Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The ZIP conversion will convert extract the files contained within ZIP format files.  These]]>
<![CDATA[
]]>
<![CDATA[      files are then made available for their own processing.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.  ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  An application could skip processing of these pages, as needed, by first calling ChkDCOStatus("49")]]>
<![CDATA[
]]>
<![CDATA[      and the following actions in the function will only be run on pages that have that status.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      As a general rule, subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      is performed on the TIFF files that were created at run time, such as the TIFF created from DOC file, not the parent DOC file.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ZipUnPack" qi="Extracts each file within a ZIP archive into separate files.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a ZIP, the files contained in the archive will placed into]]>
<![CDATA[
]]>
<![CDATA[        the current batch directory.  Each new file will also have a new page created]]>
<![CDATA[
]]>
<![CDATA[        within the application environment which can be processed by subsequent rules.]]>
<![CDATA[
]]>
<![CDATA[        The original file name from which the page was extracted will be stored in the]]>
<![CDATA[
]]>
<![CDATA[        ParentImage variable, for possible future reference within your application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ChkDCOStatus("49")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ZipUnPack()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDCOStatus("75")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example checks to see if the current page of type "other", if so, it tries to unzip the page.]]>
<![CDATA[
]]>
<![CDATA[          If the unzip is successful, then the current page was a valid zip file.  The files have now]]>
<![CDATA[
]]>
<![CDATA[          been removed from the zip and are located in the batch directory.  The next action]]>
<![CDATA[
]]>
<![CDATA[          sets the page status of the zip file to "Deleted".  This does not delete it from the batch, but]]>
<![CDATA[
]]>
<![CDATA[          stops further processing of the zip file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the contents of the ZIP file is successfully extracted.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a PDF or if there is a failure in the extraction.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or if there is a failure in the extraction, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ZipPassword" qi="Sets the password for Password protected archives that will be used by ZipUnPack.">
			<p name="pwd" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        pwd : The password for the archive.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The password provided will be used to extract password protected archives.  This action must be called before ZipUnPack.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ChkDCOStatus("49")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ZipOverwrite("True")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ZipPassword("MySafePassword")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ZipUnPack()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDCOStatus("75")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ZipOverwrite" qi="Controls overwriting files when extracting from ZIP archives.">
			<p name="overwrt" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A Boolean value that indicates if a subsequent ZipUnPack action should overwrite existing files.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Overwrite files that already exist.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Do not overwrite files that already exist.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action must be called before ZipUnPack.  If this action is not called, then ZipUnPack will use the default value of True.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ChkDCOStatus("49")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ZipOverwrite("True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ZipUnPack()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDCOStatus("75")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Tiff" qi="Multpage Tiff image tool Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[TIFF Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Tagged Image Format File conversion will convert multipage TIFs to a set of individual TIF files.  ]]>
<![CDATA[
]]>
<![CDATA[      One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.  ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  Subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      will be on the new TIFF files that were created at run time.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SplitMultipageTiff" qi="Creates separate images for each page in a multipage Tiff file.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a TIFF, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the document.  If the input page was a single]]>
<![CDATA[
]]>
<![CDATA[        page TIFF file, a single page TIFF will still be output.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which]]>
<![CDATA[
]]>
<![CDATA[        the page was extracted will be stored in the ParentImage variable,]]>
<![CDATA[
]]>
<![CDATA[        for possible future reference within your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the input TIFF has a bit depth of 1 (black and white), then the output compression will]]>
<![CDATA[
]]>
<![CDATA[        be set to group 4 fax.  If the input TIFF has a bit depth greater than 1, then the output]]>
<![CDATA[
]]>
<![CDATA[        compression will be uncompressed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SplitMultipageTiff()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a TIFF or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Pdf" qi="PDF conversion Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[PDF Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The PDF conversion will convert electronic PDF documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available PDF]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the PDFDocumentToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in ]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the ]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.  ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result ]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.   ]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first ]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296 ]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.  ]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.  ]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.  ]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages ]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a ]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[PDF Considerations]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If you have separately purchased the DCPDF option, do not mix use the actions provided ]]>
<![CDATA[
]]>
<![CDATA[      with the DCPDF Library (DCPDF.rrx) mixed with the actions from Convert within the same ]]>
<![CDATA[
]]>
<![CDATA[      task profile or your documents may not all be converted properly.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.  ]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  Subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      will be on the new TIFF files that were created at run time.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".  ]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFDocumentToImage" qi="Create a TIFF image for each page in a PDF file.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a PDF, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the document.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which]]>
<![CDATA[
]]>
<![CDATA[        the page was extracted will be stored in the ParentImage variable, for]]>
<![CDATA[
]]>
<![CDATA[        possible future reference within your application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFDocumentToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a PDF or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFBitDepth" qi="Sets the bit depth of the image output by PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        One of the following bit depth values are allowed.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1:]]>
				</b>
<![CDATA[ black and white.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[8:]]>
				</b>
<![CDATA[ 256 color.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[24:]]>
				</b>
<![CDATA[ True color.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the bit depth for the output TIFF.  The number of bits determine the color capacity of an image.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, a default value of 1 is used.  This action must be called before PDFDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFBitDepth(1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFCompression" qi="Sets the compression method used in the TIFF output by PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        One of the following compression values are allowed.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1:]]>
				</b>
<![CDATA[ No compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2:]]>
				</b>
<![CDATA[ CCITT modified Huffman RLE.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[3:]]>
				</b>
<![CDATA[ CCITT Group 3 fax.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[4:]]>
				</b>
<![CDATA[ CCITT Group 4 fax.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[5:]]>
				</b>
<![CDATA[ LZW Lempel-Ziv and Welch]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[7:]]>
				</b>
<![CDATA[ JPEG]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from PDFDocumentToImage.  If this]]>
<![CDATA[
]]>
<![CDATA[        action is not called, the default value of CCITT4 will be used.  Typically,]]>
<![CDATA[
]]>
<![CDATA[        input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFCompression(4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFConversionMethod" qi="Sets the conversion method used in the TIFF output by PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A numeric value of one of the following.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1:]]>
				</b>
<![CDATA[ Uses method 1 of converting PDF to TIFF.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2:]]>
				</b>
<![CDATA[ Uses method 2 of converting PDF to TIFF.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        There are two methods that are can be used to convert a PDF to TIFF.]]>
<![CDATA[
]]>
<![CDATA[        The first method is slightly faster.  The second method gives better results.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, PDFDocumentToImage will use the second method by default,]]>
<![CDATA[
]]>
<![CDATA[        which produces a more accurate output TIFF.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFConversionMethod(2)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFGrayscale" qi="Sets the output by PDFDocumentToImage to be grayscale.">
			<p name="p_bVal" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A Boolean value to set grayscale mode.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ The resulting PDF will be grayscale.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ The resulting PDF will not be converted to grayscale.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the PDF conversion to TIFF so the output images are grayscale.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before PDFDocumentToImage. If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        a default value of False will be used by PDFDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFGrayscale(True)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFHorizontalResolution" qi="Sets the output horizontal resolution for PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        p_iVal : A positive numeric value for the horizontal resolution in dots per inch (DPI).]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the horizontal resolution for PDF conversion to TIFF.  It is]]>
<![CDATA[
]]>
<![CDATA[        recommended that the horizontal and vertical resolutions be kept the same, creating an isotropic image.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default resolution of 200 is used.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before PDFDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFHorizontalResolution(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFVerticalResolution(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFQuality" qi="Sets the conversion quality for PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        p_iVal : A positive numeric value between 0 and 100 that determines the image quality.  100 is the highest quality.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This determines the quality of the output TIFF.  Choosing a higher]]>
<![CDATA[
]]>
<![CDATA[        value will give you a better output TIFF, but will increase processing time.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before PDFDocumentToImage.  If]]>
<![CDATA[
]]>
<![CDATA[        PDFQuality is not called, the default value of 100 is used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFQuality(100)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFVerticalResolution" qi="Sets the output vertical resolution for PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        p_iVal : A positive numeric value for the vertical resolution in dots per inch (DPI).]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the vertical resolution for PDF conversion to TIFF.  It is]]>
<![CDATA[
]]>
<![CDATA[        recommended that the horizontal and vertical resolutions be kept the same, creating an isotropic image.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default resolution of 200 is used.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before PDFDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFHorizontalResolution(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFVerticalResolution(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Images" qi="Convert Image Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Images Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Images conversion will convert Image files of various formats a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Image]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the ImageToTIFF to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.  ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  Subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      will be on the new TIFF files that were created at run time.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageToTIFF" qi="Converts an Image file to TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Image, the file will be converted to a single TIFF file.]]>
<![CDATA[
]]>
<![CDATA[        ImageFileTypesToConvert must be used along with ImageToTIFF.]]>
<![CDATA[
]]>
<![CDATA[        Only the image types set by a previous call to ImageFileTypesToConvert will]]>
<![CDATA[
]]>
<![CDATA[        be converted to a TIFF. No images will be converted if ImageFileTypesToConvert has not been set.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ImageFileTypesToConvert(".jpg,.jpeg,gif,bmp")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageToTIFF()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a supported Image type or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageMonoType" qi="Sets the method to use when converting color images to black and white tiffs.">
			<p name="Mono" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        Mono : A positive numeric value of 1 to 4 for the type of conversion to use.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        1: Convert image using Diffusion method.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        2: Convert image using Halftone method.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        3: Convert image using Bayer method.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        4: Convert image using Threshold method with a threshold value. Value defaults to 10.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the black and white conversion algorithm to use when converting color or grey scale images to TIFF.]]>
<![CDATA[
]]>
<![CDATA[        If you are using the threshold method, you must also call the ImageMonoThreshold action]]>
<![CDATA[
]]>
<![CDATA[        prior to converting the image with ImageToTIFF.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Error diffusion is a type of halftoning in which the quantization residual is distributed to neighboring]]>
<![CDATA[
]]>
<![CDATA[        pixels that have not yet been processed. Its main use is to convert a color image into a black and white image.]]>
<![CDATA[
]]>
<![CDATA[        Halftone is the reprographic technique that simulates continuous tone imagery]]>
<![CDATA[
]]>
<![CDATA[        through the use of dots, varying either in size or in spacing.  Bayer method is an image dithering algorithm]]>
<![CDATA[
]]>
<![CDATA[        that is commonly used to maintain a the characteristics of a photo image of higher colors in an image of less color depth.]]>
<![CDATA[
]]>
<![CDATA[        The threshold method makes individual pixels in an image black if their value is greater]]>
<![CDATA[
]]>
<![CDATA[        than the threshold value and the remaining pixels white.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        For best results, you may need to experiment with the different types of images that you are expecting]]>
<![CDATA[
]]>
<![CDATA[        to process and select the conversion method that gives you the best results.  If the resulting TIFF images]]>
<![CDATA[
]]>
<![CDATA[        are going to be used in a subsequent recognition process, pick the technique that works best to]]>
<![CDATA[
]]>
<![CDATA[        output dark, solid characters with as little background noise, or dithering around the characters, as possible.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ImageFileTypesToConvert(".jpg,.jpeg,gif,bmp")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageMonoType(1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageToTIFF()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageMonoThreshold" qi="Sets the threshold value when converting Image to 1 bit tiff using threshold type conversion.">
			<p name="thresh" type="short" qi="A positive numeric value from 1 to 255.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        thresh: A positive numeric value from 1 to 255.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Sets the B/W conversion algorithm value to use when converting color or grey scale images to TIFF with the Threshold method option.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ImageFileTypesToConvert(".jpg,.jpeg,gif,bmp")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageMonoType(4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageMonoThreshold(9)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageToTIFF()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageFileTypesToConvert" qi="Sets the file extension values of image types to convert to tiff.">
			<p name="fileextensions" type="string" qi="A CSV string of file extensions that defines the image types that will be converted.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        fileextensions : A CSV string of file extensions that defines the image types that will be converted.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the file extension values of image types to convert to TIFF.  The file types of JEPG, BMP, PNG, TIFF and GIF are supported.]]>
<![CDATA[
]]>
<![CDATA[        A period prefixing the extension is allowed, but not required.  Because TIFF is supported, it is possible to use]]>
<![CDATA[
]]>
<![CDATA[        this action to convert a color TIFF to a Black and White TIFF.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action must be used prior to ImageToTIFF.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageFileTypesToConvert(".jpg,.jpeg,gif,bmp")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageToTIFF()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Html" qi="Convert Html Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Html Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Html conversion will convert electronic HTM and HTML documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Html]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the HtmlToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="HtmlToImage" qi="Converts a page with *.htm or *.html file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Html Document, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Document, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Html actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          HtmlPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          HtmlTiffCompression(CCITT4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[HtmlToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Html Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="HtmlPrintQuality" qi="Adjusts the resolution of the image output by HtmlToImage.">
			<p name="dpi" type="int" qi="A single positive numeric value for the dots per inch (dpi) of the output image.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for HtmlToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[HtmlPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          HtmlDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="HtmlTiffCompression" qi="Sets the compression used in the TIFF output by HtmlToImage.">
			<p name="tiffCompression" type="string" qi="A parameter of one of the following values to set the TIFF compression:">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from HtmlToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[HtmlTiffCompression(CCITT4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          HtmlToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Rtf" qi="Convert Rtf Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Rtf Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Rtf conversion will convert electronic RTF documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Rtf]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the RtfToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RtfToImage" qi="Converts a page with *.rtf file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a Rtf Document, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Document, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Rtf actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          RtfPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RtfTiffCompression(CCITT4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RtfToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a Rtf Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RtfPrintQuality" qi="Adjusts the resolution of the image output by RtfToImage.">
			<p name="dpi" type="int" qi="A single positive numeric value for the dots per inch (dpi) of the output image.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for RtfToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RtfPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RtfToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RtfTiffCompression" qi="Sets the compression used in the TIFF output by RtfToImage.">
			<p name="tiffCompression" type="string" qi="A parameter of one of the following values to set the TIFF compression:">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from RtfToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RtfTiffCompression(CCITT4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RtfToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Txt" qi="Convert Txt Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Txt Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Txt conversion will convert electronic TXT documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Txt]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the TxtToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in]]>
<![CDATA[
]]>
<![CDATA[      a single batch is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the eDoc Conversion Actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the eDoc Conversion Actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the eDoc Conversion Actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="TxtToImage" qi="Converts a page with *.txt file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a Txt Document, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Document, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Txt actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          TxtPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          TxtTiffCompression(CCITT4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[TxtToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a Txt Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="TxtPrintQuality" qi="Adjusts the resolution of the image output by TxtToImage.">
			<p name="dpi" type="int" qi="A single positive numeric value for the dots per inch (dpi) of the output image.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for TxtToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[TxtPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          TxtToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="TxtTiffCompression" qi="Sets the compression used in the TIFF output by TxtToImage.">
			<p name="tiffCompression" type="string" qi="A parameter of one of the following values to set the TIFF compression:">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from TxtToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[TxtTiffCompression(CCITT4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          TxtToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="CustomActions" v="1.0.0">
	<com ref="Datacap.Libraries.CustomActions.Actions" qi="Description of action library">
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SampleAction" qi="sample method declaration in RRX">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SampleQuerySmartParamValue" qi="sample method demonstrating how to query an object's value using smart parameters. This action applies to field level only.">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ValidateDate" qi="validate date to format dd-mm-yyyy">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ValidateDay" qi="validate day from 1 to 31 ">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ValidateMonth" qi="validate month from 1 to 12">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ValidateYear" qi="validate year 4 digits">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ValidateBirthDay" qi="age from 16 to 45">
			<p name="birthday" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="HelloWorld" qi="Say Hello to Web service">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadFile" qi="Upload a Tank txt file">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadFileFileNetSupportingDoc" qi="Upload FileNet Supporting Docs and XML File">
			<p name="docType" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
			<p name="ID" type="String">
			</p>
			<p name="pageID" type="String">
			</p>
			<p name="name" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadFileNetDoc" qi="Upload FileNet Docs and XML File">
			<p name="docType" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
			<p name="ID" type="String">
			</p>
			<p name="pageID" type="String">
			</p>
			<p name="name" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadFileNetLeftThumb" qi="Upload FileNet Docs and XML File">
			<p name="docType" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
			<p name="ID" type="String">
			</p>
			<p name="pageID" type="String">
			</p>
			<p name="name" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadFileNetRightThumb" qi="Upload FileNet Docs and XML File">
			<p name="docType" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
			<p name="ID" type="String">
			</p>
			<p name="pageID" type="String">
			</p>
			<p name="name" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadFileNetLeftThumbOLD" qi="Upload FileNet Docs and XML File">
			<p name="docType" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
			<p name="ID" type="String">
			</p>
			<p name="pageID" type="String">
			</p>
			<p name="name" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadFileNetRightThumbOLD" qi="Upload FileNet Docs and XML File">
			<p name="docType" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
			<p name="ID" type="String">
			</p>
			<p name="pageID" type="String">
			</p>
			<p name="name" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadDocHeitech" qi="Upload Heitech XML File">
			<p name="ID" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadDocListHeitech" qi="Upload Heitech XML Doc List">
			<p name="ID" type="String">
			</p>
			<p name="AppRefNo" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SaveBarcodeList" qi="Save BarcodeList to txt">
			<p name="docID" type="String">
			</p>
			<p name="barcodeList" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SendDataSilverLake" qi="Send data silverlake">
			<p name="strCIFNumber" type="String">
			</p>
			<p name="strRefNumber" type="String">
			</p>
			<p name="strAccNumber" type="String">
			</p>
			<p name="strAccType" type="String">
			</p>
			<p name="strModule" type="String">
			</p>
			<p name="strHostDocID" type="String">
			</p>
			<p name="strScanOfficerID" type="String">
			</p>
			<p name="dtScanDateTime" type="String">
			</p>
			<p name="dtCommitalDateTime" type="String">
			</p>
			<p name="strDocURL" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="setBarcodeValueFromList" qi="Save BarcodeList to txt">
			<p name="batchID" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SaveBarcodeListOLD" qi="Save BarcodeList to txt">
			<p name="docID" type="String">
			</p>
			<p name="barcodeList" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="setBarcodeValueFromListOLD" qi="Save BarcodeList to txt">
			<p name="batchID" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UpdateFileNetDocOLD" qi="Update FileNet Docs and XML File">
			<p name="docType" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
			<p name="ID" type="String">
			</p>
			<p name="pageID" type="String">
			</p>
			<p name="name" type="String">
			</p>
			<p name="SSNITNumber" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UploadFileNetDocOLD" qi="Upload FileNet Docs and XML File">
			<p name="docType" type="String">
			</p>
			<p name="batchID" type="String">
			</p>
			<p name="ID" type="String">
			</p>
			<p name="pageID" type="String">
			</p>
			<p name="name" type="String">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="DCImageFix" v="8.1.0.0">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' Document Convertion Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['IBM InfoSphere Classification Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.0"]]>
<![CDATA[
]]>
<![CDATA[' Created 05/11/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.0"]]>
<![CDATA[
]]>
<![CDATA[' Created 05/23/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA['- Moved parameter information from the qi= tag to the standard parameter help section]]>
<![CDATA[
]]>
<![CDATA['- Moved action information from the qi= tag to the standard action help section]]>
<![CDATA[
]]>
<![CDATA['- Added IBM Copyright notice]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
	<com ref="Datacap.Libraries.ImageFix.Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageEnhance">
			<p name="BackupFileExtension" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        The file extension that the action is to assign to the backup of the original Image file.]]>
<![CDATA[
]]>
<![CDATA[        For example: tio]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The extension should be 3 or 4 alphanumeric characters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Initiates image processing to perform a preconfigured set of image enhancements.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action after a ]]>
				<scr>
<![CDATA[LoadSettings]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[LoadSettings_FingerprintID]]>
				</scr>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[LoadSettings(C:\ParentDir\Invoice\Process\ImageFix.ini)]]>
					</scr>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[ImageEnhance(tio)]]>
						</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Keep in mind in this example that the ImageFix settings specified in ImageFix.ini will be]]>
<![CDATA[
]]>
<![CDATA[          applied to every page in the batch.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page or Field Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is not 3 or 4 alphanumeric characters, or if there is an exception encountered while enhancing the image.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LoadSettings">
			<p name="BackupFileExtension" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[String]]>
				</i>
<![CDATA[value of the path to the ImageFix Settings file (.ini).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Note, however, that the action can use Smart Parameter syntax, such as the '@PATH(string)']]>
<![CDATA[
]]>
<![CDATA[        method to specify the path.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action loads the settings that the ]]>
				<b>
<![CDATA[ImageFix]]>
				</b>
<![CDATA[action will use to process all images]]>
<![CDATA[
]]>
<![CDATA[        in the current batch. The action's parameter includes the file's name and complete path to]]>
<![CDATA[
]]>
<![CDATA[        its location in the application's ]]>
				<b>
<![CDATA[Process]]>
				</b>
<![CDATA[directory. As an alternative, the parameter]]>
<![CDATA[
]]>
<![CDATA[        can use a ]]>
				<i>
<![CDATA[smart]]>
				</i>
<![CDATA[ parameter such as @Path to designate the value of the path to the]]>
<![CDATA[
]]>
<![CDATA[        same ]]>
				<b>
<![CDATA[Process]]>
				</b>
<![CDATA[directory.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[LoadSettings(C:\ParentDir\Invoice\Process\ImageFix.ini)]]>
						</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[ImageEnhance(tio)]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          Loads the settings file using the path denoted by the "ScanFixSettings" key that is listed]]>
<![CDATA[
]]>
<![CDATA[          in the Paths.ini file.  If the key pointed to a relative path, it would be converted to the]]>
<![CDATA[
]]>
<![CDATA[          appropriate full path and then use that path to find the settings:]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[LoadSettings(@PATH(ScanFixSettings))]]>
						</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[ImageEnhance(tio)]]>
					</scr>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ImageFix Settings file that you specify as a parameter is not found. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LoadSettings_FingerprintID">
			<p name="FingerprintsFolderPath" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[String]]>
				</i>
<![CDATA[ value of the path to the fingeprint folder ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Note, however, that the action can use Smart Parameter syntax, such as the '@PATH(string)']]>
<![CDATA[
]]>
<![CDATA[        method to specify the path.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Loads the specific ImageFix Settings file (.ini) that corresponds to the Fingerprint ID of the current page.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The action will search the application's fingerprint folder for a fingerprint-specific]]>
<![CDATA[
]]>
<![CDATA[        ImageFix Settings file. Settings for these files are assigned during the Image Enhancement phase]]>
<![CDATA[
]]>
<![CDATA[        of Fingerprint Definition, using tools of Rule Manager's Image Processing Setup dialog.]]>
<![CDATA[
]]>
<![CDATA[        (Chapter 3 of the Rule Manager Reference shows you how to define a fingerprint-specific]]>
<![CDATA[
]]>
<![CDATA[        ImageFix Settings file.)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Important!]]>
				</b>
<![CDATA[ The name of a fingerprint-specific ImageFix Settings file is limited to]]>
<![CDATA[
]]>
<![CDATA[        the Fingerprint ID with the ".ini" extension: 1044.ini, for example.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[LoadSettings_FingerprintID()]]>
						</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[ImageEnhance(tio)]]>
					</scr>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if a fingerprint-specific Settings file does not exist. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</com>
</rrx>
<rrx namespace="dcpdf" v="8.1.0.18">
	<i ref="rrunner">
	</i>
	<af name="dcpdf_UseAltConversionMethod" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[
]]>
<![CDATA[		None.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    There are two internal algorithms that are used to convert a PDF to a TIFF.  This action enables the alternate]]>
<![CDATA[
]]>
<![CDATA[    algorithm.  It is recommended that the alternate algorithm is used.  Testing has shown that it produces]]>
<![CDATA[
]]>
<![CDATA[    cleaner TIFF images.  This action must be called prior to dcpdf_CreateTiffFromPDF or dcpdf_CreateTiffFromPDF_CreateDocs.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[			]]>
				<b>
<![CDATA[dcpdf_UseAltConversionMethod()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_CreateTiffFromPDF()]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_SetImageResolution" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[    Two comma-separated ]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[ values specifying X resolution and Y resolution (in that order.) ]]>
<![CDATA[
]]>
<![CDATA[    The values are expressed in Dots (pixels) Per Inch (DPI).]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action sets the X and Y resolution for the pages of a PDF that is converted to TIFF.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[    the default of 200 x 200 wil be used.  It is strongly recommended that the X and Y resolutions are always set]]>
<![CDATA[
]]>
<![CDATA[    the same to produce an isotropic image, which will allow for better fingerprinting and recognition.  If this action]]>
<![CDATA[
]]>
<![CDATA[    is used, it must be called before dcpdf_CreateTiffFromPDF or dcpdf_CreateTiffFromPDF_CreateDocs.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[			]]>
				<b>
<![CDATA[dcpdf_SetImageResolution("300,300")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_CreateTiffFromPDF()]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if the parameters are not Numeric. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_SetImageBitcount" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[		]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[value of the BitCount of any image in a PDF document. The action's acceptable values are:]]>
<![CDATA[
]]>
<![CDATA[		]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[1]]>
			</b>
<![CDATA[ for Black and White images (a typical value).]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[8]]>
			</b>
<![CDATA[ for Grayscale images.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[24]]>
			</b>
<![CDATA[	for Color images.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Sets the BitCount of any image identified in a PDF file by an action such as CreateTiffFromPDF. The parameter's value for the action typically reflects the nature of the images in the PDF file. The default value is 1 (Black and white images)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Note: The BitCount is the standard number of bits per pixel throughout an image.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[			dcpdf_SetImageBitCount("1")				    black and white images.]]>
<![CDATA[
]]>
<![CDATA[			]]>
				<br>
				</br>
<![CDATA[dcpdf_SetImageBitCount("8")			grayscale images.]]>
<![CDATA[
]]>
<![CDATA[			]]>
				<br>
				</br>
<![CDATA[dcpdf_SetImageBitCount("24")			color images.]]>
<![CDATA[
]]>
<![CDATA[		]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if the parameter is not ]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_SetImageCompression" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[A ]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[value representing one the following Compressions:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[	  1 = NONE	(DUMP MODE)]]>
			<BR>
			</BR>
<![CDATA[
]]>
<![CDATA[		2 = CCITTRLE (CCITT modified Huffman RLE)]]>
			<BR>
			</BR>
<![CDATA[
]]>
<![CDATA[		3 = CCITTFAX3 (CCITT Group 3 fax encoding)]]>
			<BR>
			</BR>
<![CDATA[
]]>
<![CDATA[		4 = CCITTFAX4 (CCITT Group 4 fax encoding)]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		5 = COMPRESSION_LZW (Lempel-Ziv and Welch)]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		7 = JPEG (%JPEG DCT compression)]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		32773 = PACKBITS (Macintosh RLE)]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Sets the compression that will be used when converting a page from a PDF file to a TIFF file.  Group 4 Fax is the most]]>
<![CDATA[
]]>
<![CDATA[    common compression used for text recognition.  It produces a lossless compressed black and white image. The default compression value is 4 (CCITT Group 4 fax encoding).]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_SetImageCompression("7")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[			dcpdf_CreateTiffFromPDF("True")]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if the parameter is not ]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_MaxSizeToReconvert" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[    A ]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[ value representing the maximum image size in ]]>
<![CDATA[
]]>
<![CDATA[    KB before attempting to convert with an alternate algorithm.  If the value is 0, then the alternate]]>
<![CDATA[
]]>
<![CDATA[    algorithm will never be used.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Causes dcpdf_CreateTiffFromPDF to use a different algorithm based on the configured file size. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    The conversion of PDF to TIFF usually works fast and produces clean images.  From time to time, the]]>
<![CDATA[
]]>
<![CDATA[    resulting TIFF may become unusually large.  A reason for this has been due to the background becoming a dithered]]>
<![CDATA[
]]>
<![CDATA[    light gray background instead of a pure white.  This leads to very large image sizes because compression is now]]>
<![CDATA[
]]>
<![CDATA[    less efficient.  It also could lead to reduced recognition quality.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    To compensate for these rare situations, this action can be used to produce a clean TIFF from a PDF that compresses well.]]>
<![CDATA[
]]>
<![CDATA[    When a TIFF is created from a PDF, the file size is checked to see if it exceeds the value set by this action.  If file]]>
<![CDATA[
]]>
<![CDATA[    size is smaller, then is considered a successful conversion.  If the file size is larger, then this alternate method]]>
<![CDATA[
]]>
<![CDATA[    is performed.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    This action must be called prior to dcpdf_CreateTiffFromPDF.  If this action is not called, the default value of 2000KB is used.]]>
<![CDATA[
]]>
<![CDATA[    Calling dcpdf_SetImageGrayscale(TRUE) will cause dcpdf_CreateTiffFromPDF(True) to always use the alternate algorithm.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_SetMaxImageSize("10000")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_CreateTiffFromPDF("True")]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      This example will cause the alternate conversion algorithm to be used if the initial conversion produces]]>
<![CDATA[
]]>
<![CDATA[      a TIFF image that is larger than 10000KB.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    False if the parameter is not ]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[. Otherwise, True.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_SetImageQuality" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[		]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[value, between 1 and 100, of the Image Quality standard for images in the PDF file.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action determines the resulting image quality when creating a TIFF from a PDF file.  A higher number will produce]]>
<![CDATA[
]]>
<![CDATA[    a better looking image, but may require more processing time. The default value is 100.]]>
<![CDATA[
]]>
<![CDATA[		]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_SetImageQuality("75")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[			dcpdf_CreateTiffFromPDF("True")]]>
				<b>
				</b>
<![CDATA[
]]>
<![CDATA[	  ]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if the parameter is not ]]>
			<i>
<![CDATA[Numeric.]]>
			</i>
<![CDATA[  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_SetImageGrayscale" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[    The parameter can be True or False.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[True:]]>
			</b>
<![CDATA[ gray areas of the image should not be dithered.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False:]]>
			</b>
<![CDATA[ gray areas of the image should be dithered.  This is the default.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Sets a Grayscale flag for images in a PDF file generated by an action such as dcpdf_CreateTiffFromPDF. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    This action controls how gray areas of a grayscale image are handled when converted to black and white.  For example, if]]>
<![CDATA[
]]>
<![CDATA[    you have a text document with a gray background, it is recommended to call this action and pass "True".  This will]]>
<![CDATA[
]]>
<![CDATA[    cause the gray area below a predefined tolerance to be converted to white, producing an image that can recognize well.]]>
<![CDATA[
]]>
<![CDATA[    If you have a grayscale image and this action set to false, gray areas will be dithered to simulate gray in the resulting]]>
<![CDATA[
]]>
<![CDATA[    TIFF image. The default value is false.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    If this action is used, it must be called before dcpdf_CreateTiffFromPDF or dcpdf_CreateTiffFromPDF_CreateDocs.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_SetImageGrayscale("True")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[			dcpdf_CreateTiffFromPDF("True")]]>
<![CDATA[
]]>
<![CDATA[		]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Batch or Document.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_CreateTiffFromPDF_CreateDocs" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[		The parameter can be True or False.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		]]>
			<b>
<![CDATA[True:]]>
			</b>
<![CDATA[ Causes a document hierarchy to be created when TIFF pages are created from a PDF file.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False:]]>
			</b>
<![CDATA[ A document hierarchy will not be created, making this action operate exactly like dcpdf_CreateTiffFromPDF.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action converts the pages in a PDF file to TIFFs, like dcpdf_CreateTiffFromPDF.  The difference is that if ]]>
<![CDATA[
]]>
<![CDATA[    the parameter is True, a document hierarchy will be created for each PDF to group each of the pages from a single PDF into]]>
<![CDATA[
]]>
<![CDATA[    their own document.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[			]]>
				<b>
<![CDATA[dcpdf_CreateTiffFromPDF_CreateDocs("True")]]>
				</b>
<![CDATA[
]]>
<![CDATA[			]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[			]]>
				<br>
				</br>
<![CDATA[In this example, the action uses a primary algorithm to establish a runtime Document for each ]]>
<![CDATA[
]]>
<![CDATA[      source document in the PDF file – and assign pages to the runtime Documents according to their ]]>
<![CDATA[
]]>
<![CDATA[      placement in the source PDF files.]]>
<![CDATA[
]]>
<![CDATA[		]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Batch Level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if the action is not run at the Batch level, or if the source PDF file does not have a ]]>
<![CDATA[
]]>
<![CDATA[    minimum number of pages (0). Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_CreateTiffFromPDF" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[
]]>
<![CDATA[    None.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action looks for PDF files in the current batch; creates Image files (.tiff) for each page in the PDF file; ]]>
<![CDATA[
]]>
<![CDATA[    and creates one document for the PDF file.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    Note: dcpdf_MaxSizeToReconvert can be used to control how this action creates a TIFF file.  PDFs are converted to]]>
<![CDATA[
]]>
<![CDATA[    TIFF using a fast algorithm.  With some occasional input documents, this may produce images that are large and]]>
<![CDATA[
]]>
<![CDATA[    may not recognize well, causing them to be automatically reconverted to TIFF using a cleaner but slightly slower]]>
<![CDATA[
]]>
<![CDATA[    algorithm.  See the help for dcpdf_MaxSizeToReconvert for more information.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_CreateTiffFromPDF()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      When the action in this example encounters a PDF file in the batch, it creates ]]>
<![CDATA[
]]>
<![CDATA[      a corresponding Image file (.tiff) and gives the Image file the PDF file’s name.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Batch only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if the action is not run at the Batch level; if there are no PDF files in the batch; ]]>
<![CDATA[
]]>
<![CDATA[    or if an error occurs while TIFF files are being created. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_MakePDFDoc" access="public" bInter="bInter" bDebug="bDebug" strParam="bImprintDCO">
		<ap>
<![CDATA[
]]>
<![CDATA[    The parameter can be True or False. The default value is False.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[True:]]>
			</b>
<![CDATA[ stores recognized field data associated with each page’s TIFF image in the PDF file, to make a searchable PDF. ]]>
<![CDATA[
]]>
<![CDATA[    (The text data is not visible, but it is searchable.)]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False:]]>
			</b>
<![CDATA[ inserts the image of a page into the PDF file, the recognized text is not inserted. ]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Creates a PDF document containing one or more pages of a document. The PDF format can contain only the ]]>
<![CDATA[
]]>
<![CDATA[    original image or it can contain the image along with the recognized text to make the PDF searchable.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Only zoned field text will be included. if the input parameter is "True", and is searchable within the PDF.]]>
<![CDATA[
]]>
<![CDATA[    The searchable text may not accurately reflect the text position within the original input image.]]>
<![CDATA[
]]>
<![CDATA[    If you need the entire page text included as searchable text, or more accurate alignment,]]>
<![CDATA[
]]>
<![CDATA[    use one of the recognition actions to create the PDF, such as RecognizeDocToPDDF from the OCR_S library.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetTitle("MedicalClaims")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetSubject("Validated")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetAuthor("Steven Moffat")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetProducer("Russell Davies")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetApplication("MClaims")]]>
				<br>
				</br>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_MakePDFDoc("True")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[			]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[			This example sets several properties of the PDF file and creates a PDF that contains the ]]>
<![CDATA[
]]>
<![CDATA[      recognized text along with the original page images.]]>
<![CDATA[
]]>
<![CDATA[		]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Document Level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if the action is not run at the Document or Batch level; ]]>
<![CDATA[
]]>
<![CDATA[    if there are no pages in the document; or if an error occurs while the PDF file is being created.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
	</af>
	<af name="dcpdf_SetTitle" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[		]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[ value of the Title.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    This action sets the Title property of a PDF document generated by a subsequent ]]>
			<b>
<![CDATA[dcpdf_MakePDFDoc]]>
			</b>
<![CDATA[action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    The Title is a searchable value for the page or document.  If this action is not called prior to dcpdf_MakePDFDoc,]]>
<![CDATA[
]]>
<![CDATA[    the value will default to “Untitled”.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_SetTitle("NewInvoice")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_MakePDFDoc("True")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
		</ret>
	</af>
	<af name="dcpdf_SetSubject" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[		]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[value of the Subject.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action sets the Subject property of PDF generated by a subsequent ]]>
			<b>
<![CDATA[dcpdf_MakePDFDoc]]>
			</b>
<![CDATA[ action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    The Subject is a searchable value for the page or document. If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[    the value of the subject will be left blank in the resulting document.		]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_SetSubject("HealthClaimDoc")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetAuthor("Harriet Jones")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[			dcpdf_MakePDFDoc("True")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
			<lvl>
<![CDATA[Batch or Document.]]>
			</lvl>
<![CDATA[
]]>
<![CDATA[    ]]>
			<ret>
<![CDATA[Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
			</ret>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
	</af>
	<af name="dcpdf_SetAuthor" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[		]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[value of the Author.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    If you do not call this action, the value will default to “Should be a Task Name”.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
		</ret>
		<h>
<![CDATA[This action attaches the Author’s name (or a related value) to a PDF page or document generated by a subsequent ]]>
			<b>
<![CDATA[dcpdf_MakePDFDoc]]>
			</b>
<![CDATA[action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_SetAuthor("Harriet Jones")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetProducer("Russell Davies")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetApplication("Invoices")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_MakePDFDoc("True")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
	</af>
	<af name="dcpdf_SetProducer" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[    ]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[value of the Producer ID.    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Sets the producer value of the PDF document.  This action must be called prior to calling dcpdf_MakePDFDoc.]]>
<![CDATA[
]]>
<![CDATA[    If this action is not called, the value will default to 'Producer'.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetAuthor("Steven Moffat")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_SetProducer("Russell Davies")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetApplication("Invoices")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      dcpdf_MakePDFDoc("True")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
		</ret>
	</af>
	<af name="dcpdf_SetKeywords" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[		]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[ value of the Keyword.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		If you do not call this action, the keyword value will be left blank.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action assigns a single Keyword to a PDF page or document generated by a subsequent ]]>
			<b>
<![CDATA[dcpdf_MakePDFDoc]]>
			</b>
<![CDATA[action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		Use this action repeatedly within a rule to assign additional Keywords. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
				<i>
<![CDATA[Important!]]>
				</i>
			</b>
<![CDATA[ This action must precede the ]]>
			<b>
<![CDATA[dcpdf_MakePDFDoc]]>
			</b>
<![CDATA[action.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      dcpdf_SetKeywords("Invoices")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[dcpdf_MakePDFDoc("True")]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
		</ret>
	</af>
	<af name="dcpdf_SetApplication" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[value of the Application ID.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This sets the Application ID property of a PDF document generated by a subsequent ]]>
			<b>
<![CDATA[dcpdf_MakePDFDoc]]>
			</b>
<![CDATA[ action.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If this action is not called, the value will default to "Application".]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[dcpdf_SetApplication("Invoices")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        dcpdf_SetAuthor("Harriet Jones")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        dcpdf_MakePDFDoc("True")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Batch or Document level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</af>
</rrx>
<rrx namespace="Ewsmail" v="8.0.1.19">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' EWSMail Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/13/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA['  * SPR 27158 Added Datacap Studio help to the actions.  ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 3/18/10 NSK]]>
<![CDATA[
]]>
<![CDATA[' Added ex_EMLOption action declaration and help]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 5/17/2010 NSK]]>
<![CDATA[
]]>
<![CDATA[' Added ex_ews_version to select Exchange Server version (if not 2010)]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 5/28/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28371 - Update help to make it more consistent.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/03/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28371 - Update help for ex_scan.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/21/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28371 - Remove spaces from email variable names.  EmailCount added to ex_scan. ]]>
<![CDATA[
]]>
<![CDATA[' Adjusted help to match imail action help, where possible.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/15/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 26932 - Updated help text in ex_ews_version, ex_login and ex_EMLOption.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/16/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 26932 / 27158 - Updated help text in ex_login.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/13/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28909 Added information in the ex_scan help regarding the email processing method.]]>
<![CDATA[
]]>
<![CDATA[' Also updated ex_max_docs to clarify that a batch can end up with more attachments than the value set in ex_max_docs.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/10/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Enhanced action/method qi text for ex_login to say smartparameters are supported. SPR 31013]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/19/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 32145 31022 Removed use of SIT and removed use of qi parameters for help text.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/13/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 31793 Added information regarding email subject lengths.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[''**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="ewsmail.CDCewsmail" qi="Exchange EWS main input actions - import image attachments from email messages">
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_ews_version" qi="Select the Exchange Server version.">
			<p name="version" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        The value 0, 1 or 2, indicating the following:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        1 = Exchange 2007 SP1]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        2 = Exchange 2010]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        0 = latest version (default)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Each version of Exchange uses a slightly different communication protocol.  Use this action to set the expected version.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        In order to connect successfully with:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        •	Exchange 2007 SP1, call this action with parameter "1" before im_login.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        •	Exchange 2010, call action with parameter "2" before im_login.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        •	The latest version "known" by the .NET library in use (which is .NET 3.5 and is currently Exchange 2010), this action must be called with parameter "0".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called at all it uses the default "0", the latest version.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_ews_version(1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_login("mymailserver/Exchange.asmx","Username@Org","password")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level, Open event.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_login]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_login" qi="Specifies the the Exchange Server and mail account">
			<p name="hostname" type="string" qi="URL of Exchange Web Service, ends with /Exchange.asmx (Smartparameters are supported)">
			</p>
			<p name="username" type="string" qi="Username@Org for mail account and organization (blank to use Windows Authentication, Smartparameters are supported)">
			</p>
			<p name="password" type="string" qi="Password for mail account (blank if none or Windows Authentication, Smartparameters are supported )">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        hostname : URL of Exchange Web Service, ends with /Exchange.asmx]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        username : Username@Org for mail account and organization (blank to use Windows Authentication)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password : Password for mail account (blank if none or Windows Authentication)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        All parameters support smart parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Connects to the mail server using the specified account information.]]>
<![CDATA[
]]>
<![CDATA[        Login credentials are for a Microsoft Exchange mail server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The mail account must contain an Inbox folder and separate folders for messages imported (Done)]]>
<![CDATA[
]]>
<![CDATA[        and errors (Problem).  The Done and Problem folders must be subfolders of the email account's Inbox.]]>
<![CDATA[
]]>
<![CDATA[        The names of these folders can be specified using the ex_done_folder and ex_problem_folder actions.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The Microsoft Exchange Email actions are designed to scan an email Inbox for incoming mail messages,]]>
<![CDATA[
]]>
<![CDATA[        and place selected messages into a new batch.]]>
<![CDATA[
]]>
<![CDATA[        It is possible to ignore all messages except those containing specific attachment types.]]>
<![CDATA[
]]>
<![CDATA[        The actions are typically assigned to a Task that is executed by an unattended Taskmaster Rulerunner station.]]>
<![CDATA[
]]>
<![CDATA[        Multiple Inboxes can be scanned by stringing together a set of]]>
<![CDATA[
]]>
<![CDATA[        login/scan/logout actions for each Inbox, or by assigning an Inbox to each input task.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_login("mymailserver/Exchange.asmx","Username@Org","password")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level, open event.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the login succeeds.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_logout]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_scan" qi="Poll the specified mail server for incoming email with image attachments">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Scans emails in the Inbox for specified attachments, imports selected emails with attachments into the batch.  ]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch.]]>
<![CDATA[
]]>
<![CDATA[        A connection to the email server must have previously been established using the ex_login action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each input email (document) will contain the following variables set in the document hierarchy:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TYPE]]>
				</b>
<![CDATA[: Always set to "Document".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MessageID]]>
				</b>
<![CDATA[: The email message ID.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Subject]]>
				</b>
<![CDATA[: The email subject.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Body]]>
				</b>
<![CDATA[: The text within the email.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[DateSent]]>
				</b>
<![CDATA[: The sent date stamp on the email.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[From]]>
				</b>
<![CDATA[: The email sender.]]>
				<br>
				</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[To]]>
				</b>
<![CDATA[: The email recipients.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Priority]]>
				</b>
<![CDATA[: The state of the email importance flag.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[DateReceived]]>
				</b>
<![CDATA[: The received date stamp on the email.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each email attachment (page) will have the following variables set:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TYPE]]>
				</b>
<![CDATA[: Always set to "Other".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IMAGEFILE]]>
				</b>
<![CDATA[: The name of the attachment as saved on disk.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ATTACHNAME]]>
				</b>
<![CDATA[: The name of the attachment.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The following batch level variable is created:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[EmailCount]]>
				</b>
<![CDATA[: The number of emails scanned into the batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Note: If the configured Done or Problem folders do not exist, the email will be moved to the Deleted Items folder.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Waiting emails are processed in blocks.  The amount of emails processed in a block will be the number of]]>
<![CDATA[
]]>
<![CDATA[        waiting emails, or the number of emails remaining from the value set in ex_max_docs, up to a maximum of 50.]]>
<![CDATA[
]]>
<![CDATA[        After a block of emails are processed, the wait time]]>
<![CDATA[
]]>
<![CDATA[        is checked.  If the wait time has not been reached and the maximum number of emails]]>
<![CDATA[
]]>
<![CDATA[        has not been reached, then another block of emails are processed.]]>
<![CDATA[
]]>
<![CDATA[        If the wait time has been reached, then no more emails are input to the batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that the subject line be no longer than 78 characters as this is a]]>
<![CDATA[
]]>
<![CDATA[        common subject line length limitation.  Some systems may support even shorter lengths,]]>
<![CDATA[
]]>
<![CDATA[        truncating the subject.  Our testing has been successful with lengths up to 255 characters.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended to test your settings and use lengths appropriate for your systems.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Use ex_max_docs to configure the number of emails processed per batch.  The number of items]]>
<![CDATA[
]]>
<![CDATA[        included in the batch can be different than this amount, see ex_max_docs for more details.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ex_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_abort_time("40")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_max_docs("50")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_types("jpg,tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_scan()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[			 ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Returns ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the operation fails, and the action will also pause before returning based on]]>
<![CDATA[
]]>
<![CDATA[        the configured abort time configured by ex_abort_time.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If no selected emails were available, the action returns ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ and also pauses before returning based ]]>
<![CDATA[
]]>
<![CDATA[        on the wait time configured using ex_wait_time.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_login, ex_wait_time, ex_max_docs]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_logout" qi="Disconnect from the mail server">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Closes the connection to the mail server. ]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch after ex_login and ex_scan have completed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_logout()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open or Close event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_types" qi="Specifies valid image attachment extensions">
			<p name="extensions" type="string" qi="Comma-separated list of file image file attachment extensions to import, with or without period. If a blank extension is supplied, ex_scan will import messages with no attachments.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        extensions : A comma-separated list of file image file attachment extensions to import, ]]>
<![CDATA[
]]>
<![CDATA[        with or without period. If a blank extension is supplied, ex_scan will import messages with no attachments.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action specifies the allowable email attachment types.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of ".pdf" will be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is called and no attachment types are specified, all emails and any attachments are added to the batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If attachment types are specified and the email contains:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • Only the specified attachment types, the email and attachments will be added to the batch]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • Only unspecified attachment types, or if it contains a mix of specified and unspecified attachment types, the email is moved to the Problem folder]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • No attachments, the email is moved to the Problem folder]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ex_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_abort_time("40")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_types("jpg,tif")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_wait_time" qi="Specifies the maximum time to wait for input emails for a single batch.">
			<p name="nSecs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The maximum number of seconds to wait.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The maximum time to wait for input files for a single batch.]]>
<![CDATA[
]]>
<![CDATA[        Used by the ex_scan action after the first email has been processed to determine how long to]]>
<![CDATA[
]]>
<![CDATA[        wait for the batch to fill up.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        The import of emails into the batch will stop when the ]]>
<![CDATA[
]]>
<![CDATA[        wait limit is reached or when the maximum emails per batch has been reached.  ]]>
<![CDATA[
]]>
<![CDATA[        While waiting for new mail to arrive, the mailbox will be polled every two seconds to ]]>
<![CDATA[
]]>
<![CDATA[        check for waiting mail. The action will continue to include new emails into the batch ]]>
<![CDATA[
]]>
<![CDATA[        until this wait time is reached or the maximum number of emails per batch is reached.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default wait time of 5 seconds will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_wait_time("20")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This example causes the scan operation to wait for 20 seconds for additional email,]]>
<![CDATA[
]]>
<![CDATA[          after processing the first email, before finishing the scan operation.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_abort_time" qi="Specifies the delay time before returning when a batch aborts.">
			<p name="nSecs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The number of seconds to wait.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The action will wait the specified time before returning when an abort occurs.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful to prevent a large number of aborted batches due to]]>
<![CDATA[
]]>
<![CDATA[        an abort condition.  For example, if the email server should become unavailable]]>
<![CDATA[
]]>
<![CDATA[        for a time, the abort timeout will limit the amount of aborted batches until]]>
<![CDATA[
]]>
<![CDATA[        the mail server becomes available again.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 30 seconds will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ex_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_abort_time("60")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_max_docs" qi="Specifies maximum number of emails to include in a single batch.">
			<p name="nDocs" type="int" qi="The maximum number of emails in a batch.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nDocs : The maximum number of emails in a batch.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The import of emails into the batch will stop when this email limit is reached]]>
<![CDATA[
]]>
<![CDATA[        or when the maximum wait time has been reached.  While waiting for new mail to arrive,]]>
<![CDATA[
]]>
<![CDATA[        the configured mailbox will be polled every two seconds to check for waiting mail.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 100 will be used.  ]]>
<![CDATA[
]]>
<![CDATA[        The actual amount of emails included in the batch could be less than this maximum.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Note: The value indicates the number of emails with expected attachments that will be processed.]]>
<![CDATA[
]]>
<![CDATA[        If a waiting email contains an unexpected attachment, it is not counted against the]]>
<![CDATA[
]]>
<![CDATA[        total maximum count.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        It is also possible for an email to contain more than one valid attachment type.  When this happens,]]>
<![CDATA[
]]>
<![CDATA[        it is possible for the number of items input to the batch can be greater than the number]]>
<![CDATA[
]]>
<![CDATA[        of configured emails.  For example, if ex_max_docs is set to 5 and if there are 5 waiting]]>
<![CDATA[
]]>
<![CDATA[        emails and each email has 2 attachments, the total number of attachments that will be]]>
<![CDATA[
]]>
<![CDATA[        included in the batch will be 10.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_max_docs("50")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example causes the scan operation to limit the number of emails in a]]>
<![CDATA[
]]>
<![CDATA[          batch to a maximum of 50.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_done_folder" qi="Specifies folder for successfully imported emails">
			<p name="folder" type="string" qi="Destination folder for successfully imported emails">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folder : Destination folder for successfully imported emails]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Specifies the name of the email folder into which successfully imported emails are placed.  ]]>
<![CDATA[
]]>
<![CDATA[        This folder must be a subfolder of the email account's Inbox.  ]]>
<![CDATA[
]]>
<![CDATA[        When an email is processed and the attachment is imported, the email is moved ]]>
<![CDATA[
]]>
<![CDATA[        to the folder name specified by this action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of "Done" will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_done_folder("Imported")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_problem_folder("Failed")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_problem_folder" qi="Specifies folder for problem emails">
			<p name="folder" type="string" qi="Destination folder for problem email">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folder : Destination folder for problem email]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When an email is processed and the attachment is not one of the expected types, ]]>
<![CDATA[
]]>
<![CDATA[        the email is moved to the folder name specified by this action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        This folder must be a subfolder of the email account's Inbox.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of "Problem" will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ex_done_folder("Imported")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_problem_folder("Failed")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_EMLOption" qi="Creates a one page document per email containing an .eml file.">
			<p name="folder" type="int" qi="Optional - use a nonzero value to store one .eml file per email.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folder : Optional - use a nonzero value to store one .eml file per email.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If set, the ex_scan action creates a one page document containing the email and ]]>
<![CDATA[
]]>
<![CDATA[        attachments in an .eml file; no attachment pages are created.]]>
<![CDATA[
]]>
<![CDATA[        When called with a non-zero parameter, the ex_scan function does ]]>
<![CDATA[
]]>
<![CDATA[        not create pages for each attachment, instead one page is created per email document, ]]>
<![CDATA[
]]>
<![CDATA[        containing an .eml file suitable for subsequent processing using eDocument Conversion actions.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        When you use this action, pages for attachments are not created, and variables for those attachments are not set.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_EMLOption(1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[	]]>
	</com>
</rrx>
<rrx namespace="FileIO" v="8.1.0.8">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' File I/O Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/04/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 20527 Inital implementation.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/17/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 20527 Clarified help text for CopyFile, IsFileReadOnly and IsDirectoryPresent.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/17/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 20527 Clarified help text for CopyFile, IsFileReadOnly and IsDirectoryPresent.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.3"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/17/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA['   28678 Added Wildcard Support to DeleteFile]]>
<![CDATA[
]]>
<![CDATA['   28679 Added new action SplitFileName to parse file names]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/06/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA['   28679 Updated DStudio help text.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/11/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA['   28679 Updated DStudio help text for SplitFileName, GetProfileString & SetProfileString.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/15/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA['   29874 Removed duplicate line in the help text for GetProfileString.]]>
<![CDATA[
]]>
<![CDATA['   31022 Removed qi descriptions for parameters and moved them into the general parameter section.]]>
<![CDATA[
]]>
<![CDATA['   31618 Clarified input parameters for SplitFileName, GetProfileString and GetFileSize]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/10/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA['   32463 Updated help for SetProfileString and GetProfileString about unicode requirements.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/10/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA['   31618 Removed qi text that isn't displayed.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.FileIO.Actions" qi="File manipulation actions.">
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="CopyFile" qi="Copies a file.">
			<p name="sourcefile" type="string">
			</p>
			<p name="targetfile" type="string">
			</p>
			<p name="overwrite" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        sourcefile : The name and path of the file to copy. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        targetfile : The target path and filename.  Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        overwrite : if the target file exists, this determines if it should be overwritten. True will overwrite the target file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The file is copied from one location to the specified location.  If a file of the same target name]]>
<![CDATA[
]]>
<![CDATA[        already exists in the target directory, the overwrite parameter will determine if that file will be overwritten by the new file.]]>
<![CDATA[
]]>
<![CDATA[        The output directory must exist for this action to succeed.  You can use action IsDirectoryPresent to create]]>
<![CDATA[
]]>
<![CDATA[        the target directory.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If target file ends with a backslash, meaning only the target directory is specified,]]>
<![CDATA[
]]>
<![CDATA[        the same file name from the source string will be used as the target file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Because the target file name can be different from the source file, this action]]>
<![CDATA[
]]>
<![CDATA[        allows the copied file to be renamed in one step.  If you want to perform a "move" operation,]]>
<![CDATA[
]]>
<![CDATA[        call the DeleteFile to remove the source file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported in the source and target file name parameters.  DOS * and ? wildcards are not supported.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[CopyFile("C:\MyFile.txt", "c:\temp\+@BATCHID+.txt", true)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This action will copy MyFile.txt to the temp directory and give it a new name of the current batch ID]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[CopyFile("@VAR(IMAGEFILE)", "c:\temp\", true)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This action will copy the file specified by the variable IMAGEFILE and copy it to the temp directory.          ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully copied.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="DeleteFile" qi="Deletes a file.">
			<p name="filename" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The name and path of the file to delete. Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Deletes the specified file.  DOS wildcards are permitted in the file name.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[DeleteFile("C:\Temp\DeleteThis.txt")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The above example deletes the specific file.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[DeleteFile("C:\Temp\*.*")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The above example deletes all of the files in the 'Temp' directory.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[DeleteFile("C:\Temp\@BATCHID+.txt")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The above example deletes the file name that matches the current batch ID and has an extension of 'TXT'.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="GetFileSize" qi="Obtains the size of a file and stores it in the specified variable.">
			<p name="filename" type="string">
			</p>
			<p name="targetVariable" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The name and path of the file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        targetVariable : The name of the variable to store the file size.  The variable level must be specified with a Smart Parameter.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for each of the input parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The size of the specified file will be stored into the specified variable.  This can be]]>
<![CDATA[
]]>
<![CDATA[        helpful to test for problems, such as empty files.  Subsequent actions can]]>
<![CDATA[
]]>
<![CDATA[        perform tests on the stored value and act upon it.]]>
				<br>
				</br>
<![CDATA[ ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the specified file is not found,]]>
<![CDATA[
]]>
<![CDATA[        the action will return ]]>
				<b>
<![CDATA[true]]>
				</b>
<![CDATA[ and a size of 0 will be stored into the variable.]]>
<![CDATA[
]]>
<![CDATA[        If any other kind of error occurs, the action will return false and the variable]]>
<![CDATA[
]]>
<![CDATA[        may or may not be set to 0.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[GetFileSize("C:\Temp\MyFile.txt", "@B.MyVariable")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example sets the file size in the variable 'MyVariable' at the batch level.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the target variable is blank.  ]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="GetProfileString" qi="Reads a key value from a settings file.">
			<p name="filename" type="string">
			</p>
			<p name="section" type="string">
			</p>
			<p name="key" type="string">
			</p>
			<p name="targetVariable" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The INI file name.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        section : The section within the file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        key : The key within the section.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        targetVariable : The variable where to store the value.  The variable level must be specified with a smart parameter.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for each of the input parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Reads the value from a settings file, typically a .INI file, and stores it into the variable specified.]]>
<![CDATA[
]]>
<![CDATA[        If the variable does not exist, it will be created.]]>
<![CDATA[
]]>
<![CDATA[        If the key does not exist but the file does exist, the action will still return true]]>
<![CDATA[
]]>
<![CDATA[        and an empty string will be stored in the variable.  If you need to test for a blank]]>
<![CDATA[
]]>
<![CDATA[        key value, you can use the IsProfilePresent action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If you are reading Unicode characters from an INI file, ]]>
<![CDATA[
]]>
<![CDATA[        it is required that the file is in a format that supports Unicode.  ]]>
<![CDATA[
]]>
<![CDATA[        If the file is not a Unicode format, the Unicode characters may appear ]]>
<![CDATA[
]]>
<![CDATA[        incorrectly when read by GetProfileString or displayed in an editor.  ]]>
<![CDATA[
]]>
<![CDATA[        Most file editors will let you chose the type of file encoding.  ]]>
<![CDATA[
]]>
<![CDATA[        See the help for your specific editor.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[GetProfileString("C:\Settings.ini", "MySection", "MyKey", "@B.MyVariable")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The value for 'MyKey' will be placed into the variable 'MyVariable'.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the settings file exists and the target variable is valid.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="IsDirectoryPresent" qi="Determines if the specified directory exists and optionally creates it.">
			<p name="directoryName" type="string">
			</p>
			<p name="create" type="bool">
			</p>
			<p name="testExistence" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        directoryName : The directory path to test.  Smart parameters are allowed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        create : Specifies if the directory should be created.  True will create the directory, if it does not exist.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        testExistence : Determines if true should be returned if the directory exists or does not exist.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Checks for the existence of a directory.  Depending on the input parameters,]]>
<![CDATA[
]]>
<![CDATA[        if the directory does not exist, the action will create the directory.  The]]>
<![CDATA[
]]>
<![CDATA[        meaning of the return value can be changed using the testExistence parameter.]]>
<![CDATA[
]]>
<![CDATA[        This allows rules to continue if a directory exists or rules can continue if a directory does not exist.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsDirectoryPresent("c:\temp", true, true)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create the directory C:\temp, if it does not exist, and return true]]>
<![CDATA[
]]>
<![CDATA[          if the directory exists or was created successfully.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsDirectoryPresent("c:\temp", true, false)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create the directory C:\temp, if it does not exist, and return false]]>
<![CDATA[
]]>
<![CDATA[          if the directory exists or was created successfully.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        If testExistence is ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[, the action will return True if the directory exists or if the]]>
<![CDATA[
]]>
<![CDATA[        directory did not exist but was successfully created.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If testExistence is ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[, the action will return True if the directory does not exist.  This allows you to perform]]>
<![CDATA[
]]>
<![CDATA[        negative tests that will return true when a directory does not exist.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If an error occurs, the action will return false.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="IsFilePresent" qi="Determines if the specified file exists.">
			<p name="filename" type="string">
			</p>
			<p name="testExistence" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The file name and path.  Smart parameters are allowed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        testExistence : true tests that the file exists, false tests that the file does not exist.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Checks for the existence of a file.  Depending on the testExistence parameter, ]]>
<![CDATA[
]]>
<![CDATA[        the action can return true if a file exists or true if a file does not exist to ]]>
<![CDATA[
]]>
<![CDATA[        provide flexibility when creating rules.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsFilePresent("C:\MyDir\MyFile.abc", false)]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example, if the file does not exist, the action will return ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[True]]>
					</b>
<![CDATA[ and any subsequent actions will be processed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        If testExistence is ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ the action will return true if the file exists.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If testExistence is ]]>
				<b>
<![CDATA[false,]]>
				</b>
<![CDATA[ the action will return true if the file does not exist.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If an error occurs, the action will return false.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="IsFileReadOnly" qi="Tests the read only attribute of a file.">
			<p name="filename" type="string">
			</p>
			<p name="testForReadOnly" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The file name and path of the file to test.  Smart parameters are allowed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        testForReadOnly : Determines if the action should return true for read-only or read-write.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action will indicate if a file is set to read only.  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsFileReadOnly("c:\mydir\myfile.txt", true)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          if the file "myfile.txt" is set to read only, the action will return ]]>
					<b>
<![CDATA[true]]>
					</b>
<![CDATA[.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsFileReadOnly("c:\mydir\myfile.txt", false)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          if the file "myfile.txt" is not set to read only, the action will return ]]>
					<b>
<![CDATA[true]]>
					</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        If testForReadOnly is ]]>
				<b>
<![CDATA[true,]]>
				</b>
<![CDATA[ the action will return true if the file is read only.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If testForReadOnly is ]]>
				<b>
<![CDATA[false,]]>
				</b>
<![CDATA[ the action will return true if the file is not read only.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If an error occurs, or if the file does not exist, the action will return false.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="IsProfilePresent" qi="Tests that a profile exists and that a specific section and key exists within it.">
			<p name="filename" type="string">
			</p>
			<p name="section" type="string">
			</p>
			<p name="key" type="string">
			</p>
			<p name="testExistence" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[         filename : The INI file name.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[         section : The section within the file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[         key : The key within the section.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[         testExistence : true tests that the it exists, false tests that it does not exist.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[         The parameters "filename", "section" and "key" can accept smart parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Checks that a specific section and key exists within a settings file, typically an INI file.  It does not]]>
<![CDATA[
]]>
<![CDATA[        test the value of the key, only that a value exists.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsProfilePresent("C:\MyDir\settings.ini", "mysection", "mykey", true)]]>
					</b>
<![CDATA[ ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example, if settings.ini exists and contains "mysection", "mykey" and if "mykey" ]]>
<![CDATA[
]]>
<![CDATA[          has a non-blank value, it will return ]]>
					<b>
<![CDATA[True.]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if testExistence is true and the section and key is found within the profile and the key has an assigned value.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if testExistence is false and the section or key is not found within the profile or the key value is blank.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RenameFile" qi="Renames or moves the specified file.">
			<p name="oldName" type="string">
			</p>
			<p name="newName" type="string">
			</p>
			<p name="overwrite" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[       oldName : The source file name and path.  Allows smart parameters.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[       newName : The destination file name and path. Allows smart parameters.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[       overwrite : Specifies if the destination file should be overwritten. True will overwrite an existing file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Renames the specified file to the new name.  If the directories for the original ]]>
<![CDATA[
]]>
<![CDATA[        and new file names are different, the file will be moved to the new directory.  ]]>
<![CDATA[
]]>
<![CDATA[        If the overwrite parameter is true, the file will overwrite an existing file.  ]]>
<![CDATA[
]]>
<![CDATA[        If overwrite is false, an existing file will not be overwritten.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RenameFile("C:\MyDir\File1.txt", "C:\MyDir\File2.txt", true)]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example renames the file within the same directory, overwriting any existing file called "File2.txt".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RenameFile("C:\MyDir\File1.txt", "C:\New\File1.txt", true)]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example moves the file from MyDir to New, overwriting any existing file called "File1.txt".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully renamed or moved.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetFileReadOnly" qi="Sets or removes the read only attribute from a file or set of files.">
			<p name="readonly" type="bool">
			</p>
			<p name="filename" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[       readonly : true turns on the read only attribute, false turns it off.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[       filename : The path and filename.  Smart parameters and DOS wildcards are allowed.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets a the read only attribute of a file, or a group of files.  The read only attribute can ]]>
<![CDATA[
]]>
<![CDATA[        be set or cleared with this action.  Standard DOS * and ? wildcards can be used to affect a change]]>
<![CDATA[
]]>
<![CDATA[        on multiple files at once.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetFileReadOnly(false, "C:\MyDir\*.*")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example sets all of the files in MyDir as read-write.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetProfileString" qi="Writes a value to a profile file, typically called an INI file.">
			<p name="filename" type="string">
			</p>
			<p name="section" type="string">
			</p>
			<p name="key" type="string">
			</p>
			<p name="value" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The profile file name.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        section : The section within the file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        key : specifies if the destination file should be overwritten.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        value : The value to write.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for each of the input parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Writes a value to a settings profile, typically a file with an INI]]>
<![CDATA[
]]>
<![CDATA[        extension.  The value is stored in the variable proved as a parameter.]]>
<![CDATA[
]]>
<![CDATA[        If the variable does not exist, it will be created.]]>
<![CDATA[
]]>
<![CDATA[        If the variable does exist, the current value will be replaced with the new value.]]>
<![CDATA[
]]>
<![CDATA[        If the file does not exist, the file will be created.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If you are writing Unicode characters to the INI file, ]]>
<![CDATA[
]]>
<![CDATA[        it is required that the file exist and that it is in Unicode format.  ]]>
<![CDATA[
]]>
<![CDATA[        If the file is not a Unicode format, the Unicode characters may appear ]]>
<![CDATA[
]]>
<![CDATA[        incorrectly when read by GetProfileString or displayed in an editor.  ]]>
<![CDATA[
]]>
<![CDATA[        Most file editors will let you chose the type of file encoding.  ]]>
<![CDATA[
]]>
<![CDATA[        See the help for your specific editor.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetProfileString("C:\MyDir\config.ini","MySection","MyKey","Batch+@BATCHID")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the value is written to the profile.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
		<method name="SplitFileName" qi="Splits a file name into user specified variables.">
			<p name="inputFilename" type="string">
			</p>
			<p name="rootPathVariable" type="string">
			</p>
			<p name="pathVariable" type="string">
			</p>
			<p name="fileVariable" type="string">
			</p>
			<p name="extVariable" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[      inputFilename : The input file name to break into its three logical parts.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      rootPathVariable : The name of the variable to store the root path.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      pathVariable : The name of the variable to store the file path.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      fileVariable : The name of the variable to store the file name without the extension.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      extVariable : The name of the variable to store the file extension.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for each of the input parameters.  For each of the]]>
<![CDATA[
]]>
<![CDATA[      parameters that accept a variable, the level must be specified with a Smart Parameter.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      It is not necessary to specify a variable name for each part of the path that is split.]]>
<![CDATA[
]]>
<![CDATA[      Only destination variables for the desired values need to be specified.]]>
<![CDATA[
]]>
<![CDATA[      If you do not want to store a particular file name part, leave that parameter blank.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[      This action will split the input file name into its root path, path, file name and the extension,]]>
<![CDATA[
]]>
<![CDATA[      and place each of the parts into their own variables.  The file does not need to exist.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If the file contains a file extension, the saved file extension will contain a preceding period.      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
				<e>
<![CDATA[
]]>
<![CDATA[        ]]>
					<b>
<![CDATA[SplitFileName("C:\Dir1\Dir2\MyFile.abc","@B.FROOT","@B.FPATH", "@B.FNAME","@B.FEXT")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        This example splits the file and saves the information into 4 variables at the batch level:]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        FROOT = "C:\"]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        FPATH = "C:\Dir1\Dir2"]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        FNAME = "MyFile"]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        FEXT  = ".abc"]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
					<b>
<![CDATA[SplitFileName("@VAR(IMAGEFILE)","","","","@B.EXT")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        Obtains the value stored in the variable IMAGE file and only saves the file extension into a variable called EXT.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				</e>
<![CDATA[
]]>
<![CDATA[    ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the structure of the file name or path is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      The file does not need to exist for this action to succeed.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="FingerprintMaintenance" v="8.0.1.2">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA['Fingerprint Maintenance Actions]]>
<![CDATA[
]]>
<![CDATA[' Copyright Datacap Inc. 2009-2010, All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.0"]]>
<![CDATA[
]]>
<![CDATA[' 11/8/2010 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.0"]]>
<![CDATA[
]]>
<![CDATA[' 12/9/2010 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' Added support for smart parameters]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.2"]]>
<![CDATA[
]]>
<![CDATA[' 12/16/2010 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' Added smart paremter support to DeleteFingerprints and updated help indicating that smart parameters are supported]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.3"]]>
<![CDATA[
]]>
<![CDATA[' 5/11/2011 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' updated to Visual Studio 2010]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.4"]]>
<![CDATA[
]]>
<![CDATA[' 5/11/2012 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' added encryption]]>
<![CDATA[
]]>
<![CDATA['Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['"Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['5725-C15]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['© Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA['disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA['IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
	<h>
<![CDATA[These actions are used to automate the deletion of fingerprints in your application.  It is intended for applications]]>
<![CDATA[
]]>
<![CDATA[	that create fingerprints automatically.  By periodically deleting fingerprints that are not used you can decrease the time]]>
<![CDATA[
]]>
<![CDATA[	it takes to load them when the FindFingerprint action is called.]]>
<![CDATA[
]]>
<![CDATA[	]]>
	</h>
	<com ref="Datacap.Libraries.FingerprintMaintenance.Actions" qi="Actions to automate fingerprint deletion.">
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="OpenDatabase" qi="Opens a connection to the fingerprint database.">
			<ap>
<![CDATA[Fingerprint database connection string.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Opens a connection to the fingerprint database using the connection string provided in the parameter.  A smart parameter may be used.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[				  ]]>
					<b>
<![CDATA[OpenDatabase("provider=microsoft.jet.oledb.4.0;data source=c:\datacap\apt\APTFingerprint.mdb;persist security info=false")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example obtains the connection string set in the applicaiton manager.]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OpenDatabase("@APPVAR(*/dco_*[1]/fingerprintconn:cs)")]]>
					</b>
<![CDATA[
]]>
<![CDATA[			  ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ if the connection is established.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the connection is not established.]]>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
			<p name="ConnectionString" type="string" qi="Fingerprint database connection string.">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="SetFingerprintFolder" qi="Specifies the folder containing the fingerprint files.">
			<ap>
<![CDATA[Folder path where the fingerprints are located.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Specifies the folder containing the fingerprint files.  A smart parameter may be used.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[				  ]]>
					<b>
<![CDATA[SetFingerprintFolder("C:\Datacap\APT\fingerprint")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example obtains the path set in the applicaiton manager.]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetFingerprintFolder("@APPPATH(*/fingerprint)")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
			<p name="Folder" type="string" qi="Folder containing the fingerprints.">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="DeleteFingerprint" qi="Deletes specified fingerprint.">
			<ap>
<![CDATA[The ID of the fingerprint to delete.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Deletes the CCO, TIFF and FPXML files for the specified fingerprint.  Also deletes the database record and position information from the DCO.  A smart parameter may be used.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[				  ]]>
					<b>
<![CDATA[DeleteFingerprint("1002")]]>
					</b>
<![CDATA[
]]>
<![CDATA[			  ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
			<p name="ID" type="string" qi="ID of fingerprint to delete">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="DeleteFingerprints" qi="Deletes all fingerprints returned by the SQL statement in the parameter">
			<ap>
<![CDATA[SQL statement used to return a recordset of fingerprints that should be deleted.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Deletes all fingerprints returned by the query specified in the parameter.  A smart parameter may be used.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[			  ]]>
					<b>
<![CDATA[Access]]>
					</b>
<![CDATA[ - DeleteFingerprints("SELECT * FROM Template WHERE tp_LastHit ]]>
<![CDATA[<]]>
<![CDATA[ dateadd("d",-30,NOW)")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[			  ]]>
					<b>
<![CDATA[SQL]]>
					</b>
<![CDATA[ - DeleteFingerprints("SELECT * FROM Template WHERE tp_LastHit ]]>
<![CDATA[<]]>
<![CDATA[ dateadd(d,-2,GETDATE())")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
					<b>
<![CDATA[Oracle]]>
					</b>
<![CDATA[ - DeleteFingerprints("SELECT * FROM Template WHERE tp_LastHit ]]>
<![CDATA[<]]>
<![CDATA[ TRUNC(SYSDATE) - 30")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[		  ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
			<p name="SQL" type="string" qi="SQL statement to return a recordset of fingerprints to be deleted">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="CloseDatabase" qi="Closes connection to the fingerprint database and saves the Setup DCO.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Closes the open database connection and saves the Setup DCO if position information was deleted.  The Setup DCO will not be modified if FPXML files are used, or if no fingerprints were deleted.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[				  ]]>
					<b>
<![CDATA[CloseDatabase()]]>
					</b>
<![CDATA[
]]>
<![CDATA[			  ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="FPXML" v="8.1.0.15">
	<i ref="rrunner">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['*********************************]]>
<![CDATA[
]]>
<![CDATA['FPXML Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0" ]]>
<![CDATA[
]]>
<![CDATA['Updated 06/21/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Initial implementation of the FPXML actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1" ]]>
<![CDATA[
]]>
<![CDATA['Updated 06/24/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Action ReadZones renamed to ReadFPXMLZones, and now does not take any parameters.]]>
<![CDATA[
]]>
<![CDATA['Action SaveZones renamed to WriteFPXMLZones, and now does not take any parameters.]]>
<![CDATA[
]]>
<![CDATA['Added action SetFPXMLDirectory - sets the fingerprint XML directory. Must be called before any of the other actions.]]>
<![CDATA[
]]>
<![CDATA['Added action SetFPXMLDetailsAndLineitemPair - sets the special Details and Lineitem field types. If the application uses]]>
<![CDATA[
]]>
<![CDATA['detail lines, this action must be called before fpxml actions that read or write to the FPXML file.]]>
<![CDATA[
]]>
<![CDATA['Added action WriteFPXMLZone - writes a single field's zone to the FPXML file]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.2" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/02/2010  JMartinez]]>
<![CDATA[
]]>
<![CDATA[' The following actions have been renamed]]>
<![CDATA[
]]>
<![CDATA[' ReadFPXMLZones ->ReadZonesFPX]]>
<![CDATA[
]]>
<![CDATA[' SetFPXMLDetailsAndLineitemPair -> SetDetailsAndLineitemPairFPX]]>
<![CDATA[
]]>
<![CDATA[' SetFPXMLDiretory -> SetDirectoryFPX]]>
<![CDATA[
]]>
<![CDATA[' WriteFPXMLZones -> WriteZonesFPX]]>
<![CDATA[
]]>
<![CDATA[' WriteZoneFPXML ->WriteZoneFPX]]>
<![CDATA[
]]>
<![CDATA[' Solves issues where the former action names would cause a conflict with applications using invoice.rrx (i.e.APT) because the action names were identical.]]>
<![CDATA[
]]>
<![CDATA[' Internal functions have been updated to contain the suffix "FPX"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.3" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/08/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Detail field positions are now being saved with the prefix POS- instead of Pos-. Solves issue where the action ReadZonesFPX would not be able to ]]>
<![CDATA[
]]>
<![CDATA[' read line item zones because the position prefix of these items was not in the corret casing.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.4" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/16/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' 25317 - Fixes issue with the action WriteZonesFPX not allowing paramters in DStudio. ]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action SetFingerprintFPX]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action WriteZonesFPX]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action WriteZoneFPX]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.5" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/16/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixed bug in the code that calculates the amount of parameters passed to the action WriteZonesFPX. Solves issue where action would log that ]]>
<![CDATA[
]]>
<![CDATA[' required parameters are missing, and would return false.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.6" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/16/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Removed unused "sFingerprint" parameter from internal function "WriteDetailFieldFPX". Solves issue where the FPX write actions would cause the batch to abort]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.7" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/16/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixed issue with the WriteChildrenZonesFPX internal function that would cause the batch to abort because of a call to an non-existing function.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.8" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/20/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' WriteZonesFPX no longer requires HostName parameter. It is optional. ]]>
<![CDATA[
]]>
<![CDATA[' WriteZonesFPX now obtains the line items positions from the Details field. Requires that the action SetDetailsAndLineitemPairFPX be called in advance to ]]>
<![CDATA[
]]>
<![CDATA['   set the Details fields type.]]>
<![CDATA[
]]>
<![CDATA[' WriteZonesFPX no longer writes fields with empty positions to the FPXML]]>
<![CDATA[
]]>
<![CDATA[' Fixed bug in WriteZonesFPX where the acion would always return False.]]>
<![CDATA[
]]>
<![CDATA[' WriteZoneFPX action is now private.]]>
<![CDATA[
]]>
<![CDATA[' Updated the help text for the action SetDirectoryFPX, to reflect the correct number of parameters.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/07/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/26/2011 Rferin]]>
<![CDATA[
]]>
<![CDATA[' * 32032 Updated Copyright.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version ="8.1.0.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/24/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' The field's ID, instead of field TYPE, is now stored in the FPXML file. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version ="8.1.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/04/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' WriteChildrenZonesFPX and WriteZonesFPX now stores field info by ID in FPXML file.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/09/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action SetDetailsAndLineItemPairFPX. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.1.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/12/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Helper function used to write FPXML data now skips null fields.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/14/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Skips detail fields that do not have a child lineitem field. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Writelog("FPXML actions " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim FPXMLWrapper]]>
<![CDATA[
]]>
<![CDATA[Dim m_sDetailType]]>
<![CDATA[
]]>
<![CDATA[Dim m_sLineItemType]]>
<![CDATA[
]]>
<![CDATA[Dim m_sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[m_sDetailType = ""]]>
<![CDATA[
]]>
<![CDATA[m_sLineItemType = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Set FPXMLWrapper = CreateObject("dcctlNET.FingerprintzXML")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[  Writelog "Could not instantiate fpxml wrapper class"]]>
<![CDATA[
]]>
<![CDATA[  Err.Clear]]>
<![CDATA[
]]>
<![CDATA[End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Wrapper Methods:]]>
<![CDATA[
]]>
<![CDATA['public bool OpenFingerprint(string FingerprintDirectory, string FingerprintID, bool Create)]]>
<![CDATA[
]]>
<![CDATA['public bool AddFieldInfo(string FieldName, string FieldPosition)]]>
<![CDATA[
]]>
<![CDATA['public string[] GetFingerprintFieldList()]]>
<![CDATA[
]]>
<![CDATA['public string GetFieldInfo(string FieldName)]]>
<![CDATA[
]]>
<![CDATA['public bool UpdateFieldName(string FieldName, string NewFieldName)]]>
<![CDATA[
]]>
<![CDATA['public bool UpdateFPrint(string Type, string HostName, string HostID)]]>
<![CDATA[
]]>
<![CDATA['public bool RemoveField(string FieldName)]]>
<![CDATA[
]]>
<![CDATA['public bool Save()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['*********************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<af name="ReadZonesFPX" access="public" bInter="bInter" bDebug="bDebug" qi="Loads position information for current fingerprint">
		<h>
<![CDATA[
]]>
<![CDATA[      Loads position information for each node in the calling object and it's children. Pre-adjusts]]>
<![CDATA[
]]>
<![CDATA[      these values based on offset information stored in an 'Image_Offset' variable at any node level.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Position information is based on the Fingerprint XML position for the parent page's fingerprint ID.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The offset value is applied to all child objects of a node where an 'Image_Offset' variable is found;]]>
<![CDATA[
]]>
<![CDATA[      unless overwritten by a child node also having an Image_Offset value to apply.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page or Field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the fingeprint xml cannot be loaded. Otherwise ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim PosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage]]>
<![CDATA[
]]>
<![CDATA[	Dim bPos]]>
<![CDATA[
]]>
<![CDATA[	Dim bPM]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ReadZonesFPX = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sFingerprintDir = m_sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If Trim(sFingerprintDir) = "" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "The fingerprint directory has not been set. Exiting."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Right(FingerprintDir,1) <> "\" Then]]>
<![CDATA[
]]>
<![CDATA[    FingerprintDir = FingerprintDir & "\"]]>
<![CDATA[
]]>
<![CDATA[  End If ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If len(sOffSet)=0 then sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sName=oCurPage.Variable("TemplateID")	]]>
<![CDATA[
]]>
<![CDATA[	PosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ReadZones for " & PosName)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not FPXMLWrapper.OpenFingerprint(sFingerprintDir, sName, False) Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Could not open the fingerprint information: " & FPXMLWrapper.LastError]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = (-1*aOffSet(0))]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = (-1*aOffSet(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offsets : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oSet = 0]]>
<![CDATA[
]]>
<![CDATA[	xAdj = clng(nXoffSet)]]>
<![CDATA[
]]>
<![CDATA[	Yadj = clng(nYoffSet)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType < 4 then ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		sZonePos = FPXMLWrapper.GetFieldInfo(CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[		writelog("DCO pos:" & sZonePos)]]>
<![CDATA[
]]>
<![CDATA[		bPM = Not(CurrentObj.Variable("PatternMatch")="1")]]>
<![CDATA[
]]>
<![CDATA[		bPos = CurrentObj.Variable("Position")="0,0,0,0" or CurrentObj.Variable("Position")="" ]]>
<![CDATA[
]]>
<![CDATA[		If sZonePos <> "" and sZonePos <> "0,0,0,0" and bPM and bPos then]]>
<![CDATA[
]]>
<![CDATA[			arZonePos=split(sZonePos,",")]]>
<![CDATA[
]]>
<![CDATA[			If UBound(arZonePos)=3 Then]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(0)=arZonePos(0)+Xadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(1)=arZonePos(1)+Yadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(2)=arZonePos(2)+Xadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(3)=arZonePos(3)+Yadj]]>
<![CDATA[
]]>
<![CDATA[				CurrentObj.Variable("Position")=CStr(arZonePos(0)) & "," & CStr(arZonePos(1)) & "," & CStr(arZonePos(2)) & "," & CStr(arZonePos(3))]]>
<![CDATA[
]]>
<![CDATA[				writelog("new pos:" & CurrentObj.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		Set oSetupNode = CurrentObj.SetupNode()]]>
<![CDATA[
]]>
<![CDATA[		If Not(oSetupNode is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[			If oSetupNode.variable("RecogType")="4" then]]>
<![CDATA[
]]>
<![CDATA[				writelog(space(oSet+2) & "OMR recogtype found.") ]]>
<![CDATA[
]]>
<![CDATA[				For nChar = 1 to oSetupNode.NumOfRules]]>
<![CDATA[
]]>
<![CDATA[					Set oSubRule = oSetupNode.GetRule(nChar-1)]]>
<![CDATA[
]]>
<![CDATA[					Set oSubChar = CurrentObj.GetChild(nChar-1)]]>
<![CDATA[
]]>
<![CDATA[					If Not(oSubRule is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[						If oSubChar is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[							Set oSubChar = CurrentObj.AddChild(4, "", -1)]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						sZonePos = FPXMLWrapper.GetFieldInfo(oSubRule.Name)]]>
<![CDATA[
]]>
<![CDATA[						writelog(space(oSet+2) & "Found ZonePos: " & sZonePos)]]>
<![CDATA[
]]>
<![CDATA[						if sZonePos <> "" and sZonePos <> "0,0,0,0" then]]>
<![CDATA[
]]>
<![CDATA[							arZonePos=split(sZonePos,",")]]>
<![CDATA[
]]>
<![CDATA[							If UBound(arZonePos)=3 Then]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(0)=arZonePos(0)+Xadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(1)=arZonePos(1)+Yadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(2)=arZonePos(2)+Xadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(3)=arZonePos(3)+Yadj]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[								bRes = oSubChar.SetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))]]>
<![CDATA[
]]>
<![CDATA[								bRes = oSubChar.GetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[								'writelog("Saved X Y (" & CStr(arZonePos(2)- arZonePos(0)) & "," & CStr(arZonePos(3)-arZonePos(1)) & ") " & vbcrlf)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							end if]]>
<![CDATA[
]]>
<![CDATA[						end if]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				Next 'nChar]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oSetupNode = Nothing]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Call ZoneChildrenFPX(CurrentObj, PosName, oSet, Xadj, Yadj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ReadZonesFPX = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="SetDetailsAndLineitemPairFPX" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the type of the special Details and Lineitem fields.">
		<ap>
<![CDATA[Detail field type - type of the field that is the parent to the line item field, often called "Details". ]]>
		</ap>
		<ap>
<![CDATA[LineItem field type - type of the line item field which is the parent of the fields to be captured, often called "Lineitem". ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Sets the type of the special Details and Lineitem fields. These fields, unlike other field types, are handled by the ReadZonesFPX and WriteZonesFPX actions in a special way that is compatible with the Locate actions framework.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Using SetDetailsAndLineitemPairFPX prior to WriteZonesFPX will cause WriteZonesFPX to save line item field positions to the fingerprint file. The second parameter is the type of the line item field which is the parent of the fields to be captured and is often called "Lineitem".]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Any level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if one parameter is missing. Otherwise ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  SetDetailsAndLineitemPairFPX = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If UBound(ParamAr) < 1 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Invalid parameter count: this action expects two parameters. Exiting."]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    m_sDetailType = ParamAr(0)]]>
<![CDATA[
]]>
<![CDATA[    m_sLineItemType = ParamAr(1) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Detail field type set to " & m_sDetailType]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Lineitem field type set to " & m_sLineItemType]]>
<![CDATA[
]]>
<![CDATA[    SetDetailsAndLineitemPairFPX = True]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="SetDirectoryFPX" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the directory in which fingerprint xml files should be read and written to.">
		<ap>
<![CDATA[Fingerprint directory]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Sets the directory in which fingerprint xml files should be read and written to.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Any level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if one parameter is missing. Otherwise ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  SetDirectoryFPX = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Len(Trim(StrParam)) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Invalid parameter: this action expects the fingeprint directory. Exiting."]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    m_sFingerprintDir = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Right(m_sFingerprintDir,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      m_sFingerprintDir = m_sFingerprintDir & "\"]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Fingerprint directory set to " & m_sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[    SetDirectoryFPX = True]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="WriteZonesFPX" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Writes position information for all fields of the page">
		<ap>
<![CDATA[Fingerprint host name. Optional]]>
		</ap>
		<ap>
<![CDATA[Fingeprint host id. Optional]]>
		</ap>
		<ap>
<![CDATA[Fingeprint page type. Optional]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Writes position information for all fields of the page.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if there is a problem saving to fingerprint XML file, if not called at the page level, if not all required parameters are specified, if the page does not have a fingerprint assigned, or a fingerprint directory has not been set. Otherwise ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[  Dim oPage]]>
<![CDATA[
]]>
<![CDATA[  Dim sFingerprint]]>
<![CDATA[
]]>
<![CDATA[  Dim sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[  Dim sHostName]]>
<![CDATA[
]]>
<![CDATA[  Dim sHostID]]>
<![CDATA[
]]>
<![CDATA[  Dim oFS]]>
<![CDATA[
]]>
<![CDATA[  Dim FPXMLFile]]>
<![CDATA[
]]>
<![CDATA[  Dim i]]>
<![CDATA[
]]>
<![CDATA[  Dim oField]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sHostName = ""]]>
<![CDATA[
]]>
<![CDATA[  sHostID = ""]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   WriteZonesFPX = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action belongs on a page level only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   sFingerprintDir = m_sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if Right(sFingerprintDir,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      sFingerprintDir = sFingerprintDir & "\"]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If Trim(sFingerprintDir) = "" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "The fingerprint directory has not been set. Exiting."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   If uBound(ParamAr) >= 0 Then sHostName = MetaWord(ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   If uBound(ParamAr) >= 1 then sHostID = MetaWord(ParamAr(1))]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   sFingerprint = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If uBound(ParamAr) >= 2 then]]>
<![CDATA[
]]>
<![CDATA[      sPageType = MetaWord(ParamAr(2))]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      sPageType = oPage.Type]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   writelog("Fingerprint ID " & sFingerprint)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If Not oFS.FolderExists(sFingerprintDir) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Could not find: " & sFingerprintDir)]]>
<![CDATA[
]]>
<![CDATA[      oFS.CreateFolder(sFingerprintDir)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Created: " & sFingerprintDir)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If sHostID = "" Then]]>
<![CDATA[
]]>
<![CDATA[      sHostID = ""]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If sHostName = "" then]]>
<![CDATA[
]]>
<![CDATA[      sHostName = ""]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Fingerprint directory : " & sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If Not FPXMLWrapper.OpenFingerprint(sFingerprintDir, sFingerprint, true) Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Could not open the fingerprint information: " & FPXMLWrapper.LastError]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Fingerprint page type set to " & sPageType]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Fingerprint host name set to " & sHostName]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Fingerprint host id   set to " & sHostID]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   FPXMLWrapper.UpdateFPrint sPageType,sHostName ,sHostID]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Saving zones..." ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   For i = 0 to oPage.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[      Set oField = oPage.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If Not oField Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[        If oField.ObjectType = 3 Then]]>
<![CDATA[
]]>
<![CDATA[           If oField.Type = m_sDetailType Then]]>
<![CDATA[
]]>
<![CDATA[              Call WriteDetailFieldFPX(oField)]]>
<![CDATA[
]]>
<![CDATA[           Else]]>
<![CDATA[
]]>
<![CDATA[              If Trim(oField.Variable("Position")) <> "" AND Trim(oField.Variable("Position")) <> "0,0,0,0" Then ]]>
<![CDATA[
]]>
<![CDATA[                  FPXMLWrapper.AddFieldInfo oField.ID,oField.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[                  Writelog "Writing zones for field " & oField.ID ]]>
<![CDATA[
]]>
<![CDATA[              End If ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[              If oField.NumOfChildren <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[                Call WriteChildrenZonesFPX(oField) ]]>
<![CDATA[
]]>
<![CDATA[              End If]]>
<![CDATA[
]]>
<![CDATA[           End If]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[   Next 'i]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If FPXMLWrapper.Save Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Finished saving zones."]]>
<![CDATA[
]]>
<![CDATA[      WriteZonesFPX = True]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog "The page zones could not be written to the fingerprint XML file :" & FPXMLWrapper.LastError]]>
<![CDATA[
]]>
<![CDATA[      WriteZonesFPX = False]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
</rrx>
<rrx namespace="ICM" v="8.1.0.8">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA['IBM Content Classification Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' "Restricted Materials of IBM"]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.0" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/05/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Initial implementation.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.1" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/17/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Updated help text for actions UpdateKnowledgebaseICM and SetKnowledgeBaseNameICM.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.2" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/09/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Added action SetMaxConnectionsICM.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.3"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/16/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Removed action SetMaxConnectionsICM as it is no longer relevant with the change to Datacap.Libraries.CC.dll v8.1.0.6]]>
<![CDATA[
]]>
<![CDATA['         - Added action SetLanguageICM to specify the language used in the working knowledge base.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/01/2011 CMcGhee]]>
<![CDATA[
]]>
<![CDATA[' * 32902 - Updated help text:  fixed typos and grammar, changed name from InfoSphere ]]>
<![CDATA[
]]>
<![CDATA['to IBM Classification Module]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/07/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 32902 Re-added action SetMaxConnectionsICM as is required for multi-threaded processing in Datacap.Libraries.CC.dll v8.1.0.7]]>
<![CDATA[
]]>
<![CDATA['         Updated help text for the FindFingerprintICM action ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/08/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Removed action SetMaxConnectionsICM as it is no longer relevant with the change to Datacap.Libraries.CC.dll v8.1.0.8]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/05/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help for actions to state that they have been replaced by actions in CC.rrx library.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version ="8.1.0.8"]]>
<![CDATA[
]]>
<![CDATA['Updated 03/07/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Changed Datacap.Libraries.ICM.Actions namespace to Datacap.Libraries.CC.Actions]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
	<com ref="Datacap.Libraries.CC.Actions" qi="IBM Content Classification Actions. This action library has been replaced by CC.rrx.">
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="FindFingerprintICM" qi="This action has been replaced by FindFingerprintCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetKnowledgeBaseICM" qi="This action has been replaced by SetKnowledgeBaseCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetProblemValueICM" qi="This action has been replaced by SetProblemValueCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetLanguageICM" qi="This action has been replaced by SetLanguageCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetListenerURLICM" qi="This action has been replaced by SetListenerURLCC in CC.rrx">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UpdateKnowledgeBaseICM" qi="This action has been replaced by UpdateKnowledgeBaseCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="icr_c" v="8.1.0.6">
	<i ref="rrunner">
	</i>
	<i ref="recog_shared">
	</i>
	<af name="RecognizePageICR_C" access="public" bInter="bInter" bDebug="bDebug" qi="Performs full page recognition using the ICR/C Engine.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Performs full page character recognition on the current page based on the settings]]>
<![CDATA[
]]>
<![CDATA[      in the ICR/C tab in Datacap Studio.]]>
<![CDATA[
]]>
<![CDATA[      The action will recognize all characters on the page, and populate the page's]]>
<![CDATA[
]]>
<![CDATA[      CCO file with the recognition results.]]>
<![CDATA[
]]>
<![CDATA[      If a CCO file does not exist at the time this action is called, the action will create one.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RotateImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageICR_C()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This sequence creates a CCO file and checks to see if rotation of the image is needed.]]>
<![CDATA[
]]>
<![CDATA[        Full-page recognition then takes place based on the settings in the ICR/C]]>
<![CDATA[
]]>
<![CDATA[        tab in Datacap Studio. The recognition results are stored in the page's CCO file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if called at the wrong level or if there is a failure in the]]>
<![CDATA[
]]>
<![CDATA[      recognition process.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</af>
	<af name="RecognizePageToPDFICR_C" access="public" bInter="bInter" bDebug="bDebug" qi="Performs recognition on the current page and places the results in a PDF file.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Performs full page character recognition on the current page based on the]]>
<![CDATA[
]]>
<![CDATA[      settings in the ICR/C tab in Datacap Studio. The action will creates a PDF that]]>
<![CDATA[
]]>
<![CDATA[      contains the original page image and the recognized text.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RotateImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageToPDFICR_C()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if called at the wrong level or if there is a failure in the]]>
<![CDATA[
]]>
<![CDATA[      recognition process.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</af>
	<af name="RecognizePageFieldsICR_C" access="public" bInter="bInter" bDebug="bDebug" qi="Performs recognition on all fields that have been configured for ICR/C in Datacap Studio.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This page-level action recognizes all fields on the page that have been configured]]>
<![CDATA[
]]>
<![CDATA[      for ICR/C recognition in Datacap Studio. Individual field-level recognition actions]]>
<![CDATA[
]]>
<![CDATA[      will overwrite the results from this page-level action. This action will not recognize]]>
<![CDATA[
]]>
<![CDATA[      a zoned field if the “Skip Recognition” checkbox is selected in the ICR/C tab]]>
<![CDATA[
]]>
<![CDATA[      in Datacap Studio.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RotateImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageFieldsICR_C()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if called at the wrong level or if there is a failure in the]]>
<![CDATA[
]]>
<![CDATA[      recognition process.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</af>
	<af name="EnableLoggingICR_C" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Enables or disables event logging for the ICR/C engine.">
		<ap>
<![CDATA[
]]>
<![CDATA[      A boolean value. ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ enables ICRC logging and ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ disables ICRC logging.]]>
<![CDATA[
]]>
<![CDATA[      If no parameter is passed in, it will use the default value of ]]>
			<b>
<![CDATA[true.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action enables or disables event logging for the ICR/C engine.  Logs are written to the]]>
<![CDATA[
]]>
<![CDATA[      System event log under the entry "Datacap.Recognition.Recostar".  This action is intended]]>
<![CDATA[
]]>
<![CDATA[      for debugging ICRC recognition problems.  If this action is never called, no logging will occur.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[EnableLoggingICR_C("true")]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the logging state is successfully changed.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</af>
	<af name="RecognizeFieldICR_C" access="public" bInter="bInter" bDebug="bDebug" qi="Performs character recognition for a specific field.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Recognition is performed on the current field.  The field must have the proper]]>
<![CDATA[
]]>
<![CDATA[      settings in the ICR/C tab in Datacap Studio.  This field-level action recognizes]]>
<![CDATA[
]]>
<![CDATA[      characters based on the settings in the ICR/C tab in Datacap Studio and the value is]]>
<![CDATA[
]]>
<![CDATA[      stored in the current field object.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeFieldICR_C()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if called at the wrong level or if there is a failure in the]]>
<![CDATA[
]]>
<![CDATA[      recognition process.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</af>
	<af name="RecognizeFieldVoteICR_C" access="public" bInter="bInter" bDebug="bDebug" qi="Recognizes characters based on results from two recognition engines.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Voting adjusts the assigned confidence of recognized characters based on the results from two different]]>
<![CDATA[
]]>
<![CDATA[      recognition engines.  This action is expected to be called after field level recognition is]]>
<![CDATA[
]]>
<![CDATA[      performed on the same field by a different engine.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When this action stores the results of recognition, it first determines if the]]>
<![CDATA[
]]>
<![CDATA[      corresponding ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[ object of the Document Hierarchy already contains a value.]]>
<![CDATA[
]]>
<![CDATA[      If a value is present, indicating recognition had previously been performed on the field,]]>
<![CDATA[
]]>
<![CDATA[      the action compares the existing value with the field's new recognition results -]]>
<![CDATA[
]]>
<![CDATA[      character by character. If a character's values match the existing value,]]>
<![CDATA[
]]>
<![CDATA[      the Confidence Rating for the character is raised to the maximum level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Note that when using voting actions, the recognition results are never assigned to the field.]]>
<![CDATA[
]]>
<![CDATA[      Instead, the action changes the Confidence Ratings on the basis of results provided]]>
<![CDATA[
]]>
<![CDATA[      by the first Recognition engine.  However, if there are no previous recognition results in the field]]>
<![CDATA[
]]>
<![CDATA[      when this action is called, it will perform like the ]]>
			<b>
<![CDATA[RecognizeFieldICR_C]]>
			</b>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        RecognizeFieldOCR_S()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeFieldVoteICR_C()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This example first uses the OCR/S engine to recognize the text and store it in the field object.]]>
<![CDATA[
]]>
<![CDATA[        Then it votes on the]]>
<![CDATA[
]]>
<![CDATA[        confidence of the character by comparing it to the ICR/C engine result.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if called at the wrong level or if there is a failure in the]]>
<![CDATA[
]]>
<![CDATA[      recognition process.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</af>
	<af name="RecognizePageFields2CCO_ICR_C" access="public" bInter="bInter" bDebug="bDebug" qi="Performs recognition for all of the zoned fields on a page.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action recognizes all of the zoned fields on a page and puts]]>
<![CDATA[
]]>
<![CDATA[      the recognition results for each field in both the Datacap Object Hierarchy and in an already existing CCO.]]>
<![CDATA[
]]>
<![CDATA[      To create a CCO, call either a Full Page OCR action or the AnalyzeImage action before this action.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageFields2CCO_ICR_C()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if called at the wrong level or if the CCO does not already exist. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<see>
<![CDATA[CCO2CCO (CCO2CCO), AnalyzeImage (Recog_Shared)]]>
		</see>
	</af>
</rrx>
<rrx namespace="ImageFix" v="8.1.0.24">
	<i ref="rrunner">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['*********************************************************]]>
<![CDATA[
]]>
<![CDATA[' ImageFix Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 6.02.01  Updated 02/14/2005, 11:50 PM -MManning]]>
<![CDATA[
]]>
<![CDATA['	- ResetSettings Action removed from action library (moved up)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 6.02.02  Updated 03/02/2005, 12:40 PM -PHofle]]>
<![CDATA[
]]>
<![CDATA['	- LoadSettings Actions modified per SPR#12851]]>
<![CDATA[
]]>
<![CDATA['	  Unhandled 'Null' lookup return value caused Mismatch Error.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 6.03.01  Updated 04/27/2005, 8:20 AM -PHofle]]>
<![CDATA[
]]>
<![CDATA['	- ImageEnhance: Additional logging added for following image file processing]]>
<![CDATA[
]]>
<![CDATA['	- ImageEnhance: Additional Error Trapping for File System events]]>
<![CDATA[
]]>
<![CDATA['	- ImageEnhance: Can be used from DCO field objects having DCO page as ultimate parent.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 6.03.02  Updated 02/22/2006  -PHofle]]>
<![CDATA[
]]>
<![CDATA['   - Action ImageEnhance logs original image file attributes & clears ]]>
<![CDATA[
]]>
<![CDATA['     global 'ImageCtrl' filename before deleting file.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 6.03.03  Updated 12/05/2006  -PHofle]]>
<![CDATA[
]]>
<![CDATA['   - LoadSettings_FingerprintID return call spelling corrected.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 7.1.16  Updated 02/23/2007  -PHofle]]>
<![CDATA[
]]>
<![CDATA['   - Updated with Help and Example Tags]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 7.5.17  Updated 02/11/2008  -PHofle]]>
<![CDATA[
]]>
<![CDATA['   - Updated Action "LoadSettings" to use Smart Parameters.]]>
<![CDATA[
]]>
<![CDATA['     Permits the use of the @PATH(stringvalue) method to return a file path value from the Paths.ini file]]>
<![CDATA[
]]>
<![CDATA['     located in the same folder as the Task project file (bpp).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 7.5.18  Updated 02/12/2008  -TScholl]]>
<![CDATA[
]]>
<![CDATA['   - Updated Information tags for Action "LoadSettings" to note the use of Smart Parameters:]]>
<![CDATA[
]]>
<![CDATA['     Permits the use of the @PATH(stringvalue) method to return a file path value from the Paths.ini file]]>
<![CDATA[
]]>
<![CDATA['     located in the same folder as the Task project file (bpp).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 7.5.19  Updated 03/26/2009  - Rferin]]>
<![CDATA[
]]>
<![CDATA['   - 20834 clarification of smart parameters. Replaced company name with ParentDir in code ]]>
<![CDATA[
]]>
<![CDATA['     examples that contain paths.  Changed unused <lit> tags with <b>.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.20" ]]>
<![CDATA[
]]>
<![CDATA['   - Updated 05/01/2009 RFERIN]]>
<![CDATA[
]]>
<![CDATA['	    19745 Added G tags to make the XML format more compliant and help with editing.  Minor help ]]>
<![CDATA[
]]>
<![CDATA['     formatting fixes and modified some help text.  Requires the new buildvbs.rls 1.0.2.2.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Version = "8.0.21" ]]>
<![CDATA[
]]>
<![CDATA['   - Updated 07/23/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['	    28895 Actions now invoke the new ScanFix6 .Net wrapper to perform the Image Processing steps.]]>
<![CDATA[
]]>
<![CDATA['     Removed reference to unused global variables]]>
<![CDATA[
]]>
<![CDATA['     Removed unused private functions]]>
<![CDATA[
]]>
<![CDATA['     Action LoadSettings_FingerprintID now checks the FingerprintDir variable at the calling object. If]]>
<![CDATA[
]]>
<![CDATA['     this variable is not empty, its value is used as the fingerprint directory. Otherwise, the fingerprint]]>
<![CDATA[
]]>
<![CDATA['     directory is obtained from a fingerprint db lookup and special parsing.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.22"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/07/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.23"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/01/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Action LoadSettings_FingerprintID now sends the correct path (excluding INI part) to the Image Enhancement engine wrapper.]]>
<![CDATA[
]]>
<![CDATA[' Solves issue where the engine wrapper would create an invalid fingerprint path because of the parameter sent to it via the ]]>
<![CDATA[
]]>
<![CDATA[' LoadSettings_FingerprintID action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.24"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/27/2011 Rferin]]>
<![CDATA[
]]>
<![CDATA[' 32032 Updated Copyright]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['**********************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_ScanFix]]>
<![CDATA[
]]>
<![CDATA[On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Set g_ScanFix = CreateObject("Datacap.Libraries.ImageFix.Actions")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[  Writelog "Could not instantiate Datacap.Libraries.ImageFix.Actions object"]]>
<![CDATA[
]]>
<![CDATA[  Err.Clear]]>
<![CDATA[
]]>
<![CDATA[Else]]>
<![CDATA[
]]>
<![CDATA[  WriteLog "Datacap.Libraries.ImageFix.Actions Object created"]]>
<![CDATA[
]]>
<![CDATA[  g_ScanFix.DatacapRRDCO=DCO]]>
<![CDATA[
]]>
<![CDATA[  g_ScanFix.DatacapRRLog=DCLogX]]>
<![CDATA[
]]>
<![CDATA[  g_ScanFix.DatacapRRBatchPilot=Pilot]]>
<![CDATA[
]]>
<![CDATA[  g_ScanFix.DatacapRRState=RRState]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[	  Writelog "Error setting properties"]]>
<![CDATA[
]]>
<![CDATA[	  Err.Clear]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<af name="ImageEnhance" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Initiates image processing.">
		<ap>
<![CDATA[
]]>
<![CDATA[      The file extension that the action is to assign to the backup of the original Image file.]]>
<![CDATA[
]]>
<![CDATA[      For example: tio]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The extension should be 3 or 4 alphanumeric characters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Initiates image processing to perform a preconfigured set of image enhancements.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Include this action after a ]]>
			<scr>
<![CDATA[LoadSettings]]>
			</scr>
<![CDATA[ or ]]>
			<scr>
<![CDATA[LoadSettings_FingerprintID]]>
			</scr>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<scr>
<![CDATA[LoadSettings(C:\ParentDir\Invoice\Process\ImageFix.ini)]]>
				</scr>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageEnhance(tio)]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</scr>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Keep in mind in this example that the ImageFix settings specified in ImageFix.ini will be]]>
<![CDATA[
]]>
<![CDATA[        applied to every page in the batch.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page or Field Level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the parameter is not 3 or 4 alphanumeric characters.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ImageEnhance = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not g_ScanFix Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[    Set g_ScanFix.CurrentDCO = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[    ImageEnhance = g_ScanFix.ImageEnhance(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog "ScanFix object is not initialized."]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="LoadSettings" access="public" bInter="bInter" bDebug="bDebug" strParam="sFilePath" qi="Loads the settings that an ImageFix action will use to process all images in the current batch. Note: The action can use a smart parameter to designate the path value for the Settings file (.ini).">
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[value of the name of the ImageFix Settings file (.ini). The action will search]]>
<![CDATA[
]]>
<![CDATA[      for a file of this name in the application's ]]>
			<b>
<![CDATA[Process]]>
			</b>
<![CDATA[directory.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If this file is not located in the ]]>
			<b>
<![CDATA[Process]]>
			</b>
<![CDATA[ directory, you  must provide the file's]]>
<![CDATA[
]]>
<![CDATA[      full path as well as its name.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Note, however, that the action can use Smart Parameter syntax, such as the '@PATH(string)']]>
<![CDATA[
]]>
<![CDATA[      method to specify the path.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action loads the settings that the ]]>
			<b>
<![CDATA[ImageFix]]>
			</b>
<![CDATA[action will use to process all images]]>
<![CDATA[
]]>
<![CDATA[      in the current batch. The action's parameter includes the file's name and complete path to]]>
<![CDATA[
]]>
<![CDATA[      its location in the application's ]]>
			<b>
<![CDATA[Process]]>
			</b>
<![CDATA[directory. As an alternative, the parameter]]>
<![CDATA[
]]>
<![CDATA[      can use a ]]>
			<i>
<![CDATA[smart]]>
			</i>
<![CDATA[ parameter such as @Path to designate the value of the path to the]]>
<![CDATA[
]]>
<![CDATA[      same ]]>
			<b>
<![CDATA[Process]]>
			</b>
<![CDATA[directory.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LoadSettings(C:\ParentDir\Invoice\Process\ImageFix.ini)]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</scr>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<scr>
<![CDATA[ImageEnhance(tio)]]>
				</scr>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        Loads the settings file using the path denoted by the "ScanFixSettings" key that is listed]]>
<![CDATA[
]]>
<![CDATA[        in the Paths.ini file.  If the key pointed to a relative path, it would be converted to the]]>
<![CDATA[
]]>
<![CDATA[        appropriate full path and then use that path to find the settings:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LoadSettings(@PATH(ScanFixSettings))]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</scr>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<scr>
<![CDATA[ImageEnhance(tio)]]>
				</scr>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ImageFix Settings file that you specify as a parameter is not found. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  LoadSettings = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not g_ScanFix Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[    g_ScanFix.CurrentDCO = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[    LoadSettings = g_ScanFix.LoadSettings(sFilePath)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog "ScanFix object is not initialized."]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="LoadSettings_FingerprintID" access="public" bInter="bInter" bDebug="bDebug" qi="Loads the specific ImageFix Settings file (.ini) that corresponds to the Fingerprint ID of the current page.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Loads the specific ImageFix Settings file (.ini) that corresponds to the Fingerprint ID of the current page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The action will search the application's fingerprint folder for a fingerprint-specific]]>
<![CDATA[
]]>
<![CDATA[      ImageFix Settings file. Settings for these files are assigned during the Image Enhancement phase]]>
<![CDATA[
]]>
<![CDATA[      of Fingerprint Definition, using tools of Rule Manager's Image Processing Setup dialog.]]>
<![CDATA[
]]>
<![CDATA[      (Chapter 3 of the Rule Manager Reference shows you how to define a fingerprint-specific]]>
<![CDATA[
]]>
<![CDATA[      ImageFix Settings file.)]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Important!]]>
			</b>
<![CDATA[ The name of a fingerprint-specific ImageFix Settings file is limited to]]>
<![CDATA[
]]>
<![CDATA[      the Fingerprint ID with the ".ini" extension: 1044.ini, for example.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LoadSettings_FingerprintID()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</scr>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<scr>
<![CDATA[ImageEnhance(tio)]]>
				</scr>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if a fingerprint-specific Settings file does not exist. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    LoadSettings_FingerprintID = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim sFingerPrintFolderPath]]>
<![CDATA[
]]>
<![CDATA[	  Dim sProjectFolderPath]]>
<![CDATA[
]]>
<![CDATA[	  Dim aLookup	]]>
<![CDATA[
]]>
<![CDATA[	  Dim sFprintpath]]>
<![CDATA[
]]>
<![CDATA[	  Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[  			]]>
<![CDATA[
]]>
<![CDATA[	  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("FingerprintDir") <> "" Then]]>
<![CDATA[
]]>
<![CDATA[      sFingerPrintFolderPath = CurrentObj.Variable("FingerprintDir")]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("TemplateID")<>"" then	]]>
<![CDATA[
]]>
<![CDATA[		    aLookup = GetDataArray("SELECT TP_CCOPATH FROM TEMPLATE WHERE TP_TEMPLATEID=" & CurrentObj.Variable("TemplateID") & "; ")]]>
<![CDATA[
]]>
<![CDATA[  				]]>
<![CDATA[
]]>
<![CDATA[		    sFingerPrintFolderPath = ""]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[		    If isarray(aLookup) and not(isEmpty(aLookup)) then]]>
<![CDATA[
]]>
<![CDATA[			      sFingerPrintFolderPath = trim(aLookup(0,0))]]>
<![CDATA[
]]>
<![CDATA[			    If isnull(sFingerPrintFolderPath)=true then ]]>
<![CDATA[
]]>
<![CDATA[				    sFingerPrintFolderPath=""]]>
<![CDATA[
]]>
<![CDATA[			    Else]]>
<![CDATA[
]]>
<![CDATA[				    sFingerPrintFolderPath = trim(FileMgr.GetParentFolderName(sFingerPrintFolderPath))]]>
<![CDATA[
]]>
<![CDATA[			    End if]]>
<![CDATA[
]]>
<![CDATA[		    End if]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[		    If sFingerPrintFolderPath="" then]]>
<![CDATA[
]]>
<![CDATA[			    Writelog("No FingerPrint INI found.")]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[		    Else]]>
<![CDATA[
]]>
<![CDATA[			    Writelog("FingerPrint Path: '" & cstr(sFingerPrintFolderPath) & "' ")]]>
<![CDATA[
]]>
<![CDATA[		    End if]]>
<![CDATA[
]]>
<![CDATA[	    End if]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not g_ScanFix Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[      Set g_ScanFix.CurrentDCO = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	    LoadSettings_FingerprintID = g_ScanFix.LoadSettings_FingerprintID (sFingerPrintFolderPath)]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog "ScanFix object is not initialized."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
</rrx>
<rrx namespace="Imail" v="8.1.0.14">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' IMail Actions]]>
<![CDATA[
]]>
<![CDATA['--------------------------------------------------------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA['--------------------------------------------------------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/04/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA['  * SPR 26933 Added Datacap Studio help to the actions.  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/18/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA['  * SPR 27526 Updated help for im_login, im_types, im_done_folder and im_problem_folder.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/24/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA['  * SPR 27526 Updated help for im_login and help overview.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/05/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA['  * SPR 28296 Replaced "e-mail" with email in help text.   Help changes for im_types, im_wait_time and im_abort_time.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/28/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28371 - Update help to make it more consistent.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/03/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28371 - Update help for im_scan.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/23/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28371 - The spaces were removed in email variable DateSent.  Made help more consistent with ewsmail text where possible.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/15/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 26932 Updated help text for im_types, im_done_folder and im_problem_folder.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/10/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' SPR 31013 Updated method im_login with smartparameter support]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/19/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 32145 31022 Removed use of SIT and removed use of qi parameters for help text.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/13/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 31793 Added information regarding email subject lengths.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="dcjmail.CDCjmail" qi="IMAP email import actions - import image attachments from email messages.">
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      The IMail actions are designed to scan an email Inbox for incoming mail messages,]]>
<![CDATA[
]]>
<![CDATA[      and place selected messages into a new Batch.]]>
<![CDATA[
]]>
<![CDATA[      It is possible to ignore all messages except those containing specific attachment types.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      The actions are typically assigned to a Task that is executed by an unattended Taskmaster Rulerunner station.]]>
<![CDATA[
]]>
<![CDATA[      Multiple Inboxes can be scanned by stringing together a set of]]>
<![CDATA[
]]>
<![CDATA[      login/scan/logout actions for each Inbox, or by assigning an Inbox to each input task.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The mail account must contain an Inbox folder and separate folders for messages successfully imported (Done folder)]]>
<![CDATA[
]]>
<![CDATA[      and messages that encountered errors (Problem folder).  Processed emails will be placed into one of these folders.]]>
<![CDATA[
]]>
<![CDATA[      Done and Problem folders must be at the same level of the folder hierarchy as the Inbox and must be manually]]>
<![CDATA[
]]>
<![CDATA[      created prior to running your application.]]>
<![CDATA[
]]>
<![CDATA[      The names of these folders can be changed using the im_done_folder and im_problem_folder actions.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="im_login" qi="Specifies the IMAP mail server URL and login credentials.">
			<p name="hostname" type="string">
			</p>
			<p name="username" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        hostname : URL of IMAP mail server.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        username : Username for mail account.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password : Password for mail account.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Connects to the mail server using the specified account information.]]>
<![CDATA[
]]>
<![CDATA[        Specifies the mail server URL and login credentials.]]>
<![CDATA[
]]>
<![CDATA[        Login credentials are for a mail server that supports the IMAP protocol (such as MS Exchange, and many others).]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Refer to the top-level help for general information about scanning the inbox and requirements for the "Done" and "Problem" folders.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_login("mymailserver.com","theuser","password")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the login succeeds.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[im_done_folder, im_problem_folder, im_wait_time, im_abort_time]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="im_scan" qi="Poll the specified mail server for incoming emails with image attachments.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Scans emails in the Inbox for specified attachments, imports selected emails with attachments into the batch.]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch.]]>
<![CDATA[
]]>
<![CDATA[        A connection to the email server must have previously been established using the im_login action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each input email will contain the following variables set in the document hierarchy:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TYPE]]>
				</b>
<![CDATA[: Always set to "Document".]]>
				<br>
				</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Subject]]>
				</b>
<![CDATA[: The email subject.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Body]]>
				</b>
<![CDATA[: The text within the email.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[DateSent]]>
				</b>
<![CDATA[: The sent date stamp on the email.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[From]]>
				</b>
<![CDATA[: The email sender.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[User]]>
				</b>
<![CDATA[: The email user.]]>
				<br>
				</br>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[To]]>
				</b>
<![CDATA[: The email recipients.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Priority]]>
				</b>
<![CDATA[: The state of the email importance flag.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Each email attachment will have the following variables set:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TYPE]]>
				</b>
<![CDATA[: Always set to "Other".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IMAGEFILE]]>
				</b>
<![CDATA[: The name of the attachment as saved on disk.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        The following batch level variable is created:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[EmailCount]]>
				</b>
<![CDATA[: The number of emails scanned into the batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that the subject line be no longer than 78 characters as this is a]]>
<![CDATA[
]]>
<![CDATA[        common subject line length limitation.  Some systems may support even shorter lengths,]]>
<![CDATA[
]]>
<![CDATA[        truncating the subject.  Our testing has been successful with lengths up to 255 characters.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended to test your settings and use lengths appropriate for your systems.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_abort_time("40")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_types("jpg,tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_scan()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Returns ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the operation fails, and pauses before returning.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
				<br>
				</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[        If no selected emails were available, the action returns ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ and pauses before returning.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Action returns when timeout is reached, or the requested number of emails have been processed.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="im_logout" qi="Disconnect from the mail server.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Closes the connection to the mail server.]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch after im_login and im_scan have completed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_logout()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open or Close event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="im_types" qi="Specifies valid file extensions for image attachments.">
			<p name="extensions" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        extensions : Comma-separated list of file image file extensions to import, ]]>
<![CDATA[
]]>
<![CDATA[        with or without period.  If the parameter is blank, all emails with or without attachments will be processed.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action specifies the allowable email attachment types.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of ".pdf" will be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is called and no attachment types are specified, all emails and any attachments are added to the batch.]]>
<![CDATA[
]]>
<![CDATA[        When emails without attachments are processed, this will result in documents without any "pages".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If attachment types are specified and the email contains:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • Only the specified attachment types, the email and attachments will be added to the batch]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • Only unspecified attachment types, or if it contains a mix of specified and unspecified attachment types, the email is moved to the Problem folder]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • No attachments, the email is moved to the Problem folder]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_abort_time("40")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_types("jpg,tif")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="im_wait_time" qi="Specifies the maximum time to wait for input emails for a single batch.">
			<p name="nSecs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The maximum number of seconds to wait.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[        The maximum time to wait for input emails for a single batch, when there is at least one pending email.]]>
<![CDATA[
]]>
<![CDATA[        Used by the im_scan action after the first email has been processed to determine ]]>
<![CDATA[
]]>
<![CDATA[        how long to wait for the batch to fill up.  If no emails are pending, the im_scan action]]>
<![CDATA[
]]>
<![CDATA[        will not wait regardless of the wait time value.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The import of emails into the batch will stop when the wait limit is reached]]>
<![CDATA[
]]>
<![CDATA[        or when the maximum emails per batch has been reached.  ]]>
<![CDATA[
]]>
<![CDATA[        While waiting for new mail to arrive,]]>
<![CDATA[
]]>
<![CDATA[        the configured mailbox will be polled every two seconds to check for waiting mail.]]>
<![CDATA[
]]>
<![CDATA[        The action will continue to include new files into the batch until this wait time]]>
<![CDATA[
]]>
<![CDATA[        is reached or the maximum number of emails per batch is reached.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default wait time of 5 seconds will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_wait_time("20")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_abort_time("60")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_types("jpg,tif")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="im_abort_time" qi="Specifies the delay time before returning when a batch aborts.">
			<p name="nSecs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The number of seconds to wait.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The action will wait the specified time before returning when an abort occurs.  ]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful to prevent a large number of aborted batches due to an abort condition.  ]]>
<![CDATA[
]]>
<![CDATA[        For example, if the email server should become unavailable for a time, ]]>
<![CDATA[
]]>
<![CDATA[        the abort timeout will limit the number of aborted batches until the mail server becomes available again.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default abort time value of 30 seconds will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_abort_time("60")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_types("jpg,tif")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="im_max_docs" qi="Specifies maximum number of emails to include in a single batch.">
			<p name="nDocs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nDocs : The maximum number of emails in a batch.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The import of emails into the batch will stop when this email limit is reached]]>
<![CDATA[
]]>
<![CDATA[        or when the maximum wait time has been reached.  While waiting for new mail to arrive, ]]>
<![CDATA[
]]>
<![CDATA[        the configured mailbox will be polled every two seconds to check for waiting mail.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 100 will be used.]]>
<![CDATA[
]]>
<![CDATA[        The actual amount included in the batch could be less than this maximum.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_abort_time("60")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_max_docs("50")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_types("jpg,tif")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example causes the scan operation to limit the number of emails in a]]>
<![CDATA[
]]>
<![CDATA[          batch to a maximum of 50.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="im_done_folder" qi="Specifies the IMAP folder for successfully imported emails.">
			<p name="folder" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folder : Destination IMAP folder for successfully imported emails.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When an email is processed and the attachment is imported, the email is moved to the folder name]]>
<![CDATA[
]]>
<![CDATA[        specified by this action.]]>
<![CDATA[
]]>
<![CDATA[        The folder is expected to be on the root level, the same level as the inbox folder in the mail account specified by the im_login action.  ]]>
<![CDATA[
]]>
<![CDATA[        If the folder exists in a subfolder,]]>
<![CDATA[
]]>
<![CDATA[        then use a forward slash to separate the folder names.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of "Done" will be used.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_done_folder("Imported")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_problem_folder("Failed")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example changes the default names of the "Done" and "Problem" folders and also requires ]]>
<![CDATA[
]]>
<![CDATA[          the "Imported" and "Failed" folders to be on the same level as the "Inbox" folder.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_done_folder("Inbox/Imported")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_problem_folder("Inbox/Failed")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[          This example requires the folders to be a subfolder of the Inbox folder.          ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	]]>
		<method name="im_problem_folder" qi="Specifies the IMAP folder for problem emails.">
			<p name="folder" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[      folder : Destination IMAP folder for problem emails.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[       When an email is processed and the attachment is not one of the expected types, ]]>
<![CDATA[
]]>
<![CDATA[       the email is moved to the folder specified by this action. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[       The folder is expected to be on the root level, the same level as the inbox folder of the mail account specified by the im_login action.  ]]>
<![CDATA[
]]>
<![CDATA[       If the folder exists in a subfolder, then use a forward slash to separate the folder names.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[       If this action is not called, the default value of "Problem" will be used.       ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
				<e>
<![CDATA[
]]>
<![CDATA[       im_done_folder("Imported")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[       ]]>
					<b>
<![CDATA[im_problem_folder("Failed")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[       This example changes the default name of the "Problem" folder to "Failed" and]]>
<![CDATA[
]]>
<![CDATA[       requires the "Imported" and "Failed" folders to be on the same level as the "Inbox" folder.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[       im_done_folder("Inbox/Imported")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[       ]]>
					<b>
<![CDATA[im_problem_folder("Inbox/Failed")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[       This example specifies the folder which is a subfolder of the Inbox folder.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	]]>
	</com>
</rrx>
<rrx namespace="Intellocate" v="8.1.0.13">
	<i ref="rrunner">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['****************************************************]]>
<![CDATA[
]]>
<![CDATA[' Intellocate.rrx - Adds Zone's position info into the runtime DCO via the web verify task.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2012 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 6.03.09 Updated 12/22/2005 -APROKSHIN ]]>
<![CDATA[
]]>
<![CDATA['  - FillHostTemplateTable]]>
<![CDATA[
]]>
<![CDATA['  - iloc_AssignPageType  are changed to use Conn (embeded into RuleRun connection to the rule database)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 6.03.10 Updated 01/06/2005 -APROKSHIN ]]>
<![CDATA[
]]>
<![CDATA['  - Rules iloc_SetZones, iloc_SetDetailZones, iloc_AdjustZones do ignore ]]>
<![CDATA[
]]>
<![CDATA['    all fields with setup DCO variable <V n="src">DB</V>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 6.5.01 Updated 02/28/2006 -PHofle]]>
<![CDATA[
]]>
<![CDATA['  - GetDetailBottomEdge updated]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 6.5.02 Updated 03/10/2006 -PHofle]]>
<![CDATA[
]]>
<![CDATA['  - Added Logging to iloc_SetDetailZones]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 8.0.03 Updated 04/14/2008 -PHofle]]>
<![CDATA[
]]>
<![CDATA['  * Actions iloc_AssignPageType & FillHostTemplateTable call utility InitFPDB from rrunner.rxx to check the global]]>
<![CDATA[
]]>
<![CDATA['    fingerprint database connection. Will initialize the connection if it is not ]]>
<![CDATA[
]]>
<![CDATA['    active. SPR 21855]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version 8.0.04]]>
<![CDATA[
]]>
<![CDATA['  - Updated 05/01/2009 RFERIN]]>
<![CDATA[
]]>
<![CDATA['    19745 Added G tags to make the XML format more compliant and help with editing.  Minor help ]]>
<![CDATA[
]]>
<![CDATA['    formatting fixes and modified some help text.  Requires the new buildvbs.rls 1.0.2.2.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 8.0.05]]>
<![CDATA[
]]>
<![CDATA['  - Updated 06/22/2009 RFERIN]]>
<![CDATA[
]]>
<![CDATA['    24701 Help text corrections for iloc_AssignPageType and IsPageDataMissing.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 8.0.07]]>
<![CDATA[
]]>
<![CDATA['  - Updated 10/04/2010 MSchlachter]]>
<![CDATA[
]]>
<![CDATA['    24701 Added DCO locking]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.08"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/07/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version 8.0.08]]>
<![CDATA[
]]>
<![CDATA['  - Updated 02/08/2011 SKozlov]]>
<![CDATA[
]]>
<![CDATA['    24701 Eliminated long log line, coming from dco, when dco setup cannot be locked for writing.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/12/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 29830 Updated help for iloc_adjustzones to clarify it must be used on existing fingerprints.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/18/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 30130, 30132 Updated help for iloc_AssignPageType and IsPageDataMissing.]]>
<![CDATA[
]]>
<![CDATA['   30134 iloc_SetDetailZones now returns false on a failure.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/18/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 30134 iloc_SetDetailZones now always returns true.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/10/2012 RFerin]]>
<![CDATA[
]]>
<![CDATA[' * 30134 Added additional logging to iloc_AssignPageType and FillHostTemplateTable.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' LOG VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("Intellocate Actions " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['****************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
	<g>
<![CDATA[
]]>
<![CDATA['==== - unused functions - ==========================================]]>
<![CDATA[
]]>
	</g>
	<af name="iloc_SetZones" access="public" bInter="bInter" bDebug="bDebug" qi="Writes the position coordinates of a new fingerprint's zoned fields from a page's Data file to the Pos properties of the corresponding Field objects in the Document Hierarchy file (.xml).">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Writes the position coordinates of a new fingerprint's zoned fields from a page's Data ]]>
<![CDATA[
]]>
<![CDATA[    file to the Pos properties of the corresponding Field objects in the Document Hierarchy file (.xml).]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[iloc_SetZones()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if a fingerprint match has not occurred, or if the Document Hierarchy file ]]>
<![CDATA[
]]>
<![CDATA[    (.xml) cannot be saved.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[   Dim arXY]]>
<![CDATA[
]]>
<![CDATA[   arXY = Split("0,0,0,0",",")]]>
<![CDATA[
]]>
<![CDATA[   arXY(0) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(1) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(2) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(3) = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oSetup = CurrentObj.SetupObject]]>
<![CDATA[
]]>
<![CDATA[   sSetupPath=oSetup.path]]>
<![CDATA[
]]>
<![CDATA[on error resume next]]>
<![CDATA[
]]>
<![CDATA[If oSetup.readlock(sSetupPath) Then]]>
<![CDATA[
]]>
<![CDATA[   If(oSetup Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Can not get SetupObject from currentObj.  Does the DCO exist?")]]>
<![CDATA[
]]>
<![CDATA[      iloc_SetZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      writelog("Setup Object is received. SetupObj has path" & vbCrLf & oSetup.Path)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[   If(oPage Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Can not get currentObj.")]]>
<![CDATA[
]]>
<![CDATA[      iloc_SetZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' find assigned template]]>
<![CDATA[
]]>
<![CDATA[   sTempl = ""]]>
<![CDATA[
]]>
<![CDATA[   sTempl = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[   writelog("Template ID " & sTempl)]]>
<![CDATA[
]]>
<![CDATA[   If(CStr(sTempl) = "" ) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog "unable find out template ID"]]>
<![CDATA[
]]>
<![CDATA[      iloc_SetZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Call processRunTimeSubFields(oSetup, oPage, sTempl, arXY)]]>
<![CDATA[
]]>
<![CDATA['  call processRunTimeDetailFields(oSetup, oPage, sTempl, arXY)]]>
<![CDATA[
]]>
<![CDATA['  call GetDetailBottomEdge(oSetup, oPage, sTempl)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   writelog("save DCO Setup from " & oSetup.path)	 ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	   If oSetup.WriteSetup(sSetupPath)  Then]]>
<![CDATA[
]]>
<![CDATA[	      writelog("save DCO into local copy")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	      iloc_SetZones = True ]]>
<![CDATA[
]]>
<![CDATA[	   Else]]>
<![CDATA[
]]>
<![CDATA[	      writelog("unable to save DCO into local copy")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	      iloc_SetZones = False  ]]>
<![CDATA[
]]>
<![CDATA[	   End If]]>
<![CDATA[
]]>
<![CDATA[	   oSetup.UnlockIt()]]>
<![CDATA[
]]>
<![CDATA[Else]]>
<![CDATA[
]]>
<![CDATA[  writelog("unable to save DCO because it was locked")]]>
<![CDATA[
]]>
<![CDATA[  writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[  iloc_SetZones = False  ]]>
<![CDATA[
]]>
<![CDATA[End If]]>
<![CDATA[
]]>
<![CDATA[  oSetup.path=sSetupPath]]>
<![CDATA[
]]>
<![CDATA[   if err.number<>0 then]]>
<![CDATA[
]]>
<![CDATA[   	writelog("Error:")]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.number]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.description]]>
<![CDATA[
]]>
<![CDATA[   	err.clear]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[''web   if WriteDCOSetup() then]]>
<![CDATA[
]]>
<![CDATA[''web      iloc_SetZones = true]]>
<![CDATA[
]]>
<![CDATA[''web   else]]>
<![CDATA[
]]>
<![CDATA[''web      iloc_SetZones = false]]>
<![CDATA[
]]>
<![CDATA[     ''web   end if ]]>
		</g>
	</af>
	<af name="iloc_SetDetailZones" access="public" bInter="bInter" bDebug="bDebug" qi="Writes the position coordinates of a new fingerprint's Detail Line fields from a page's Data file to the Pos properties of the corresponding Detail Line Field objects of the application's Document Hierarchy..">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Writes the position coordinates of a new fingerprint's Detail Line fields ]]>
<![CDATA[
]]>
<![CDATA[    from a page's Data file to the Pos properties of the corresponding Detail Line ]]>
<![CDATA[
]]>
<![CDATA[    Field objects of the application's Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[iloc_SetDetailZones()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oSetup = CurrentObj.SetupObject]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(oSetup Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Error - SetupObject Not Found in iloc_SetDetailZones.  Does the DCO exist?")]]>
<![CDATA[
]]>
<![CDATA[		iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("Setup Object path:'" & oSetup.Path & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[   sSetupPath=oSetup.path]]>
<![CDATA[
]]>
<![CDATA[If oSetup.readlock(sSetupPath) Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	If(oPage Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Error - Can Not get currentObj in iloc_SetDetailZones.")]]>
<![CDATA[
]]>
<![CDATA[    iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Template ID for oPage]]>
<![CDATA[
]]>
<![CDATA[	sTempl = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	writelog("Template ID:'" & sTempl & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Len(sTempl)=0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Error - Template ID not found in iloc_SetDetailZones.")]]>
<![CDATA[
]]>
<![CDATA[		iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Call processRunTimeSubFields(oSetup, oPage, sTempl, arXY)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Call ProcessRunTimeDetailFields(oSetup, oPage, sTempl)]]>
<![CDATA[
]]>
<![CDATA[	Call GetDetailBottomEdge(oSetup, oPage, sTempl)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If oSetup.WriteSetup(sSetupPath)=False Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Unable to save Setup DCO:'" & oSetup.path & "'")]]>
<![CDATA[
]]>
<![CDATA[			iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			writelog("Saved DCO Setup:'" & oSetup.path & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		oSetup.UnlockIt()]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("unable to save DCO because it was locked '" & oSetup.path & "'")]]>
<![CDATA[
]]>
<![CDATA[		iloc_SetDetailZones = True ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[   oSetup.Path=sSetupPath]]>
<![CDATA[
]]>
<![CDATA[	   if err.number<>0 then]]>
<![CDATA[
]]>
<![CDATA[   	writelog("Error:")]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.number]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.description]]>
<![CDATA[
]]>
<![CDATA[   	err.clear]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[	''web   if WriteDCOSetup() then]]>
<![CDATA[
]]>
<![CDATA[	''web      iloc_SetDetailZones = true]]>
<![CDATA[
]]>
<![CDATA[	''web   else]]>
<![CDATA[
]]>
<![CDATA[	''web      iloc_SetDetailZones = false]]>
<![CDATA[
]]>
<![CDATA[     ''web   end if ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="iloc_AdjustZones" access="public" bInter="bInter" bDebug="bDebug" qi="Updates fingerprint-specific position coordinates for Field objects in the Document Hierarchy based on the locations listed for the current source page's Data file (.xml)">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Updates fingerprint-specific position coordinates for Field objects in the ]]>
<![CDATA[
]]>
<![CDATA[    Document Hierarchy based on the locations listed for the current source page's Data file (.xml)]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    This action is designed to be used on existing fingerprints only.  It will only update fields]]>
<![CDATA[
]]>
<![CDATA[    that do not have position information.  Existing fields will not be updated, even if the position]]>
<![CDATA[
]]>
<![CDATA[    information for those fields has changed. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[iloc_AdjustZones()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if a fingerprint match has not occurred and a Template ID ]]>
<![CDATA[
]]>
<![CDATA[    value has not been assigned to the current page, or if the Document ]]>
<![CDATA[
]]>
<![CDATA[    Hierarchy file cannot be saved. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[   Dim arImageOffset]]>
<![CDATA[
]]>
<![CDATA[   on error resume next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oSetup = CurrentObj.SetupObject]]>
<![CDATA[
]]>
<![CDATA[   sSetupPath=oSetup.path]]>
<![CDATA[
]]>
<![CDATA[If oSetup.readlock(sSetupPath) Then]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' set Image Overlay Offset]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Find Image Offset information]]>
<![CDATA[
]]>
<![CDATA[   sOffset = CurrentObj.Variable("Image_Offset") ]]>
<![CDATA[
]]>
<![CDATA[   If Len(sOffSet)=0 Then sOffSet=oPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[   If Len(sOffSet)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[      Set oChild = oPage.FindChild("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[      If Not(oChild Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[          sOffset = Trim(oChild.Text)]]>
<![CDATA[
]]>
<![CDATA[          sOffset = Replace(sOffset,";","")			]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If(sOffset="") Then]]>
<![CDATA[
]]>
<![CDATA[      ioX = 0]]>
<![CDATA[
]]>
<![CDATA[      ioY = 0]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      arImageOffset = Split(sOffset,",")]]>
<![CDATA[
]]>
<![CDATA[      If(UBound(arImageOffset) <> 1) Then]]>
<![CDATA[
]]>
<![CDATA[         ioX = 0]]>
<![CDATA[
]]>
<![CDATA[         ioY = 0       ]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[         ioX = CInt(arImageOffset(0))]]>
<![CDATA[
]]>
<![CDATA[         ioY = CInt(arImageOffset(1))         ]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' find assigned template]]>
<![CDATA[
]]>
<![CDATA[   sTempl = ""]]>
<![CDATA[
]]>
<![CDATA[   sTempl = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[   If(CStr(sTempl) = "" ) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog "unable find out template ID"]]>
<![CDATA[
]]>
<![CDATA[      iloc_AdjustZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' variable to help find out DETAILS dimension]]>
<![CDATA[
]]>
<![CDATA[   Dim arXY]]>
<![CDATA[
]]>
<![CDATA[   arXY = Split("0,0,0,0",",")]]>
<![CDATA[
]]>
<![CDATA[   arXY(0) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(1) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(2) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(3) = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Call AdjustSetupSubfields(oSetup, oPage, sTempl, arXY, ioX, ioY)]]>
<![CDATA[
]]>
<![CDATA[   Call GetDetailBottomEdge(oSetup, oPage, sTempl)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   writelog("save DCO Setup from " & oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	   If(oSetup.WriteSetup(sSetupPath)) Then]]>
<![CDATA[
]]>
<![CDATA[	      writelog("save DCO into local copy")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	      iloc_AdjustZones = True]]>
<![CDATA[
]]>
<![CDATA[	   Else]]>
<![CDATA[
]]>
<![CDATA[	   		writelog("unable to save DCO into local copy")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	      iloc_AdjustZones = False]]>
<![CDATA[
]]>
<![CDATA[	   End If]]>
<![CDATA[
]]>
<![CDATA[	   oSetup.UnlockIt()]]>
<![CDATA[
]]>
<![CDATA[	 Else]]>
<![CDATA[
]]>
<![CDATA[	 			writelog("unable to save DCO because it was locked")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	 	iloc_AdjustZones = False]]>
<![CDATA[
]]>
<![CDATA[	 End If]]>
<![CDATA[
]]>
<![CDATA[    oSetup.Path=sSetupPath]]>
<![CDATA[
]]>
<![CDATA[	if err.number<>0 then]]>
<![CDATA[
]]>
<![CDATA[   	writelog("Error:")]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.number]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.description]]>
<![CDATA[
]]>
<![CDATA[   	err.clear]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[''web   if WriteDCOSetup() then]]>
<![CDATA[
]]>
<![CDATA[''web      iloc_AdjustZones = true]]>
<![CDATA[
]]>
<![CDATA[''web   else]]>
<![CDATA[
]]>
<![CDATA[''web      iloc_AdjustZones = false]]>
<![CDATA[
]]>
<![CDATA[     ''web   end if ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</g>
	</af>
	<af name="IsPageDataMissing" access="public" bInter="bInter" bDebug="bDebug" qi="Checks to see that the current page data exists.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Checks to see that the current page data exists. ]]>
<![CDATA[
]]>
<![CDATA[    This action does not physically check for the existence of a data file.  It confirms]]>
<![CDATA[
]]>
<![CDATA[    that a valid page data is loaded into memory.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[IsPageDataMissing()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the current page does not have page data. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[  If(CurrentObj.NumOfChildren = 0) Then]]>
<![CDATA[
]]>
<![CDATA[    IsPageDataMissing = True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    IsPageDataMissing = False]]>
<![CDATA[
]]>
<![CDATA[  End If ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="iloc_AssignPageType" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Assigns a required Page Type value to a newly created fingerprint.">
		<ap>
<![CDATA[
]]>
<![CDATA[    The value of the page type to assign to the current page.  The input parameter must be one of the following:]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    1. A numeric value that corresponds to the Page Type.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    2. A string value of the page type name.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Assigns a required Page Type value to a newly created fingerprint.]]>
<![CDATA[
]]>
<![CDATA[    The assigned value corresponds to the values configured in the PageType table within the fingerprint database.]]>
<![CDATA[
]]>
<![CDATA[    These values are custom defined for each application.]]>
<![CDATA[
]]>
<![CDATA[    If a string value is passed as a parameter, this action will look up the corresponding numeric value within the database.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<scr>
<![CDATA[Iloc_AssignPageType("2")]]>
				</scr>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      This example assigns a page type of 2 to the new fingerprint.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
				<scr>
<![CDATA[Iloc_AssignPageType("PageSeparator")]]>
				</scr>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      This example assigns a page type of "PageSeparator" to the new fingerprint.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the numeric value cannot be retrieved from the fingerprint database or if there is]]>
<![CDATA[
]]>
<![CDATA[    no connection to the fingerprint database. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   iloc_AssignPageType = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If InitFPDB=False then ]]>
<![CDATA[
]]>
<![CDATA[      writeLog("No connection to FP Database.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If(IsNumeric(strParam)) Then]]>
<![CDATA[
]]>
<![CDATA[      writeLog("param in iloc_AssignPageType is numeric: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      writeLog("param in iloc_AssignPageType is non-numeric: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[      sSQL = "select pt_PageTypeID,pt_PageType from PageType where pt_PageType='" & strParam & "'"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Dim oRecSet]]>
<![CDATA[
]]>
<![CDATA[      Set oRecSet = Conn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If DBErrTrap(conn, "iloc_AssignPageType") Then]]>
<![CDATA[
]]>
<![CDATA[         oRecSet.Close()]]>
<![CDATA[
]]>
<![CDATA[         writeLog("iloc_AssignPageType Database error after: " & sSQL )]]>
<![CDATA[
]]>
<![CDATA[         Set oRecSet=Nothing]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If oRecSet.state = 0 Then									]]>
<![CDATA[
]]>
<![CDATA[          writelog(Space(4) & "Unable to open recordset.")	]]>
<![CDATA[
]]>
<![CDATA[          Set oRecSet = Nothing]]>
<![CDATA[
]]>
<![CDATA[      End If ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If oRecSet.eof Or oRecSet.bof Then			]]>
<![CDATA[
]]>
<![CDATA[          writelog(Space(4) & "No records returned.")		]]>
<![CDATA[
]]>
<![CDATA[          writelog(Space(4) & "Insert as Page type into PageType page.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          sSQL1 = "insert into PageType(pt_PageType) values ('"& strParam &"')"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Conn.Execute(sSQL1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          If DBErrTrap(conn, "GetDataArray1") Then]]>
<![CDATA[
]]>
<![CDATA[             writeLog("GetDataArray1 Database error after: " & sSQL1 )]]>
<![CDATA[
]]>
<![CDATA[             Exit Function]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' reread again ? what is the purpose?]]>
<![CDATA[
]]>
<![CDATA[         oRecSet.Close]]>
<![CDATA[
]]>
<![CDATA[         Set oRecSet = Conn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[         If DBErrTrap(conn, "iloc_AssignPageType") Then]]>
<![CDATA[
]]>
<![CDATA[            oRecSet.Close()]]>
<![CDATA[
]]>
<![CDATA[            writeLog("iloc_AssignPageType Database error after: " & sSQL )]]>
<![CDATA[
]]>
<![CDATA[            Set oRecSet=Nothing]]>
<![CDATA[
]]>
<![CDATA[            Exit Function]]>
<![CDATA[
]]>
<![CDATA[         End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['''         call ExecuteSQL(bInter, bDebug, sSQL1)]]>
<![CDATA[
]]>
<![CDATA['''          Set oRecSet = oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      nRowCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      oRecSet.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      writelog("Retrieved value from database: " & oRecSet.Fields.Item(0).Value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Select Case oRecSet.Fields.Item(0).Type]]>
<![CDATA[
]]>
<![CDATA[          Case 3  ' int]]>
<![CDATA[
]]>
<![CDATA[             strParam = CInt(oRecSet.Fields.Item(0).Value)]]>
<![CDATA[
]]>
<![CDATA[             writelog("Obtained new value: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[          Case Else]]>
<![CDATA[
]]>
<![CDATA[             writelog("got nonnumeric value") ]]>
<![CDATA[
]]>
<![CDATA[             strParam = CStr(oRecSet.Fields.Item(0).Value)]]>
<![CDATA[
]]>
<![CDATA[             writelog("Obtained new value: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[      End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oRecSet = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   nTemplateID = CInt(CurrentObj.Variable("TemplateID"))]]>
<![CDATA[
]]>
<![CDATA[   sSQL2 = "Update Template set tp_PageType=" & CInt(strParam) &_]]>
<![CDATA[
]]>
<![CDATA[           " where tp_TemplateID="& nTemplateID]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   conn.Execute(sSQL2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If DBErrTrap(conn, "iloc_AssignPageType") Then]]>
<![CDATA[
]]>
<![CDATA[      writeLog("iloc_AssignPageType Database error after: " & sSQL2 )]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      writelog("Update successful for nTemplateID: " & nTemplateID)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   iloc_AssignPageType = True ]]>
<![CDATA[
]]>
		</g>
	</af>
</rrx>
<rrx namespace="Livelink" v="8.1.0.1">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' OpenText Livelink Release Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Requires OpenText Livelink LAPI dll files and Microsoft Visual J# Version 2.0 Redistributable Package  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.0"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/18/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Initial implementation of Livelink .Net Actions library. The action library contains the same functionality exposed in the previous implementation]]>
<![CDATA[
]]>
<![CDATA['   but handles many situations that made the previous implementation unusable. These changes include:]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['   * Naming the uploaded pages using the convention BatchId.PageId. The previous implementation was always uploading the image name as PageId, so it would]]>
<![CDATA[
]]>
<![CDATA['   cause problems when running more than one batch (two or more batches will contain different TM000001 files).]]>
<![CDATA[
]]>
<![CDATA['   * Error handling with detailed messages]]>
<![CDATA[
]]>
<![CDATA['   * Ability to get user id and user password from the application file]]>
<![CDATA[
]]>
<![CDATA['   * Ability to close the connection to the server]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.0"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/17/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added IBM Copyright Notice]]>
<![CDATA[
]]>
<![CDATA[' *31610 Replaced instances of LiveLink in help text with correct trademark spelling, Livelink.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/19/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' *31022 Moved qi parameter information to its own parameter section.  Indicated in the help which parameters support smart parameters.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.Livelink.Actions" qi="OpenText Livelink Release Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="Connect_LL" qi="Connects to the Livelink repository.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Connects to the Livelink repository. This action should be called after setting the connection parameters via the following actions: ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<i>
<![CDATA[
]]>
<![CDATA[            SetServerName_LL("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID_LL("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword_LL("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetPort_LL(2099)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</i>
<![CDATA[
]]>
<![CDATA[        ]]>
				</b>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName_LL("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID_LL("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword_LL("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetPort_LL(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[Connect_LL()]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if the connection to the repository cannot be established. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="Disconnect_LL" qi="Closes the connection to the Livelink repository.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Closes the connection to the Livelink repository. This action should be called after the ]]>
				<scr>
<![CDATA[Upload_LL()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect_LL()]]>
				</scr>
<![CDATA[.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Typically this action would be called at the Batch's close node, after the connection to the repository is made and documents are uploaded.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName_LL("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID_LL("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword_LL("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetPort_LL(2099)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect_LL()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[Disconnect_LL()]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if the connection to fax server cannot be closed. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="Upload_LL" qi="Uploads images to the Livelink repository, under the logged in user's workspace.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Uploads images to the Livelink repository, under the logged in user's workspace. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action after a ]]>
				<scr>
<![CDATA[Connect_LL()]]>
				</scr>
<![CDATA[ action. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[Upload_LL()]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Note: if the Connect_LL() action is not called prior to calling Upload_LL(), Upload_LL() will automatically call the Connect_LL() action. However, the actions]]>
<![CDATA[
]]>
<![CDATA[          that set the connection parameters need to be called prior to Upload_LL(). ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Document or Page levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the expected level or if an exception is encountered while uploading images.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetServerName_LL" qi="Sets the name of the Livelink server to connect to.">
			<p name="ServerName" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ServerName : The name of the Livelink server server.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the name of the Livelink server to connect to.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[Upload_LL()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect_LL()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetServerName_LL("myserver")]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID_LL("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword_LL("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetPort_LL(2099)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect_LL()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetUserID_LL" qi="Sets the user ID to connect to the Livelink server.">
			<p name="UserID" type="string" qi="The user ID to be used to connect to the Livelink server.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        UserID : The user ID to be used to connect to the Livelink server.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the user ID to connect to the Livelink server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[Upload_LL()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect_LL()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName_LL("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetUserID_LL("myuser")]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword_LL("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetPort_LL(2099)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect_LL()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetUserPassword_LL" qi="Sets the user ID password to connect to the Livelink server.">
			<p name="UserPassword" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        UserPassword : The user ID password to connect to the Livelink server.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the user ID password to connect to the Livelink server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[Upload_LL()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect_LL()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName_LL("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID_LL("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetUserPassword_LL("mypassword")]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetPort_LL(2099)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect_LL()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetPort_LL" qi="Sets the port number to be used to connect to the Livelink server.">
			<p name="Port" type="int" qi="Sets the port number to be used to connect to the Livelink server.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        Port : Sets the port number to be used to connect to the Livelink server.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the port number to be used to connect to the Livelink server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[Upload_LL()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect_LL()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName_LL("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID_LL("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword_LL("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetPort_LL(2099)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect_LL()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="Nenu" v="8.1.0.25">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' NENU Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' 'Restricted Materials of IBM']]>
<![CDATA[
]]>
<![CDATA[' 5725-C15]]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/17/2009 OGorbunov]]>
<![CDATA[
]]>
<![CDATA[' * 22425 Inital implementation.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/17/2009 OGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Consolidated SetaTMLog actions]]>
<![CDATA[
]]>
<![CDATA[' Added functionality to QuerySetAge function to recognize seconds. ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.3"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/06/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29187 Added help text. Removed SetDebugFlag.  SetTMLog was changed to ConfigureMessageLog.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/11/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29196 Update help text for parameters that accept smart parameters. ]]>
<![CDATA[
]]>
<![CDATA['       OpenApplicationEx, SetApplication, SetServer, SetAdminDB, SetEngineDB, SetUser, SetPassword, SetStation, ]]>
<![CDATA[
]]>
<![CDATA['       ChangeBatchesStatus, ChangeBatchesStatusOrder, ChangeBatchesStatusTaskOrder, MoveBatches, ]]>
<![CDATA[
]]>
<![CDATA['       SendEmail, ResetPendingOrNotify, ConfigureMessageLog, SetSQLSeparator, QuerySetJobID, ]]>
<![CDATA[
]]>
<![CDATA['       QuerySetTaskID, QuerySetStatus, QuerySetOperator, QuerySetStation, QuerySetDateRange,]]>
<![CDATA[
]]>
<![CDATA['       QuerySetAge, QuerySetGeneric and WriteEventLog.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/01/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added actions (help review needed):]]>
<![CDATA[
]]>
<![CDATA[' ClearLog()]]>
<![CDATA[
]]>
<![CDATA[' SetReportingTable(...)	]]>
<![CDATA[
]]>
<![CDATA[' SetUsageDBTable(...)]]>
<![CDATA[
]]>
<![CDATA[' ClearAudit()]]>
<![CDATA[
]]>
<![CDATA[' ClearDebug()]]>
<![CDATA[
]]>
<![CDATA[' Added classes(header review needed. Copied the same one from "Datacap.Libraries.Nenu.Actions".):]]>
<![CDATA[
]]>
<![CDATA[' "Datacap.Libraries.Nenu.aTMSetup"]]>
<![CDATA[
]]>
<![CDATA[' "Datacap.Libraries.Nenu.Reporting"]]>
<![CDATA[
]]>
<![CDATA[' "Datacap.Libraries.Nenu.BatchProcess"]]>
<![CDATA[
]]>
<![CDATA[' "Datacap.Libraries.Nenu.SQLQuerySetup"]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/01/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Renamed class "Datacap.Libraries.Nenu.Actions" to "Datacap.Libraries.Nenu.Logging"]]>
<![CDATA[
]]>
<![CDATA[' Renamed class "Datacap.Libraries.Nenu.aTMSetup" to "Datacap.Libraries.Nenu.AppSetup"]]>
<![CDATA[
]]>
<![CDATA[' Renamed action ConfigureMessageLog to ConfigureLogging and moved it to Logging class]]>
<![CDATA[
]]>
<![CDATA[' Moved DisconnectAll to AppSetup class]]>
<![CDATA[
]]>
<![CDATA[' Renamed action GetRecordSet to WriteRecordSet and moved to Logging class]]>
<![CDATA[
]]>
<![CDATA[' Renamed GetSQLQuery to WriteSQLQuery and moved to Logging class]]>
<![CDATA[
]]>
<![CDATA[' Renamed ChangeBatchesStatus to ChangeBatchStatus]]>
<![CDATA[
]]>
<![CDATA[' Renamed ChangeBatchesStatusOrder to ChangeBatchStatusOrder]]>
<![CDATA[
]]>
<![CDATA[' Renamed ChangeBatchesStatusTaskOrder to ChangeBatchStatusTaskOrder]]>
<![CDATA[
]]>
<![CDATA[' Remamed class "Datacap.Libraries.Nenu.SQLQuerySetup" to "Datacap.Libraries.Nenu.QuerySetup"]]>
<![CDATA[
]]>
<![CDATA[' Renamed action SetSQLSeparator to QuerySetSeparator]]>
<![CDATA[
]]>
<![CDATA[' Moved action RunSQLQuery to QuerySetup class]]>
<![CDATA[
]]>
<![CDATA[' Renamed action ClearAudit to ClearAuditTable]]>
<![CDATA[
]]>
<![CDATA[' Renamed action ClearDebug to ClearDebugTable]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['' Version = "8.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/09/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' moved all the actions to a single class "Actions"]]>
<![CDATA[
]]>
<![CDATA[' renamed:]]>
<![CDATA[
]]>
<![CDATA[' ConfigureLogging to LogConfigure]]>
<![CDATA[
]]>
<![CDATA[' WriteRecordSet to LogWriteRecordSet]]>
<![CDATA[
]]>
<![CDATA[' WriteSQLQuery to LogWriteSQLQuery]]>
<![CDATA[
]]>
<![CDATA[' ClearLog to LogClear]]>
<![CDATA[
]]>
<![CDATA[' SendEmail to LogSendEmail]]>
<![CDATA[
]]>
<![CDATA[' WriteEventLog to LogWriteEventLog]]>
<![CDATA[
]]>
<![CDATA[' DisconnectAll to SetupDisconnectAll]]>
<![CDATA[
]]>
<![CDATA[' OpenApplication to SetupOpenApplication]]>
<![CDATA[
]]>
<![CDATA[' OpenApplicationEx to SetupOpenApplicationEx]]>
<![CDATA[
]]>
<![CDATA[' RunSqlQuery to ProcessRunSqlQuery]]>
<![CDATA[
]]>
<![CDATA[' ClearAuditTable to ProcessClearAuditTable]]>
<![CDATA[
]]>
<![CDATA[' ClearDebugTable to ProcessClearDebugTable]]>
<![CDATA[
]]>
<![CDATA[' MoveDBRecords to ProcessMoveDBRecords]]>
<![CDATA[
]]>
<![CDATA[' ChangeBatchStatus to ProcessChangeBatchStatus]]>
<![CDATA[
]]>
<![CDATA[' ChangeBatchStatusOrder to ProcessChangeBatchStatusOrder]]>
<![CDATA[
]]>
<![CDATA[' ChangeBatchStatusTaskOrder to ProcessChangeBatchStatusTaskOrder]]>
<![CDATA[
]]>
<![CDATA[' DeleteBatches to ProcessDeleteBatches]]>
<![CDATA[
]]>
<![CDATA[' MoveBatches to ProcessMoveBatches]]>
<![CDATA[
]]>
<![CDATA[' ResetPendingOrNotify to ProcessResetPendingOrNotify]]>
<![CDATA[
]]>
<![CDATA[' QueryTMUsage to ReportQueryTMUsage]]>
<![CDATA[
]]>
<![CDATA[' SetReportingTable to RetorpSetReportingTable]]>
<![CDATA[
]]>
<![CDATA[' SetUsageDBTable to ReportSetUsageDBTable]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/23/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29187 Minor help updates.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/28/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Renamed RetorpSetReportingTable to ReportSetReportingTable]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/28/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added parameter asAttachment to ProcessResetPendingOrNotify]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/30/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29187 Minor help updates.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/18/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added parameter to ProcessMoveDBRecords action to select target DB date time separator.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/22/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29886 Clarified the help to state that when performing multiple operations that include]]>
<![CDATA[
]]>
<![CDATA['       moving the database records, the database move should be performed last.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/27/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Moved parameter targetDBSQLSeparator in the action ProcessMoveDBRecords to the end of list, as it is not likely to be used.]]>
<![CDATA[
]]>
<![CDATA[' Updated help for QuerySetSeparator.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/13/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 30131 Fixed help text for ProcessDeleteBatches.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/01/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added ProcessInjectBatches Function]]>
<![CDATA[
]]>
<![CDATA[' Added QuerySetBatchRange Function]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/21/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added function QuerySetDateFormat and QuerySetDateTimeFormat]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/22/2011 RFerin ]]>
<![CDATA[
]]>
<![CDATA[' 32144 Removed support for DCSit.  Use smart parameters to obtain passwords from the application service.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/22/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' 31243 Fixed help for action SetupOpenApplication]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/03/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Moved parameter information from the qi= tag to the standard parameter help section]]>
<![CDATA[
]]>
<![CDATA[' Moved action information from the qi= tag to the standard action help section]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/03/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed typo in coma word]]>
<![CDATA[
]]>
<![CDATA[' Added location of the audit and debug tables to the help]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.22"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/14/2012 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed typos in action's help]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.23"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/20/2012 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed typos in action's help]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.24"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/20/2012 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed help for QuerySetGeneric action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.25"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/20/2012 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed help for SetupOpenApplication, SetupOpenApplicationEX, SetPasword, SetUser and SetStation (LDAP - leave blank user, pwd and station).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.Nenu.Actions" qi="Logging actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      NENU, the New Enhanced Notification Utility, can monitor one or more applications, perform maintenance]]>
<![CDATA[
]]>
<![CDATA[      and reporting on them.  Everything NENU does is action based, allowing it to be]]>
<![CDATA[
]]>
<![CDATA[      highly customized to the needs of specific applications.  NENU has the ability to build queries using]]>
<![CDATA[
]]>
<![CDATA[      rulesets and actions from within Datacap Studio.  The results of the queries can be acted]]>
<![CDATA[
]]>
<![CDATA[      on directly to send notifications or automatically adjust batch states.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Using the "QuerySet" actions, queries can be dynamically generated at run time, piece by piece.]]>
<![CDATA[
]]>
<![CDATA[      Each action will specify aspects of the query until it is finally executed.  The result is]]>
<![CDATA[
]]>
<![CDATA[      a record set of batches that can be acted upon as required.]]>
<![CDATA[
]]>
<![CDATA[      For example, it is possible to delete or mote batches that have reached a certain age.  If batches]]>
<![CDATA[
]]>
<![CDATA[      have become stuck in an aborted state, an email can be generated to a set of recipients to notify them]]>
<![CDATA[
]]>
<![CDATA[      of the issue.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogClear" qi="Clears current Log.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Clears current log.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogClear()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogConfigure" qi="Sets the severity level to activate logging and enables logging features.">
			<p name="severity" type="int">
			</p>
			<p name="filePath" type="string">
			</p>
			<p name="overwrite" type="bool">
			</p>
			<p name="reflash" type="bool">
			</p>
			<p name="showTime" type="bool">
			</p>
			<p name="showDate" type="bool">
			</p>
			<p name="showSeverity" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        severity: The log severity limit. 0 = log only severe errors.  5 = log all messages. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        filePath: Log file path name.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        overwrite: True will overwrite any existing file. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        reflash: True will flush the error message buffer to disk after every write. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        showTime: True adds the current time to each log message. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        showDate: True adds the current date to each log message. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        showSeverity: True adds the severity to the log. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Configures the Rulerunner message log.  The severity limit controls if informational messages or only severe error]]>
<![CDATA[
]]>
<![CDATA[        messages are placed into the log.  Logging only severe errors will provide the best performance at the]]>
<![CDATA[
]]>
<![CDATA[        expense of reduced debug information, should a debug trace be required.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This logging only adjusts the messages that are logged from the task run by NENU.  It will not]]>
<![CDATA[
]]>
<![CDATA[        change the logging as configured for each of the tasks in the target application.  If this action]]>
<![CDATA[
]]>
<![CDATA[        is not called, no log file will be created.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogConfigure("5", "C:\ParentDir\NENU\Logs")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example, the logs will be placed into this custom directory.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogConfigure("5", "@APPPATH(export)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example, the output directory is retrieved from the application service]]>
<![CDATA[
]]>
<![CDATA[          using Smart parameters.  The path is the export directory for the current application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if logging is successfully configured.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogWriteRecordSet" qi="Outputs the results of ProcessRunSqlQuery to the error log.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Writes out the result of the last call to ProcessRunSqlQuery to the error file.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful for debugging an application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!011")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogWriteRecordSet("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the write is successful.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery, LogWriteSQLQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogWriteSQLQuery" qi="Outputs the constructed SQL query to the error log.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Writes out the result of the previous calls to the "QuerySet" actions to the error file.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful for debugging an application, allowing you to view the]]>
<![CDATA[
]]>
<![CDATA[        exact SQL that was constructed and used in ProcessRunSqlQuery.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!011")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogWriteSQLQuery("")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the log is successfully written.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery, LogWriteRecordSet]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogSendEmail" qi="Sends email with log to comma separated list of recipients.">
			<p name="asattachment" type="bool">
			</p>
			<p name="addressFrom" type="string">
			</p>
			<p name="addressTo" type="string">
			</p>
			<p name="subject" type="string">
			</p>
			<p name="user" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<p name="domain" type="string">
			</p>
			<p name="server" type="string">
			</p>
			<p name="port" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        All parameters support Smart parameters.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        asattachment: Send the log as attachment to the e-mail. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        addressFrom: Address From (Optional). Default value: currentUser@currentDomain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        addressTo: Comma separated list of recipients. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        subject: email subject (Optional). Default value: 'NENU notification current_date_and_time'. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        user: Mail user name (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password: Mail user password (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        domain: Mail user domain (Optional). Default value: current domain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        server: Mail Server name (Optional). Default value: mail.current_domain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        port: Mail Server Port number (Optional). Default value: 25. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sends an email using the SMTP protocol.  As NENU actions run, an in-memory log keeps track of each of the NENU actions]]>
<![CDATA[
]]>
<![CDATA[        that are called and their parameters.  The LogSendEmail action will place the action activity information into an]]>
<![CDATA[
]]>
<![CDATA[        email and send it.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogSendEmail("jsmith@somewhere.com", "jdoe@somewhere.com,mmoore@somewhere.com", "", "", "", "", "", "")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the email is sent.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogWriteEventLog" qi="Writes a message to the Event Log.">
			<p name="message" type="string">
			</p>
			<p name="level" type="int">
			</p>
			<p name="eventID" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        message: Message to write to the Event Log and the local log.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        level: Integer value. 0 - informational, 1 - Warning, 2 - Error. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        eventID: Integer value. Desired Event ID. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Unconditionally writes out a message to the Windows Event Log and to the application log file for the running task.]]>
<![CDATA[
]]>
<![CDATA[        Set the level and event ID to the values that is appropriate for the message being logged.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogWriteEventLog("This is an informational message.", "0", "10")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example writes the message 'This is an informational message.' to the event log.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogWriteEventLog("@B.MyMessage", "0", "10")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example uses Smart parameters to write out the value of the batch level variable "MyMessage".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the event is successfully logged.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetupDisconnectAll" qi="Disconnect from all Taskmaster servers.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Closes the connections to all Taskmaster databases that were opened by NENU actions.]]>
<![CDATA[
]]>
<![CDATA[        Some NENU actions will automatically close the connection to the database]]>
<![CDATA[
]]>
<![CDATA[        after a query has been performed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetupDisconnectAll()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="SetupOpenApplication" qi="Creates connection to the application based on default settings.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        A simplified version of SetupOpenApplicationEx.  It is identical in operation with the difference that]]>
<![CDATA[
]]>
<![CDATA[        all of the default parameters are used.  The default values can be set]]>
<![CDATA[
]]>
<![CDATA[        independently by individual actions, such as SetApplication, SetServer, etc.  See SetupOpenApplicationEx for more information.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP and LLLDAP authentication the ]]>
				<b>
<![CDATA[User]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[Password]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[Station]]>
				</b>
<![CDATA[ values has to be ]]>
				<b>
<![CDATA[blank]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetUser("user")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetPassword("password")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetStation("1")]]>
					<br>
					</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetupOpenApplication()]]>
					</b>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the application exists in the application service the connection was successful.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        SetupOpenApplicationEx, SetApplication, SetServer, SetAdminDB, SetEngineDB, SetUser, SetPassword, SetStation]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="SetupOpenApplicationEx" qi="Creates connection to the application based on the parameters provided.">
			<p name="application" type="string">
			</p>
			<p name="server" type="string">
			</p>
			<p name="admin" type="string">
			</p>
			<p name="engine" type="string">
			</p>
			<p name="debugFlag" type="bool">
			</p>
			<p name="user" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<p name="station" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        All parameters, except for debugFlag, support Smart parameters. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        application: Application name (Optional). Default value: the name of the application that is running this action. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        server: Server name (Optional). Default value: first available server in the application. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        admin: Administration Database name (Optional). Default value: first available Admin DB. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        engine: Engine Database name (Optional). Default value: first available Engine DB. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        debugFlag: Debug Flag (Optional). Default value: false. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        user: User name (Optional). Default value: current user credentials. Leave Blank for LDAP authentication.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password: Password (Optional). Default value: current user credentials. Leave Blank for LDAP authentication.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        station: Station ID (Optional). Default value: Current station name. Leave Blank for LDAP authentication.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Similar to SetupOpenApplication, this action will connect NENU to a specific application.]]>
<![CDATA[
]]>
<![CDATA[        The difference between the two actions is that here the default parameters]]>
<![CDATA[
]]>
<![CDATA[        can be overridden in one single action.  These parameters determine what application]]>
<![CDATA[
]]>
<![CDATA[        is to be monitored by NENU.  This action, or SetupOpenApplication, should be called first, then]]>
<![CDATA[
]]>
<![CDATA[        the NENU actions can be used to perform queries on the application and perform any]]>
<![CDATA[
]]>
<![CDATA[        required actions based on the results.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP and LLLDAP authentication the ]]>
				<b>
<![CDATA[User]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[Password]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[Station]]>
				</b>
<![CDATA[ values has to be ]]>
				<b>
<![CDATA[blank]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetupOpenApplicationEX("Survey", "", "SurveyAdm.mdb", "SurveyEng.mdb", "False", "", "", "1")]]>
					</b>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the application exists in the application service the connection was successful.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        SetupOpenApplication, SetApplication, SetServer, SetAdminDB, SetEngineDB, SetUser, SetPassword, SetStation]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetApplication" qi="Specifies the name of the Application used by NENU.">
			<p name="application" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        application: The application name.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the name of the application, as defined within the application service, which]]>
<![CDATA[
]]>
<![CDATA[        will be used by NENU.  The application]]>
<![CDATA[
]]>
<![CDATA[        will determine the rules and databases that will be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetApplication("APT")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the application name is missing.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetServer" qi="Specifies the name of the Taskmaster Server.">
			<p name="server" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        server: Server name.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The name of the Taskmaster server as it is defined in the application service, which will be]]>
<![CDATA[
]]>
<![CDATA[        the server used by subsequent NENU actions.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetServer("Server 1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if a server name is not specified.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetAdminDB" qi="Specifies the Administration database.">
			<p name="adminDB" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        adminDB: Administration Database key in the Application Service.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Obtains the Administrator database connection information from the application service.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetAdminDB("*/tmadmin:cs")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetEngineDB" qi="Specifies the Engine database.">
			<p name="engineDB" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        engineDB: Engine Database key in the Application Service. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Obtains the Engine database connection information from the application service.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetEngineDB("*/tmengine:cs")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetUser("Admin")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetUser" qi="Action to set a user name to login to the Server.">
			<p name="user" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        user: User name.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Specifies the name of the user for the login to the Administrator and Engine databases.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP and LLLDAP authentication the ]]>
				<b>
<![CDATA[User]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[Password]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[Station]]>
				</b>
<![CDATA[ values has to be ]]>
				<b>
<![CDATA[blank]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetUser("Admin")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetPassword" qi="Action to set password to connect to the Server.">
			<p name="password" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        password: Password. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Specifies the password for the previously specified user ID.  ]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP and LLLDAP authentication the ]]>
				<b>
<![CDATA[User]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[Password]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[Station]]>
				</b>
<![CDATA[ values has to be ]]>
				<b>
<![CDATA[blank]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetUser("Admin")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetPassword("@APPVAR(values/gen/mypassword)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This example uses the smart parameter @APPPVAR to obtain the value of the password from the value name "mypassword"]]>
<![CDATA[
]]>
<![CDATA[          in the "Custom Values" tab of the application service manager.  The value name is configurable.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetStation" qi="Action to set station ID to connect to the Server.">
			<p name="station" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        station: Station ID. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Specifies the station ID for login.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP and LLLDAP authentication the ]]>
				<b>
<![CDATA[User]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[Password]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[Station]]>
				</b>
<![CDATA[ values has to be ]]>
				<b>
<![CDATA[blank]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetStation("1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessChangeBatchStatus" qi="Changes the status of one or more batches.">
			<p name="newStatus" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        newStatus: The new batch status: aborted, cancelled, finished, hold, job done, pending, running.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will have their status attribute changed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The database connection will be closed by this action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!011")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessChangeBatchStatus("hold")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batch status is successfully changed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessChangeBatchStatusOrder" qi="Changes batch status and order.">
			<p name="newStatus" type="string">
			</p>
			<p name="newOrder" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        newStatus: The new batch status: aborted, cancelled, finished, hold, job done, pending, running.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        newOrder: New order. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will have their status and order attributes changed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The database connection will be closed by this action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessChangeBatchStatusOrder("hold", "1")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batch status is successfully changed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessChangeBatchStatusTaskOrder" qi="Changes batch status, task and order.">
			<p name="newStatus" type="string">
			</p>
			<p name="newOrder" type="int">
			</p>
			<p name="newTask" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        newStatus: The new batch status: aborted, cancelled, finished, hold, job done, pending, running.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        newOrder: New order. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        newTask: New job task. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will have their status, order and task attributes changed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The database connection will be closed by this action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!011")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessChangeBatchStatusTaskOrder("hold", "1", "Verify")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batch status is successfully changed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessClearAuditTable" qi="Clears the Audit table located in the admin database.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Clears the Audit table located in the admin database.  This action can be called to ensure]]>
<![CDATA[
]]>
<![CDATA[        that Audit table is cleared when information is moved from one]]>
<![CDATA[
]]>
<![CDATA[        database to another.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessClearAuditTable("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the table is cleared.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessClearDebugTable]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessClearDebugTable" qi="Clears the Debug table located in the engine database.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Clears the Debug table located in the engine database.  This action can be called to ensure]]>
<![CDATA[
]]>
<![CDATA[        that Debug table is cleared when information is moved from one]]>
<![CDATA[
]]>
<![CDATA[        database to another.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessClearDebugTable("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the table is cleared.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessClearAuditTable]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessDeleteBatches" qi="Delete selected batches.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will be deleted from disk.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        A previous query must have been run to identify the batches to delete.]]>
<![CDATA[
]]>
<![CDATA[        The database connection will be closed by this action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!011")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessDeleteBatches("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batches are deleted.  Otherwise ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessMoveBatches, ProcessMoveDBRecords]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessMoveBatches" qi="Move selected batches to folder specified in the parameter.">
			<p name="pathTo" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        pathTo: The destination directory for the batches. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will be moved to the specified destination directory.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        A previous query must have been run to identify the batches to move to the new directory.]]>
<![CDATA[
]]>
<![CDATA[        The destination directory must exist.  The database connection will be closed by this action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If you are moving batches from one location to another and also moving database records from]]>
<![CDATA[
]]>
<![CDATA[        one database to another, move the batches first.  The movement of the database records should]]>
<![CDATA[
]]>
<![CDATA[        be performed last.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!011")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessMoveBatches("C:\My Old Batches\")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example runs a query to select all batches from station "1" where the Job ID]]>
<![CDATA[
]]>
<![CDATA[          does not equal "011", then moves the batches to a directory called "My Old Batches".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!011")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessMoveBatches("@APPPATH(BatchArchiveDirectory)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example also selects the same set of batches as above, however it uses a]]>
<![CDATA[
]]>
<![CDATA[          Smart parameter to obtain the full path to directory from the Application Service.]]>
<![CDATA[
]]>
<![CDATA[          A key called "BatchArchiveDirectory" will have to exist in the Application Service.]]>
<![CDATA[
]]>
<![CDATA[          If these rules are used for multiple applications, each application can have]]>
<![CDATA[
]]>
<![CDATA[          a unique definition of this value within the Application Service, making these rules]]>
<![CDATA[
]]>
<![CDATA[          very flexible.]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          One benefit of this approach is that in an environment where there is a test system]]>
<![CDATA[
]]>
<![CDATA[          and a production system, each system will have unique values stored in the]]>
<![CDATA[
]]>
<![CDATA[          Application Service.  Each of the environments can have a different physical directory]]>
<![CDATA[
]]>
<![CDATA[          specified within the Application Service, allowing the rules in each system to remain identical.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batches are successfully moved.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessDeleteBatches, ProcessMoveDBRecords]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessMoveDBRecords" qi="Creates connection to the application based on the parameters provided and moves selected database data to this application.">
			<p name="application" type="string">
			</p>
			<p name="server" type="string">
			</p>
			<p name="admin" type="string">
			</p>
			<p name="engine" type="string">
			</p>
			<p name="debugFlag" type="bool">
			</p>
			<p name="user" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<p name="station" type="string">
			</p>
			<p name="deleteOriginal" type="bool">
			</p>
			<p name="targetDBSQLSeparator" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        application: Application name (Optional). Default value: the name of the application that is running this action. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        server: Server name (Optional). Default value: first available server in the application. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        admin: Administration Database name (Optional). Default value: first available Admin DB. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        engine: Engine Database name (Optional). Default value: first available Engine DB. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        debugFlag: Debug Flag (Optional). Default value: false. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        user: User name (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password: Password (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        station: Station ID (Optional). Default value: Current station name]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        deleteOriginal: Delete database records in source database. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        targetDBSQLSeparator: Target Database date and time separator (Optional). If left blank action will try to detect the correct separator based on the connection string. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Creates connection to the application based on the parameters provided and moves]]>
<![CDATA[
]]>
<![CDATA[        selected database data to this application.  When performing operations on a batch and you are also]]>
<![CDATA[
]]>
<![CDATA[        going to be moving the database records from one database to another, perform the database]]>
<![CDATA[
]]>
<![CDATA[        move operation last.  When database records are moved, the database connection is still]]>
<![CDATA[
]]>
<![CDATA[        connected to the original database.  Performing subsequent operations will still be]]>
<![CDATA[
]]>
<![CDATA[        working on the original database, not the records in the new database.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessMoveDBRecords("APTBack","tms","admin","engine","false","admin","admin","1","true","")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example the source database is Oracle and the target is Access.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessMoveBatches, ProcessDeleteBatches]]>
			</see>
		</method>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessResetPendingOrNotify" qi="Resets all selected batches to 'Pending' status.">
			<p name="threshold" type="int">
			</p>
			<p name="asattachment" type="bool">
			</p>
			<p name="addressFrom" type="string">
			</p>
			<p name="addressTo" type="string">
			</p>
			<p name="subject" type="string">
			</p>
			<p name="user" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<p name="domain" type="string">
			</p>
			<p name="server" type="string">
			</p>
			<p name="port" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        All parameters, except for threshold, support Smart parameters.]]>
<![CDATA[
]]>
<![CDATA[        threshold: Maximum amount of attempts to reset the batch to status 'Pending'. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        asattachment: Send the log as attachment to the e-mail. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        addressFrom: Address From (Optional). Default value: currentUser@currentDomain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        addressTo: The email recipient.  If multiple recipients, separate using a comma. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        subject: Email subject (Optional). Default value: 'NENU notification current_date_and_time'. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        user: Mail user name (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password: Mail user password (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        domain: Mail user domain (Optional). Default value: current domain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        server: Mail Server name (Optional). Default value: mail.current_domain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        port: Mail Server Port number (Optional). Default value: 25. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Resets the status of all batches selected by a previous SQL query to 'Pending' status.]]>
<![CDATA[
]]>
<![CDATA[        The action will attempt to reset the batch by the amount specified in the 'threshold' parameter.]]>
<![CDATA[
]]>
<![CDATA[        if the maximum reset attempts are reached, the action sends an email, along with the a log,]]>
<![CDATA[
]]>
<![CDATA[        to the provided list of recipients.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!011")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessResetPendingOrNotify("3", "rrodrig@somewhere.com", "tom@somewhere.com,john@somewhere.com","","","","","","")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the email is sent.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessRunSqlQuery" qi="Runs the previously defined NENU query.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Performs the SQL select query using a query previously built using NENU actions.]]>
<![CDATA[
]]>
<![CDATA[        The "QuerySet" actions need to have been previously called to create the]]>
<![CDATA[
]]>
<![CDATA[        query.  The resulting record set is retained in memory and can be acted upon]]>
<![CDATA[
]]>
<![CDATA[        using other actions.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The action LogWriteRecordSet can be used to write out the recordset, usually for]]>
<![CDATA[
]]>
<![CDATA[        debugging, as well as LogWriteSQLQuery which will output the constructed query.]]>
<![CDATA[
]]>
<![CDATA[        QueryClear can be used to remove any existing]]>
<![CDATA[
]]>
<![CDATA[        query settings.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!011")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessRunSqlQuery("")]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example obtains results that include all batches, except for 011, that have]]>
<![CDATA[
]]>
<![CDATA[          been run on station "1".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query is successful.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[LogWriteRecordSet, LogWriteSQLQuery, QueryClear]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ReportQueryTMUsage" qi="Update the ReportUser Database with the current users.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action will query the number of users current logged on and place the information]]>
<![CDATA[
]]>
<![CDATA[        into the reportUser.  This information is statistical information that can later]]>
<![CDATA[
]]>
<![CDATA[        be used to generate usage reports with the RV2 reporting system.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ReportQueryTMUsage("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the database update was successful.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ReportSetReportingTable" qi="Sets database that contains reports on all processed batches">
			<p name="tbName" type="string">
			</p>
			<p name="batchColumn" type="string">
			</p>
			<p name="attemptColumn" type="string">
			</p>
			<p name="doneColumn" type="string">
			</p>
			<p name="actionColumn" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tbName: Table name in Engine database. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        batchColumn: Optional. Name of the column that contains Batch ID. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        attemptColumn: Optional. Name of the column that contains attempts. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        doneColumn: Optional. Name of the column that contains completion result. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        actionColumn: Optional. Name of the column that contains last action performed. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets database that contains reports on all processed batches. Table must exist in the engine database.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ReportSetReportingTable("NENU","nn_batch","nn_attempt","nn_done","nn_action")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ReportSetUsageDBTable]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ReportSetUsageDBTable" qi="Sets database that contains reports on users logged in to TM">
			<p name="tbName" type="string">
			</p>
			<p name="ipAddressColumn" type="string">
			</p>
			<p name="jobIDColumn" type="string">
			</p>
			<p name="portColumn" type="string">
			</p>
			<p name="processedBathcesColumn" type="string">
			</p>
			<p name="stationColumn" type="string">
			</p>
			<p name="taskIDColumn" type="string">
			</p>
			<p name="userIDColumn" type="string">
			</p>
			<p name="queryTimeColumn" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tbName: Table name in Engine database. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ipAddressColumn: IP Address column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        jobIDColumn: Job ID column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        portColumn: Port column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        processedBathcesColumn: Processed batches column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        stationColumn: Station ID column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        taskIDColumn: Task ID column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        userIDColumn: User ID column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        queryTimeColumn: Query time column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets database that contains reports on users logged in to TM. Table must exist in the engine database.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ReportSetUsageDBTable("reportUsers","ru_ip","ru_job","ru_port","ru_bathces","ru_station","ru_task","ru_user","ru_time")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ReportSetUsageDBTable]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetSeparator" qi="Sets SQL Date and Time Separator for SQL queries.">
			<p name="separator" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        separator: Date separator. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Configures the Date and Time separator used by the database.  If this action is not called, the]]>
<![CDATA[
]]>
<![CDATA[        value for the separator will be selected based on the connection string. Some database]]>
<![CDATA[
]]>
<![CDATA[        separators are: MS SQL"'", Oracle "'", Access "#".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetSeparator("#")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QueryClear" qi="Clears the SQL query.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Clears any SQL query that may be in memory.  This action can be called to ensure]]>
<![CDATA[
]]>
<![CDATA[        that any NENU query that you build is not building on any previous information.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QueryClear("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query is cleared.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetDateFormat" qi="Sets custom Date format for SQL queries.">
			<p name="dateFormat" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dateFormat: Date format. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Configures the Date format used by the database.  If this action is not called, the]]>
<![CDATA[
]]>
<![CDATA[        value for the Date format will be ]]>
				<b>
<![CDATA["yyyy/MM/dd"]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        Detailed description of available values are:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[d]]>
				</b>
<![CDATA[	Represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[dd]]>
				</b>
<![CDATA[	Represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ddd]]>
				</b>
<![CDATA[	Represents the abbreviated name of the day of the week (Mon, Tues, Wed etc.)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[dddd]]>
				</b>
<![CDATA[	Represents the full name of the day of the week (Monday, Tuesday etc.)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[h]]>
				</b>
<![CDATA[	12-hour clock hour (e.g. 7)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[hh]]>
				</b>
<![CDATA[	12-hour clock, with a leading 0 (e.g. 07)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[H]]>
				</b>
<![CDATA[	24-hour clock hour (e.g. 19)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[HH]]>
				</b>
<![CDATA[	24-hour clock hour, with a leading 0 (e.g. 19)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[m]]>
				</b>
<![CDATA[	Minutes]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[mm]]>
				</b>
<![CDATA[	Minutes with a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[M]]>
				</b>
<![CDATA[	Month number]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MM]]>
				</b>
<![CDATA[	Month number with leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MMM]]>
				</b>
<![CDATA[	Abbreviated Month Name (e.g. Dec)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MMMM]]>
				</b>
<![CDATA[	Full month name (e.g. December)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[s]]>
				</b>
<![CDATA[	Seconds]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ss]]>
				</b>
<![CDATA[	Seconds with leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[t]]>
				</b>
<![CDATA[	Abbreviated AM / PM (e.g. A or P)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[tt]]>
				</b>
<![CDATA[	AM / PM (e.g. AM or PM]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[y]]>
				</b>
<![CDATA[	Year, no leading zero (e.g. 2001 would be 1)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yy]]>
				</b>
<![CDATA[	Year, leading zero (e.g. 2001 would be 01)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yyy]]>
				</b>
<![CDATA[	Year (e.g. 2001 would be 001)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yyyy]]>
				</b>
<![CDATA[	Year (e.g. 2001 would be 2001)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[K]]>
				</b>
<![CDATA[	Represents the time zone information of a date and time value (e.g. +05:00)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[z]]>
				</b>
<![CDATA[	With DateTime values, represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. (e.g. +6)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[zz]]>
				</b>
<![CDATA[	As z but with leading zero (e.g. +06)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[zzz]]>
				</b>
<![CDATA[	With DateTime values, represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. (e.g. +06:00)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[f]]>
				</b>
<![CDATA[	Represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ff]]>
				</b>
<![CDATA[	Represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fff]]>
				</b>
<![CDATA[	Represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ffff]]>
				</b>
<![CDATA[	Represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. While it is possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fffff]]>
				</b>
<![CDATA[	Represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. While it is possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ffffff]]>
				</b>
<![CDATA[	Represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. While it is possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fffffff]]>
				</b>
<![CDATA[	Represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. While it is possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[F]]>
				</b>
<![CDATA[	Represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[:]]>
				</b>
<![CDATA[	Represents the time separator defined in the current DateTimeFormatInfo..::.TimeSeparator property. This separator is used to differentiate hours, minutes, and seconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[/]]>
				</b>
<![CDATA[ 	 Represents the date separator defined in the current DateTimeFormatInfo..::.DateSeparator property. This separator is used to differentiate years, months, and days.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA["]]>
				</b>
<![CDATA[ 	 Represents a quoted string (quotation mark). Displays the literal value of any string between two quotation marks ("). Your application should precede each quotation mark with an escape character (\).]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[']]>
				</b>
<![CDATA[	 Represents a quoted string (apostrophe). Displays the literal value of any string between two apostrophe (') characters.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[%c]]>
				</b>
<![CDATA[ 	Represents the result associated with a c custom format specifier, when the custom date and time format string consists solely of that custom format specifier. That is, to use the d, f, F, h, m, s, t, y, z, H, or M custom format specifier by itself, the application should specify %d, %f, %F, %h, %m, %s, %t, %y, %z, %H, or %M. For more information about using a single format specifier, see Using Single Custom Format Specifiers.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetDateFormat("dd-MMM-yy")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
			<see>
<![CDATA[QuerySetDateTimeFormat]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetDateTimeFormat" qi="Sets custom DateTime format for SQL queries.">
			<p name="dateTimeFormat" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dateTimeFormat: DateTime format. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Configures the Date and Time format used by the database.  If this action is not called, the]]>
<![CDATA[
]]>
<![CDATA[        value for the Date format will be ]]>
				<b>
<![CDATA["yyyy/MM/dd HH:mm:ss"]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        Detailed description of available values are:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[d]]>
				</b>
<![CDATA[	Represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[dd]]>
				</b>
<![CDATA[	Represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ddd]]>
				</b>
<![CDATA[	Represents the abbreviated name of the day of the week (Mon, Tues, Wed etc.)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[dddd]]>
				</b>
<![CDATA[	Represents the full name of the day of the week (Monday, Tuesday etc.)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[h]]>
				</b>
<![CDATA[	12-hour clock hour (e.g. 7)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[hh]]>
				</b>
<![CDATA[	12-hour clock, with a leading 0 (e.g. 07)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[H]]>
				</b>
<![CDATA[	24-hour clock hour (e.g. 19)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[HH]]>
				</b>
<![CDATA[	24-hour clock hour, with a leading 0 (e.g. 19)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[m]]>
				</b>
<![CDATA[	Minutes]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[mm]]>
				</b>
<![CDATA[	Minutes with a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[M]]>
				</b>
<![CDATA[	Month number]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MM]]>
				</b>
<![CDATA[	Month number with leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MMM]]>
				</b>
<![CDATA[	Abbreviated Month Name (e.g. Dec)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MMMM]]>
				</b>
<![CDATA[	Full month name (e.g. December)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[s]]>
				</b>
<![CDATA[	Seconds]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ss]]>
				</b>
<![CDATA[	Seconds with leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[t]]>
				</b>
<![CDATA[	Abbreviated AM / PM (e.g. A or P)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[tt]]>
				</b>
<![CDATA[	AM / PM (e.g. AM or PM]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[y]]>
				</b>
<![CDATA[	Year, no leading zero (e.g. 2001 would be 1)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yy]]>
				</b>
<![CDATA[	Year, leading zero (e.g. 2001 would be 01)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yyy]]>
				</b>
<![CDATA[	Year (e.g. 2001 would be 001)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yyyy]]>
				</b>
<![CDATA[	Year (e.g. 2001 would be 2001)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[K]]>
				</b>
<![CDATA[	Represents the time zone information of a date and time value (e.g. +05:00)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[z]]>
				</b>
<![CDATA[	With DateTime values, represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. (e.g. +6)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[zz]]>
				</b>
<![CDATA[	As z but with leading zero (e.g. +06)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[zzz]]>
				</b>
<![CDATA[	With DateTime values, represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. (e.g. +06:00)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[f]]>
				</b>
<![CDATA[	Represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ff]]>
				</b>
<![CDATA[	Represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fff]]>
				</b>
<![CDATA[	Represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ffff]]>
				</b>
<![CDATA[	Represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. While it is possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fffff]]>
				</b>
<![CDATA[	Represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. While it is possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ffffff]]>
				</b>
<![CDATA[	Represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. While it is possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fffffff]]>
				</b>
<![CDATA[	Represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. While it is possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[F]]>
				</b>
<![CDATA[	Represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[:]]>
				</b>
<![CDATA[	Represents the time separator defined in the current DateTimeFormatInfo..::.TimeSeparator property. This separator is used to differentiate hours, minutes, and seconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[/]]>
				</b>
<![CDATA[ 	 Represents the date separator defined in the current DateTimeFormatInfo..::.DateSeparator property. This separator is used to differentiate years, months, and days.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA["]]>
				</b>
<![CDATA[ 	 Represents a quoted string (quotation mark). Displays the literal value of any string between two quotation marks ("). Your application should precede each quotation mark with an escape character (\).]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[']]>
				</b>
<![CDATA[	 Represents a quoted string (apostrophe). Displays the literal value of any string between two apostrophe (') characters.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[%c]]>
				</b>
<![CDATA[ 	Represents the result associated with a c custom format specifier, when the custom date and time format string consists solely of that custom format specifier. That is, to use the d, f, F, h, m, s, t, y, z, H, or M custom format specifier by itself, the application should specify %d, %f, %F, %h, %m, %s, %t, %y, %z, %H, or %M. For more information about using a single format specifier, see Using Single Custom Format Specifiers.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetDateFormat("dd-MMM-yy hh:mm:ss tt")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
			<see>
<![CDATA[QuerySetDateFormat]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QueryClear" qi="Clears the SQL query.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Clears any SQL query that may be in memory.  This action can be called to ensure]]>
<![CDATA[
]]>
<![CDATA[        that any NENU query that you build is not building on any previous information.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QueryClear("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query is cleared.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetJobID" qi="Sets the Job ID for the SQL query.">
			<p name="jobid" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        jobid: Job ID.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When building a query, this action sets the job ID that will be selected in the result set.]]>
<![CDATA[
]]>
<![CDATA[        If you wish to match multiple job IDs, use commas to separate values.  An exclamation point]]>
<![CDATA[
]]>
<![CDATA[        can be used to negate the query.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetJobID("010,011")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create a result set that contains batches with job ID of "010" and "011".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetJobID("010")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetJobID("011")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create an empty result set.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetJobID("!011")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create a result set that contains all batches except for the job ID of "011".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetTaskID" qi="Sets the Task ID for the SQL query.">
			<p name="taskid" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        taskid: Task ID.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When building a query, this action sets the task ID that will be selected in the result set.]]>
<![CDATA[
]]>
<![CDATA[        The current task batches selected will match the supplied value.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetTaskID("Verify")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will query all batches for the survey application that are]]>
<![CDATA[
]]>
<![CDATA[          at the verify task.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetTaskID("@B.MyQueryTask")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example uses Smart parameters to retrieve the name of]]>
<![CDATA[
]]>
<![CDATA[          the task to query from a batch level variable called 'MyQueryTask'.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetStatus" qi="Sets the Task status for the SQL query.">
			<p name="status" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        status: The batch status: aborted, cancelled, finished, hold, job done, pending, running.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified status.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetStatus("finished")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetPriority" qi="Sets the Priority for the SQL query.">
			<p name="priority" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        priority: Batch Priority. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified priority.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetPriority("1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetBranch" qi="Sets the minimum number of children for the SQL query.">
			<p name="children" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        children: The minimum number of children for the batch. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that have at least the minimum number of specified children.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetBranch("3")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetOperator" qi="Sets the operator for the SQL query.">
			<p name="operator" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        operator: The operator ID.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified operator ID.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetOperator("Admin")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetStation" qi="Sets the station for the SQL query.">
			<p name="station" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        station: The station ID.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified station.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetStation("1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetDateRange" qi="Sets Date range for SQL query.">
			<p name="start" type="string">
			</p>
			<p name="end" type="string">
			</p>
			<p name="queryAgeStart" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        start: Date Range Start.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        end: Date Range End.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        queryAgeStart: True will use the batch start date.  False will use the batch end date. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified priority.]]>
<![CDATA[
]]>
<![CDATA[        If queryAgeStart is set to True, the query will use the batch start date, qs_start.  If queryAgeStart]]>
<![CDATA[
]]>
<![CDATA[        is set to False, the query will use the batch end date, qu_done.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetDateRange("03/16/2010","05/26/2010","True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will select all of the batches that have been created ]]>
<![CDATA[
]]>
<![CDATA[          between the two specified dates.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetDateRange("03/16/2010","@DATE(mm/dd/yyyy)","True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example uses a Smart parameter to obtain the current date.  The query will]]>
<![CDATA[
]]>
<![CDATA[          select all batches that have been created between 03/16/2010 and the current date.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetAge" qi="Selects batches based on age using a date or number of seconds.">
			<p name="age" type="string">
			</p>
			<p name="queryAgeStart" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        age: All dates prior or within this date will be selected.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        queryAgeStart: If true, age will use the start time of the batch.  If false, age will use the end time of the batch. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Builds a query that selects batches based on the age of a batch.  The age can be specified using a date or in seconds.]]>
<![CDATA[
]]>
<![CDATA[        The queryAgeStart parameter determines if the age is based on the start of the batch, the qs_start column, ]]>
<![CDATA[
]]>
<![CDATA[        or based on the end of the batch, the qu_done column.]]>
<![CDATA[
]]>
<![CDATA[        If a date is specified, all batches will be selected based on the date. ]]>
<![CDATA[
]]>
<![CDATA[        If a number is specified, all batches will be selected based on the number of seconds.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        To control the age range use the exclamation point '!'.   When the exclamation point is not specified,]]>
<![CDATA[
]]>
<![CDATA[        the age between now and the specified value will be selected.  When the exclamation point is specified,]]>
<![CDATA[
]]>
<![CDATA[        the ages that are older than the value specified will be selected.         ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetAge("300","True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will select all batches started within last 300 seconds.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetAge("!300","true")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will select all batches started prior to 300 seconds ago.]]>
<![CDATA[
]]>
<![CDATA[          Use the same pattern when using dates.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetGeneric" qi="Builds an SQL query using the provided column name and value.">
			<p name="column" type="string">
			</p>
			<p name="value" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        column: Column in the database table to query.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        value: Value to match within the specified column.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Allows building of a query where the column and value of the tmbatch, queue or qstats table are explicitly specified.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Any wild card specified in the "value" parameter would need to be appropriate for your target database.]]>
<![CDATA[
]]>
<![CDATA[        The column value is not validated until the query is run using ProcessRunSqlQuery.        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetGeneric("pb_userid", "admin")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetBatchRange" qi="Sets range of batches for SQL query.">
			<p name="start" type="string">
			</p>
			<p name="end" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        start: BatchID of the first batch in the range. Default value 00000000.000". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        end: BatchID of the last batch in the range. Default value zzzzzzzz.zzz". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Allows selecting batch range based on the BatchID.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetBatchRange("20110059.001","20110059.010")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[InjectBatches("20110059.001")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[InjectBatches]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessInjectBatches" qi="Injects the data from master batch to all batches selected and updates DB.">
			<p name="masterBatchID" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        masterBatchID: Master batch to copy data from. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Allows creating large set of batches at some predefined  state.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetBatchRange("20110059.001","20110059.010")]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[InjectBatches("20110059.001")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if all the all the batches were successfully set.  ]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[QuerySetBatchRange]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="ocr_a" v="8.1.0.62">
	<i ref="rrunner">
	</i>
	<i ref="recog_shared">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' ocr_a.rrx - OCR/A Abbyy Recognition Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Updated 09/07/07 ]]>
<![CDATA[
]]>
<![CDATA['		7.2.2 SetFastMode, RecognizeToPDF, SetAutoRotation are implemented.]]>
<![CDATA[
]]>
<![CDATA['		7.1.4 improved formatting]]>
<![CDATA[
]]>
<![CDATA['		7.1.3 compatible with Abbyy 8.1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Updated 01/09/2009 JMartinez ]]>
<![CDATA[
]]>
<![CDATA['   7.5.1 '- Renamed ocrA.rrx to ocr_a.rrx]]>
<![CDATA[
]]>
<![CDATA['          - Solves issue with out-of-memory error when processing converting large documents to PDF:]]>
<![CDATA[
]]>
<![CDATA['          a) instead of keeping the ABBYY "layout" files in memory, they are now created and saved in a subfolder of the 'batch folder, named "layout".  This folder is automatically deleted after the PDF conversion, unless the variable '"abbyy_deletetmp" is set to "1"]]>
<![CDATA[
]]>
<![CDATA['          b) PDF conversion code has been modified to use the appropriate ABBYY API objects to improve memory 'efficiency]]>
<![CDATA[
]]>
<![CDATA['          - Corrected logging of action as "scansoft recognition", now shows "ABBYY recognition"]]>
<![CDATA[
]]>
<![CDATA['          - PDF quality can now be specified by setting the "abbyy_quality" variable to a value between 1 and 100. default is '100]]>
<![CDATA[
]]>
<![CDATA['          - Improved logging in RecognizeDocToPDF action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Updated 01/19/2009 JMartinez ]]>
<![CDATA[
]]>
<![CDATA['   7.5.2  - Now references recog_shared.rrx  ]]>
<![CDATA[
]]>
<![CDATA['          - Improved overall action logging]]>
<![CDATA[
]]>
<![CDATA['          - Full page recognition automatically normalizes the CCO (unless the "CCONormalization_OFF" action is called before)]]>
<![CDATA[
]]>
<![CDATA['          - Action names are now standardized. The old actions are now private for backwards compatibility]]>
<![CDATA[
]]>
<![CDATA['          - Fixes issue where running recognition on a field without a zone, or a field where the zone is outside the boundaries of the page, would cause a batch to abort.]]>
<![CDATA[
]]>
<![CDATA['          - The following actions have been renamed (old action names still exist, and are "private" for backwards compatibility)]]>
<![CDATA[
]]>
<![CDATA['           OCRA_Recog -> RecognizeFieldOCR_A]]>
<![CDATA[
]]>
<![CDATA['           OCRA_RecogVote ->RecognizeFieldVoteOCR_A]]>
<![CDATA[
]]>
<![CDATA['           OCRA_RecogPage -> RecognizePageOCR_A]]>
<![CDATA[
]]>
<![CDATA['           OCRA_RecogZones-> RecognizePageFieldsOCR_A]]>
<![CDATA[
]]>
<![CDATA['           OCRA_RecognizeToPDF -> RecognizeToPDFOCR_A]]>
<![CDATA[
]]>
<![CDATA['           OCRA_SetFastMode -> SetFastModeOCR_A]]>
<![CDATA[
]]>
<![CDATA['           OCRA_SetAutoRotation -> SetAutoRotationOCR_A]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Updated 01/27/2009 JMartinez ]]>
<![CDATA[
]]>
<![CDATA['   7.5.3  - RecognizeToPDFOCR_A action does not abort the batch when the action is called at the batch level. Instead, it logs that it needs to be called at the correct level and returns false.]]>
<![CDATA[
]]>
<![CDATA['          - Actions RecognizeFieldVoteOCR_A and RecognizeFieldOCR_A now check for valid field positions before attempting recognition.]]>
<![CDATA[
]]>
<![CDATA['          - Added help text for public actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Updated 01/28/2009 JMartinez ]]>
<![CDATA[
]]>
<![CDATA['   7.5.4  - Actions are now looking for the correct flag to skip recongition]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.5"]]>
<![CDATA[
]]>
<![CDATA['Updated 01/29/2009 JMartinez ]]>
<![CDATA[
]]>
<![CDATA['           - Fixes bug introduced in the last version (7.5.4)]]>
<![CDATA[
]]>
<![CDATA['           - Now logs RRX version]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.6"]]>
<![CDATA[
]]>
<![CDATA['Updated 02/02/2009 JMartinez ]]>
<![CDATA[
]]>
<![CDATA['           - Fixes bug in page level recognition that would cause a batch to abort if a CCO  file did not exist prior to the action (RecognizePageOCR_A) call]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.7"]]>
<![CDATA[
]]>
<![CDATA['Updated 02/04/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['            - Full page recognition now pays attention to the varaible set by the SetFingerprintRecogPriority]]>
<![CDATA[
]]>
<![CDATA['            - CCOcreation algorithm is now consistent with the algoruthms in the other recognition engines]]>
<![CDATA[
]]>
<![CDATA['            - Added private action RecognizeToFileOCR_A]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.8"]]>
<![CDATA[
]]>
<![CDATA['Updated 03/04/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['            - Action RecognizeFieldVoteOCR_A no longer aborts when the field postions are outside the image margin. ]]>
<![CDATA[
]]>
<![CDATA['              Instead of aborting the batch, this error is logged.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.9"]]>
<![CDATA[
]]>
<![CDATA['Updated 04/08/2009 Rferin]]>
<![CDATA[
]]>
<![CDATA['  - 13844 Updated SetFastModeOCR_A help to list available parameters and recommend to disable it on field ]]>
<![CDATA[
]]>
<![CDATA['    recognition.  Fixed incorrect examples and minor formatting issues for all actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1"]]>
<![CDATA[
]]>
<![CDATA['Updated 04/22/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  - 25492 Full page OCR no longer rotates images automatically. New action SetAutoRotationOCR_A must be called with parameter]]>
<![CDATA[
]]>
<![CDATA['    "true" for automatic rotation.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.2"]]>
<![CDATA[
]]>
<![CDATA['Updated 06/04/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  - 13049  Now supports reading rotated fields. The default rotation setting is "no rotation" and can be changed via DStudio.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.3"]]>
<![CDATA[
]]>
<![CDATA['Updated 06/04/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  - Cleaned up logging]]>
<![CDATA[
]]>
<![CDATA['  - Now each call to full page OCR releases the image at the end of the call (20556).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.4" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/11/2009 RFERIN]]>
<![CDATA[
]]>
<![CDATA['	  19745 Added G tags to make the XML format more compliant and help with editing.  Minor help ]]>
<![CDATA[
]]>
<![CDATA['   formatting fixes and modified some help text.  Requires the new buildvbs.rls 1.0.2.2.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.5"]]>
<![CDATA[
]]>
<![CDATA['  Updated 6/12/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated to look for ABBYY engine files in OCRA9 folder ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.6" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/15/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   Added support for Barcode field recognition]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.7" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/16/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   Added new action RecognizeBarcodeOCR_A]]>
<![CDATA[
]]>
<![CDATA['   - Can be called at the field and page levels]]>
<![CDATA[
]]>
<![CDATA['   - if called at the page level, stores the barcode in page variable BarcodeX where X is the index of the barcode(1-based). ]]>
<![CDATA[
]]>
<![CDATA['   - if called at the field level, stores the barcode in the field text]]>
<![CDATA[
]]>
<![CDATA['   - Barcode recognition, at both field and page levels, now stores the following data per barcode read:]]>
<![CDATA[
]]>
<![CDATA['   -     Barcode type (variable BarcodeXType) , Orientation (variable BarcodeXOrientation), Position (variable BarcodeXPosition),]]>
<![CDATA[
]]>
<![CDATA['         and Text (variable BarcodeXType) - where X is the index of the barcode (1-based). ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.8" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/16/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   Added support for OMR fields]]>
<![CDATA[
]]>
<![CDATA['   Added new action EnableEngineLogsOCR_A. This action is to be used for debuggin purposes. It writes a log file (engine.log) to the batch]]>
<![CDATA[
]]>
<![CDATA['   folder during recognition]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.9" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/17/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   Added new action RotateImageOCR_A used to automatically rotate images to the upside up position.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.10" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/17/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Modified RecognizeToPDFOCR_A action to be compatible with the ABBYY Engine 9.x ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.11" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/19/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added new action "ReleaseEngineOCR_A" which releases the recognition engine. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/23/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' 22141 Field level recognition actions now check for the flag to remove spaces post recognition. If this flag is set]]>
<![CDATA[
]]>
<![CDATA['       spaces are removed.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/30/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added new action OCRA_ConvertImage2BW which can be used to convert an image (Color or Grayscale) to BW]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/17/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes issue where running full page OCR would corrupt the image file. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/04/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Removed duplicate reference to action SetAutoRotationOCR_A]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/22/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Action RecognizeToPDFOCR_A now supports conversion to PDF/A]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/24/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Recognition actions now load the recognition engine if it is not loaded at the time of the call. Solves issue]]>
<![CDATA[
]]>
<![CDATA[' where calling ReleaseEngineOCR_A would cause post recognition attempts to fail because the engine is not loaded.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/25/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes bug in color to BW conversion action where the resulting image's bit depth would remain 24 (color) instead of 1 (BW).  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/03/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes a bug in the action action OCRA_ConvertImage2BW that would cause a sharing violation error when other actions attempted to use the images processed by OCRA_ConvertImage2BW.]]>
<![CDATA[
]]>
<![CDATA[' Action OCRA_ConvertImage2BW now takes a parameter which is the file extension that the action is to assign to the backup of the original Image file.]]>
<![CDATA[
]]>
<![CDATA[' Updated the documentation of the OCRA_ConvertImage2BW action to describe the new parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/9/2009 NSK]]>
<![CDATA[
]]>
<![CDATA[' SPR 26650 Raised character confidence by approx 1 to better match other engines]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/14/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' SPR 24337 RecognizeFieldOCR_A now calls helper function to initialize the engine before calling recognition.]]>
<![CDATA[
]]>
<![CDATA['           OMR Recognition now reads the "MultiPunch" dco variable and sets the OMR field properties accordingly before recognition.]]>
<![CDATA[
]]>
<![CDATA['           OMR Checkbox type property is now exposed through the runtime/setup dco variable "OMRType". The following]]>
<![CDATA[
]]>
<![CDATA['           values are valid for this variable:]]>
<![CDATA[
]]>
<![CDATA['           0 - Checkmarks in squares       ]]>
<![CDATA[
]]>
<![CDATA['           1 - Checkmarks against an empty background (default)            ]]>
<![CDATA[
]]>
<![CDATA['           2 - The checkmark has a non-standard form  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.22"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/16/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes syntax error introduced un previous version ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.23"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/17/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' SPR 24337 Enforces MultiPunch = No setting. ]]>
<![CDATA[
]]>
<![CDATA['           Fixes a bug in the interpretation of the OMRType variable]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.24"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/17/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' SPR 24338 Barcode recognition automatically removes start and end asterisks when y_bNoAtisk is NOT set to 1.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.25"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/18/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' SPR 24338 Fixes abort when setting the barcode orientation or type at the page level.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.26"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/18/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' SPR 24338 Fixes abort when setting the barcode orientation or type at the page level.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.27"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/25/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' SPR 26650 readjusted character confidence map again to better match other engines]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.28"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/30/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' SPR 24592 now saves rotated images when SetAutoRotationOCR_A("true") is used]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.29"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/02/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' SPR 24647 Actions RecognizeFieldOCR_A and RecognizePageFieldsOCR_A no longer abort when the field postions are outside the image margin. no longer aborts when the field postions are outside the image margin. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.30"]]>
<![CDATA[
]]>
<![CDATA[' Updated 1/28/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated to contain all fixes and enhancements included in v7.5.36 (TM7.6)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.31"]]>
<![CDATA[
]]>
<![CDATA['Updated 02/03/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Solves issue with JPG image to PDF conversion. Solves issue where batches would abort when converting a images of type other than TIF to PDF.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.32"]]>
<![CDATA[
]]>
<![CDATA['Updated 02/04/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Solves abort that happens in the conversion to PDF called at the document level. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.33"]]>
<![CDATA[
]]>
<![CDATA['Updated 02/05/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' 26980 Solves issue where full page recognition of an image containing OCR_A text would ignore such text. Now OCR_A text results are returned. ]]>
<![CDATA[
]]>
<![CDATA[' Solves issue where field level recognition would ignor OCR_A text even with the property "TextType" set to OCR_A. Now OCR_A text is properly read with this setting.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.34"]]>
<![CDATA[
]]>
<![CDATA['Updated 04/07/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['27272 - Page level recognition now uses the ABBYY engine setting "CalculateExactConfidence" to obtain more accurate confidence results. Does not apply to field level recog.]]>
<![CDATA[
]]>
<![CDATA['      - Page and Field level recognition now logs confidence information (including IsSuspicious flag for field objects only) if the runtime/setup variable "DebugConfData" is set to 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.35"]]>
<![CDATA[
]]>
<![CDATA['Updated 04/07/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['27272 - Field level recognition now uses the ABBYY engine setting "CalculateExactConfidence" to obtain more accurate confidence results.     ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.36"]]>
<![CDATA[
]]>
<![CDATA['Updated 05/12/10 RFerin]]>
<![CDATA[
]]>
<![CDATA['24570 - Updated Datacap Studio help text for SetAutoRotationOCR_A, SetFastModeOCR_A and RecognizeToPDFOCR_A.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.37"]]>
<![CDATA[
]]>
<![CDATA['Updated 06/29/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['27272 - The confidence mapping algorithm has been updated to calculate confidence using the ABBYY engine's IsSuspicious flag.]]>
<![CDATA[
]]>
<![CDATA['      - The RecognizePageOCR_A action now uses ABBYY's AnalyzeAndRecognizePage function instead of RecognizeImageAsPlainText, in order to obtain additional]]>
<![CDATA[
]]>
<![CDATA['        recognition statistics, including the IsSuspicious flag mentioned above. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.38"]]>
<![CDATA[
]]>
<![CDATA['Updated 07/01/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['27272 - The confidence mapping formula has been updated as follows:]]>
<![CDATA[
]]>
<![CDATA['        If the character is marked by the "suspicious" flag, then Datacap conf is set to 1.]]>
<![CDATA[
]]>
<![CDATA['        Otherwise, the Datacap confidence is calculated using the formula MAX(10, M * (Abbyy confiodence + C))        ]]>
<![CDATA[
]]>
<![CDATA['        Where M is 0.1 and C is 50 by default. ]]>
<![CDATA[
]]>
<![CDATA['        The variables M and C can be changed by using calling the action SetConfCalculationParams(M,C)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.39"]]>
<![CDATA[
]]>
<![CDATA['Updated 07/28/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['27272 - Updated full page recognition action to properly iterate through the TableCell block returned by the engine. These type of text blocks have a special structure (contain subblocks). ]]>
<![CDATA[
]]>
<![CDATA['       Solves the issue where text inside table cells would not show in the recognition results.]]>
<![CDATA[
]]>
<![CDATA['     ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.40"]]>
<![CDATA[
]]>
<![CDATA['Updated 08/06/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['27272 - The confidence mapping formula has been updated as follows:]]>
<![CDATA[
]]>
<![CDATA['        If the character is marked by the "suspicious" flag, then Datacap conf is set to 1.]]>
<![CDATA[
]]>
<![CDATA['        Otherwise, the Datacap confidence is calculated using the formula MAX(10, (M/100) * (Abbyy confiodence + C))        ]]>
<![CDATA[
]]>
<![CDATA['        Where M is 10 and C is 50 by default. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.41"]]>
<![CDATA[
]]>
<![CDATA['Updated 08/16/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['27272-  The variable C default value in the confidence formula MAX(10, (M/100) * (Abbyy confiodence + C)) has been increased from 50 to 60.]]>
<![CDATA[
]]>
<![CDATA['        Tests have shown that setting C to 60 results in less low confidence characters and does not cause substitution problems.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.42"]]>
<![CDATA[
]]>
<![CDATA['Updated 08/17/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['        Commented out extra logging that was added for debugging purposes only.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.43"]]>
<![CDATA[
]]>
<![CDATA['Updated 12/01/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['        RecognizeToPDFOCR_A: ExportType parameter is set based on the type of export (PDF Normal or PDFA)]]>
<![CDATA[
]]>
<![CDATA['        Exposed a setting to generate PDFA1A documents. This feature can be enabled by setting the page level variable "y_pdfA1A" to "1",]]>
<![CDATA[
]]>
<![CDATA['        (requires that the page variable "y_pdfA" is set to "1" for PDFA for PDFA creation).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.44"]]>
<![CDATA[
]]>
<![CDATA['Updated 12/20/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['        Solves issue where the recognition language setting is ignored and therefore always defaulted to English.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.45"]]>
<![CDATA[
]]>
<![CDATA['Updated 12/21/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['       Fixed the functionality of setting the variable DetectSmallCaps to 0. When set to 0, this causes the engine to avoid mistakenly reading an upper]]>
<![CDATA[
]]>
<![CDATA['       case character as lower case. When this problem is observed in the recognition rsults, the DetectSmallCaps variable has to be set to 0]]>
<![CDATA[
]]>
<![CDATA['       to avoid it. When the variable is set to zero, overall recognition time is affected by an increase of a fraction of a second.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.46"]]>
<![CDATA[
]]>
<![CDATA['Updated 01/07/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA['       OCRA_ConvertImage2BW now forces the modified image compression to TIFF G4. Solves issue where image compression would not always be consistent when ]]>
<![CDATA[
]]>
<![CDATA['       saving the black and white image.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.47"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/07/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.48"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/17/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Solves issue where recognition of Barcode and OMR field types would return empty results because of an attempt to set an empty text field type's language property ]]>
<![CDATA[
]]>
<![CDATA[' - Field level recognition now checks the field type before setting language settings. It skips Barcode and OMR Fields since the language property are irrelevant ]]>
<![CDATA[
]]>
<![CDATA[' these field types. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.49"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/07/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Solves the issue where the logic that passes the "Text Type" setting to the engine was getting skipped so it would always default to "Normal" regardless of the user setting.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.50"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/18/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added IBM Copyright notice.]]>
<![CDATA[
]]>
<![CDATA[' Characters returned by the engine are now converted to their Unicode representation (instead of ASCCII) prior to inserting them to the DCO or CCO.]]>
<![CDATA[
]]>
<![CDATA[' Now uses Datacap.Libraries.Abbyy wrapper for recognition and TIFF to PDF conversion. dcocra.dll and dcAbbyyHlpr.dll are now obsolete.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.51"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/18/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Replaced instances of CHR with CHRW and instances of ASC with ASCW for Unicode support.]]>
<![CDATA[
]]>
<![CDATA[' Removed filtering of character codes outside the range of 0-255 returned by the engine and inserted into the CCO.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.52"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/13/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Now compatible with FREngine 10 and above. Not backwards compatible with FREngine 9.x and earlier engine files.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.53"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/05/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Solves issue where the position of individual OMR character (or box) positions would npt be saved after OMR recognition is performed.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.54"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/13/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Now pays attention to the locale variable "hr_locale". If this variable is set, the actions try to map the locale value to the corresponding engine language setting. If there is not a ]]>
<![CDATA[
]]>
<![CDATA[' mapping between the engine setting and Windows locale, the default English is used. If the recognition language has been previously set (variable "y_lg" is populated), the]]>
<![CDATA[
]]>
<![CDATA[' latter takes precedence, unless the variable "dco_uselocale" is set to "1" in which case the locale value will take precedence.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.55"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/13/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixed syntax error introduced in version 8.1.0.54]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.56"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/09/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Renamed "Text" variable which conflicted with the "Text" function of the Export.rrx library. Solves issue where loading actions from Export.rrx before ocr_a.rrx would result in an abort. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.57"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/21/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Solves issue where the default character confidence value of 1 would always be applied to recognized characters. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.58"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/09/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Explicitly releases Abbyy objects before releasing the engine object. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.59"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/25/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Solves issue introduced in v8.1.0.57 where LineBreak and Paragraph break characters would be inserted into the CCO as regular characters. Now inserted in CCO as new like before. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.60"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/15/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Bug fix: "y_pdfA1A" flag, when set to 1, now generates the correct PDFA1A format. Default PDFA format is A1A.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.61"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/25/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' RecognizeToPDFOCR_A always returns true unless called at a level other than the Page or Document levels.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.62"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/05/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Rotation (during recognition or via RotateImage action)- images with CCITT T4 compression get saved with a compression CCITT T.6 since ABBYY does not support writing out to CCITT T.4.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Global entries ---------------------------------------------------->]]>
<![CDATA[
]]>
<![CDATA[Dim oABBYYRecognition]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' LOG RRX VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("OCR_A " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim m_LowConfThresh]]>
<![CDATA[
]]>
<![CDATA[Dim m_LowConfAdjust ]]>
<![CDATA[
]]>
<![CDATA[Dim m_NormalConfAdjust]]>
<![CDATA[
]]>
<![CDATA[Dim m_DebugConfVar ]]>
<![CDATA[
]]>
<![CDATA[Dim m_LowConfThreshVar ]]>
<![CDATA[
]]>
<![CDATA[Dim m_LowConfAdjustVar]]>
<![CDATA[
]]>
<![CDATA[Dim m_NormalConfAdjustVar]]>
<![CDATA[
]]>
<![CDATA[Dim m_confC]]>
<![CDATA[
]]>
<![CDATA[Dim m_ConfM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[m_confC = 60]]>
<![CDATA[
]]>
<![CDATA[m_confM = 10]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[m_LowConfThresh = 50]]>
<![CDATA[
]]>
<![CDATA[m_LowConfAdjust = 60]]>
<![CDATA[
]]>
<![CDATA[m_NormalConfAdjust = 20]]>
<![CDATA[
]]>
<![CDATA[m_DebugConfVar = "DebugConfData"]]>
<![CDATA[
]]>
<![CDATA[m_LowConfThreshVar = "LowConfThreshold"]]>
<![CDATA[
]]>
<![CDATA[m_LowConfAdjustVar = "LowConfAdjust"]]>
<![CDATA[
]]>
<![CDATA[m_NormalConfAdjustVar = "NormalConfAdjust"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['___________________________________________________________________________________________________]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['	CABBYYRecognition]]>
<![CDATA[
]]>
<![CDATA['___________________________________________________________________________________________________]]>
<![CDATA[
]]>
<![CDATA[Class CABBYYRecognition]]>
<![CDATA[
]]>
<![CDATA[	Public m_FullPageRecogArea]]>
<![CDATA[
]]>
<![CDATA[	Public m_bRecogCreateCCO]]>
<![CDATA[
]]>
<![CDATA[        Public m_oPageProcessingParams]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Private m_oFRELoader]]>
<![CDATA[
]]>
<![CDATA[	Private Engine]]>
<![CDATA[
]]>
<![CDATA[	Private m_oImageDoc]]>
<![CDATA[
]]>
<![CDATA[	Private m_oLayout]]>
<![CDATA[
]]>
<![CDATA[	Private m_PrepareImageMode]]>
<![CDATA[
]]>
<![CDATA[	Private m_bABBYYEngineLogs]]>
<![CDATA[
]]>
<![CDATA[	Private m_strCurrentImage]]>
<![CDATA[
]]>
<![CDATA[  Private m_oDocInfo]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Recognition consts]]>
<![CDATA[
]]>
<![CDATA[	Private REJECTED_CHAR]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Constraction & Destruction -----------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Private Sub Class_Initialize	' Initialize event.]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Initializing Object Datacap.Libraries.Abbyy.EngineWrapper"]]>
<![CDATA[
]]>
<![CDATA[		Set m_oFRELoader = CreateObject("Datacap.Libraries.Abbyy.EngineWrapper" )]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Object Datacap.Libraries.Abbyy.EngineWrapper successfully created"]]>
<![CDATA[
]]>
<![CDATA[	  m_bABBYYEngineLogs = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Set Engine = m_oFRELoader.Engine]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If m_bABBYYEngineLogs Then]]>
<![CDATA[
]]>
<![CDATA[        Engine.StartLogging Pilot.BatchDir & "\engine.log" , true]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Set m_oLayout = Engine.CreateLayout()]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Set m_PrepareImageMode = Engine.CreatePrepareImageMode]]>
<![CDATA[
]]>
<![CDATA[		m_PrepareImageMode.CorrectSkewMode = 0]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Set m_oPageProcessingParams = Engine.CreatePageProcessingParams()]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		REJECTED_CHAR = 126]]>
<![CDATA[
]]>
<![CDATA[		m_bRecogCreateCCO = False]]>
<![CDATA[
]]>
<![CDATA[		m_strCurrentImage = ""]]>
<![CDATA[
]]>
<![CDATA[		m_FullPageRecogArea = 1]]>
<![CDATA[
]]>
<![CDATA[	End Sub]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Private Sub Class_Terminate		' Terminate event.]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    Set Engine = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set m_PrepareImageMode = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set m_oPageProcessingParams = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set m_oImageDoc = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set m_oLayout = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set m_oDocInfo = Nothing]]>
<![CDATA[
]]>
<![CDATA[		'm_oFRELoader.Unload]]>
<![CDATA[
]]>
<![CDATA[    m_oFRELoader.Dispose]]>
<![CDATA[
]]>
<![CDATA[		Set m_oFRELoader = Nothing]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	End Sub]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Private methods ----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Private Function GetConfidence(nConfidence,bIsSuspicious)]]>
<![CDATA[
]]>
<![CDATA[		Dim tConf]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If bIsSuspicious Then]]>
<![CDATA[
]]>
<![CDATA[      tConf = nConfidence * CDbl(m_confM/100)]]>
<![CDATA[
]]>
<![CDATA[      If tConf > 7 Then tConf = 7 'suspicious fields should not have confidence greater than 7]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      tConf = CDbl(m_confM/100) * (nConfidence + m_confC)]]>
<![CDATA[
]]>
<![CDATA[      If tConf > 10 Then tConf = 10]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		GetConfidence = CInt(tConf)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Private Sub SetZone(oDCO)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    m_oLayout.Blocks.RemoveAll]]>
<![CDATA[
]]>
<![CDATA[		'm_oLayout.Blocks.Add Block]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Dim nLeft, nTop, nRight, nBottom, nWidth, nHeight]]>
<![CDATA[
]]>
<![CDATA[    Dim Checkmark]]>
<![CDATA[
]]>
<![CDATA[    Dim DCOChild]]>
<![CDATA[
]]>
<![CDATA[    Dim Region]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Dim Block, str]]>
<![CDATA[
]]>
<![CDATA[		str = ""]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    nWidth = m_oImageDoc.BlackWhiteImage.Width]]>
<![CDATA[
]]>
<![CDATA[    nHeight = m_oImageDoc.BlackWhiteImage.Height]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		If(oDCO.ObjectType() = 2)	Then ]]>
<![CDATA[
]]>
<![CDATA[			  nLeft = 0]]>
<![CDATA[
]]>
<![CDATA[			  nTop = 0]]>
<![CDATA[
]]>
<![CDATA[			  nRight = nWidth]]>
<![CDATA[
]]>
<![CDATA[			  nBottom = nHeight]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		If (oDCO.ObjectType() = 3) Then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      retn = oDCO.GetPosition( nLeft, nTop, nRight, nBottom)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If nLeft < 0 Then nLeft = 0]]>
<![CDATA[
]]>
<![CDATA[      If nTop < 0 Then nTop = 0]]>
<![CDATA[
]]>
<![CDATA[      If nRight < 0 Then nRight = 0]]>
<![CDATA[
]]>
<![CDATA[      If nBottom < 0 Then nBottom = 0]]>
<![CDATA[
]]>
<![CDATA[      If nLeft > nWidth Then nLeft = nWidth]]>
<![CDATA[
]]>
<![CDATA[      If nTop > nHeight Then nTop = nHeight]]>
<![CDATA[
]]>
<![CDATA[      If nRight > nWidth Then nRight = nWidth]]>
<![CDATA[
]]>
<![CDATA[      If nBottom > nHeight Then nBottom = nHeight]]>
<![CDATA[
]]>
<![CDATA[      If nLeft = nRight Or nBottom = nTop Then Exit Sub]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    End If      ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    Set Region = Engine.CreateRegion]]>
<![CDATA[
]]>
<![CDATA[    Region.AddRect nLeft, nTop, nRight, nBottom]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    If oDCO.Variable("RecogType") = "4" Then 'OMR/Checkbox]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "OMR field found."]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Set CheckmarkGroup = m_oLayout.AddBlock(5,Region)  '5 - Checkmark Group]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If "1" = oDCO.Variable("MultiPunch") Then]]>
<![CDATA[
]]>
<![CDATA[          CheckmarkGroup.MaximumCheckedInGroup = 0]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Multiple checked items are allowed."]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[          'CheckmarkGroup.MaximumCheckedInGroup = 1]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Only one checked item is allowed."]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If "" <> oDCO.Variable("MinimumCheckedOMR") Then]]>
<![CDATA[
]]>
<![CDATA[          Writelog "A minimum number of checked checkmark is set: " &  oDCO.Variable("MinimumCheckedOMR")]]>
<![CDATA[
]]>
<![CDATA[          CheckmarkGroup.MinimumCheckedInGroup = CInt(oDCO.Variable("MinimumCheckedOMR"))]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Adding OMR subfields..."]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        For i = 0 To oDCO.NumOfChildren-1]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            Writelog "Processing subfield " & i]]>
<![CDATA[
]]>
<![CDATA[            Set DCOChild = oDCO.GetChild(i)  ]]>
<![CDATA[
]]>
<![CDATA[            retn = DCOChild.GetPosition(nLeft, nTop, nRight, nBottom)]]>
<![CDATA[
]]>
<![CDATA[            Set Region = Engine.CreateRegion]]>
<![CDATA[
]]>
<![CDATA[            Region.AddRect nLeft, nTop, nRight, nBottom]]>
<![CDATA[
]]>
<![CDATA[            Set Checkmark = CheckmarkGroup.AddCheckMark(Region) '5 Checkmark]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            Writelog "Checkmark " & i & " Position" & nLeft & "," &  nTop & "," &  nRight & "," &  nBottom]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If nLeft < 0 Then nLeft = 0]]>
<![CDATA[
]]>
<![CDATA[            If nTop < 0 Then nTop = 0]]>
<![CDATA[
]]>
<![CDATA[            If nRight < 0 Then nRight = 0]]>
<![CDATA[
]]>
<![CDATA[            If nBottom < 0 Then nBottom = 0]]>
<![CDATA[
]]>
<![CDATA[            If nLeft > nWidth Then nLeft = nWidth]]>
<![CDATA[
]]>
<![CDATA[            If nTop > nHeight Then nTop = nHeight]]>
<![CDATA[
]]>
<![CDATA[            If nRight > nWidth Then nRight = nWidth]]>
<![CDATA[
]]>
<![CDATA[            If nBottom > nHeight Then nBottom = nHeight]]>
<![CDATA[
]]>
<![CDATA[            If nLeft = nRight Or nBottom = nTop Then Exit Sub]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            Writelog "Checkmark " & i & " Position" & nLeft & "," &  nTop & "," &  nRight & "," &  nBottom]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If "0" = oDCO.Variable("OMRType") Then]]>
<![CDATA[
]]>
<![CDATA[              Checkmark.CheckmarkType = 0 'Checkmarks in squares.]]>
<![CDATA[
]]>
<![CDATA[              Writelog "OMR type is set to Squares"]]>
<![CDATA[
]]>
<![CDATA[            ElseIf "2" = oDCO.Variable("OMRType") Then]]>
<![CDATA[
]]>
<![CDATA[              Writelog "OMR type is set to a non-standard form"]]>
<![CDATA[
]]>
<![CDATA[              Checkmark.CheckmarkType = 2 'The checkmark has a non-standard form. ]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[              Writelog "OMR type is set to empty background"]]>
<![CDATA[
]]>
<![CDATA[              Checkmark.CheckmarkType = 1 'Checkmarks against an empty background]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Next ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    ElseIf oDCO.Variable("y_fType") = "3" Then 'Barcode]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[        'writelog "debug Found barcode field, creating block..."]]>
<![CDATA[
]]>
<![CDATA[        Dim BarcodeBlock]]>
<![CDATA[
]]>
<![CDATA[        Set BarcodeBlock = m_oLayout.AddBlock(3,Region)  '3 - Barcode]]>
<![CDATA[
]]>
<![CDATA[        'writelog "debug Created"]]>
<![CDATA[
]]>
<![CDATA[        '0 BT_Unknown Denotes unknown type of barcode. ]]>
<![CDATA[
]]>
<![CDATA[        '1 BT_Code39 Barcode in "Code 39" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '2 BT_Interleaved25 Barcode in "Interleaved 2 of 5" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '3 BT_EAN13 Barcode in "EAN 13" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '4 BT_Code128 Barcode in "Code 128" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '5 BT_EAN8 Barcode in "EAN 8" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '6 BT_PDF417 Barcode in "PDF417" standard.  ]]>
<![CDATA[
]]>
<![CDATA[        '7 BT_Codabar Barcode in "Codabar" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '8 BT_UPCE Barcode in "UPC-E" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '9 BT_Industrial25 Barcode in "Industrial 2 of 5" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '10 BT_IATA25 Barcode in "IATA 2 of 5" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '11 BT_Matrix25 Barcode in "Matrix 2 of 5" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '12 BT_Code93 Barcode in "Code 93" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '13 BT_PostNet Barcode in "PostNet" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '14 BT_UCC128 Barcode in "UCC-128" standard. ]]>
<![CDATA[
]]>
<![CDATA[        '15 BT_Patch Barcode in "Patch" standard. The barcode of type Patch can be automatically detected during analysis only if the IBarcodeParams::Type property is set to 'BT_Patch. ]]>
<![CDATA[
]]>
<![CDATA[        '16 BT_Aztec Barcode in "Aztec" standard. The barcode of type Aztec can be automatically detected during analysis only if the IBarcodeParams::Type property is set to 'BT_Aztec. ]]>
<![CDATA[
]]>
<![CDATA[        '17 BT_Autodetect Forces ABBYY FineReader Engine to automatically detect the barcode type during recognition.]]>
<![CDATA[
]]>
<![CDATA[        'Note: The Patch and Aztec barcode types are not detected automatically. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If "" <> oDCO.Variable("y_bType") Then]]>
<![CDATA[
]]>
<![CDATA[          BarcodeBlock.BarcodeParams.Type = CInt(oDCO.Variable("y_bType"))]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        '0 BO_Unknown Denotes unknown type of barcode orientation. It may be used as the return value if ABBYY FineReader Engine has failed to detect barcode orientation. ]]>
<![CDATA[
]]>
<![CDATA[        '1 BO_Left_To_Right Barcode is oriented from left to right. ]]>
<![CDATA[
]]>
<![CDATA[        '2 BO_Down_To_Top Barcode is oriented from down to top. ]]>
<![CDATA[
]]>
<![CDATA[        '3 BO_Right_To_Left Barcode is oriented from right to left. ]]>
<![CDATA[
]]>
<![CDATA[        '4 BO_Top_To_Down Barcode is oriented from top to down. ]]>
<![CDATA[
]]>
<![CDATA[        '5 BO_Autodetect Detect the barcode orientation automatically. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If "" <> oDCO.Variable("y_bOri") Then]]>
<![CDATA[
]]>
<![CDATA[          BarcodeBlock.BarcodeParams.Orientation = CInt(oDCO.Variable("y_bOri"))]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        If "1" = oDCO.Variable("y_bCSum") Then]]>
<![CDATA[
]]>
<![CDATA[          BarcodeBlock.BarcodeParams.HasCheckSum = True]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[          BarcodeBlock.BarcodeParams.HasCheckSum = False]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        If "1" = oDCO.Variable("y_bNoAtisk") Then]]>
<![CDATA[
]]>
<![CDATA[          BarcodeBlock.BarcodeParams.IsCode39WithoutAsterisk = True]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[          BarcodeBlock.BarcodeParams.IsCode39WithoutAsterisk = False]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		    Set abbyyText = m_oLayout.AddBlock(0,Region) '0 - Text Block  ]]>
<![CDATA[
]]>
<![CDATA[        abbyyText.RecognizerParams.ExactConfidenceCalculation = true ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        'rotation type]]>
<![CDATA[
]]>
<![CDATA[        If oDCO.Variable("y_rot") <> "" Then]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            ' 0 RT_NoRotation This value denotes no rotation. ]]>
<![CDATA[
]]>
<![CDATA[            ' 1 RT_Clockwise Rotation 90 degrees clockwise. ]]>
<![CDATA[
]]>
<![CDATA[            ' 2 RT_Counterclockwise Rotation 90 degrees counterclockwise or 270 degrees clockwise. ]]>
<![CDATA[
]]>
<![CDATA[            ' 3 RT_Upsidedown Rotation upside down, or 180 degrees ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            abbyyText.ImageProcessingParams.RotationType = CInt(oDCO.Variable("y_rot"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        End If		    ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End Sub]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[  Private Function SetLanguageParameters(RecognizerParams,oDCO)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[        str = oDCO.Variable("y_cs")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If "" = Trim(str) Then 'If there is not a character set specified, then load the specfied language]]>
<![CDATA[
]]>
<![CDATA[		        ]]>
<![CDATA[
]]>
<![CDATA[            If oDCO.Variable("y_lg") <> "" Then ]]>
<![CDATA[
]]>
<![CDATA[              If oDCO.Variable("hr_locale") <> "" AND oDCO.Variable("dco_uselocale") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[                l_sLang = m_oFRELoader.MapLocale(oDCO.Variable("hr_locale"))]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                If l_sLang = "" Then ]]>
<![CDATA[
]]>
<![CDATA[                   RecognizerParams.SetPredefinedTextLanguage(oDCO.Variable("y_lg")) ]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[                   RecognizerParams.SetPredefinedTextLanguage(l_sLang) ]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[              Else]]>
<![CDATA[
]]>
<![CDATA[                RecognizerParams.SetPredefinedTextLanguage(oDCO.Variable("y_lg")) ]]>
<![CDATA[
]]>
<![CDATA[              End If            ]]>
<![CDATA[
]]>
<![CDATA[            ElseIf oDCO.Variable("hr_locale") <> "" Then]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[              l_sLang = m_oFRELoader.MapLocale(oDCO.Variable("hr_locale"))]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[              If l_sLang = "" Then ]]>
<![CDATA[
]]>
<![CDATA[                  RecognizerParams.SetPredefinedTextLanguage("English") ]]>
<![CDATA[
]]>
<![CDATA[              Else]]>
<![CDATA[
]]>
<![CDATA[                  RecognizerParams.SetPredefinedTextLanguage(l_sLang) ]]>
<![CDATA[
]]>
<![CDATA[              End If]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[              RecognizerParams.SetPredefinedTextLanguage("English") ]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            Writelog "Language set to " & RecognizerParams.TextLanguage.InternalName]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[        Else 'If there is a character set specified, then create a custom language]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            ' Create new TextLanguage object]]>
<![CDATA[
]]>
<![CDATA[		        Set TextLanguage = Engine.CreateTextLanguage]]>
<![CDATA[
]]>
<![CDATA[		        TextLanguage.InternalName = "RE"]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[            BLLS_Alphabet = 0]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            ' Create regular expression description ]]>
<![CDATA[
]]>
<![CDATA[            Dim RegExpDescription]]>
<![CDATA[
]]>
<![CDATA[            Set RegExpDescription = Engine.CreateRegExpDictionaryDesc ]]>
<![CDATA[
]]>
<![CDATA[            RegExpDescription.SetText str 'specify regexp here ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            ' Create Base language ]]>
<![CDATA[
]]>
<![CDATA[            Dim BaseLanguage ]]>
<![CDATA[
]]>
<![CDATA[            Set BaseLanguage = Engine.CreateBaseLanguage ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            BaseLanguage.DictionaryDescriptions.Add RegExpDescription ]]>
<![CDATA[
]]>
<![CDATA[            BaseLanguage.AllowWordsFromDictionaryOnly = True ' do not allow OCR text, which does not correspond to regexp ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            BaseLanguage.InternalName = "RE" ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If oDCO.Variable("y_Alphabet") <> "" Then]]>
<![CDATA[
]]>
<![CDATA[                BaseLanguage.LetterSet(BLLS_Alphabet) = oDCO.Variable("y_Alphabet")]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[                BaseLanguage.LetterSet(BLLS_Alphabet) = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!#'&,./;:?@\$([{)]}+<>=-_" ' specify set of recognition characters. ]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            TextLanguage.BaseLanguages.Add BaseLanguage ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            Set RecognizerParams.TextLanguage = TextLanguage]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        str = oDCO.Variable("y_tt")]]>
<![CDATA[
]]>
<![CDATA[        If (str<>"") Then]]>
<![CDATA[
]]>
<![CDATA[          '.TextType = CInt(str)]]>
<![CDATA[
]]>
<![CDATA[          'Dim possibleTextTypes]]>
<![CDATA[
]]>
<![CDATA[          Set possibleTextTypes = Engine.CreateLongsCollection]]>
<![CDATA[
]]>
<![CDATA[          'possibleTextTypes.Add 0 '0 for Normal text type ]]>
<![CDATA[
]]>
<![CDATA[          possibleTextTypes.Add CInt(str) '5 for FREngine.TextTypeEnum.TT_OCR_A ]]>
<![CDATA[
]]>
<![CDATA[          RecognizerParams.PossibleTextTypes = possibleTextTypes]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        RecognizerParams.WritingStyle = 1	'American]]>
<![CDATA[
]]>
<![CDATA[        str = oDCO.Variable("y_ws")]]>
<![CDATA[
]]>
<![CDATA[        If (str<>"") Then RecognizerParams.WritingStyle = CInt(str)]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Done setting language parameters."]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[  End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Private Function PreRecog(oPage)]]>
<![CDATA[
]]>
<![CDATA[		PreRecog = False]]>
<![CDATA[
]]>
<![CDATA[		Dim ImageName]]>
<![CDATA[
]]>
<![CDATA[ 		ImageName = oPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[		If(m_strCurrentImage = ImageName) Then PreRecog = True : Exit Function]]>
<![CDATA[
]]>
<![CDATA[		If Not(FileMgr.FileExists(ImageName)) Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Image file doesn't exist - aborting recognition")]]>
<![CDATA[
]]>
<![CDATA[			nTaskStatus=retAbort 'Set to Abort in RRA]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Set m_oDocInfo = Engine.CreateDocumentInfo() ]]>
<![CDATA[
]]>
<![CDATA[		Set m_oImageDoc = Engine.PrepareAndOpenImage(ImageName, m_PrepareImageMode, Nothing, m_oDocInfo)]]>
<![CDATA[
]]>
<![CDATA[		If m_oImageDoc Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("OCR/A PrepareAndOpenImage failed")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		m_strCurrentImage = ImageName]]>
<![CDATA[
]]>
<![CDATA[		PreRecog = True]]>
<![CDATA[
]]>
<![CDATA[	End Function	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Public methods -----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Public Sub EnableLogs]]>
<![CDATA[
]]>
<![CDATA[    Engine.StartLogging Pilot.BatchDir & "\engine.log" , true]]>
<![CDATA[
]]>
<![CDATA[  End Sub]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Public Function RecognizeToPDF(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    RecognizeToPDF = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog "ABBYY recognition to PDF."]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_sr") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Recognition of " & CurrentObj.ID & " is skipped by the settings.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim strPDFName, ImageName, oPage]]>
<![CDATA[
]]>
<![CDATA[    Dim FRDocument]]>
<![CDATA[
]]>
<![CDATA[    Dim PDFExportParams]]>
<![CDATA[
]]>
<![CDATA[    Dim SynthesisParamsForDocument]]>
<![CDATA[
]]>
<![CDATA[    Dim iExportMethod]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Set FRDocument = Engine.CreateFRDocument()]]>
<![CDATA[
]]>
<![CDATA[		Set PDFExportParams = Engine.CreatePDFExportParams()]]>
<![CDATA[
]]>
<![CDATA[    Set SynthesisParamsForDocument = Engine.CreateSynthesisParamsForDocument]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SynthesisParamsForDocument.FontFormattingDetectionParams.DetectSmallCaps = False]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Creating FRDocument for object " & CurrentObj.ID]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If (CurrentObj.ObjectType = 1) Then 'DOCUMENT]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      For i=0 To CurrentObj.NumOfChildren-1 ]]>
<![CDATA[
]]>
<![CDATA[        Set oPage = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[        ImageName = oPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Adding image " & ImageName & "..."]]>
<![CDATA[
]]>
<![CDATA[        FRDocument.AddImageFile ImageName,Nothing,Nothing]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Added."]]>
<![CDATA[
]]>
<![CDATA[      Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		ElseIf (CurrentObj.ObjectType = 2) Then]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      ImageName = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Adding image " & ImageName & "..."]]>
<![CDATA[
]]>
<![CDATA[      FRDocument.AddImageFile ImageName,Nothing,Nothing]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Added."]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    strPDFName = Pilot.BatchDir & "\" & CurrentObj.ID & ".pdf"]]>
<![CDATA[
]]>
<![CDATA[		Writelog "Filename: "  & strPDFName]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Setting PDF Export parameters..."]]>
<![CDATA[
]]>
<![CDATA[    iExportMethod = 3]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_pdfA") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "PDF export mode is PDFA"]]>
<![CDATA[
]]>
<![CDATA[      PDFExportParams.PDFAComplianceMode = 2 : Writelog "PDFA type: A1A"]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("y_pdfA1B") = "1" Then PDFExportParams.PDFAComplianceMode = 1 : Writelog "PDFA type: A1B"]]>
<![CDATA[
]]>
<![CDATA[      iExportMethod = 6]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[		  PDFExportParams.PDFFeatures.EmbedFonts = False]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 1"]]>
<![CDATA[
]]>
<![CDATA[    'SET COMMON PDF PROPERTIES]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'KEYWORDS]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_PDFKeys") <> "" Then FRDocument.DocumentContentInfo.Keywords = CurrentObj.Variable("y_PDFKeys")]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 2"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'AUTHOR]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_PDFAuthor") <> "" Then FRDocument.DocumentContentInfo.Author = CurrentObj.Variable("y_PDFAuthor")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'TITLE]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_PDFTitle") <> "" Then FRDocument.DocumentContentInfo.Title = CurrentObj.Variable("y_PDFTitle")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'SUBJECT ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_PDFSubject") <> "" Then FRDocument.DocumentContentInfo.Subject = CurrentObj.Variable("y_PDFSubject")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'PRODUCER]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_PDFProducer") <> "" Then FRDocument.DocumentContentInfo.Producer = CurrentObj.Variable("y_PDFProducer")]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 3"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    'CREATOR]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_pdfCreator") <> "" Then]]>
<![CDATA[
]]>
<![CDATA[       FRDocument.DocumentContentInfo.Creator = CurrentObj.Variable("y_pdfCreator")]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       FRDocument.DocumentContentInfo.Creator = "IBM Datacap OCR/A actions."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 4"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'PICTURE RESOLUTION]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_pdfResolution") <> "" Then]]>
<![CDATA[
]]>
<![CDATA[      PDFExportParams.ResolutionType = 0]]>
<![CDATA[
]]>
<![CDATA[      PDFExportParams.Resolution = CInt(CurrentObj.Variable("y_pdfResolution"))]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      PDFExportParams.ResolutionType = 2 'Source]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'PAGE LAYOUT 'todo search this property]]>
<![CDATA[
]]>
<![CDATA[    'exportParams.SetPageSizeByLayoutSize = True]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 5"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'QUALITY 'todo research quality]]>
<![CDATA[
]]>
<![CDATA[    'If CurrentObj.Variable("y_PDFQuality") <> "" AND IsNumeric(CurrentObj.Variable("y_PDFQuality")) Then]]>
<![CDATA[
]]>
<![CDATA[    '    If CInt(CurrentObj.Variable("y_PDFQuality")) <= 100 AND CInt(CurrentObj.Variable("y_PDFQuality")) >=0 Then]]>
<![CDATA[
]]>
<![CDATA[    '        exportParams.Quality = CInt(CurrentObj.Variable("y_PDFQuality"))]]>
<![CDATA[
]]>
<![CDATA[    '    Else]]>
<![CDATA[
]]>
<![CDATA[    '        exportParams.Quality = 100]]>
<![CDATA[
]]>
<![CDATA[    '    End If]]>
<![CDATA[
]]>
<![CDATA[    'Else]]>
<![CDATA[
]]>
<![CDATA[    '    exportParams.Quality = 100]]>
<![CDATA[
]]>
<![CDATA[    'End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Writelog "PDF Quality set to " & exportParams.Quality]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    'EXPORT MODE]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_PDFTextExpMod") <> "" Then]]>
<![CDATA[
]]>
<![CDATA[      PDFExportParams.TextExportMode = CInt(CurrentObj.Variable("y_PDFTextExpMod"))]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Dim PageProcessingParams]]>
<![CDATA[
]]>
<![CDATA[      Set PageProcessingParams = Engine.CreatePageProcessingParams]]>
<![CDATA[
]]>
<![CDATA[      PDFExportParams.TextExportMode = 2 'image on text]]>
<![CDATA[
]]>
<![CDATA[      SetLanguageParameters PageProcessingParams.RecognizerParams,CurrentObj]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("y_FastMode") = "true" Or CurrentObj.Variable("y_FastMode") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[        PageProcessingParams.RecognizerParams.FastMode = true]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        PageProcessingParams.RecognizerParams.FastMode = false]]>
<![CDATA[
]]>
<![CDATA[      End If ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Recognizing FRDocument..."]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("y_AutoRotate") = "0" OR CurrentObj.Variable("y_AutoRotate") = "false" Or CurrentObj.Variable("y_AutoRotate") = "" Then]]>
<![CDATA[
]]>
<![CDATA[        PageProcessingParams.DetectOrientation = false]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        PageProcessingParams.DetectOrientation = true]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      FRDocument.AnalyzeAndRecognize PageProcessingParams, Nothing]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Done."]]>
<![CDATA[
]]>
<![CDATA[      Set PageProcessingParameters = Nothing]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[     Writelog "Synthesizing FRDocument..."]]>
<![CDATA[
]]>
<![CDATA[    FRDocument.Synthesize SynthesisParamsForDocument]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Done."]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 6"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Text Export mode set to " & PDFExportParams.TextExportMode]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'END OF PDF PROPERTY SETTING]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Save result to PDF]]>
<![CDATA[
]]>
<![CDATA[		WriteLog "Creating PDF file " &  strPDFName]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Exporting FRDocument to PDF format..."]]>
<![CDATA[
]]>
<![CDATA[    Writelog "File name is " & strPDFName]]>
<![CDATA[
]]>
<![CDATA[    FRDocument.Export strPDFName, iExportMethod, PDFExportParams]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 7"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog strPDFName & " created."]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Function GetCurrentObjectImages]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Dim l_iIndex]]>
<![CDATA[
]]>
<![CDATA[    Dim l_sImages]]>
<![CDATA[
]]>
<![CDATA[    Set DCOObject = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If DCOObject.ObjectType = 1 Then 'Document]]>
<![CDATA[
]]>
<![CDATA[        For l_iIndex = 0 To nPages - 1]]>
<![CDATA[
]]>
<![CDATA[           l_sImages = l_sImages & DCOObject.GetChild(l_iIndex).Variable("ABBYYInternalImg") & ","]]>
<![CDATA[
]]>
<![CDATA[        Next]]>
<![CDATA[
]]>
<![CDATA[    ElseIf DCOObject.ObjectType = 2 Then 'Page]]>
<![CDATA[
]]>
<![CDATA[        l_sImages = DCOObject.Variable("ABBYYInternalImg")]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    GetCurrentObjectImages = l_sImages]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Public Function RecognizeToFile(CurrentObj, ExportType)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("y_sr") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Recognition of " & CurrentObj.ID & " is skipped by the settings.")]]>
<![CDATA[
]]>
<![CDATA[        RecognizeToFile = true]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    RecognizeToTextFile = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog "ABBYY recognition to RTF."]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Dim strPDFName, ImageName, oPage, l_oExporter]]>
<![CDATA[
]]>
<![CDATA[    Dim l_sLayoutFolder]]>
<![CDATA[
]]>
<![CDATA[    Dim l_sExtension]]>
<![CDATA[
]]>
<![CDATA[    l_sLayoutFolder = Pilot.BatchDir & "\layout"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not FileMgr.FolderExists (l_sLayoutFolder) Then]]>
<![CDATA[
]]>
<![CDATA[        FileMgr.CreateFolder l_sLayoutFolder]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set DA = Engine.CreateDocumentAnalyzer()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[		If (CurrentObj.ObjectType = 2) Then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      'Create the export parameters]]>
<![CDATA[
]]>
<![CDATA[      If ExportType = 0 Then]]>
<![CDATA[
]]>
<![CDATA[		    Set exportParams = Engine.CreateRTFExportParams()]]>
<![CDATA[
]]>
<![CDATA[		    exportParams.KeepLines = true ]]>
<![CDATA[
]]>
<![CDATA[        l_sExtension = "rtf"]]>
<![CDATA[
]]>
<![CDATA[      ElseIf ExportType = 2 Then ]]>
<![CDATA[
]]>
<![CDATA[        'XLS]]>
<![CDATA[
]]>
<![CDATA[      ElseIf ExportType = 3 Then ]]>
<![CDATA[
]]>
<![CDATA[        'PDF  ]]>
<![CDATA[
]]>
<![CDATA[      ElseIf ExportType = 4 Then ]]>
<![CDATA[
]]>
<![CDATA[        'PDFA]]>
<![CDATA[
]]>
<![CDATA[      ElseIf ExportType = 5 Then ]]>
<![CDATA[
]]>
<![CDATA[        'DBF]]>
<![CDATA[
]]>
<![CDATA[      ElseIf ExportType = 6 Then ]]>
<![CDATA[
]]>
<![CDATA[        'Text]]>
<![CDATA[
]]>
<![CDATA[		    Set exportParams = Engine.CreateTextExportParams()]]>
<![CDATA[
]]>
<![CDATA[        l_sExtension = "txt"  ]]>
<![CDATA[
]]>
<![CDATA[      ElseIf ExportType = 7 Then ]]>
<![CDATA[
]]>
<![CDATA[        'XML]]>
<![CDATA[
]]>
<![CDATA[      ElseIf ExportType = 8 Then ]]>
<![CDATA[
]]>
<![CDATA[        'PPT]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      'Save result to file type]]>
<![CDATA[
]]>
<![CDATA[      ImageName = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Recognizing page " & CurrentObj.ID & "(" & ImageName & ")"]]>
<![CDATA[
]]>
<![CDATA[      strPDFName = Left(ImageName, Len(ImageName) - 3) & l_sExtension]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		  WriteLog "Creating file " &  strPDFName]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Set m_oDocInfo = Engine.CreateDocumentInfo()]]>
<![CDATA[
]]>
<![CDATA[			Set imageDoc = Engine.PrepareAndOpenImage(ImageName, m_PrepareImageMode, Nothing, m_oDocInfo)]]>
<![CDATA[
]]>
<![CDATA[			Set layout = Engine.CreateLayout()]]>
<![CDATA[
]]>
<![CDATA[			DA.AnalyzeAndRecognizePage imageDoc, m_oPageProcessingParams, layout, Nothing]]>
<![CDATA[
]]>
<![CDATA[			imageDoc.SaveModified]]>
<![CDATA[
]]>
<![CDATA[      call layout.SaveToFile(l_sLayoutFolder & "\" & CurrentObj.ID + ".layout")]]>
<![CDATA[
]]>
<![CDATA[		  ]]>
<![CDATA[
]]>
<![CDATA[      call Engine.ExportPage (ExportType,strPDFName,imageDoc,layout,exportParams)]]>
<![CDATA[
]]>
<![CDATA[      RecognizeToFile = True]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    Set DA = Nothing]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("abbyy_deletetmp") <> "1" Then]]>
<![CDATA[
]]>
<![CDATA[        FileMgr.DeleteFolder l_sLayoutFolder, true ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Public Function RemoveStartEndAsterisks(p_sText)]]>
<![CDATA[
]]>
<![CDATA[      l_sCleaned = p_sText]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If Left(l_sCleaned,1) = "*" AND Right(l_sCleaned,1) = "*" Then ]]>
<![CDATA[
]]>
<![CDATA[        l_sCleaned = Right(l_sCleaned, Len(l_sCleaned)-1)]]>
<![CDATA[
]]>
<![CDATA[        l_sCleaned = Left(l_sCleaned, Len(l_sCleaned)-1)]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      RemoveStartEndAsterisks = l_sCleaned]]>
<![CDATA[
]]>
<![CDATA[  End Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[  Public Function GetBarCodes(oCurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Dim ImageName]]>
<![CDATA[
]]>
<![CDATA[    Dim oBarcodeAParams]]>
<![CDATA[
]]>
<![CDATA[    Dim oDocAnalyzer]]>
<![CDATA[
]]>
<![CDATA[    Dim oBlock]]>
<![CDATA[
]]>
<![CDATA[    Dim oParagraph]]>
<![CDATA[
]]>
<![CDATA[    Dim oCharParams]]>
<![CDATA[
]]>
<![CDATA[    Dim lLeft, lRight,lTop,lBottom]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set oCharParams = Engine.CreateCharParams]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ImageName = oCurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[    Set oBarcodeAParams = Engine.CreateBarcodeAnalysisParams]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If "" <> oCurrentObj.Variable("y_bType") Then]]>
<![CDATA[
]]>
<![CDATA[      oBarcodeAParams.BarcodeParameters.Type = CInt(oCurrentObj.Variable("y_bType"))]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If "" <> oCurrentObj.Variable("y_bOri") Then]]>
<![CDATA[
]]>
<![CDATA[      oBarcodeAParams.BarcodeParameters.Orientation = CInt(oCurrentObj.Variable("y_bOri"))]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If "1" = oCurrentObj.Variable("y_bCSum") Then]]>
<![CDATA[
]]>
<![CDATA[      oBarcodeAParams.BarcodeParameters.HasCheckSum = True]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      oBarcodeAParams.BarcodeParameters.HasCheckSum = False]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set m_oDocInfo = Engine.CreateDocumentInfo()    ]]>
<![CDATA[
]]>
<![CDATA[    Set imageDoc = Engine.PrepareAndOpenImage(ImageName, m_PrepareImageMode, Nothing, m_oDocInfo)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Set layout = Engine.CreateLayout()]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Engine.ExtractBarcodes imageDoc,oBarcodeAParams,layout,nothing]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Number of barcodes found " & layout.Blocks.Count]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    For i=0 to layout.blocks.count - 1]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Set oBlock = layout.Blocks.Item(i)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      For j=0 to oBlock.BarcodeBlockProperties.Text.Paragraphs.Count - 1 ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Set oParagraph =  oBlock.BarcodeBlockProperties.Text.Paragraphs.Item(j)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If oCurrentObj.ObjectType = 2 Then]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          oParagraph.GetCharParams 0, oCharParams]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          lleft = oCharParams.Left]]>
<![CDATA[
]]>
<![CDATA[          ltop = oCharParams.Top]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          oParagraph.GetCharParams oParagraph.Length-1, oCharParams]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          lright = oCharParams.Right]]>
<![CDATA[
]]>
<![CDATA[          lbottom = oCharParams.Bottom]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If "1" = oCurrentObj.Variable("y_bNoAtisk") Then]]>
<![CDATA[
]]>
<![CDATA[            oCurrentObj.Variable("Barcode" & i + 1) = oParagraph.Text]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[            oCurrentObj.Variable("Barcode" & i + 1) = RemoveStartEndAsterisks(oParagraph.Text)]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          oCurrentObj.Variable("Barcode" & i + 1 & "Type") = oBlock.BarcodeBlockProperties.BarcodeType]]>
<![CDATA[
]]>
<![CDATA[          oCurrentObj.Variable("Barcode" & i + 1 & "Orientation") = oBlock.BarcodeBlockProperties.BarcodeOrientation]]>
<![CDATA[
]]>
<![CDATA[          oCurrentObj.Variable("Barcode" & i + 1 & "Position") = lLeft & "," &  lTop &  "," &  lRight &  "," & lBottom]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Barcode " & i + 1 & " text: " & oCurrentObj.Variable("Barcode" & i + 1)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Next 'j]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Next 'i]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    GetBarCodes = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End Function ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[  Public Function RotateImage(p_sPath)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set m_oPageProcessingParams = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set m_oPageProcessingParams = Engine.CreatePageProcessingParams()]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Only turn on automatic image rotation]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.DetectBarcodes = False ]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.DetectInvertedImage = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.ObjectsExtractionParams.RemoveTexture = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.ObjectsExtractionParams.DetectMatrixPrinter = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.DetectOrientation = True '*****]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.PageAnalysisParams.DetectPictures = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.ObjectsExtractionParams.DetectPorousText = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.PageAnalysisParams.DetectTables = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.ObjectsExtractionParams.FastObjectsExtraction = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.ObjectsExtractionParams.FlexiFormsDA = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.ObjectsExtractionParams.FullTextIndexDA = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.OrientationDetectionParams.ProhibitClockwiseRotation = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.ObjectsExtractionParams.ProhibitColorImage = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.OrientationDetectionParams.ProhibitCounterclockwiseRotation = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.PageAnalysisParams.ProhibitModelAnalysis = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.OrientationDetectionParams.ProhibitUpsidedownRotation = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.ObjectsExtractionParams.RemoveTexture = False]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.PageAnalysisParams.SingleColumnMode = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim oImageDoc]]>
<![CDATA[
]]>
<![CDATA[    Dim oLayout]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set oImageDoc = Engine.PrepareAndOpenImage(p_sPath, m_PrepareImageMode, Nothing, Nothing)]]>
<![CDATA[
]]>
<![CDATA[    Set oLayout = Engine.CreateLayout()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Engine.AnalyzePage oImageDoc, m_oPageProcessingParams, oLayout, Nothing]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Image doc modified after analysis? " & oImageDoc.IsModified]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Rotation: " & oImageDoc.ImageRotation]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If oImageDoc.IsModified Then]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Image rotation was performed during page analysis."]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If oImageDoc.ImageColorType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog  "Saving image " & p_sPath & "..."]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If m_oImageDoc.SourceImageFileFormat = 17 Then]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Image will be saved as Group 3 Compressed. Original format of Fax Group 3 Compressed is not supported for wrintig out files." ]]>
<![CDATA[
]]>
<![CDATA[          m_oImageDoc.BlackWhiteImage.WriteToFile p_sPath,18,Nothing,Nothing]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[          oImageDoc.BlackWhiteImage.WriteToFile p_sPath,m_oImageDoc.SourceImageFileFormat,Nothing,Nothing]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Else ]]>
<![CDATA[
]]>
<![CDATA[        Writelog  "Saving color image " & p_sPath & "..."]]>
<![CDATA[
]]>
<![CDATA[        m_oImageDoc.ColorImage.WriteToFile p_sPath,m_oImageDoc.SourceImageFileFormat,Nothing,Nothing]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Image saved."]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    RotateImage = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Function CreateBackupFile(p_sOriginal,p_sBackupExt)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim l_oFile]]>
<![CDATA[
]]>
<![CDATA[    Set l_oFile = FileMgr.GetFile (p_sOriginal)]]>
<![CDATA[
]]>
<![CDATA[    sFileExtension = Right(l_ofile.name,Len(l_ofile.name)-InstrRev(l_ofile.name,".")+1) 'file.txt]]>
<![CDATA[
]]>
<![CDATA[    sFileName = Replace(l_oFile.Name,sFileExtension,"")]]>
<![CDATA[
]]>
<![CDATA[    sParentPath = Replace(l_oFile.path,l_ofile.name,"")]]>
<![CDATA[
]]>
<![CDATA[    sNewFileName = sParentPath & sFileName & "." & p_sBackupExt]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_oFile.Copy sNewFileName]]>
<![CDATA[
]]>
<![CDATA[    l_oFile.Delete]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Error while backing up image " & p_sOriginal & ": "& Err.Description]]>
<![CDATA[
]]>
<![CDATA[      CreateBackupFile = p_sOriginal]]>
<![CDATA[
]]>
<![CDATA[    End If  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set l_oFile = nothing]]>
<![CDATA[
]]>
<![CDATA[    CreateBackupFile = sNewFileName]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    '-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[  Public Function ConvertToBW(p_sPath,p_sBackupExt)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim oImageDoc]]>
<![CDATA[
]]>
<![CDATA[    sWorkingFile = CreateBackupFile(p_sPath,p_sBackupExt)]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Color to BW conversion. Working image " & sWorkingFile]]>
<![CDATA[
]]>
<![CDATA[    m_PrepareImageMode.DiscardColorImage = true]]>
<![CDATA[
]]>
<![CDATA[    Set oImageDoc = Engine.PrepareAndOpenImage(sWorkingFile, m_PrepareImageMode, Nothing, Nothing)]]>
<![CDATA[
]]>
<![CDATA[    Writelog "source image format ID " & oImageDoc.SourceImageFileFormat]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Color oImageDoc.SourceImageFileFormat values]]>
<![CDATA[
]]>
<![CDATA[    ' 3 IFF_BmpColorUncompressed]]>
<![CDATA[
]]>
<![CDATA[    ' 8 IFF_JpegColorJfif]]>
<![CDATA[
]]>
<![CDATA[    '14 IFF_PngColorPng]]>
<![CDATA[
]]>
<![CDATA[    '23 IFF_TiffColorUncompressed,]]>
<![CDATA[
]]>
<![CDATA[    '24 IFF_TiffColorPackbits]]>
<![CDATA[
]]>
<![CDATA[    '25 IFF_TiffColorJpegJfif]]>
<![CDATA[
]]>
<![CDATA[    '26 IFF_TiffColorABBYYLossless]]>
<![CDATA[
]]>
<![CDATA[    '28 IFF_Jpeg2kColor]]>
<![CDATA[
]]>
<![CDATA[    '32 IFF_TiffColorLZW]]>
<![CDATA[
]]>
<![CDATA[    '35 IFF_TiffColorZip]]>
<![CDATA[
]]>
<![CDATA[    '38 IFF_GifColorLZW]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    TIFFG4Compression = 18]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    sFileExtension = Right(p_sPath,Len(p_sPath)-InstrRev(p_sPath,".")+1) 'file.txt]]>
<![CDATA[
]]>
<![CDATA[    sNewFileName = Replace(p_sPath,sFileExtension,".tif")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Output file name is " & sNewFileName]]>
<![CDATA[
]]>
<![CDATA[    oImageDoc.BlackWhiteImage.WriteToFile sNewFileName,TIFFG4Compression,Nothing,Nothing]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Done writing output file"]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.ImageName = sNewFileName]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set oImageDoc = Nothing]]>
<![CDATA[
]]>
<![CDATA[    ConvertToBW = True]]>
<![CDATA[
]]>
<![CDATA[  End Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[  Function PopulateCCO(oCCO, Paragraphs, bCreateCCO, bVote)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      bNewWord = True]]>
<![CDATA[
]]>
<![CDATA[		  bNewLine = True]]>
<![CDATA[
]]>
<![CDATA[      strConfData = ""]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Dim  previousBottom,previousTop, previousDefined, top, bottom]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      previousBottom = 0]]>
<![CDATA[
]]>
<![CDATA[      previousTop = 0]]>
<![CDATA[
]]>
<![CDATA[      previousDefined  = False]]>
<![CDATA[
]]>
<![CDATA[      top = 0]]>
<![CDATA[
]]>
<![CDATA[      bottom = 0]]>
<![CDATA[
]]>
<![CDATA[      newlineinserted = false]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      nParagraph = Paragraphs.Count - 1]]>
<![CDATA[
]]>
<![CDATA[      'Writelog "************************new block*****************************"]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        For i = 0 To nParagraph]]>
<![CDATA[
]]>
<![CDATA[          Set Paragraph = Paragraphs.Item(i)]]>
<![CDATA[
]]>
<![CDATA[	        sText = Paragraph.Text]]>
<![CDATA[
]]>
<![CDATA[          'Writelog "Paragraph text :" & sText]]>
<![CDATA[
]]>
<![CDATA[          If Len(sText) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[          'writelog sText]]>
<![CDATA[
]]>
<![CDATA[	        For j = 0 To Paragraph.Length - 1]]>
<![CDATA[
]]>
<![CDATA[            'writelog "******************Paragraph not empty, processing..."]]>
<![CDATA[
]]>
<![CDATA[            Set CharParams = Nothing            ]]>
<![CDATA[
]]>
<![CDATA[            Set CharParams = Engine.CreateCharParams]]>
<![CDATA[
]]>
<![CDATA[		        'writelog "debug char text: " & Mid(sText, j + 1, 1)]]>
<![CDATA[
]]>
<![CDATA[            Paragraph.GetCharParams j, CharParams]]>
<![CDATA[
]]>
<![CDATA[		        conf = 1]]>
<![CDATA[
]]>
<![CDATA[		        Set ExtendedRecAttributes = CharParams.SelectedCharacterRecognitionVariant 'TODO: debug why this is always null, need to get charConfidence]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            chrCode = AscW(Mid(sText, j + 1, 1))]]>
<![CDATA[
]]>
<![CDATA[            dLeft = CharParams.Left]]>
<![CDATA[
]]>
<![CDATA[            dTop = CharParams.Top]]>
<![CDATA[
]]>
<![CDATA[            dRight = CharParams.Right]]>
<![CDATA[
]]>
<![CDATA[            dBottom = CharParams.Bottom]]>
<![CDATA[
]]>
<![CDATA[            'dBottom = dTop + CharParams.CharacterHeight]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            'writelog "character height " & CharParams.CharacterHeight]]>
<![CDATA[
]]>
<![CDATA[            'writelog "calculate char height " & (dBottom - dTop)]]>
<![CDATA[
]]>
<![CDATA[            'writelog "character top " & dTop]]>
<![CDATA[
]]>
<![CDATA[            'If CharParams.CharacterHeight > 50 Then writelog "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!greater than 50 pixels"]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[            strConfData = strConfData & chrW(13) & chrW(10)  & "Character: '" & Mid(sText, j + 1, 1) & "', ABBYY Confidence: "]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            '*******CONFIDENCE CALCULATION]]>
<![CDATA[
]]>
<![CDATA[            If Not ExtendedRecAttributes Is Nothing Then ]]>
<![CDATA[
]]>
<![CDATA[              conf = ExtendedRecAttributes.CharConfidence]]>
<![CDATA[
]]>
<![CDATA[              strConfData = strConfData & conf & ", Datacap Confidence: " & GetConfidence(conf,CharParams.IsSuspicious) & ", IsSuspicious: "  & CharParams.IsSuspicious]]>
<![CDATA[
]]>
<![CDATA[			        conf = GetConfidence(conf,CharParams.IsSuspicious)]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[              'The following special characters do not have the extended recognition attributes:]]>
<![CDATA[
]]>
<![CDATA[              '0x2028 - Line break symbol. ]]>
<![CDATA[
]]>
<![CDATA[              '0xFFFC - Object replacement character. ]]>
<![CDATA[
]]>
<![CDATA[              '0x0009 - Tabulation. ]]>
<![CDATA[
]]>
<![CDATA[              '0x0020 - Space. ]]>
<![CDATA[
]]>
<![CDATA[              If chrCode = 9 OR chrCode = 32 OR chrCode = 8233 OR chrCode = 8232 Then]]>
<![CDATA[
]]>
<![CDATA[                conf = 9]]>
<![CDATA[
]]>
<![CDATA[              End If]]>
<![CDATA[
]]>
<![CDATA[		        End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            '*******END CONFIDENCE CALCULATION]]>
<![CDATA[
]]>
<![CDATA[            'writelog "debug conf " & conf]]>
<![CDATA[
]]>
<![CDATA[            top = CharParams.Top]]>
<![CDATA[
]]>
<![CDATA[            bottom = CharParams.Bottom]]>
<![CDATA[
]]>
<![CDATA[            If previousDefined Then]]>
<![CDATA[
]]>
<![CDATA[                If previousBottom < top AND newlineinserted = false Then]]>
<![CDATA[
]]>
<![CDATA[                    'bNewLine = true]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[            previousBottom = bottom]]>
<![CDATA[
]]>
<![CDATA[            previousTop = top]]>
<![CDATA[
]]>
<![CDATA[            previousDefined = true]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If bNewLine = False Then]]>
<![CDATA[
]]>
<![CDATA[              If AscW(Mid(sText, j + 1, 1)) = 10 OR AscW(Mid(sText, j + 1, 1)) = 13 OR AscW(Mid(sText, j + 1, 1)) = 8233 OR AscW(Mid(sText, j + 1, 1)) = 8232 OR AscW(Mid(sText, j + 1, 1)) = 8226 Then]]>
<![CDATA[
]]>
<![CDATA[                      bNewLine = true]]>
<![CDATA[
]]>
<![CDATA[              End If]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            'If ((chrCode <= 0) Or (chrCode > 255)) Then ]]>
<![CDATA[
]]>
<![CDATA[            '        Writelog "Invalid character code found :" & chrCode]]>
<![CDATA[
]]>
<![CDATA[            '        chrCode = REJECTED_CHAR 'rejected character; DCO requirements]]>
<![CDATA[
]]>
<![CDATA[            'End If ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            PUNCTUATION = False]]>
<![CDATA[
]]>
<![CDATA[            'CharCode 63 below is handled as a punctuation since ABBYY seems to be using it as a miscellaneous newline character. When]]>
<![CDATA[
]]>
<![CDATA[            'this character code is not handled as such, it causes CCO2CCO to remove any words that has this character.]]>
<![CDATA[
]]>
<![CDATA[				    If ((chrCode = 32) Or (chrCode = 9) Or (chrCode = 63)) Then bNewWord = True : PUNCTUATION = True]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            '************POPULATE CCO]]>
<![CDATA[
]]>
<![CDATA[            If (bCreateCCO) Then]]>
<![CDATA[
]]>
<![CDATA[				                                                ]]>
<![CDATA[
]]>
<![CDATA[				        If ((chrCode = 10) Or (chrCode = 13) Or (chrCode = 8232) Or (chrCode = 8233)) Then bNewLine = True : PUNCTUATION = True]]>
<![CDATA[
]]>
<![CDATA[                '8232 - line break]]>
<![CDATA[
]]>
<![CDATA[				        '8233 - paragraph break]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[				        If Not(PUNCTUATION) And Not (chrCode = REJECTED_CHAR) Then ]]>
<![CDATA[
]]>
<![CDATA[                  'If bNewLine Then Writelog "new line"]]>
<![CDATA[
]]>
<![CDATA[                  'writelog "" & chrCode & " : " &  Mid(sText, j + 1, 1) & ": " & dLeft & "," & dTop & "," & dRight & "," & dBottom ]]>
<![CDATA[
]]>
<![CDATA[					        oCCO.InsertCharWL chrCode, conf, bNewWord, bNewLine, dLeft, dTop, dRight, dBottom ]]>
<![CDATA[
]]>
<![CDATA[					        bNewWord = False]]>
<![CDATA[
]]>
<![CDATA[					        bNewLine = False]]>
<![CDATA[
]]>
<![CDATA[				        End If]]>
<![CDATA[
]]>
<![CDATA[			      Else]]>
<![CDATA[
]]>
<![CDATA[              If Not(PUNCTUATION) And Not (chrCode = REJECTED_CHAR) Then]]>
<![CDATA[
]]>
<![CDATA[				        If (bVote) Then oCCO.PutCharVote chrCode, conf, dLeft, dTop, dRight, dBottom ': writelog "inserted charcode " & chrCode & " : " &  Mid(sText, j + 1, 1) & ": " & dLeft & ","  &  dTop & "," & dRight & "," & dBottom ]]>
<![CDATA[
]]>
<![CDATA[				        If Not(bVote) Then oCCO.PutChar chrCode, conf, dLeft, dTop, dRight, dBottom ': writelog "inserted charcode " & chrCode & " : " &  Mid(sText, j + 1, 1) & ": " & dLeft & ","  &  dTop & "," & dRight & "," & dBottom ]]>
<![CDATA[
]]>
<![CDATA[              End If]]>
<![CDATA[
]]>
<![CDATA[			      End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            '************END POPULATE CCO]]>
<![CDATA[
]]>
<![CDATA[	        Next]]>
<![CDATA[
]]>
<![CDATA[          bNewLine = true]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[        Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Public Function RecognizePage(oPage)]]>
<![CDATA[
]]>
<![CDATA[		RecognizePage = False]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    If oPage.Variable("y_sr") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Recognition of " & oPage.ID & " is skipped by the settings.")]]>
<![CDATA[
]]>
<![CDATA[        RecognizePage = true]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[		If( Not(PreRecog(oPage)) ) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Dim strCCOName, bCreateCCO, oCCO, bNewWord, theTime, bVote, ImageName, PText, Text]]>
<![CDATA[
]]>
<![CDATA[		ImageName = oPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("----- OCR/A page recognition of: " & ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not IsObject(CCOCreator) Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Could not obtain CCOCreator object. Aborting.")]]>
<![CDATA[
]]>
<![CDATA[			nTaskStatus=retAbort ]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		strCCOName = Left(ImageName, Len(ImageName)-3) & "cco"]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If Not(FileMgr.FileExists(strCCOName)) Then ]]>
<![CDATA[
]]>
<![CDATA[      bCreateCCO = True]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[      bCreateCCO = False]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("s_srCreateCCO") = "1" Then bCreateCCO = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		If (bCreateCCO) Then]]>
<![CDATA[
]]>
<![CDATA[			Set oCCO = CCOCreator.Create()]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Set oCCO = CCOCreator.Load(strCCOName)]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		bVote = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not IsObject(oCCO) Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Could not create CCO - recognition failed")]]>
<![CDATA[
]]>
<![CDATA[			nTaskStatus=retAbort 'Set to Abort in RRA]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		SetZone(oPage)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    Dim possibleTextTypes]]>
<![CDATA[
]]>
<![CDATA[    Set possibleTextTypes = Engine.CreateLongsCollection]]>
<![CDATA[
]]>
<![CDATA[    possibleTextTypes.Add 0 '0 for Normal text type ]]>
<![CDATA[
]]>
<![CDATA[    possibleTextTypes.Add 5 '5 for FREngine.TextTypeEnum.TT_OCR_A ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set m_oPageProcessingParams = Engine.CreatePageProcessingParams]]>
<![CDATA[
]]>
<![CDATA[    Set m_oPageSynthesisParams = Engine.CreateSynthesisParamsForPage]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.RecognizerParams.PossibleTextTypes = possibleTextTypes]]>
<![CDATA[
]]>
<![CDATA[    m_oPageProcessingParams.RecognizerParams.ExactConfidenceCalculation = true ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If oPage.Variable("y_FastMode") = "true" Or oPage.Variable("y_FastMode") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[      m_oPageProcessingParams.RecognizerParams.FastMode = true]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      m_oPageProcessingParams.RecognizerParams.FastMode = false]]>
<![CDATA[
]]>
<![CDATA[    End If ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If oPage.Variable("y_AutoRotate") = "0" OR oPage.Variable("y_AutoRotate") = "false" Or oPage.Variable("y_AutoRotate") = "" Then]]>
<![CDATA[
]]>
<![CDATA[      m_oPageProcessingParams.DetectOrientation = false]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      m_oPageProcessingParams.DetectOrientation = true]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'TODO: small caps ]]>
<![CDATA[
]]>
<![CDATA[    'If oPage.Variable("DetectSmallCaps") = "0" Then]]>
<![CDATA[
]]>
<![CDATA[    '  m_oPageSynthesisParams.FontFormattingDetectionParams.DetectSmallCaps = FALSE]]>
<![CDATA[
]]>
<![CDATA[    '  Writelog "DetectSmallCaps set to " & m_oPageSynthesisParams.FontFormattingDetectionParams.DetectSmallCaps]]>
<![CDATA[
]]>
<![CDATA[    'End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Call SetLanguageParameters(m_oPageProcessingParams.RecognizerParams,oPage)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Engine.AnalyzeAndRecognizePage m_oImageDoc, m_oPageProcessingParams,m_oPageSynthesisParams, m_oLayout, m_oDocInfo]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'If Not m_oPageSynthesisParams.FontFormattingDetectionParams.DetectSmallCaps Then]]>
<![CDATA[
]]>
<![CDATA[    '  Writelog "Writing temp ABBYY export file, then removing."]]>
<![CDATA[
]]>
<![CDATA[    '  Call Engine.ExportPage(0, Pilot.BatchDir & "\tmp_abbyy.rtf", m_oImageDoc, m_oLayout, Nothing)]]>
<![CDATA[
]]>
<![CDATA[    '  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    '  FileMgr.DeleteFile Pilot.BatchDir & "\tmp_abbyy.rtf"]]>
<![CDATA[
]]>
<![CDATA[    '  If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[    '    Writelog "Could not delete the temporary file " & Pilot.BatchDir & "\tmp_abbyy.rtf"]]>
<![CDATA[
]]>
<![CDATA[    '    Writelog Err.Description]]>
<![CDATA[
]]>
<![CDATA[    '    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[     ' End If]]>
<![CDATA[
]]>
<![CDATA[   ''   Writelog "Done adding and removing temp ABBYY export file."]]>
<![CDATA[
]]>
<![CDATA[    'End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If m_oPageProcessingParams.DetectOrientation Then]]>
<![CDATA[
]]>
<![CDATA[      If m_oImageDoc.IsModified And m_oImageDoc.ImageRotation <> 0 And m_oImageDoc.ImageRotation <> 1 Then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image rotation was performed during page analysis." & m_oImageDoc.SourceImageFileFormat]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If m_oImageDoc.ImageColorType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[          Writelog  "Saving image " & p_sPath & "..."]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If m_oImageDoc.SourceImageFileFormat = 17 Then]]>
<![CDATA[
]]>
<![CDATA[            Writelog "Image will be saved as Group 3 Compressed. Original format of Fax Group 3 Compressed is not supported for writing out files." ]]>
<![CDATA[
]]>
<![CDATA[            m_oImageDoc.BlackWhiteImage.WriteToFile oPage.ImageName,18,Nothing,Nothing]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[            m_oImageDoc.BlackWhiteImage.WriteToFile oPage.ImageName,m_oImageDoc.SourceImageFileFormat,Nothing,Nothing]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Else ]]>
<![CDATA[
]]>
<![CDATA[          Writelog  "Saving color image " & p_sPath & "..."]]>
<![CDATA[
]]>
<![CDATA[          m_oImageDoc.ColorImage.WriteToFile oPage.ImageName,m_oImageDoc.SourceImageFileFormat,Nothing,Nothing]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image saved."]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    nBlocks = m_oLayout.Blocks.Count - 1]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'writelog m_oLayout.TextAsString]]>
<![CDATA[
]]>
<![CDATA[    'writelog "nBlocks is " & nBlocks]]>
<![CDATA[
]]>
<![CDATA[    'writelog "create CCO?  " & bCreateCCO]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    for h=0 to nBlocks]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      Set Block = m_oLayout.Blocks.Item(h)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If Not Block Is Nothing And (Block.Type = 0 Or Block.Type = 2) Then ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[       ' writelog "INFO******************BLOCK TYPE: "& Block.Type]]>
<![CDATA[
]]>
<![CDATA[        If Block.Type = 2 Then]]>
<![CDATA[
]]>
<![CDATA[          Dim l_oCell]]>
<![CDATA[
]]>
<![CDATA[          'writelog "******************TABLE BLOCK******************************"]]>
<![CDATA[
]]>
<![CDATA[		      'writelog "number of cells " & Block.TableBlockProperties.Cells.Count]]>
<![CDATA[
]]>
<![CDATA[          For k = 0 to Block.GetAsTableBlock().Cells.Count - 1]]>
<![CDATA[
]]>
<![CDATA[            'writelog "Processing cell " & k]]>
<![CDATA[
]]>
<![CDATA[            Set l_oCell = Block.GetAsTableBlock().Cells(k)]]>
<![CDATA[
]]>
<![CDATA[            If l_oCell.Block.Type = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[              Set Paragraphs = l_oCell.Block.GetAsTextBlock().Text.Paragraphs]]>
<![CDATA[
]]>
<![CDATA[              PopulateCCO oCCO, Paragraphs,bCreateCCO, bVote]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[          Next]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[		      Set Paragraphs = Block.GetAsTextBlock().Text.Paragraphs]]>
<![CDATA[
]]>
<![CDATA[          PopulateCCO oCCO, Paragraphs, bCreateCCO, bVote]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        'writelog "*********************UNKNOWN BLOCK*************************"]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		oCCO.Left = 0]]>
<![CDATA[
]]>
<![CDATA[		oCCO.Top = 0 ]]>
<![CDATA[
]]>
<![CDATA[		oCCO.Right = m_oImageDoc.BlackWhiteImage.Width]]>
<![CDATA[
]]>
<![CDATA[ 		oCCO.Bottom = m_oImageDoc.BlackWhiteImage.Height]]>
<![CDATA[
]]>
<![CDATA[		bSaved = oCCO.Save(strCCOName)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Recognition Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Set oCCO		= Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		m_FullPageRecogArea = 1]]>
<![CDATA[
]]>
<![CDATA[		RecognizePage = True]]>
<![CDATA[
]]>
<![CDATA[    Set m_oImageDoc = Nothing]]>
<![CDATA[
]]>
<![CDATA[    m_strCurrentImage = ""]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Public Function RecognizePageFields(oPage)]]>
<![CDATA[
]]>
<![CDATA[		RecognizePageFields = False]]>
<![CDATA[
]]>
<![CDATA[		If( Not(PreRecog(oPage)) ) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("----- OCR/A page fields recognition of: " & oPage.ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Dim theTime]]>
<![CDATA[
]]>
<![CDATA[		theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Total fields: " & oPage.NumOfChildren)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Dim oField]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 To oPage.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[			Set oField = oPage.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[      RecognizeField(oField)]]>
<![CDATA[
]]>
<![CDATA[			Set oField = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Next ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Recognition Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[		RecognizePageFields = True]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Public Function RecognizeField(oField)]]>
<![CDATA[
]]>
<![CDATA[		RecognizeField = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		If oField.Variable("y_sr") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Recognition of " & oField.ID & " is skipped by the settings.")]]>
<![CDATA[
]]>
<![CDATA[        RecognizeField = true]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[		ElseIf oField.Variable("Position") = "" OR oField.Variable("Position") = "0,0,0,0" Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Recognition of " & oField.ID & " is skipped because it doesn't have zones defined.")]]>
<![CDATA[
]]>
<![CDATA[        RecognizeField = true]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oField.Parent]]>
<![CDATA[
]]>
<![CDATA[		While (oPage.ImageName="")]]>
<![CDATA[
]]>
<![CDATA[			Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[		Wend]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("----- OCR/A field recognition of: " & oField.ID & ", " & oPage.ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug -3"]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[		If( Not(PreRecog(oPage)) ) Then WriteLog("Prerecog has failed.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug -2"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim theTime, oParams]]>
<![CDATA[
]]>
<![CDATA[		theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		SetZone(oField)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		'writelog "debug 1"]]>
<![CDATA[
]]>
<![CDATA[		Set SynthesisParamsForPage = Engine.CreateSynthesisParamsForPage]]>
<![CDATA[
]]>
<![CDATA[		Set ObjectsExtractionParams = Engine.CreateObjectsExtractionParams ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'ObjectsExtractionParams.FullTextIndexDA = true]]>
<![CDATA[
]]>
<![CDATA[    '.ObjectsExtractionParams.FlexiFormsDA = true]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not IsObject(m_oImageDoc) Then WriteLog("no image doc")]]>
<![CDATA[
]]>
<![CDATA[		If Not IsObject(SynthesisParamsForPage) Then WriteLog("no oParams")]]>
<![CDATA[
]]>
<![CDATA[		If Not IsObject(m_oLayout) Then WriteLog("no m_oLayout")]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 2"]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    'On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(m_oLayout.Blocks.Item(0).GetAsTextBlock()) Then]]>
<![CDATA[
]]>
<![CDATA[      'If oPage.Variable("DetectSmallCaps") = "0" Then SynthesisParamsForPage.DetectSmallCaps = FALSE]]>
<![CDATA[
]]>
<![CDATA[      'If oField.Variable("DetectSmallCaps") = "0" Then SynthesisParamsForPage.DetectSmallCaps = FALSE]]>
<![CDATA[
]]>
<![CDATA[      Call SetLanguageParameters(m_oLayout.Blocks.Item(0).GetAsTextBlock().RecognizerParams,oField)]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Engine.RecognizePage m_oImageDoc, SynthesisParamsForPage, ObjectsExtractionParams, m_oLayout, m_oDocInfo]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Err.Number <> 0  Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Recognition of " & oField.ID & " did not succeed because " & Err.Description]]>
<![CDATA[
]]>
<![CDATA[        Err.Clear]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 3"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		'Recog info]]>
<![CDATA[
]]>
<![CDATA[		Set Block = m_oLayout.Blocks.Item(0)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim sText, Paragraph, Paragraphs, CharParams, ExtendedRecAttributes]]>
<![CDATA[
]]>
<![CDATA[		Dim  previousBottom,previousTop, previousDefined, top, bottom]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    previousBottom = 0]]>
<![CDATA[
]]>
<![CDATA[    previousTop = 0]]>
<![CDATA[
]]>
<![CDATA[    previousDefined  = False]]>
<![CDATA[
]]>
<![CDATA[    top = 0]]>
<![CDATA[
]]>
<![CDATA[    bottom = 0]]>
<![CDATA[
]]>
<![CDATA[    newlineinserted = false]]>
<![CDATA[
]]>
<![CDATA[    'writelog "debug 4 - " & Block.Type]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Block.Type = 0 Then 'TextBlock]]>
<![CDATA[
]]>
<![CDATA[        oField.Clear]]>
<![CDATA[
]]>
<![CDATA[        strConfData = ""]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        l_LowConfThresh = m_LowConfThresh]]>
<![CDATA[
]]>
<![CDATA[        l_LowConfAdjust = m_LowConfAdjust]]>
<![CDATA[
]]>
<![CDATA[        l_NormalConfAdjust = m_NormalConfAdjust]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If IsNumeric(CurrentObj.Variable(m_LowConfThreshVar)) Then l_LowConfThresh = CInt(CurrentObj.Variable(m_LowConfThreshVar))]]>
<![CDATA[
]]>
<![CDATA[        If IsNumeric(CurrentObj.Variable(m_LowConfAdjustVar)) Then l_LowConfAdjust = CInt(CurrentObj.Variable(m_LowConfAdjustVar))]]>
<![CDATA[
]]>
<![CDATA[        If IsNumeric(CurrentObj.Variable(m_NormalConfAdjustVar)) Then l_NormalConfAdjust = CInt(CurrentObj.Variable(m_NormalConfAdjustVar))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        strConfData = "Confidence adjust settings: " & l_LowConfThresh & "," & l_LowConfAdjust & "," & l_NormalConfAdjust]]>
<![CDATA[
]]>
<![CDATA[        Set Block = Block.GetAsTextBlock]]>
<![CDATA[
]]>
<![CDATA[		    Set CharParams = Engine.CreateCharParams]]>
<![CDATA[
]]>
<![CDATA[		    Set Paragraphs = Block.Text.Paragraphs]]>
<![CDATA[
]]>
<![CDATA[		    nParagraph = Block.Text.Paragraphs.Count - 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		    For i = 0 To nParagraph]]>
<![CDATA[
]]>
<![CDATA[			    Set Paragraph = Paragraphs.Item(i)]]>
<![CDATA[
]]>
<![CDATA[			    sText = Paragraph.Text]]>
<![CDATA[
]]>
<![CDATA[          'Writelog "Paragraph text (direct from Engine) is " & sText]]>
<![CDATA[
]]>
<![CDATA[			    ]]>
<![CDATA[
]]>
<![CDATA[          For j = 0 To Paragraph.Length - 1]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[				    Paragraph.GetCharParams j, CharParams]]>
<![CDATA[
]]>
<![CDATA[				    conf = 1]]>
<![CDATA[
]]>
<![CDATA[				    Set ExtendedRecAttributes = CharParams.SelectedCharacterRecognitionVariant]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            strConfData = strConfData & chrW(13) & chrW(10)  & "Character: '" & Mid(sText, j + 1, 1) & "', ABBYY Confidence: "]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[				    If Not ExtendedRecAttributes Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[              conf = ExtendedRecAttributes.CharConfidence]]>
<![CDATA[
]]>
<![CDATA[              strConfData = strConfData & conf & ", Datacap Confidence: " & GetConfidence(conf,CharParams.IsSuspicious) & ", IsSuspicious: "  & CharParams.IsSuspicious]]>
<![CDATA[
]]>
<![CDATA[  				    conf = GetConfidence(conf,CharParams.IsSuspicious)]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[              'The following special characters do not have the extended recognition attributes:]]>
<![CDATA[
]]>
<![CDATA[              '0x2028 - Line break symbol. ]]>
<![CDATA[
]]>
<![CDATA[              '0xFFFC - Object replacement character. ]]>
<![CDATA[
]]>
<![CDATA[              '0x0009 - Tabulation. ]]>
<![CDATA[
]]>
<![CDATA[              '0x0020 - Space. ]]>
<![CDATA[
]]>
<![CDATA[              l_charCode = AscW(Mid(sText, j + 1, 1))]]>
<![CDATA[
]]>
<![CDATA[              If l_charCode = 9 OR l_charCode = 32 OR l_charCode = 8233 OR l_charCode = 8232 Then]]>
<![CDATA[
]]>
<![CDATA[                conf = 9]]>
<![CDATA[
]]>
<![CDATA[              End If]]>
<![CDATA[
]]>
<![CDATA[				    End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            top = CharParams.Top]]>
<![CDATA[
]]>
<![CDATA[            bottom = CharParams.Bottom]]>
<![CDATA[
]]>
<![CDATA[            If previousDefined Then]]>
<![CDATA[
]]>
<![CDATA[                If previousBottom < top AND newlineinserted = false Then]]>
<![CDATA[
]]>
<![CDATA[                    Set oDCOChar = oField.AddChild(4, "", -1)]]>
<![CDATA[
]]>
<![CDATA[                    oDCOChar.AddValue 10, 8]]>
<![CDATA[
]]>
<![CDATA[                    newlineinserted = true]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[            previousBottom = bottom]]>
<![CDATA[
]]>
<![CDATA[            previousTop = top]]>
<![CDATA[
]]>
<![CDATA[            previousDefined = true]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				    Set oDCOChar = oField.AddChild(4, "", -1)]]>
<![CDATA[
]]>
<![CDATA[				    oDCOChar.SetPosition CharParams.Left, CharParams.Top, CharParams.Right, CharParams.Bottom]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If AscW(Mid(sText, j + 1, 1)) = 8233 OR AscW(Mid(sText, j + 1, 1)) = 8232 OR AscW(Mid(sText, j + 1, 1)) = 8226 Then]]>
<![CDATA[
]]>
<![CDATA[				        If newlineinserted = false Then ]]>
<![CDATA[
]]>
<![CDATA[                  oDCOChar.AddValue 10, 8]]>
<![CDATA[
]]>
<![CDATA[                    newlineinserted = true]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[                'writelog "Adding character " & AscW(Mid(sText, j + 1, 1)) & " ------ " & Mid(sText, j + 1, 1)]]>
<![CDATA[
]]>
<![CDATA[                oDCOChar.AddValue AscW(Mid(sText, j + 1, 1)), conf]]>
<![CDATA[
]]>
<![CDATA[                newlineinserted = false]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[			    Next]]>
<![CDATA[
]]>
<![CDATA[		    Next]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If oField.Variable("dc_delSpace") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[            RemoveSpaces oField]]>
<![CDATA[
]]>
<![CDATA[        End If  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If CurrentObj.Variable(m_DebugConfVar) <> "" Then]]>
<![CDATA[
]]>
<![CDATA[          Writelog "---------------- CONFIDENCE DETAILS ---------------------"]]>
<![CDATA[
]]>
<![CDATA[          Writelog strConfData ]]>
<![CDATA[
]]>
<![CDATA[          Writelog "-------------- END CONFIDENCE DETAILS ---------------------"]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Recognized field text is " & oField.Text]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    ElseIf Block.Type = 5 Then 'Checkmark group]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "CheckmarkGroup block type found"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        sText = ""]]>
<![CDATA[
]]>
<![CDATA[        sConf = ""]]>
<![CDATA[
]]>
<![CDATA[        nChecked = 0]]>
<![CDATA[
]]>
<![CDATA[        Set Block = Block.GetAsCheckmarkGroup()]]>
<![CDATA[
]]>
<![CDATA[        For iCheck=0 to Block.Count-1]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[            Set Checkmark =  Block.GetAsCheckmarkGroup.Item(iCheck)]]>
<![CDATA[
]]>
<![CDATA[            Writelog "Checkmark state " & iCheck & ": " & Checkmark.CheckmarkState]]>
<![CDATA[
]]>
<![CDATA[            If 1 = Checkmark.CheckmarkState Then'Checked]]>
<![CDATA[
]]>
<![CDATA[                nChecked = nChecked + 1]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                If CurrentObj.Variable("MultiPunch") <> "1" And nchecked > 1 Then]]>
<![CDATA[
]]>
<![CDATA[                  sText = sText & "0"]]>
<![CDATA[
]]>
<![CDATA[                  sConf = sConf & "1"]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[                  If CheckMark.IsSuspicious Then]]>
<![CDATA[
]]>
<![CDATA[                    sConf = sConf & "1"]]>
<![CDATA[
]]>
<![CDATA[                  Else]]>
<![CDATA[
]]>
<![CDATA[                    sConf = sConf & "9"]]>
<![CDATA[
]]>
<![CDATA[                  End If]]>
<![CDATA[
]]>
<![CDATA[                  ]]>
<![CDATA[
]]>
<![CDATA[                  sText = sText & "1"]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[                sText = sText & "0"]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                If CheckMark.IsSuspicious Then]]>
<![CDATA[
]]>
<![CDATA[                  sConf = sConf & "1"]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[                  sConf = sConf & "9"]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[        Next]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Text = sText]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.ConfidenceString = sConf]]>
<![CDATA[
]]>
<![CDATA[        Writelog("  ") ]]>
<![CDATA[
]]>
<![CDATA[	      Writelog("Text Value:        " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[	      Writelog("ConfidenceString:  " & CurrentObj.ConfidenceString)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    ElseIf Block.Type = 3 Then 'Barcode]]>
<![CDATA[
]]>
<![CDATA[        oField.Clear]]>
<![CDATA[
]]>
<![CDATA[        'writelog "debug barcode found"]]>
<![CDATA[
]]>
<![CDATA[        Dim lLeft, lRight,lTop,lBottom]]>
<![CDATA[
]]>
<![CDATA[        Dim BarcodeBlock]]>
<![CDATA[
]]>
<![CDATA[        Set BarcodeBlock = Block.GetAsBarcodeBlock()]]>
<![CDATA[
]]>
<![CDATA[        'writelog "debug barcode found 2"]]>
<![CDATA[
]]>
<![CDATA[        lleft = BarcodeBlock.BarcodeText.Item(0).Left]]>
<![CDATA[
]]>
<![CDATA[        ltop = BarcodeBlock.BarcodeText.Item(0).Top]]>
<![CDATA[
]]>
<![CDATA[        'writelog "debug barcode found 3"]]>
<![CDATA[
]]>
<![CDATA[        lright = BarcodeBlock.BarcodeText.Item(BarcodeBlock.BarcodeText.Count-1).Right]]>
<![CDATA[
]]>
<![CDATA[        lbottom = BarcodeBlock.BarcodeText.Item(BarcodeBlock.BarcodeText.Count-1).Bottom]]>
<![CDATA[
]]>
<![CDATA[        'writelog "debug barcode found 4"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If "1" = oField.Variable("y_bNoAtisk") Then]]>
<![CDATA[
]]>
<![CDATA[          oField.Text = BarcodeBlock.Text]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[          oField.Text = RemoveStartEndAsterisks(BarcodeBlock.Text)]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[        'writelog "debug barcode found 5"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        oField.SetPosition lleft,ltop,lright,lbottom]]>
<![CDATA[
]]>
<![CDATA[        oField.Variable("Barcode" ) = oField.Text]]>
<![CDATA[
]]>
<![CDATA[        oField.Variable("Barcode" & "Type") = BarcodeBlock.BarcodeType]]>
<![CDATA[
]]>
<![CDATA[        'oField.Variable("Barcode" & "Orientation") = BarcodeBlock.BarcodeText.Item(0).Orientation]]>
<![CDATA[
]]>
<![CDATA[        oField.Variable("Barcode" & "Position") = lLeft & "," &  lTop &  "," &  lRight &  "," & lBottom]]>
<![CDATA[
]]>
<![CDATA[        oField.Variable("Barcode" & "SupplementType") = BarcodeBlock.SupplementType]]>
<![CDATA[
]]>
<![CDATA[        oField.Variable("Barcode" & "SupplementValue") = BarcodeBlock.SupplementValue]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Barcode " & "text: " & oField.Variable("Barcode")]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Unhandled block type found: " & Block.Type]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Recognition Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		RecognizeField = True]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Private Function CharVote(chrCode, nLeft, nTop, nRight, nBottom, oField)]]>
<![CDATA[
]]>
<![CDATA[		CharVote = False]]>
<![CDATA[
]]>
<![CDATA[		For nChar = 0 To oField.NumOfChildren()-1]]>
<![CDATA[
]]>
<![CDATA[			Set oDCOChar = oField.GetChild(nChar)]]>
<![CDATA[
]]>
<![CDATA[			If(oDCOChar.ObjectType=4)	Then 'char]]>
<![CDATA[
]]>
<![CDATA[				oDCOChar.GetPosition nLeft1, nTop1, nRight1, nBottom1 ]]>
<![CDATA[
]]>
<![CDATA[				If(IsHugeOverlapped(nLeft1, nTop1, nRight1, nBottom1, nLeft, nTop, nRight, nBottom)) Then 'Raise the confidence if charcode is the same]]>
<![CDATA[
]]>
<![CDATA[					If(oDCOChar.CharValue(0) = chrCode) Then ]]>
<![CDATA[
]]>
<![CDATA[						If (oDCOChar.CharConfidence(0) < 9) Then ]]>
<![CDATA[
]]>
<![CDATA[							oDCOChar.CharConfidence(0) = 9]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							oDCOChar.CharConfidence(0) = 10]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[					CharVote = True]]>
<![CDATA[
]]>
<![CDATA[					Exit Function]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[		CharVote = False]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Public Function RecognizeFieldVote(oField)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    RecognizeFieldVote = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		If oField.Variable("y_sr") = "1" Or oField.Variable("RecogType") = "4" Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Recognition of " & oField.ID & " is skipped by the settings.")]]>
<![CDATA[
]]>
<![CDATA[        RecognizeFieldVote = true]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[		ElseIf oField.Variable("Position") = "" OR oField.Variable("Position") = "0,0,0,0" Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Recognition of " & oField.ID & " is skipped because it doesn't have zones defined.")]]>
<![CDATA[
]]>
<![CDATA[        RecognizeFieldVote = true]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Create a temporary copy of the field before the recognition since it will be overridden]]>
<![CDATA[
]]>
<![CDATA[    Dim l_oTmpDCO]]>
<![CDATA[
]]>
<![CDATA[    Dim l_oOrigField]]>
<![CDATA[
]]>
<![CDATA[    Dim theTime]]>
<![CDATA[
]]>
<![CDATA[	  theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpDCO = CreateObject("TDCO.Batch")]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpDCO = l_oTmpDCO.AddChild(0,"tmpbatch",-1)	]]>
<![CDATA[
]]>
<![CDATA[    Set l_oOrigField = l_oTmpDCO.AddChild(3,"tmpfield",-1)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_oOrigField.XML = CurrentObj.XML]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    RecognizeField oField]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If l_oOrigField.Text = "" Or oField.Text = "" Then]]>
<![CDATA[
]]>
<![CDATA[      'if the field is empty then ignore the vote, and store the recognition results in the field's Text property]]>
<![CDATA[
]]>
<![CDATA[       Writelog "Field is empty. Voting skipped."]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      'If a previous recognition engine / or user had entered data into the field, then preserver the first value and ]]>
<![CDATA[
]]>
<![CDATA[      'perform the voting (modify confidence string)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Dim l_oDCOChar]]>
<![CDATA[
]]>
<![CDATA[      Dim l_oDCOChar2]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      For nChar = 0 To l_oOrigField.NumOfChildren()-1]]>
<![CDATA[
]]>
<![CDATA[			    Set l_oDCOChar = l_oOrigField.GetChild(nChar)]]>
<![CDATA[
]]>
<![CDATA[          Set l_oDCOChar2 = oField.GetChild(nChar) ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If l_oDCOChar2 Is Nothing Then Exit For]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  		    If(l_oDCOChar.ObjectType=4)	Then 'char]]>
<![CDATA[
]]>
<![CDATA[  			      Writelog "Comparing " & l_oDCOChar.CharValue(0) & " and " & l_oDCOChar2.CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[              If(l_oDCOChar.CharValue(0) = l_oDCOChar2.CharValue(0)) Then ]]>
<![CDATA[
]]>
<![CDATA[                  Writelog "Characters match!"]]>
<![CDATA[
]]>
<![CDATA[						      If (l_oDCOChar.CharConfidence(0) < 9) Then ]]>
<![CDATA[
]]>
<![CDATA[                      Writelog "Setting character confidence to 9."]]>
<![CDATA[
]]>
<![CDATA[							        l_oDCOChar.CharConfidence(0) = 9]]>
<![CDATA[
]]>
<![CDATA[						      Else]]>
<![CDATA[
]]>
<![CDATA[                      Writelog "Setting confidence to 10"]]>
<![CDATA[
]]>
<![CDATA[							        l_oDCOChar.CharConfidence(0) = 10]]>
<![CDATA[
]]>
<![CDATA[                  End If]]>
<![CDATA[
]]>
<![CDATA[					    End If]]>
<![CDATA[
]]>
<![CDATA[			    End If]]>
<![CDATA[
]]>
<![CDATA[		  Next]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      oField.Text = l_oOrigField.Text]]>
<![CDATA[
]]>
<![CDATA[      oField.ConfidenceString = l_oOrigField.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Set l_oOrigField = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Set l_oTmpDCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		RecognizeFieldVote = True]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Public Function CatchError(strError)]]>
<![CDATA[
]]>
<![CDATA[		CatchError= False]]>
<![CDATA[
]]>
<![CDATA[		If Err.number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[			If strError<>"" Then err.description = strError]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Error #" & CStr(Err.number) & ": " & err.description)]]>
<![CDATA[
]]>
<![CDATA[			CatchError = True]]>
<![CDATA[
]]>
<![CDATA[			nTaskStatus=RetAbort ]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Err.Clear    ' Clear the error.]]>
<![CDATA[
]]>
<![CDATA[		'On Error GoTo 0]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[End Class 'CABBYYRecognition]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<af name="EnableEngineLogsOCR_A" access="public" bInter="bInter" bDebug="bDebug" qi="Enables ABBYY Engine logging.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action enables ABBYY Engine logging. The log file is created in the batch folder with the name "engine.log"]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        RecognizePageOCR_A()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[EnableEngineLogsOCR_A()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This sequence creates a log file in the batch folder with the name "engine.log"]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Any level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if logging is successfully enabled.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	EnableEngineLogsOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	EnableEngineLogsOCR_A = oABBYYRecognition.EnableLogs]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="SetConfCalculationParamsOCR_A" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Specifies the values to use for ABBYY->Datacap confidence mapping.">
		<ap>
<![CDATA[
]]>
<![CDATA[      The M and C values for the following formula ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Datacap Confidence = MAX(10, (M/100) * (ABBYY Confidence + C))]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The default values for M is 10. The default value for C is 60.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Specifies the values to use for ABBYY->Datacap confidence mapping.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetConfCalculationParamsOCR_A(0.1,70)]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Any level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if both parameters are not passed or are not numeric.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    SetConfCalculationParamsOCR_A = FALSE]]>
<![CDATA[
]]>
<![CDATA[    Dim sParams]]>
<![CDATA[
]]>
<![CDATA[    sParams = Split(strParam,",")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If UBound(sParams) < 1 Then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog "This action requires two parameters. Exiting"]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If Not IsNumeric(sParams(0)) Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Both parameters have to be numeric. Exiting"]]>
<![CDATA[
]]>
<![CDATA[      ElseIf Not IsNumeric(sParams(1)) Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Both parameters have to be numeric. Exiting"]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        m_ConfM = CInt(sParams(0))]]>
<![CDATA[
]]>
<![CDATA[        m_confC = CInt(sParams(1))]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Confidence mapping formula is MAX(10, (M/100) * (ABBYY Confidence + C))"]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Where M is " & m_ConfM]]>
<![CDATA[
]]>
<![CDATA[        Writelog "And C is " & m_ConfC]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        SetConfCalculationParamsOCR_A = TRUE]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizePageOCR_A" access="public" bInter="bInter" bDebug="bDebug" qi="Refers to settings in the OCR/A tab of the Recognition Options Setup dialog to recognize all characters on a page, and populates the page's Fingerprint file (.cco) with the recognition results.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action responds to settings in the OCR/A tab of the Recognition Options Setup dialog to recognize]]>
<![CDATA[
]]>
<![CDATA[      all characters on a page, and populates the page's CCO file with the recognition results.]]>
<![CDATA[
]]>
<![CDATA[      If a CCO file does not exist at the time this action is called, the action will create one.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RotateImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageOCR_A()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This sequence creates a CCO file for the current page, and checks to see if rotation of]]>
<![CDATA[
]]>
<![CDATA[        the image is needed.  Full-page recognition then takes place in response to settings in]]>
<![CDATA[
]]>
<![CDATA[        the OCR/A tab of the Recognition Options Setup dialog.]]>
<![CDATA[
]]>
<![CDATA[        The recognition results are stored in the CCO file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("This action must be called at the page level. Exiting...") : Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageOCR_A = oABBYYRecognition.RecognizePage(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If UpdateCCO Then]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("v_ccoNormOFF") <> "1" Then]]>
<![CDATA[
]]>
<![CDATA[          NormalizeCCO false,false]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizePageFieldsOCR_A" access="public" bInter="bInter" bDebug="bDebug" qi="A page-level action that recognizes all fields on the page that have been configured for OCR/A recognition (see the OCR/A tab of the Recognition Options Setup dialog.) ">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This page-level action recognizes all fields on the page that have been configured for OCR/A]]>
<![CDATA[
]]>
<![CDATA[      recognition (see the OCR/A tab of the Recognition Options Setup dialog.) ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Note:]]>
			</b>
<![CDATA[Individual field-level recognition actions will overwrite the results from this]]>
<![CDATA[
]]>
<![CDATA[      page-level action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The action will not recognize a zoned field if the Skip Recognition checkbox in the OCR/A]]>
<![CDATA[
]]>
<![CDATA[      tab of the Recognition Options Setup dialog has been selected.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ReadZones()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageFieldsOCR_A()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[      Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageFieldsOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("This action must be called at the page level. Exiting...") : Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageFieldsOCR_A =  oABBYYRecognition.RecognizePageFields(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizeFieldOCR_A" access="public" bInter="bInter" bDebug="bDebug" qi="A field-level action that retrieves a zoned field's settings from the OCR/A tab of the Recognition Options Setup dialog, and uses these settings to recognize the field's value.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This field-level action retrieves a zoned field's settings from the OCR/A tab of the]]>
<![CDATA[
]]>
<![CDATA[      Recognition Options Setup dialog, and uses these settings to recognize the field's value.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        TaxpayerSSN Rule 1]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeFieldOCR_A()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        In the example, the rule uses]]>
<![CDATA[
]]>
<![CDATA[        the action to retrieve and apply settings in the OCR/A tab of the Recognition Options]]>
<![CDATA[
]]>
<![CDATA[        Setup dialog, settings that have been previously assigned to a Document Hierarchy's zoned field.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[      Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeFieldOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType<>3) Then WriteLog("This action must be called at the field level. Exiting...") : Exit Function	'must be a field]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	RecognizeFieldOCR_A = oABBYYRecognition.RecognizeField(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizeBarcodeOCR_A" access="public" bInter="bInter" bDebug="bDebug" qi="A field/page level action that retrieves barcodes.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      A field/page level action that retrieves barcodes.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        TaxpayerSSN Rule 1]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeBarcodeOCR_A]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Field and Page levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[object or ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[ object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[      Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeBarcodeOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType=3) Then]]>
<![CDATA[
]]>
<![CDATA[     InitABBYY]]>
<![CDATA[
]]>
<![CDATA[     CurrentObj.Variable("y_fType") = "3" ]]>
<![CDATA[
]]>
<![CDATA[     RecognizeBarcodeOCR_A = oABBYYRecognition.RecognizeField(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  ElseIf (CurrentObj.ObjectType=2) Then]]>
<![CDATA[
]]>
<![CDATA[     InitABBYY]]>
<![CDATA[
]]>
<![CDATA[     RecognizeBarcodeOCR_A = oABBYYRecognition.GetBarcodes(CurrentObj) ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("This action must be called at the field or page level. Exiting...")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeBarcodeOCR_A = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizeFieldVoteOCR_A" access="public" bInter="bInter" bDebug="bDebug" qi="A field-level action that initiates a voting procedure that first uses specifications in the OCR/A tab of the Recognition Options Setup dialog to recognize the field's characters.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This field-level action initiates a voting procedure that first uses specifications in the OCR/A tab]]>
<![CDATA[
]]>
<![CDATA[      of the Recognition Options Setup dialog to recognize the field's characters. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When this action stores the results of recognition, it first determines if the corresponding]]>
<![CDATA[
]]>
<![CDATA[      Field object of the Document Hierarchy contains a value. If a value is present, the action]]>
<![CDATA[
]]>
<![CDATA[      compares the field's existing value with the recognition results - character by character.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If a particular character's values match, the Confidence Rating for the character is raised to the maximum]]>
<![CDATA[
]]>
<![CDATA[      level.  If the values do not match, the Confidence Rating for the character is lowered to the minimum.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Note that when using this voting procedure, the second Recognition engine is secondary and]]>
<![CDATA[
]]>
<![CDATA[      its results are never assigned.  Instead, the action changes the Confidence Ratings on the basis of]]>
<![CDATA[
]]>
<![CDATA[      results provided by the first Recognition engine. If there are no recognition results previous to]]>
<![CDATA[
]]>
<![CDATA[      this action, it will act just like the ]]>
			<b>
<![CDATA[RecognizeFieldOCR_A]]>
			</b>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        RecognizeFieldICR_C()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeFieldVoteOCR_A()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[      Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeFieldVoteOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>3) Then WriteLog("This action must be called at the field level. Exiting...") : Exit Function	'must be a field]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[	RecognizeFieldVoteOCR_A = oABBYYRecognition.RecognizeFieldVote(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RotateImageOCR_A" access="public" bInter="bInter" bDebug="bDebug" qi="">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action checks if the scanned Image file needs to be rotated by 90, 180, or 270 degrees to be in the upright position.  If rotation is necessary, the action saves the Image file]]>
<![CDATA[
]]>
<![CDATA[      in the new, correct position.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RotateImageOCR_A()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage()]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[ object of the]]>
<![CDATA[
]]>
<![CDATA[      Document Hierarchy, or if the action cannot locate the Image file representing the current page.]]>
<![CDATA[
]]>
<![CDATA[      Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  RotateImageOCR_A = True]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Image rotation is skipped: image file does not exist.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  writelog "Rotating image " & CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[  oABBYYRecognition.RotateImage(CurrentObj.ImageName)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="SetAutoRotationOCR_A" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="This action set to False turns off automatic image orientation detection and rotation.">
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True:]]>
			</b>
<![CDATA[ Forces image orientation detection and rotation.  This is the default value.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False:]]>
			</b>
<![CDATA[ Image orientation and rotation will not be performed.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action set to True forces image orientation detection and rotation.  If this action is not called, the value will]]>
<![CDATA[
]]>
<![CDATA[      default to True.  If used, this action must be called prior to recognition and both actions must be called at the same level.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetAutoRotationOCR_A("True")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RecognizePageOCR_A]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	SetAutoRotationOCR_A = True]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("y_AutoRotate") = StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizeToPDFOCR_A" access="public" bInter="bInter" bDebug="bDebug" qi="Converts a scanned Images (.tif) to an Adobe Portable Document Format (PDF) file.">
		<ap>
<![CDATA[
]]>
<![CDATA[      None.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Converts a scanned Images (.tif) to an Adobe Portable Document Format (PDF) file.  The PDF is searchable as it also]]>
<![CDATA[
]]>
<![CDATA[      includes the text as read directly by the recognition engine.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When placed at page level, the action recognizes and converts the current tif page to a pdf file and a cco for the page is created.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When placed at document level, the action recognizes and converts all tif pages in the existing doc into one]]>
<![CDATA[
]]>
<![CDATA[      pdf file.  A .cco is created for each page in the document.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeToPDFOCR_A()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Document or Page Level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if called at an invalid level.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeToPDFOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType <> 2 And CurrentObj.ObjectType <> 1) Then Writelog("This action must be called at the document or page level. Exiting...") : Exit Function	'must be at least a page ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  'Writelog "pdf recognition"]]>
<![CDATA[
]]>
<![CDATA[	RecognizeToPDFOCR_A = oABBYYRecognition.RecognizeToPDF(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="SetFastModeOCR_A" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="This action set to TRUE provides 2-2.5 times faster recognition speed at the cost of a moderately increased error rate (1.5-2 times more errors).">
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True:]]>
			</b>
<![CDATA[ Enables "Fast Mode" which sacrifices recognition quality over speed.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False:]]>
			</b>
<![CDATA[ Disables "Fast Mode" causing the recognition to run slower, but provides more accurate results.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If no parameter is specified, the value defaults to False.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action set to TRUE provides 2-2.5 times faster recognition speed at the cost of a moderately]]>
<![CDATA[
]]>
<![CDATA[      increased error rate (1.5-2 times more errors).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      It is recommended to disable fast mode if you are performing field level recognition because]]>
<![CDATA[
]]>
<![CDATA[      you will sacrifice quality yet see negligible speed increase at the field level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If you use this action, it must be called prior to recognition.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetFastModeOCR_A("True")]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	SetFastModeOCR_A = True]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("y_FastMode") = strParam]]>
<![CDATA[
]]>
<![CDATA[	SetFastModeOCR_A = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="ReleaseEngineOCR_A" access="public" bInter="bInter" bDebug="bDebug" qi="This action releases the ABBYY engine.">
		<h>
<![CDATA[
]]>
<![CDATA[      This action releases the ABBYY engine.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ReleaseEngineOCR_A()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	ReleaseEngineOCR_A = True]]>
<![CDATA[
]]>
<![CDATA[  If IsAlive(oABBYYRecognition) Then Set oABBYYRecognition = Nothing]]>
<![CDATA[
]]>
<![CDATA[	ReleaseEngineOCR_A = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="OCRA_ConvertImage2BW" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="This action converts a Color or Grayscale image to Black and White.">
		<ap>
<![CDATA[
]]>
<![CDATA[      The file extension that the action is to assign to the backup of the original Image file.]]>
<![CDATA[
]]>
<![CDATA[      For example: tio]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The extension should be 3 or 4 alphanumeric characters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action converts a Color or Grayscale image to Black and White.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[OCRA_ConvertImage2BW()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False ]]>
			</b>
<![CDATA[ if called at a level other than the Page.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the parameter is not 3 or 4 alphanumeric characters.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	OCRA_ConvertImage2BW = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType <> 2 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "This action can only be called at the page level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sFiltered = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	sResult = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For n = 1 To Len(sFiltered)]]>
<![CDATA[
]]>
<![CDATA[		char = Mid(sFiltered,n,1)]]>
<![CDATA[
]]>
<![CDATA[		If (AscW(char)>=48 And AscW(char)<=57) Or (AscW(char)>=65 And AscW(char)<=90) Or (AscW(char)>=97 And AscW(char)<=122) Then]]>
<![CDATA[
]]>
<![CDATA[			sResult = sResult & Mid(sFiltered,n,1)]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'char]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If len(sResult)<3 or len(sResult)>4 then ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Parameter must be 3 or 4 alphanumeric characters.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("Save original file with extension: '" & sResult & "' ")	]]>
<![CDATA[
]]>
<![CDATA[    oABBYYRecognition.ConvertToBW CurrentObj.ImageName,sResult  ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	OCRA_ConvertImage2BW = True ]]>
<![CDATA[
]]>
<![CDATA[  oABBYYRecognition.CatchError("") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
</rrx>
<rrx namespace="OCR_s" v="8.1.0.17">
	<i ref="rrunner">
	</i>
	<i ref="recog_shared">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' OCR_S Actions]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['IBM InfoSphere Classification Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.03" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	-  Charachter position TWIPS -> Pixels]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.04" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- OMR skips new line]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.05" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- AutoRotate, OMR, PDF conversion, requesting abort if the image is missing]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.07" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- RecognizeDocToPDF]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.08" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- RotateImage is added]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.09" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- CorrectSinglePunch condition corrected]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.10" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- Stop is removed from RotateImage]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.11" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- Skip last charachter in afield if it's a line termination]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.12" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- RecognizeDoc2PDF : FileName is corrected]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.13" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- RecognizeToFile_OCR_S is added]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.14" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- SetZone uses oDCO.Variable other then oDCO.SetupNode.Variable]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.2.01" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- Inversion is OFF while rotating image]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.2.02" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/17/2007 NSK]]>
<![CDATA[
]]>
<![CDATA['	- RecogniceDoc2PDF: help text corrected per SPR 19242]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.2.03" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/12/08 TScholl]]>
<![CDATA[
]]>
<![CDATA[' * Information tags for RecognizeDocToPDF, RecognizeFieldOCR_S, RecognizeFieldVoteOcr_S, RecognizeOM_OCR_OS, RecognizePageFieldsOCR_S, ]]>
<![CDATA[
]]>
<![CDATA['	  RecognizePage_OCR_S,RecognizeToPDF, RecognizeToFile_OCR_S, RotateImge]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.04" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/12/2008 TScholl]]>
<![CDATA[
]]>
<![CDATA[' * Fixed syntax issues introduced in version 7.2.03]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.05" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/04/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   - Uses DCOCRS.Net recognition engine wrapper]]>
<![CDATA[
]]>
<![CDATA['   - Implements the option to use DCOProcessor when making calls to the recognition engine]]>
<![CDATA[
]]>
<![CDATA['   - Enabled actions SetLegacyDecompositionOCR_S and SetFastTradeOFFOCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.6" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/29/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   - Implements DCOPRocessor errors, hangs and recovery by making calls to DCOProcessorExecute helper function from Recog_Shared.rrx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/05/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   - Full Page Recognition action now invokes the "NormalizeCCO" (from cco2cco.rrx) action Tto ensure compatibility between CCOs when ]]>
<![CDATA[
]]>
<![CDATA['     these are produced by different recognition engines.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/12/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   - Fixed issue where the recognition error handler in full page recognition would cause an error when calling NormalizeCCO.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/12/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['   - Action ReleaseEngine now only gets invoked within the context of DCOProcessor. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/14/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Actions updated to use the latest DCOProcessorExecute helper function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/14/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated calls to the engine wrapper that now take XML as parameter. All actions affected.]]>
<![CDATA[
]]>
<![CDATA[' Helper function "ReleaseEngine" has been removed. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/23/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixed issue with OMR Field recognition (SPR 22781)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/02/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Full Page Recongition now resets the BOTTOM property of the CCO object after it has been normalized.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/12/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added new action "SetEngineTimeout" which takes a numeric parameter, in seconds. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/18/2008]]>
<![CDATA[
]]>
<![CDATA['  - InitOCRS helper function now initilizes DCOProcessor if it is not alive (when DCOProcessor is turned ON - default)]]>
<![CDATA[
]]>
<![CDATA['  - All recognition actions, including AutoRotate now store recognition status at the current object level ("RecogStatus"). Always returning "TRUE", but set abort status when recog fails - unless ConitnueOnFailure is used. ]]>
<![CDATA[
]]>
<![CDATA['  - If UseOutOfProcessRecog is ON, then any engine failure is be treated the same as engine hang (DCOProcessor timeout), in the sense that we will kill the engine, wait for the delay, and either retry the operation or (if RecogContinueOnFailure is ON) return.  If RecogContinueOnFailure is ON we dont retry the operation automatically regardless of the type of failure (engine error, engine timeout, or engine hung causing DCOProcessor timeout).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/22/2008]]>
<![CDATA[
]]>
<![CDATA['  - RotateImage always returns TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/23/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added RRA-specific string parsing handler. Fixes issue where recognition would not succeed in RRA.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/23/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Now using helper function SetParentObjectXML to handle special RRA\RRX XML parsing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/23/2008 TScholl]]>
<![CDATA[
]]>
<![CDATA['  - Adds Information for the SetEngineTimeout action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/25/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Batch aborts now happen immediately when set programmatically. Fixes the issue where a recognition actions sets the batch to abort, but the batch is only aborted after the ruleset runs. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/27/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' RecognizePageFields modified to handle the new recognition result statuses returned by the OCRS engine wrapper]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.22"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/29/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - SetEngineTimeout action now storing the timeout in the global g_iOCRSEngineTimeout w/wo DCOProcessor ON.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.23"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/02/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Actions "RecognizeFieldOCR_S", and "RecognizePageFields2CCOOCR_S" modify to pass only the field's xml to the engine wrapper when performing recognition.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.24"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/09/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Field level recognition actions now check for a valid XML result returned by the engine wrappers. Fixes issues where a DCOProcessor timeout will corrupt the a field's XML causeing the batch to abort.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.25"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/13/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' RecognizeFieldOCR_S and RecognizePageFields2CCOOCR_S modified to call IN_OUT_RECOG_PROCESS_EXECUTE_RETRY when retrying instead of IN_OUT_RECOG_PROCESS_EXECUTE. Solves the issue where]]>
<![CDATA[
]]>
<![CDATA[' a retry would take place without restarting DCO processor.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.26"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/13/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['- Fixes the issue causing RecognizePageFieldsOCR_S to abort everytime it was called (invalid conversion from string to int). ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.27"]]>
<![CDATA[
]]>
<![CDATA['Updated 11/11/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Recognition actions now log the return code description in addition to the return code value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.28"]]>
<![CDATA[
]]>
<![CDATA['Updated 1/7/2009 TPeters]]>
<![CDATA[
]]>
<![CDATA['Added "This action is not for use when processing handprinted documents; it is only intended for use on machine printed documents." to RecognizeDocToPDF Action help]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.29"]]>
<![CDATA[
]]>
<![CDATA['Updated 02/18/2009]]>
<![CDATA[
]]>
<![CDATA['Made the action "RecognizeOM_OCR_S" private]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.30"]]>
<![CDATA[
]]>
<![CDATA['Updated 02/18/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Action RotateImage now calls AnalyzeImage after the second attempt to rotate an image succeeds. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.31"]]>
<![CDATA[
]]>
<![CDATA['Updated 03/26/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 23540 Clarified parameters for RecognizeDocToPDF.  Cleaned up the help text for all the ]]>
<![CDATA[
]]>
<![CDATA[' actions and made formatting more consistent. ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.32"]]>
<![CDATA[
]]>
<![CDATA['Updated 03/26/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 20508 Fixed a few typos in the help text. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.33"]]>
<![CDATA[
]]>
<![CDATA['Updated 06/02/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 19745 Added G tags to make the XML format more compliant and help with editing.  ]]>
<![CDATA[
]]>
<![CDATA[' Minor help formatting fixes and modified some help text.  Requires the new buildvbs.rls 1.0.2.2. ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/23/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' 22141 Field level recognition actions now check for the flag to remove spaces post recognition. If this flag is set]]>
<![CDATA[
]]>
<![CDATA['       spaces are removed.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.2"]]>
<![CDATA[
]]>
<![CDATA['Updated 08/10/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 23540 Fixed two typos in the help for RecognizePageOCR_S_2TextFile and RotateImage.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.3" ]]>
<![CDATA[
]]>
<![CDATA['Updated 12/07/09 JMartinez]]>
<![CDATA[
]]>
<![CDATA['26920 Fixes abort when calling RecognizeFieldOCR_S with the flag (cause by invalid variable name)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.4" ]]>
<![CDATA[
]]>
<![CDATA['Updated 03/25/10 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Fixes syntax error introduced in version 8.0.3]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.5" ]]>
<![CDATA[
]]>
<![CDATA['Updated 07/19/10 RFerin]]>
<![CDATA[
]]>
<![CDATA['SPR 28110 Update RotateImage help text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.6"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/13/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['RecognizePageFieldsOCR_S now forces the datafile to be written before the call to recognition. Handles issue where datafile is not be updated]]>
<![CDATA[
]]>
<![CDATA['prior to recognition, causing recognition to return empty results.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.7"]]>
<![CDATA[
]]>
<![CDATA['Updated 12/03/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['RecognizePageFieldsOCR_S now populates the page object DATAFILE object when it is empty or does not exist yet at the page level. Solves issue]]>
<![CDATA[
]]>
<![CDATA['where writing out the datafile fails because the DATAFILE variable is not yet populated at the time that RecognizePageFieldsOCR_S is called, resulting]]>
<![CDATA[
]]>
<![CDATA['in empty recognition results.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/07/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/10/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' RecognizeFieldVoteOCR_S : fixes the issue that would cause a batch to abort, if the voting recognition results contain less characters than the ]]>
<![CDATA[
]]>
<![CDATA[' recognition results returned by the pre-voting recognition engine.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/07/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Corrected help text for the action RecognizeDocToPDF.]]>
<![CDATA[
]]>
<![CDATA[' Updated RecognizeDocToPDF to handle parameter 5. This was to make the actions RecognizeToPDF and RecognizeDocToPDF consistent.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/01/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes issue where the action RecognizePageFields2CCO_OCR_S would not update the CCO after the field characters are added.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/23/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Moved action information from the qi= tag to the standard action help section]]>
<![CDATA[
]]>
<![CDATA[' Added IBM Copyright notice]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/18/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' 31991 Updated help text for action RecognizeToFile_OCR_S to. This action can be called only at the Document or Page level.]]>
<![CDATA[
]]>
<![CDATA[' 32483 Updated help text for action RecognizePageFields2CCO_OCR_S, RecognizeToPDF, and RecognizeDocToPDF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/04/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for actions RecognizeToPDF, RecognizeDocToPDF, and RecognizeToFile_OCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/15/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes issue in the action RecognizeToFile_OCR_S that would cause it to skip recognition and return false when called at the correct (supported) DCO levels (Document and Page). ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/16/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action RecognizeToFile_OCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/11/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Solves issue where Locale information would not persist all the way through to the engine wrapper.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['--------------------------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' LOG RRA VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("OCR_S " & Version)]]>
<![CDATA[
]]>
<![CDATA['********************************************************************]]>
<![CDATA[
]]>
<![CDATA[On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Global entries ---------------------------------------------------->]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim goOCR_S_Recognition]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<af name="SetEngineTimeout" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[value indicating the number of seconds to wait to determine that an OCR/S recognition]]>
<![CDATA[
]]>
<![CDATA[      action has stalled or exited.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action sets the number of seconds to wait before assuming an OCR/S recognition action is no longer]]>
<![CDATA[
]]>
<![CDATA[      running correctly. When the timeout is reached, the recognition process is removed from memory.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[SetEngineTimeout]]>
			</b>
<![CDATA[only has an effect if out-of-process recognition is enabled by the use of]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[UseOutOfProcessRecog]]>
			</b>
<![CDATA[, and if OCR/S recognition is being used.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If a recognition action does not complete within the specified number of seconds indicated by a]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[SetOutOfProcessRecogTimeout]]>
			</b>
<![CDATA[action or a ]]>
			<b>
<![CDATA[SetEngineTimeout]]>
			</b>
<![CDATA[action, it is assumed that the]]>
<![CDATA[
]]>
<![CDATA[      recognition engine has encountered a severe error, is removed from memory, and recognition will]]>
<![CDATA[
]]>
<![CDATA[      automatically be re-started one more time. If the recognition action completes successfully within]]>
<![CDATA[
]]>
<![CDATA[      the specified time on either the first or second attempt, that recognition action will be successful.]]>
<![CDATA[
]]>
<![CDATA[      If the recognition action does not complete by the specified time on the second attempt, the recognition]]>
<![CDATA[
]]>
<![CDATA[      action will be set to abort if ]]>
			<b>
<![CDATA[RecogContinueOnFailure(False)]]>
			</b>
<![CDATA[was used.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If ]]>
			<b>
<![CDATA[SetEngineTimeout]]>
			</b>
<![CDATA[is not called, the default value of 180 seconds will be used. In normal]]>
<![CDATA[
]]>
<![CDATA[      conditions, the default value will be sufficient and does not need to be changed. This value will]]>
<![CDATA[
]]>
<![CDATA[      need to be increased only if a single page consistently takes more than 3 minutes to complete, which]]>
<![CDATA[
]]>
<![CDATA[      is a very atypical situation. The programmer can choose to shorten this time to reduce the time to]]>
<![CDATA[
]]>
<![CDATA[      detect failures earlier, provided there is time left to perform recognition in "worst case" scenarios.]]>
<![CDATA[
]]>
<![CDATA[      For best results, this timeout should be set the same or longer than the value specified in a]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[SetOutOfProcessRecogTimeout]]>
			</b>
<![CDATA[action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When a ]]>
			<b>
<![CDATA[SetEngineTimeout]]>
			</b>
<![CDATA[action is called, the setting will be in effect for the entire batch, allowing you to set the value once, then call as many recognition actions as necessary.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetEngineTimeout("180")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RecogContinueOnFailure("True")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SetEngineTimeout = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[        g_iOCRSEngineTimeout =  CLng(StrParam) * 1000]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Setting OCRS Engine timeout to " & g_iOCRSEngineTimeout]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Invalid parameter type passed. This action expects a numeric value."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizeToPDF" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
		<ap>
<![CDATA[
]]>
<![CDATA[      A numeric value indicating the Document Format type:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[1.]]>
			</b>
<![CDATA[ A PDF document with the original image in the foreground with the recognized text hidden in the background (but in the correct position). Perfect for archiving and indexing documents.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[2.]]>
			</b>
<![CDATA[ A general PDF document where the text in the original image is replaced by the corresponding text recognized by the engine.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[3.]]>
			</b>
<![CDATA[ A special type of PDF document, where the suspect words are covered by their images cut out from the original image.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[4.]]>
			</b>
<![CDATA[ A non-searchable PDF document.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[      This action converts a scanned Image file (.tif) to an Adobe Portable Document Format (PDF) file file specified by the parameter.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeToPDF("3")]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the rule with this action is not applied to a page. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    RecognizeToPDF = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If (CurrentObj.ObjectType <> 2) Then Exit Function	'can only be called at Page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("RecognizeDocToPDF: Parameter is not a numeric value.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Dim l_iMethod]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_iMethod = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If l_iMethod >=1 AND l_iMethod <=5 Then]]>
<![CDATA[
]]>
<![CDATA[        If l_iMethod = 5 Then l_iMethod = 23 'PDFImage only]]>
<![CDATA[
]]>
<![CDATA[        RecognizeToPDF = RecognizeToFile_OCR_S(false,false,CStr(l_iMethod))]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("RecognizeToPDF: Invalid parameter passed: '" & StrParam & "'. Please refer to the documentation for valid values.")]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizeDocToPDF" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
		<ap>
<![CDATA[
]]>
<![CDATA[      A numeric value indicating the Document Format type:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[1.]]>
			</b>
<![CDATA[ A PDF document with the original image in the foreground with the recognized text hidden in the background (but in the correct position). Perfect for archiving and indexing documents.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[2.]]>
			</b>
<![CDATA[ A general PDF document where the text in the original image is replaced by the corresponding text recognized by the engine.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[3.]]>
			</b>
<![CDATA[ A special type of PDF document, where the suspect words are covered by their images cut out from the original image.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[4.]]>
			</b>
<![CDATA[ A non-searchable PDF document.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Converts all pages in a document to Adobe PDF format and places them in a searchable PDF file (.pdf)]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeDocToPDF("1")]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Document level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the action is not applied at the Document level of the Document Hierarchy, or]]>
<![CDATA[
]]>
<![CDATA[      if conversion is not successful. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    RecognizeDocToPDF = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If (CurrentObj.ObjectType <> 1) Then Exit Function	'can only be called at Document level]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("RecognizeDocToPDF: Parameter is not a numeric value.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Dim l_iMethod]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_iMethod = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If l_iMethod >=1 AND l_iMethod <=5 Then]]>
<![CDATA[
]]>
<![CDATA[        If l_iMethod = 5 Then l_iMethod = 23 'PDFImage only]]>
<![CDATA[
]]>
<![CDATA[        RecognizeDocToPDF = RecognizeToFile_OCR_S(false,false,CStr(l_iMethod))]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("RecognizeToPDF: Invalid parameter passed: '" & StrParam & "'. Please refer to the documentation for valid values.")]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizePageOCR_S" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action responds to settings in the OCR/S tab of the Recognition Options Setup dialog to recognize]]>
<![CDATA[
]]>
<![CDATA[      all characters on a page, and populates the page's CCO file with the recognition results.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[Alert!]]>
				</i>
<![CDATA[
]]>
<![CDATA[      ]]>
			</b>
<![CDATA[If a CCO file does not exist at the time this action is called, the action will create one.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RotateImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageOCR_S()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This sequence creates a CCO file for the current page, and checks to see if rotation of the image is needed.]]>
<![CDATA[
]]>
<![CDATA[        Full-page recognition then takes place in response to settings in the OCR/S tab of the Recognition]]>
<![CDATA[
]]>
<![CDATA[        Options Setup dialog The recognition results are stored in the CCO file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[      Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    RecognizePageOCR_S = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If (CurrentObj.ObjectType<>2) Then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog ("This action must be called at the page level.")	'must be a page]]>
<![CDATA[
]]>
<![CDATA[      Exit function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    LogDCOProcessorState]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim theTime]]>
<![CDATA[
]]>
<![CDATA[		theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim l_oTmpDCO, l_oTmpParent, l_oTmpPage]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpDCO = CreateObject("TDCO.Batch")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Parent.ObjectType = 0 Then]]>
<![CDATA[
]]>
<![CDATA[      Set l_oTmpParent = l_oTmpDCO]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Set l_oTmpParent = l_oTmpDCO.AddChild(1,"tempdoc",-1)]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_oTmpParent.XML = CurrentObj.Parent.XML]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpPage = l_oTmpParent.FindChild(CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    l_oTmpPage.Variable("hr_locale") = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SetParentObjectXML l_oTmpPage.Parent.XML]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpDCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    g_iRes = IN_OUT_RECOG_PROCESS_EXECUTE("DCOCRS.Net.OCRSEngine", "RecognizePageEx", CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable("RecogStatus") = cstr(g_iRes)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Recognition return status: " & CurrentObj.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(CurrentObj.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Recognition Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CInt(CurrentObj.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[       If Not g_bContinueOnFailure Then]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          g_iRes = IN_OUT_RECOG_PROCESS_EXECUTE_RETRY("DCOCRS.Net.OCRSEngine", "RecognizePageEx", CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Variable("RecogStatus") = cstr(g_iRes)]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Recognition return status: " & CurrentObj.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(CurrentObj.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If CInt(CurrentObj.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[              nTaskStatus = retAbort 'Set the task to abort]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Recognition was not successfull. ContinueOnFailure is ON, batch will not abort at this point."]]>
<![CDATA[
]]>
<![CDATA[          IN_OUT_RECOG_PROCESS_EXECUTE_RETRY "DCOCRS.Net.OCRSEngine","",""]]>
<![CDATA[
]]>
<![CDATA[       End If]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If UpdateCCO Then]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("v_ccoNormOFF") <> "1" Then]]>
<![CDATA[
]]>
<![CDATA[          NormalizeCCO false,false]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Err.Number = 0 Then]]>
<![CDATA[
]]>
<![CDATA[        Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    RecognizePageOCR_S = TRUE]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizeToFile_OCR_S" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
		<ap>
<![CDATA[
]]>
<![CDATA[      The action requires a ]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[parameter from 1-22 to specify a combination of recognition targets]]>
<![CDATA[
]]>
<![CDATA[      and output formats.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Important!]]>
			</b>
<![CDATA["Image" refers to the image of the bound ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[      "Filename" is the string portion of a file's name that precedes its extension.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The output for all of these parameters will produce a file name that is identical to the original]]>
<![CDATA[
]]>
<![CDATA[      file name and will have the extension specified for that parameter.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[1.]]>
			</b>
<![CDATA[ A PDF document with the original image in the foreground with the recognized text hidden in the background (but in the correct position). Perfect for archiving and indexing documents.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[2.]]>
			</b>
<![CDATA[ A general PDF document where the text in the original image is replaced by the corresponding text recognized by the engine.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[3.]]>
			</b>
<![CDATA[ A special type of PDF document, where the suspect words are covered by their images cut out from the original image.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[4.]]>
			</b>
<![CDATA[ A non-searchable PDF document.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[5.]]>
			</b>
<![CDATA[ Recognize an HTML image of the bound ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".html" (HTML 140).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[6.]]>
			</b>
<![CDATA[ Recognize an image of the bound ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in an Excel file.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".xls" (Excel 2000.)]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[7.]]>
			</b>
<![CDATA[ Recognize any image of the bound ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Word2000 file with a ".doc" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".doc" (Word 2000).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[8.]]>
			</b>
<![CDATA[ Recognize any image of the bound ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a WordML file.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".doc" (Word ML).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[9.]]>
			</b>
<![CDATA[ Recognize any image of the bound ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Word97 file.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".doc" (Word 97)]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[10.]]>
			</b>
<![CDATA[ Recognize any image of the bound ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a RTF2000SWord file.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".rtf" (RTF 2000SWord)]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[11.]]>
			</b>
<![CDATA[ Recognize any image of the bound ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in an RTF2000 file.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".rtf" (RTF 2000).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[12.]]>
			</b>
<![CDATA[ Recognize the image of the bound ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".RTF6" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".rtf" (Rich Text).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[13.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with an "RTF6" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".rtf" (Rich Text).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[14.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".Text" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".txt" (Text).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[15.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".Csv" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".txt" (CSV - Comma Separated Variable).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[16.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".FormattedTxt" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".txt" (Formatted Text).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[17.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".UText" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".txt" (Text).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[18.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".UCSV" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".CSV" (Comma Separated Variable).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[19.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".UFormattedText" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".txt" (Text).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[20.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".Audio" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".aud" (Text).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[21.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".WordPad" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".rtf" (Rich Text for WordPad).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[22.]]>
			</b>
<![CDATA[ Recognize the image of the ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".XML" extension.]]>
<![CDATA[
]]>
<![CDATA[      Output: ".xml" (XML).]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Performs OCR recognition on the image of a source page, and stores the output of the OCR/S recognition]]>
<![CDATA[
]]>
<![CDATA[      engine in a file. The output file is in one of 22 alternative formats. Because the files are not actually]]>
<![CDATA[
]]>
<![CDATA[      processed in the format you specify, this action is useful primarily for debugging the engine,]]>
<![CDATA[
]]>
<![CDATA[      of if you need raw (unverified) OCR output in that format.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeToFile_OCR_S("21")]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page or Document.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if a ruleset with this action is bound to a ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[object of the Document Hierarchy,]]>
<![CDATA[
]]>
<![CDATA[      or if the parameter is not numeric. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    RecognizeToFile_OCR_S = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If (CurrentObj.ObjectType <> 1 AND CurrentObj.ObjectType <> 2)  Then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Action must be called at the document or page levels."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function	'can only be called at Document, or Page levels.]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    LogDCOProcessorState]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim theTime]]>
<![CDATA[
]]>
<![CDATA[		theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    If Not IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("RecognizeToFile_OCR_S: Parameter is not a numeric value.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Dim l_iMethod]]>
<![CDATA[
]]>
<![CDATA[    l_iMethod = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim l_oTmpDCO, l_oTmpParent, l_oTmpPage]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  If l_iMethod >= 1 AND l_iMethod <= 23  Then '1 to 22 range]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("s_srcnvrtmd") = l_iMethod]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("s_srbatchdir") = Pilot.BatchDir]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Set l_oTmpDCO = CreateObject("TDCO.Batch")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[        If CurrentObj.Parent.ObjectType = 0 Then]]>
<![CDATA[
]]>
<![CDATA[          Set l_oTmpParent = l_oTmpDCO]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[          Set l_oTmpParent = l_oTmpDCO.AddChild(1,"tempdoc",-1)]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[        l_oTmpParent.XML = CurrentObj.Parent.XML]]>
<![CDATA[
]]>
<![CDATA[        Set l_oTmpPage = l_oTmpParent.FindChild(CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[        l_oTmpPage.Variable("hr_locale") = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[        writelog "LOCALE " & l_oTmpPage.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[        SetParentObjectXML l_oTmpPage.Parent.XML]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[        Set l_oTmpDCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[        Set l_oTmpParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[        Set l_oTmpPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        g_iRes = IN_OUT_RECOG_PROCESS_EXECUTE("DCOCRS.Net.OCRSEngine", "RecognizePageToFileEx", CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[	  Else]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("RecognizeToFile_OCR_S: Invalid parameter passed: '" & StrParam & "'. Please refer to the documentation for valid values.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[	  End If ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable("RecogStatus") = g_iRes]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Recognition return status: " & CurrentObj.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(CurrentObj.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Recognition Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CInt(CurrentObj.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[       If Not g_bContinueOnFailure Then]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[          g_iRes = IN_OUT_RECOG_PROCESS_EXECUTE_RETRY("DCOCRS.Net.OCRSEngine", "RecognizePageToFileEx", CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Variable("RecogStatus") = cstr(g_iRes)]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Recognition return status: " & CurrentObj.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(CurrentObj.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If CInt(CurrentObj.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[              nTaskStatus = retAbort 'Set the task to abort]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Recognition was not successfull. ContinueOnFailure is ON, batch will not abort at this point."]]>
<![CDATA[
]]>
<![CDATA[          IN_OUT_RECOG_PROCESS_EXECUTE_RETRY "DCOCRS.Net.OCRSEngine","",""]]>
<![CDATA[
]]>
<![CDATA[       End If]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    RecognizeToFile_OCR_S = TRUE]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizePageOCR_S_2TextFile" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action generates a Text file (.txt) that contains the raw recognition results for each page in]]>
<![CDATA[
]]>
<![CDATA[      the batch, and adds the file to the current batch. ]]>
			<b>
<![CDATA[Note:]]>
			</b>
<![CDATA[The action does not create or populate]]>
<![CDATA[
]]>
<![CDATA[      a page's Fingerprint file (.cco) file with the recognition results.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageOCR_S_2TextFile()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[ object of]]>
<![CDATA[
]]>
<![CDATA[      the Document Hierarchy. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  RecognizePageOCR_S_2TextFile = RecognizeToFile_OCR_S(false,false,"14")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizePageFieldsOCR_S" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This page-level action recognizes all fields on the page that have been configured for OCR/S]]>
<![CDATA[
]]>
<![CDATA[      recognition (see the OCR/S tab of the Recognition Options Setup dialog.)]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Note:]]>
			</b>
<![CDATA[Individual field-level recognition actions will overwrite the results from this page-level action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The action will not recognize a zoned field if the Skip Recognition checkbox in the OCR/S tab of the]]>
<![CDATA[
]]>
<![CDATA[      Recognition Options Setup dialog has been selected.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ReadZones()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageFieldsOCR_S()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[      Document Hierarchy. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageFieldsOCR_S = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType<>2) Then RecognizePageFieldsOCR_S = False : Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  LogDCOProcessorState]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim theTime]]>
<![CDATA[
]]>
<![CDATA[	theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[  Dim conf, left, top, right, bottom]]>
<![CDATA[
]]>
<![CDATA[	Dim l_sRes]]>
<![CDATA[
]]>
<![CDATA[  l_sRes = ""]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Total fields: " & CurrentObj.NumOfChildren)]]>
<![CDATA[
]]>
<![CDATA[  Dim l_oTmpDCO, l_oTmpField]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpDCO = CreateObject("TDCO.Batch")]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpField = l_oTmpDCO.AddChild(3,"tmpfield",-1)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  For i = 0 To CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[	    Set oField = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[      l_oTmpField.XML = oField.XML]]>
<![CDATA[
]]>
<![CDATA[      l_oTmpField.Variable("hr_locale") = oField.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[      l_oTmpField.Variable("IMAGEPATH") = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		  If((oField.Variable("s_sr")="1") Or (oField.Variable("RecogType")="4")) Then]]>
<![CDATA[
]]>
<![CDATA[			    WriteLog("----- ScanSoft field recognition of: " & oField.ID & ", "& CurrentObj.ImageName &" is skipped by the settings -----")]]>
<![CDATA[
]]>
<![CDATA[		  Else]]>
<![CDATA[
]]>
<![CDATA[			    oField.Clear]]>
<![CDATA[
]]>
<![CDATA[			    oField.Variable("IMAGEPATH") = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[          SetParentObjectXML l_oTmpField.XML]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          l_sRes = IN_OUT_RECOG_PROCESS_EXECUTE("DCOCRS.Net.OCRSEngine", "RecognizeFieldEx", oField.ID)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If ValidateRecogResult(l_sRes) Then]]>
<![CDATA[
]]>
<![CDATA[              oField.XML = l_sRes]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[              oField.Variable("RecogStatus") = l_sRes]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Recognition return status: " & oField.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(oField.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If CInt(oField.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[             If Not g_bContinueOnFailure Then]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[                l_sRes = IN_OUT_RECOG_PROCESS_EXECUTE_RETRY("DCOCRS.Net.OCRSEngine", "RecognizeFieldEx", oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                If ValidateRecogResult(l_sRes) Then]]>
<![CDATA[
]]>
<![CDATA[                    oField.XML = l_sRes]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[                    oField.Variable("RecogStatus") = l_sRes]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[               Writelog "Recognition return status: " & oField.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(oField.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                If CInt(oField.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[                    nTaskStatus = retAbort 'Set the task to abort]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[             Else]]>
<![CDATA[
]]>
<![CDATA[                Writelog "Recognition was not successfull. ContinueOnFailure is ON, batch will not abort at this point."]]>
<![CDATA[
]]>
<![CDATA[                IN_OUT_RECOG_PROCESS_EXECUTE_RETRY "DCOCRS.Net.OCRSEngine","",""]]>
<![CDATA[
]]>
<![CDATA[             End If]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[		  End If]]>
<![CDATA[
]]>
<![CDATA[  Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Recognition Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpDCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpField = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizePageFields2CCO_OCR_S" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Performs recognition on fields that have been designated for OCR/S recognition then transfers the]]>
<![CDATA[
]]>
<![CDATA[      Zonal OCR_S recognition values to the page's CCO file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        RecognizePageFields2CCO ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizePageFields2CCO_OCR_S()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CreateTextFile]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageFields2CCO_OCR_S = TRUE]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType<>2) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  LogDCOProcessorState]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim theTime]]>
<![CDATA[
]]>
<![CDATA[	theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim conf, left, top, right, bottom]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Load CCO]]>
<![CDATA[
]]>
<![CDATA[	Dim strCCOName]]>
<![CDATA[
]]>
<![CDATA[	strCCOName = Replace(lcase(CurrentObj.ImageName), ".tif", ".cco")]]>
<![CDATA[
]]>
<![CDATA[  If Not(FileMgr.FileExists(strCCOName)) Then WriteLog("Skipping recognition. CCO doesn't exist") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Dim l_oCCO]]>
<![CDATA[
]]>
<![CDATA[	Set l_oCCO = CCOCreator.Load(strCCOName)]]>
<![CDATA[
]]>
<![CDATA[	Dim l_sRes]]>
<![CDATA[
]]>
<![CDATA[  l_sRes = ""]]>
<![CDATA[
]]>
<![CDATA[  theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Total fields: " & CurrentObj.NumOfChildren)]]>
<![CDATA[
]]>
<![CDATA[  Dim l_oTmpDCO, l_oTmpField]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpDCO = CreateObject("TDCO.Batch")]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpField = l_oTmpDCO.AddChild(3,"tmpfield",-1)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  For i = 0 To CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[	    Set oField = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      l_oTmpField.XML = oField.XML]]>
<![CDATA[
]]>
<![CDATA[      l_oTmpField.Variable("hr_locale") = oField.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[      l_oTmpField.Variable("IMAGEPATH") = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		  If((oField.Variable("s_sr")="1") Or (oField.Variable("RecogType")="4")) Then]]>
<![CDATA[
]]>
<![CDATA[			    WriteLog("----- ScanSoft field recognition of: " & oField.ID & ", "& CurrentObj.ImageName &" is skipped by the settings -----")]]>
<![CDATA[
]]>
<![CDATA[		  Else]]>
<![CDATA[
]]>
<![CDATA[			    oField.Clear]]>
<![CDATA[
]]>
<![CDATA[			    oField.Variable("IMAGEPATH") = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[          SetParentObjectXML l_oTmpField.XML]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          l_sRes = IN_OUT_RECOG_PROCESS_EXECUTE("DCOCRS.Net.OCRSEngine", "RecognizeFieldEx", oField.ID)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If ValidateRecogResult(l_sRes) Then]]>
<![CDATA[
]]>
<![CDATA[              oField.XML = l_sRes]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[              oField.Variable("RecogStatus") = l_sRes]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Recognition return status: " & oField.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(oField.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If CInt(oField.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[             If Not g_bContinueOnFailure Then]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[                l_sRes = IN_OUT_RECOG_PROCESS_EXECUTE_RETRY("DCOCRS.Net.OCRSEngine", "RecognizeFieldEx", oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                If ValidateRecogResult(l_sRes) Then]]>
<![CDATA[
]]>
<![CDATA[                    oField.XML = l_sRes]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[                    oField.Variable("RecogStatus") = l_sRes]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[               Writelog "Recognition return status: " & oField.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(oField.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                If CInt(oField.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[                    nTaskStatus = retAbort 'Set the task to abort]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[             Else]]>
<![CDATA[
]]>
<![CDATA[                Writelog "Recognition was not successfull. ContinueOnFailure is ON, batch will not abort at this point."]]>
<![CDATA[
]]>
<![CDATA[                IN_OUT_RECOG_PROCESS_EXECUTE_RETRY "DCOCRS.Net.OCRSEngine","",""]]>
<![CDATA[
]]>
<![CDATA[             End If]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Dim l_oDCOChar]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If oField.Variable("dc_delSpace") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[              RemoveSpaces oField]]>
<![CDATA[
]]>
<![CDATA[          End If  ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          For nChar = 0 To oField.NumOfChildren()-1]]>
<![CDATA[
]]>
<![CDATA[			        Set l_oDCOChar = oField.GetChild(nChar)]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[              l_oDCOChar.GetPosition left, top, right, bottom]]>
<![CDATA[
]]>
<![CDATA[  		        ]]>
<![CDATA[
]]>
<![CDATA[              If(l_oDCOChar.ObjectType=4)	Then 'char]]>
<![CDATA[
]]>
<![CDATA[				          ]]>
<![CDATA[
]]>
<![CDATA[                  l_oCCO.PutChar l_oDCOChar.CharValue(0), l_oDCOChar.CharConfidence(0),left, top, right, bottom]]>
<![CDATA[
]]>
<![CDATA[                  ]]>
<![CDATA[
]]>
<![CDATA[			        End If]]>
<![CDATA[
]]>
<![CDATA[		      Next    ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[		  End If]]>
<![CDATA[
]]>
<![CDATA[  Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Saving CCO to " & strCCOName)]]>
<![CDATA[
]]>
<![CDATA[  l_oCCO.Save strCCOName]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Done.")]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Recognition Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpDCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpField = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizeFieldOCR_S" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This field-level action retrieves a zoned field's settings from the OCR/S tab of the Recognition Options Setup]]>
<![CDATA[
]]>
<![CDATA[      dialog, and uses these settings to recognize the field's value.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        TaxpayerSSN Rule 1]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeFieldOCR_S()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        In the example, the rule uses the action to retrieve and apply settings in the OCR/S tab of]]>
<![CDATA[
]]>
<![CDATA[        the Recognition Options Setup dialog... settings that have been previously assigned to a]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy's zoned field.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Field only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[      Document Hierarchy. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    RecognizeFieldOCR_S = True]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    If (CurrentObj.ObjectType<>3) Then ]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("This action must be called at the field level.") ]]>
<![CDATA[
]]>
<![CDATA[        Exit Function	'must be a field]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    LogDCOProcessorState]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    Dim theTime]]>
<![CDATA[
]]>
<![CDATA[		theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[    Dim l_sRes]]>
<![CDATA[
]]>
<![CDATA[    l_sRes = ""  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim l_sXML]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim l_oPage]]>
<![CDATA[
]]>
<![CDATA[    Set l_oPage = CurrentObj.Parent]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    do while l_oPage.ImageName = "" ]]>
<![CDATA[
]]>
<![CDATA[      Set l_oPage = l_oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[    loop ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable("IMAGEPATH") = l_oPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Parent image " & CurrentObj.Variable("IMAGEPATH")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim l_oTmpDCO, l_oTmpField]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpDCO = CreateObject("TDCO.Batch")]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpField = l_oTmpDCO.AddChild(3,"tmpfield",-1)]]>
<![CDATA[
]]>
<![CDATA[    l_oTmpField.XML = CurrentObj.XML]]>
<![CDATA[
]]>
<![CDATA[    l_oTmpField.Variable("hr_locale") = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[    l_oTmpField.Variable("IMAGEPATH") = CurrentObj.Variable("IMAGEPATH")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SetParentObjectXML l_oTmpField.XML]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpDCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpField = Nothing]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_sRes = IN_OUT_RECOG_PROCESS_EXECUTE("DCOCRS.Net.OCRSEngine", "RecognizeFieldEx", CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If ValidateRecogResult(l_sRes) Then]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.XML = l_sRes]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("RecogStatus") = l_sRes]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Recognition return status: " & CurrentObj.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(CurrentObj.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Recognition Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CInt(CurrentObj.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[       If Not g_bContinueOnFailure Then]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[          l_sRes = IN_OUT_RECOG_PROCESS_EXECUTE_RETRY("DCOCRS.Net.OCRSEngine", "RecognizeFieldEx", CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If ValidateRecogResult(l_sRes) Then]]>
<![CDATA[
]]>
<![CDATA[                CurrentObj.XML = l_sRes]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[                CurrentObj.Variable("RecogStatus") = l_sRes]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Recognition return status: " & CurrentObj.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(CurrentObj.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If CInt(CurrentObj.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[              nTaskStatus = retAbort 'Set the task to abort]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Recognition was not successfull. ContinueOnFailure is ON, batch will not abort at this point."]]>
<![CDATA[
]]>
<![CDATA[          IN_OUT_RECOG_PROCESS_EXECUTE_RETRY "DCOCRS.Net.OCRSEngine","",""]]>
<![CDATA[
]]>
<![CDATA[       End If]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("dc_delSpace") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[            RemoveSpaces CurrentObj]]>
<![CDATA[
]]>
<![CDATA[    End If  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    RecognizeFieldOCR_S = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RecognizeFieldVoteOCR_S" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This field-level action initiates a voting procedure that first uses specifications in the OCR/S]]>
<![CDATA[
]]>
<![CDATA[      tab of the Recognition Options Setup dialog to recognize the field's characters. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When this action stores the results of recognition, it first determines if the corresponding]]>
<![CDATA[
]]>
<![CDATA[      Field object of the Document Hierarchy contains a value. If a value is present, the action]]>
<![CDATA[
]]>
<![CDATA[      compares the field's existing value with the recognition results - character by character.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If a particular character's values match, the Confidence Rating for the character]]>
<![CDATA[
]]>
<![CDATA[      is raised to the maximum level.  If the values do not match, the Confidence Rating for the character]]>
<![CDATA[
]]>
<![CDATA[      is lowered to the minimum. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Note that when using this voting procedure, the second Recognition engine is secondary and its results]]>
<![CDATA[
]]>
<![CDATA[      are never assigned.  Instead, the action changes the Confidence Ratings on the basis of results provided]]>
<![CDATA[
]]>
<![CDATA[      by the first Recognition engine. If there are no recognition results previous to this action, it]]>
<![CDATA[
]]>
<![CDATA[      will act just like the ]]>
			<b>
<![CDATA[RecognizeFieldOCR_S]]>
			</b>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        RecognizeFieldICR_C()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RecognizeFieldVoteOCR_S()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Field only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[ object of the]]>
<![CDATA[
]]>
<![CDATA[      Document Hierarchy. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    RecognizeFieldVoteOCR_S = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If (CurrentObj.ObjectType<>3) Then Exit Function	'must be a field]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Create a temporary copy of the field before the recognition since it will be overridden]]>
<![CDATA[
]]>
<![CDATA[    Dim l_oTmpDCO]]>
<![CDATA[
]]>
<![CDATA[    Dim l_oOrigField]]>
<![CDATA[
]]>
<![CDATA[    Dim theTime]]>
<![CDATA[
]]>
<![CDATA[	  theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpDCO = CreateObject("TDCO.Batch")]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpDCO = l_oTmpDCO.AddChild(0,"tmpbatch",-1)	]]>
<![CDATA[
]]>
<![CDATA[    Set l_oOrigField = l_oTmpDCO.AddChild(3,"tmpfield",-1)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_oOrigField.XML = CurrentObj.XML]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    RecognizeFieldOCR_S true,true]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If l_oOrigField.Text = "" Or CurrentObj.Text = "" Then]]>
<![CDATA[
]]>
<![CDATA[      'if the field is empty then ignore the vote, and store the recognition results in the field's Text property]]>
<![CDATA[
]]>
<![CDATA[       Writelog "Field is empty. Voting skipped."]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      'If a previous recognition engine / or user had entered data into the field, then preserver the first value and ]]>
<![CDATA[
]]>
<![CDATA[      'perform the voting (modify confidence string)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Dim l_oDCOChar]]>
<![CDATA[
]]>
<![CDATA[      Dim l_oDCOChar2]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      For nChar = 0 To l_oOrigField.NumOfChildren()-1]]>
<![CDATA[
]]>
<![CDATA[			    Set l_oDCOChar = l_oOrigField.GetChild(nChar)]]>
<![CDATA[
]]>
<![CDATA[          Set l_oDCOChar2 = CurrentObj.GetChild(nChar) ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If l_oDCOChar2 Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[            WriteLog("Exiting voting algorithm: no more characters to compare.")]]>
<![CDATA[
]]>
<![CDATA[            Exit For]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  		    If(l_oDCOChar.ObjectType=4)	Then 'char]]>
<![CDATA[
]]>
<![CDATA[  				    ]]>
<![CDATA[
]]>
<![CDATA[  			      Writelog "Comparing " & l_oDCOChar.CharValue(0) & " and " & l_oDCOChar2.CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[              If(l_oDCOChar.CharValue(0) = l_oDCOChar2.CharValue(0)) Then ]]>
<![CDATA[
]]>
<![CDATA[                  Writelog "Characters match!"]]>
<![CDATA[
]]>
<![CDATA[						      If (l_oDCOChar.CharConfidence(0) < 9) Then ]]>
<![CDATA[
]]>
<![CDATA[                      Writelog "Setting character confidence to 9."]]>
<![CDATA[
]]>
<![CDATA[							        l_oDCOChar.CharConfidence(0) = 9]]>
<![CDATA[
]]>
<![CDATA[						      Else]]>
<![CDATA[
]]>
<![CDATA[                      Writelog "Setting confidence to 10"]]>
<![CDATA[
]]>
<![CDATA[							        l_oDCOChar.CharConfidence(0) = 10]]>
<![CDATA[
]]>
<![CDATA[                  End If]]>
<![CDATA[
]]>
<![CDATA[					    End If]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[			    End If]]>
<![CDATA[
]]>
<![CDATA[		  Next]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = l_oOrigField.Text]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.ConfidenceString = l_oOrigField.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Recognition Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[    RecognizeFieldVoteOCR_S = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="SetLegacyDecompositionOCR_S" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      "Decomposes" an image to prepare it for field or page recognition.  This action intensifies gradients]]>
<![CDATA[
]]>
<![CDATA[      between and within words on the current page.  The action will increase recognition time and should]]>
<![CDATA[
]]>
<![CDATA[      only be used as needed.  This action will affect page and field level recognition.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetLegacyDecompositionOCR_S("1010")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RecognizePageOCR_S()]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This combination creates a CCO file for the current page, intensifies gradients between and]]>
<![CDATA[
]]>
<![CDATA[        within words on the page, then uses settings in the OCR/S tab of the Recognition Options Setup]]>
<![CDATA[
]]>
<![CDATA[        dialog to carry out word recognition of the page.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  '1 - Auto]]>
<![CDATA[
]]>
<![CDATA[  '2 - Fast]]>
<![CDATA[
]]>
<![CDATA[  '3 - Legacy]]>
<![CDATA[
]]>
<![CDATA[  '4 - Standard]]>
<![CDATA[
]]>
<![CDATA[	SetLegacyDecompositionOCR_S = False]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("s_srdecompmethod") = "3" ]]>
<![CDATA[
]]>
<![CDATA[	SetLegacyDecompositionOCR_S = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="SetFastTradeOffOCR_S" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Increases the speed of the RecognizePageOCR_S action. This action's "tradeoff" may]]>
<![CDATA[
]]>
<![CDATA[      be accuracy for speed.  This action must be called before the recognition action and]]>
<![CDATA[
]]>
<![CDATA[      will affect page and field level recognition.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Rotate Image()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetFastTradeOffOCR_S()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RecognizePageOCR_S()]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action speeds the word recognition process of the RecognizePageOCR_S action.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  '1 - Accurate]]>
<![CDATA[
]]>
<![CDATA[  '2 - Balanced]]>
<![CDATA[
]]>
<![CDATA[  '3 - Fast]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	SetFastTradeOffOCR_S = False]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("s_srrmtradeoff") = "3" ]]>
<![CDATA[
]]>
<![CDATA[	SetFastTradeOffOCR_S = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="RotateImage" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action checks if the scanned Image file (.tio) needs to be rotated by 90, 180, or 270 degrees.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If rotation is necessary, the action saves the Image file(.tio) in the new, correct position and updates the CCO file with the correct position coordinates.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Following an action that creates a page's CCO file, this action checks if the scanned Image file (.tio) needs]]>
<![CDATA[
]]>
<![CDATA[      to be rotated by 90, 180, or 270 degrees.  If rotation is necessary, the action saves the Image file(.tio)]]>
<![CDATA[
]]>
<![CDATA[      in the new, correct position and updates the CCO file with the correct position coordinates.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      It is recommended that this action be called in a separate ruleset after recognition due]]>
<![CDATA[
]]>
<![CDATA[      to instances where the recognition engine will not release the image until the ruleset has completed.]]>
<![CDATA[
]]>
<![CDATA[      This problem can manifest as a “cco does not exist” error in the log file.]]>
<![CDATA[
]]>
<![CDATA[      Also note that there are some rare occasions where images will not be rotated correctly.]]>
<![CDATA[
]]>
<![CDATA[      This may happen if the page is mostly all graphics or the text is all capital letters.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RotateTIO()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RotateImage()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        RecognizePageICR_C()]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        In this example, a CCO file that corresponds to an existing Image file (.tio) is created by the]]>
<![CDATA[
]]>
<![CDATA[        AnalyzeImage action. The RotateTIO action checks to see if rotation of the image is appropriate,]]>
<![CDATA[
]]>
<![CDATA[        and by how much. If applicable, the subsequent RotateImage action rotates the image in response]]>
<![CDATA[
]]>
<![CDATA[        to the value provided by the RotateTIO action, and provides the new CCO file with correct position coordinates.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[      Document Hierarchy, or if the action cannot locate the Image file representing the current page.]]>
<![CDATA[
]]>
<![CDATA[      Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  RotateImage = True]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LogDCOProcessorState]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("RotateImage skipping. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  writelog "Rotating image..."]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim l_oTmpDCO, l_oTmpParent, l_oTmpPage]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpDCO = CreateObject("TDCO.Batch")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.Parent.ObjectType = 0 Then]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpParent = l_oTmpDCO]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Set l_oTmpParent = l_oTmpDCO.AddChild(1,"tempdoc",-1)]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  l_oTmpParent.XML = CurrentObj.Parent.XML]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpPage = l_oTmpParent.FindChild(CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[  l_oTmpPage.Variable("hr_locale") = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  SetParentObjectXML l_oTmpPage.Parent.XML]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpDCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[  Set l_oTmpPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  g_iRes = IN_OUT_RECOG_PROCESS_EXECUTE("DCOCRS.Net.OCRSEngine", "AutoRotateEx", CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  writelog "Image rotation completed. Result: (" & g_iRes & ")"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("RecogStatus") = g_iRes]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog "Return status: " & CurrentObj.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(CurrentObj.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CInt(CurrentObj.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[       If Not g_bContinueOnFailure Then]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[          g_iRes = IN_OUT_RECOG_PROCESS_EXECUTE_RETRY("DCOCRS.Net.OCRSEngine", "AutoRotateEx", CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Variable("RecogStatus") = cstr(g_iRes)]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Return status: " & CurrentObj.Variable("RecogStatus") & "(" & g_ErrDescr(CInt(CurrentObj.Variable("RecogStatus"))) & ")"]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If CInt(CurrentObj.Variable("RecogStatus")) > 2 Then]]>
<![CDATA[
]]>
<![CDATA[              nTaskStatus = retAbort 'Set the task to abort]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[              writelog "Invoking AnalyzeImage..." ]]>
<![CDATA[
]]>
<![CDATA[              l_bRes = AnalyzeImage( False, False)]]>
<![CDATA[
]]>
<![CDATA[              writelog "Done. Return status is " & l_bRes ]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          Writelog "Recognition was not successfull. ContinueOnFailure is ON, batch will not abort at this point."]]>
<![CDATA[
]]>
<![CDATA[          IN_OUT_RECOG_PROCESS_EXECUTE_RETRY "DCOCRS.Net.OCRSEngine","",""]]>
<![CDATA[
]]>
<![CDATA[       End If]]>
<![CDATA[
]]>
<![CDATA[ Else]]>
<![CDATA[
]]>
<![CDATA[    writelog "Invoking AnalyzeImage..." ]]>
<![CDATA[
]]>
<![CDATA[    l_bRes = AnalyzeImage( False, False)]]>
<![CDATA[
]]>
<![CDATA[    writelog "Done. Return status is " & l_bRes ]]>
<![CDATA[
]]>
<![CDATA[ End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
</rrx>
<rrx namespace="ocr_sr" v="8.1.0.10">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['******************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' OCRS R Recognition Actions ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/19/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA['   Initial implementation. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.1" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/24/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Action names are now consistent, ending in OCR_S]]>
<![CDATA[
]]>
<![CDATA[' Added actions RecognizeToFile_OCRS,RecognizeFieldVoteOCR_S,RecognizePageFields2CCO_OCRS]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.2" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/24/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Removed action RecognizePageFields2CCO_OCRS - usually this action applies to handprint recognition which is not performed by this engine.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.3" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/09/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for actions RecognizeToPDFOCR_S,RecognizeToFileOCR_S, and RecognizeFieldVoteOCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.4" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/11/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action RecognizePageOCR_S to say that NormalizeCCO or CCO2CCO actions must be called after full page OCR ]]>
<![CDATA[
]]>
<![CDATA[' if the application will be using navigation and pattern match actions. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/23/10 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action RecognizeFieldVoteOCR_S to describe exaclty how confidence values are raised. ]]>
<![CDATA[
]]>
<![CDATA[' Corrected retrun value help text for action RotateImageOCR_S ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/24/11 jmartinez]]>
<![CDATA[
]]>
<![CDATA['- Moved parameter information from the qi= tag to the standard parameter help section]]>
<![CDATA[
]]>
<![CDATA['- Moved action information from the qi= tag to the standard action help section]]>
<![CDATA[
]]>
<![CDATA['- Added IBM Copyright notice]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/18/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' 31991 Updated help text for action RecognizeToFile_OCR_S to. This action can be called only at the Document or Page level.]]>
<![CDATA[
]]>
<![CDATA[' 32483 Updated help text for action RecognizeToPDFOCR_S.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/04/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action RecognizeToPDFOCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/17/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the action RecognizeFieldOCR_S. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/20/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the action RecognizePageOCR_S. ]]>
<![CDATA[
]]>
<![CDATA['*****************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.ScansoftR.Actions">
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizeFieldOCR_S">
			<ap>
<![CDATA[None]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This field-level action is a shortcut to zonal recognition procedures that are carried out]]>
<![CDATA[
]]>
<![CDATA[        in response to settings in the OCR/S tab of DStudio. ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizeFieldOCR_S()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Field level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Field]]>
				</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizeFieldVoteOCR_S">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This field-level action initiates a voting procedure that first uses specifications in the OCR/S]]>
<![CDATA[
]]>
<![CDATA[        tab of the Recognition Options Setup dialog to recognize the field's characters. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When this action stores the results of recognition, it first determines if the corresponding]]>
<![CDATA[
]]>
<![CDATA[        Field object of the Document Hierarchy contains a value. If a value is present, the action]]>
<![CDATA[
]]>
<![CDATA[        compares the field's existing value with the recognition results - character by character.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If a particular character's values match, the Confidence Rating for the character]]>
<![CDATA[
]]>
<![CDATA[        is raised to 9 if the original confidence is smaller than 9. Otherwise the confidence of matching characters is raised to the maximum level (10).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Note that when using this voting procedure, the second Recognition engine is secondary and its results]]>
<![CDATA[
]]>
<![CDATA[        are never assigned.  Instead, the action changes the Confidence Ratings on the basis of results provided]]>
<![CDATA[
]]>
<![CDATA[        by the first Recognition engine. If there are no recognition results previous to this action, it]]>
<![CDATA[
]]>
<![CDATA[        will act just like the ]]>
				<b>
<![CDATA[RecognizeFieldOCR_S]]>
				</b>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          RecognizeFieldICR_C()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizeFieldVoteOCR_S()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Field only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Field]]>
				</b>
<![CDATA[ object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizePageOCR_S">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action responds to settings in the OCR/S tab of the Recognition Options Setup dialog to recognize]]>
<![CDATA[
]]>
<![CDATA[        all characters on a page, and populates the page's CCO file with the recognition results.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<i>
<![CDATA[Alert!]]>
					</i>
<![CDATA[
]]>
<![CDATA[        ]]>
				</b>
<![CDATA[ The NormalizeCCO action from the ]]>
				<b>
<![CDATA[CCO2CCO]]>
				</b>
<![CDATA[ action library should be called after]]>
<![CDATA[
]]>
<![CDATA[        RecognizePageOCR_S if the application will be using the navigation and pattern match actions]]>
<![CDATA[
]]>
<![CDATA[        to find recognized text on a page or perform pattern matching. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<i>
<![CDATA[Alert!]]>
					</i>
<![CDATA[
]]>
<![CDATA[        ]]>
				</b>
<![CDATA[If a CCO file does not exist at the time this action is called, the action will create one.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          AnalyzeImage()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RotateImage()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizePageOCR_S()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[NormalizeCCO("")]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This sequence creates a CCO file for the current page, and checks to see if rotation of the image is needed.]]>
<![CDATA[
]]>
<![CDATA[          Full-page recognition then takes place in response to settings in the OCR/S tab of the Recognition]]>
<![CDATA[
]]>
<![CDATA[          Options Setup dialog The recognition results are stored in the CCO file. The words and lines in the CCO are then sorted]]>
<![CDATA[
]]>
<![CDATA[          for use by navigation and pattern match actions.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizePageFieldsOCR_S">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This page-level action recognizes all fields on the page that have been configured for OCR/S]]>
<![CDATA[
]]>
<![CDATA[        recognition (see the OCR/S tab of the Recognition Options Setup dialog.)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[Individual field-level recognition actions will overwrite the results from this page-level action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The action will not recognize a zoned field if the Skip Recognition checkbox in the OCR/S tab of the]]>
<![CDATA[
]]>
<![CDATA[        Recognition Options Setup dialog has been selected.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ReadZones()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizePageFieldsOCR_S()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizeToPDFOCR_S">
			<p name="OutputPDFType" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A numeric value indicating the PDF output type:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1.]]>
				</b>
<![CDATA[ A PDF document with the original image in the foreground with the recognized text hidden in the background (but in the correct position). Perfect for archiving and indexing documents.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2.]]>
				</b>
<![CDATA[ A general PDF document where the text in the original image is replaced by the corresponding text recognized by the engine.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[3.]]>
				</b>
<![CDATA[ A special type of PDF document, where the suspect words are covered by their images cut out from the original image.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[4.]]>
				</b>
<![CDATA[ A non-searchable PDF document.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<lvl>
<![CDATA[Document and Page only.]]>
			</lvl>
			<h>
<![CDATA[
]]>
<![CDATA[        This action converts a scanned Image file (.tif) to an Adobe Portable Document Format (PDF) file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizeToPDF(3)]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the rule with this action is not applied to a document or page object, and/or if the parameters are not in the valid range. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RotateImageOCR_S">
			<ap>
<![CDATA[None]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Following an action that creates a page's CCO file, this action checks if the scanned Image file (.tio) needs]]>
<![CDATA[
]]>
<![CDATA[        to be rotated by 90, 180, or 270 degrees.  If rotation is necessary, the action saves the Image file(.tio)]]>
<![CDATA[
]]>
<![CDATA[        in the new, correct position and updates the CCO file with the correct position coordinates.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<i>
<![CDATA[Alert!]]>
					</i>
<![CDATA[
]]>
<![CDATA[        ]]>
				</b>
<![CDATA[
]]>
<![CDATA[        Within a rule, a RotateTIO action with a True parameter must precede the RotateImage action (see the example).]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          AnalyzeImage()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RotateTIO()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RotateImage()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RecognizePageICR_C()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          In this example, a CCO file that corresponds to an existing Image file (.tio) is created by the]]>
<![CDATA[
]]>
<![CDATA[          AnalyzeImage action. The RotateTIO action checks to see if rotation of the image is appropriate,]]>
<![CDATA[
]]>
<![CDATA[          and by how much. If applicable, the subsequent RotateImage action rotates the image in response]]>
<![CDATA[
]]>
<![CDATA[          to the value provided by the RotateTIO action, and provides the new CCO file with correct position coordinates.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[ object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy, or if the action cannot locate the Image file representing the current page.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizeToFileOCR_S">
			<p name="FileType" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fileType]]>
				</b>
<![CDATA[ - The action requires a ]]>
				<i>
<![CDATA[Numeric]]>
				</i>
<![CDATA[parameter from 1-22 to specify a combination of recognition targets]]>
<![CDATA[
]]>
<![CDATA[        and output formats.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Important!]]>
				</b>
<![CDATA["Image" refers to the image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        "Filename" is the string portion of a file's name that precedes its extension.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The output for all of these parameters will produce a file name that is identical to the original]]>
<![CDATA[
]]>
<![CDATA[        file name and will have the extension specified for that parameter.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1.]]>
				</b>
<![CDATA[ A PDF document with the original image in the foreground with the recognized text hidden in the background (but in the correct position). Perfect for archiving and indexing documents.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2.]]>
				</b>
<![CDATA[ A general PDF document where the text in the original image is replaced by the corresponding text recognized by the engine.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[3.]]>
				</b>
<![CDATA[ A special type of PDF document, where the suspect words are covered by their images cut out from the original image.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[4.]]>
				</b>
<![CDATA[ A non-searchable PDF document.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[5.]]>
				</b>
<![CDATA[ Recognize an HTML image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".html" (HTML 140).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[6.]]>
				</b>
<![CDATA[ Recognize an image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in an Excel file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".xls" (Excel 2000.)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[7.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Word2000 file with a ".doc" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".doc" (Word 2000).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[8.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a WordML file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".doc" (Word ML).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[9.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Word97 file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".doc" (Word 97)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[10.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a RTF2000SWord file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (RTF 2000SWord)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[11.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in an RTF2000 file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (RTF 2000).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[12.]]>
				</b>
<![CDATA[ Recognize the image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".RTF6" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (Rich Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[13.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an "RTF6" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (Rich Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[14.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".Text" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[15.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".Csv" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (CSV - Comma Separated Variable).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[16.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".FormattedTxt" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (Formatted Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[17.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".UText" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[18.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".UCSV" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".CSV" (Comma Separated Variable).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[19.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".UFormattedText" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[20.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".Audio" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".aud" (Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[21.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".WordPad" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (Rich Text for WordPad).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[22.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".XML" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".xml" (XML).]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Performs OCR recognition on the image of a source page, and stores the output of the OCR/S recognition]]>
<![CDATA[
]]>
<![CDATA[        engine in a file. The output file is in one of 22 alternative formats. Because the files are not actually]]>
<![CDATA[
]]>
<![CDATA[        processed in the format you specify, this action is useful primarily for debugging the engine,]]>
<![CDATA[
]]>
<![CDATA[        of if you need raw (unverified) OCR output in that format.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[RecognizePageOCR_S_2TextFile(21)]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page or Document.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if a ruleset with this action is bound to a ]]>
				<b>
<![CDATA[Field]]>
				</b>
<![CDATA[object of the Document Hierarchy,]]>
<![CDATA[
]]>
<![CDATA[        or if the parameter is not numeric. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="OpenTextFaxServer" v="8.1.0.7">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' Open Text Fax Server (RightFax) Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.0"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/16/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  Initial Implementation of Open Text Fax Server actions (RightFax)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/17/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  Exposed action Disconnect() which allows an application to disconnect or close the connection to the server.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/17/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  Exposed action SetAbortTimeout(int Milliseconds) to allows the user to set the time to wait before aborting a batch.]]>
<![CDATA[
]]>
<![CDATA['  Updated help text for actions to include default values used.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.1.3"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/23/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added action SendFax and accompanying help text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.1.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 1/11/11 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated documentation for the SendAsFax action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 1/12/11 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated documentation for the UseWindowsAuthentication action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/23/11 JMartinez]]>
<![CDATA[
]]>
<![CDATA['- Moved parameter information from the qi= tag to the standard parameter help section]]>
<![CDATA[
]]>
<![CDATA['- Moved action information from the qi= tag to the standard action help section]]>
<![CDATA[
]]>
<![CDATA['- Added IBM Copyright notice]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/23/11 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 35163 - Identified which parameters support smart parameters.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.OpenTextFaxServer.Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="Connect">
			<h>
<![CDATA[
]]>
<![CDATA[        Connects to the fax server. This action should be called after setting the server connection parameters via the following actions: ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<i>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetWindowsAuthentication(True)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</i>
<![CDATA[
]]>
<![CDATA[        ]]>
				</b>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[Connect()]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if the connection to fax server cannot be established. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="Disconnect">
			<h>
<![CDATA[
]]>
<![CDATA[        Disconnects to the fax server. This action should be called after the ]]>
				<scr>
<![CDATA[Import()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Typically this action would be called at the Batch's close node, after the connection to the fax server is made and faxes are imported.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportPages()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[Disconnect()]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if the connection to fax server cannot be closed. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImportFaxes">
			<h>
<![CDATA[
]]>
<![CDATA[        This action imports faxes from the fax server. Each fax that is imported is stored in a document inside the Datacap batch. The following fax information]]>
<![CDATA[
]]>
<![CDATA[        will be stored in the document's variables (some of these variables can be empty): ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[UniqueID]]>
				</i>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[Status]]>
				</i>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[TotalPages]]>
				</i>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[LastHistoryChangeDateTime]]>
				</i>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[FromFaxNumber]]>
				</i>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[FromName]]>
				</i>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[FromVoiceNumber]]>
				</i>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[FromGeneralFaxNumber]]>
				</i>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[FromGeneralVoiceNumber]]>
				</i>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[Attachments]]>
				</i>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action after a ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[ImportFaxes()]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Note: if the Connect() action is not called prior to calling ImportFaxes(), ImportFaxes() will automatically call the Connect() action. However, the actions]]>
<![CDATA[
]]>
<![CDATA[          that set the connection parameters need to be called prior to ImportFaxes(). ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if an exception is encountered while importing faxes.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SendAsFax">
			<p name="ToFaxNumber" type="string">
			</p>
			<p name="ToName" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ToFaxNumber : Recipient's fax number. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ToName : Recipient's name. This paramater is optional. If left empty, the default ToName configured for the logged in user (on the server) will be used.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Faxes the document contents to the specified fax number.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SendAsFax("123-456-8971","John Doe")]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Note: a connection to the fax server must be established via actions before using the ]]>
					<b>
<![CDATA[
]]>
<![CDATA[            ]]>
						<i>
<![CDATA[SendAsFax]]>
						</i>
					</b>
<![CDATA[ action. ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Document and Page levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the document or page levels, or the fax number is not specified, or the document does not contain pages (attachments), if a connection cannot be made to the fax server, or if the fax server returns an exception while attempting to send the fax.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetAbortTimeout">
			<p name="Milliseconds" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        Milliseconds :The amount of time, in milliseconds, to wait before aborting a batch. The default value is 10000 ms (10 seconds). ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the amount of time to wait before aborting a batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The action will wait the specified time before returning when an abort occurs.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful to prevent a large number of aborted batches due to]]>
<![CDATA[
]]>
<![CDATA[        an abort condition. For example, if the fax server should become unavailable]]>
<![CDATA[
]]>
<![CDATA[        for a time, the abort timeout will limit the amount of aborted batches until]]>
<![CDATA[
]]>
<![CDATA[        the fax server becomes available again.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 10 seconds will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetAbortTimeout(5000)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetFaxRemovalAfterImport">
			<p name="RemoveFaxes" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A boolean that sets whether or not to remove processed faxes from the server. The default value is False.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ – Faxes will be removed from the fax server once they are imported into a Datacap batch.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ –  Faxes will remain in the fax server once they are imported into a Datacap batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[The default value is False ]]>
				</b>
<![CDATA[ ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets whether or not to remove processed faxes from the server after they have been imported into the Datacap batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of False will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetFaxRemovalAfterImport(True)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetMaxNumberOfFaxes">
			<p name="MaxFaxes" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MaxFaxes]]>
				</b>
<![CDATA[ – The maximum number of faxes allowed per batch. The default value is 100.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the maximum number of faxes allowed per batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 100 faxes per batch will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetMaxNumberOfFaxes(5)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetPollingInterval">
			<p name="Milliseconds" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Milliseconds]]>
				</b>
<![CDATA[ - The amount of time, in milliseconds, to wait before polling the fax server again. The default value is 2000 ms (2 seconds). ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the amount of time to wait before resuming fax polling from the server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 2 seconds will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetPollingInterval(5000)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetServerName">
			<p name="ServerName" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ServerName]]>
				</b>
<![CDATA[- The name of the fax server. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the name of the fax server to connect to.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<b>
<![CDATA[ImportFaxes()]]>
				</b>
<![CDATA[ or ]]>
				<b>
<![CDATA[Connect()]]>
				</b>
<![CDATA[ action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetServerName("myserver")]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetUserID">
			<p name="UserID" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[UserID]]>
				</b>
<![CDATA[- The user ID to be used to connect to the fax server. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the user ID to connect to the fax server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<b>
<![CDATA[ImportFaxes()]]>
				</b>
<![CDATA[ or ]]>
				<b>
<![CDATA[Connect()]]>
				</b>
<![CDATA[ action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            ]]>
					<b>
<![CDATA[SetUserID("myuser")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetUserPassword">
			<p name="UserPassword" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[UserPassword]]>
				</b>
<![CDATA[- The user ID password to connect to the fax server. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the user ID password to connect to the fax server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<b>
<![CDATA[ImportFaxes()]]>
				</b>
<![CDATA[ or ]]>
				<b>
<![CDATA[Connect()]]>
				</b>
<![CDATA[ action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you create an advanced value in the custom values tab in the]]>
<![CDATA[
]]>
<![CDATA[        Application Manager to encrypt your password instead of hard coding it in the]]>
<![CDATA[
]]>
<![CDATA[        action parameter.  The password can be retrieved using smart parameters.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetUserPassword("mypassword")]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetProtocol">
			<p name="Protocol" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        The protocol to be used to connect to the fax server. The default value is 4 (TCPIP). ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Valid parameter values are: ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1]]>
				</b>
<![CDATA[ – Named Pipes]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2]]>
				</b>
<![CDATA[ – IPXOS2]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[3]]>
				</b>
<![CDATA[ - SPX]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[4]]>
				</b>
<![CDATA[ - TCPIP]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[5]]>
				</b>
<![CDATA[ - IPX]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[6]]>
				</b>
<![CDATA[ - SecTCPIP]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[7]]>
				</b>
<![CDATA[ - SecSPX]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the protocol to be used to connect to the fax server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 4 (TCPIP protocol) will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetProtocol(4)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetWindowsAuthentication">
			<p name="UseWindowsAuthentication" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        Sets whether or not to use Windows Authentication to connect to the fax server. The default value is False.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ – Windows Authentication will be used. The actions SetUserID() and SetUserPassword() are not required when UseWindowsAuthentication is set to True.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ –  Fax Server user authentication will be used. The actions SetUserID() and SetUserPassword() are required when UseWindowsAuthentication is set to False.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[The default value is False ]]>
				</b>
<![CDATA[ ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the user ID password to connect to the fax server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of False seconds will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetWindowsAuthentication(True)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="PatternMatch" v="8.1.0.21">
	<i ref="rrunner">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' PatternMatch Actions]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Actions for matching / finding image patterns and text patterns]]>
<![CDATA[
]]>
<![CDATA[' image patterns/registration marks, etc in black & white images: PatternMatch_Identify, PatternMatch_Fingerprint, and PatternMatch_PageType actions call pm_Match]]>
<![CDATA[
]]>
<![CDATA[' text patterns in the CCO: pat_RecogMatch_Id  calls rm_match]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' Restricted Materials of IBM]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/21/2011 NSK for VS2010 Unicode]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/9/2012 NSK help text updated for pat_RecogMatch_ID]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/12/2012 NSK help text updated for all actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' LOG VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("PatternMatch.rrx " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['********************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_DCI ]]>
<![CDATA[
]]>
<![CDATA[Set g_DCI = CreateObject("DCIMAGE.DCImageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_dictAnchors]]>
<![CDATA[
]]>
<![CDATA[Set g_dictAnchors = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_dictPMID]]>
<![CDATA[
]]>
<![CDATA[Set g_dictPMID = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[' g_dictPMID will contain a dictionary of dictionaries]]>
<![CDATA[
]]>
<![CDATA[' the first level is keyed/indexed by Fingerprint ID]]>
<![CDATA[
]]>
<![CDATA[' each Fingerprint dictionary can contain multiple Pattern dictionaries]]>
<![CDATA[
]]>
<![CDATA[' each Pattern dictionary is keyed by the Position (expected coordinates) of a PatternMatch field in that Fingerprint]]>
<![CDATA[
]]>
<![CDATA[' the value (Item) of each Pattern dictionary entry is a csv of the field level METRIC and ReqConf values.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_dictPMIMAGE]]>
<![CDATA[
]]>
<![CDATA[Set g_dictPMIMAGE = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[' A dictionary of Image Handles based on the Key which is a fingerprint ID]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_MatchConf]]>
<![CDATA[
]]>
<![CDATA[g_MatchConf = clng(9)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim ogSemaphore            ' Semaphore to protect underlying dll when using Quattro]]>
<![CDATA[
]]>
<![CDATA[Set ogSemaphore = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim arAnchors()		' anchors that were found on this page]]>
<![CDATA[
]]>
<![CDATA[ReDim arAnchors(2, 0)]]>
<![CDATA[
]]>
<![CDATA[' first dimension is expected, found point]]>
<![CDATA[
]]>
<![CDATA[' value is (X,Y) of center point]]>
<![CDATA[
]]>
<![CDATA[Dim counter				' max dim of second dimension]]>
<![CDATA[
]]>
<![CDATA[counter = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' globals for linear scaling]]>
<![CDATA[
]]>
<![CDATA[Dim xScale]]>
<![CDATA[
]]>
<![CDATA[Dim xOff]]>
<![CDATA[
]]>
<![CDATA[Dim yScale]]>
<![CDATA[
]]>
<![CDATA[Dim yOff]]>
<![CDATA[
]]>
<![CDATA[xScale = 1]]>
<![CDATA[
]]>
<![CDATA[yScale = 1]]>
<![CDATA[
]]>
<![CDATA[xOff = 0]]>
<![CDATA[
]]>
<![CDATA[yOff = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
	<g>
<![CDATA[
]]>
<![CDATA[' RECOGMATCH UTILITY]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_dictRecAnchors]]>
<![CDATA[
]]>
<![CDATA[Set g_dictRecAnchors = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_dictRMID]]>
<![CDATA[
]]>
<![CDATA[Set g_dictRMID = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_DictTextIndex]]>
<![CDATA[
]]>
<![CDATA[Set g_DictTextIndex = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
	<af name="MatchPattern" access="public" bInter="bInter" bDebug="bDebug" qi="Align the image of this field on the current page with the fingerprint">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Searches on the current image in a zone associated with the current field]]>
<![CDATA[
]]>
<![CDATA[    for a match to the pattern specified for this field in a fingerprint.]]>
<![CDATA[
]]>
<![CDATA[    The zoned area from the original fingerprint is matched against a larger]]>
<![CDATA[
]]>
<![CDATA[    zone in the current image. The search area is controlled by the METRIC variable.]]>
<![CDATA[
]]>
<![CDATA[    METRIC=200,100 means search from 200 pixels to the left and right, and 100 pixels]]>
<![CDATA[
]]>
<![CDATA[    above and below the expected location. If METRIC is not specified, the default is 500]]>
<![CDATA[
]]>
<![CDATA[    pixels horizontal and vertical. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  The fingerprint is determined by the current image's Fingerprint ID, or the ]]>
<![CDATA[
]]>
<![CDATA[    Global Fingerprint ID if the current image is not identified.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    MatchPattern may be called on any field and if matched an offset variable will ]]>
<![CDATA[
]]>
<![CDATA[    be saved for that field.  If called prior to ReadZones then ReadZones will ]]>
<![CDATA[
]]>
<![CDATA[    use the offset for that field when setting its position.  ]]>
<![CDATA[
]]>
<![CDATA[    Other fields will be unaffected.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If the field is matched to the fingerprint with a confidence equal to or greater than the required confidence,]]>
<![CDATA[
]]>
<![CDATA[    the position of the field is set to the found location.]]>
<![CDATA[
]]>
<![CDATA[    If the field is not matched, the function returns false.]]>
<![CDATA[
]]>
<![CDATA[    If not found and the field's Required variable is nonzero, the field status is set to 1 (Error or Validation failed).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    This action operates on black and white images, grayscale or color images will cause the action to fail. The fingerprint image must have the same resolution (DPI) as the current page image. The geometric shape contained in the Anchor field should be bold and well defined with clear edges, with crisp black and white markings, producing a distinct shape. The shape should be thick and compact, not composed of long thin lines. To avoid false positive matches, the shape should not match other shapes or black areas that may exist nearby within the same image.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[MatchPattern()]]>
				</b>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[		]]>
			</e>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    - The Anchor position returned is not Numeric; or]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    - No image is found; or]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    - The accuracy of the match is below the set Confidence Value; or]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    - An Anchor match does not occur.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim l_HBitMap	]]>
<![CDATA[
]]>
<![CDATA[	Dim nL, nT, nR, nB]]>
<![CDATA[
]]>
<![CDATA[	Dim mL, mT, mR, mB]]>
<![CDATA[
]]>
<![CDATA[	Dim nX, nY, nC]]>
<![CDATA[
]]>
<![CDATA[	Dim vAnchor, nBH, nSub ]]>
<![CDATA[
]]>
<![CDATA[	Dim aAnchor, aMetric	]]>
<![CDATA[
]]>
<![CDATA[	Dim nTID]]>
<![CDATA[
]]>
<![CDATA[	Dim sTIDFileName]]>
<![CDATA[
]]>
<![CDATA[	Dim aResult]]>
<![CDATA[
]]>
<![CDATA[	Dim nWidth, nHeight, nResolution, nResult]]>
<![CDATA[
]]>
<![CDATA[	Dim nConf]]>
<![CDATA[
]]>
<![CDATA[	Dim oSA]]>
<![CDATA[
]]>
<![CDATA[	Dim g_oPM]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	MatchPattern = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called from a DCO field.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nTID = oCurPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'vANCHOR is the Position of the AREA on the Permanent Fingerprint to Match to.]]>
<![CDATA[
]]>
<![CDATA[	'vMETRIC is the area to search beyond the center of the source area: vANCHOR. Pattern is (Horizonal,Vertical) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(CurrentObj.Variable("ANCHOR"))>0 then]]>
<![CDATA[
]]>
<![CDATA[		vANCHOR = CurrentObj.Variable("ANCHOR")]]>
<![CDATA[
]]>
<![CDATA[		Writelog("'ANCHOR' variable found. ANCHOR ZONE='" & vANCHOR & "' ")]]>
<![CDATA[
]]>
<![CDATA[	Elseif len(CurrentObj.Variable("Pos" & nTID))>0 then]]>
<![CDATA[
]]>
<![CDATA[		vANCHOR = CurrentObj.Variable("Pos" & nTID) ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("'Pos" & nTID & "' variable found. ANCHOR ZONE='" & vANCHOR & "' ")]]>
<![CDATA[
]]>
<![CDATA[	Else ]]>
<![CDATA[
]]>
<![CDATA[		vANCHOR = CurrentObj.Variable("Position")	]]>
<![CDATA[
]]>
<![CDATA[		Writelog("'Position' variable found. ANCHOR ZONE='" & vANCHOR & "' ")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  vMETRIC=""]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.FindVariable("METRIC")>0 then]]>
<![CDATA[
]]>
<![CDATA[  	vMETRIC = CurrentObj.Variable("METRIC")]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Run Time METRIC variable found. METRIC='" & vMETRIC & "'")]]>
<![CDATA[
]]>
<![CDATA[  Elseif CurrentObj.Variable("METRIC")<>"" then]]>
<![CDATA[
]]>
<![CDATA[    vMETRIC = CurrentObj.Variable("METRIC")]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Setup XML METRIC variable found. METRIC='" & vMETRIC & "'")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		vMETRIC = "500,500"]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Default Metric used. METRIC='" & vMETRIC & "'")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aAnchor=Split(vAnchor, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(aAnchor)]]>
<![CDATA[
]]>
<![CDATA[		If IsNumeric(aAnchor(i)) then ]]>
<![CDATA[
]]>
<![CDATA[			aAnchor(i)=CLng(aAnchor(i))]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			writelog("Invalid Anchor Position info. A non-numeric value was found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Set PATTERN AREA]]>
<![CDATA[
]]>
<![CDATA[	nL = aAnchor(0)]]>
<![CDATA[
]]>
<![CDATA[	nT = aAnchor(1)]]>
<![CDATA[
]]>
<![CDATA[	nR = aAnchor(2)]]>
<![CDATA[
]]>
<![CDATA[	nB = aAnchor(3)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aMetric = Split(vMetric, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(aMetric )]]>
<![CDATA[
]]>
<![CDATA[		If IsNumeric(aMetric (i)) then ]]>
<![CDATA[
]]>
<![CDATA[			aMetric(i)=CLng(aMetric (i))]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			writelog("Invalid METRIC Position information. A non-numeric value was found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                    ' Get Pattern Match object lock]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Calculate Search Area based on METRIC, Note: must be recalculated using image area to reflect image bounds]]>
<![CDATA[
]]>
<![CDATA[	mL = aAnchor(0)-aMetric(0)]]>
<![CDATA[
]]>
<![CDATA[	If mL<0 then mL = Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	mT = aAnchor(1)-aMetric(1)]]>
<![CDATA[
]]>
<![CDATA[	if mT<0 then mT = Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	mR = aAnchor(2)+aMetric(0)]]>
<![CDATA[
]]>
<![CDATA[	mB = aAnchor(3)+aMetric(1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(nTID)>0 and IsNumeric(nTID) then]]>
<![CDATA[
]]>
<![CDATA[		aResult = GetDataArray("SELECT tp_ImagePath FROM Template WHERE tp_TemplateID =" & nTID & "; ")	]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		aResult = GetDataArray("SELECT tp_ImagePath FROM Template WHERE tp_Status =" & chr(39) & "<Global>" & chr(39) & "; ")]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If isArray(aResult) then]]>
<![CDATA[
]]>
<![CDATA[		sTIDFileName  = g_DCI.FileName ]]>
<![CDATA[
]]>
<![CDATA[		sTIDFileName = aResult(0,0)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Anchor Image: '" & sTIDFileName & "' ")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Anchor Image Path found.")]]>
<![CDATA[
]]>
<![CDATA[    pm_ReleaseLock()                                               ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_DCI.FileName = sTIDFileName]]>
<![CDATA[
]]>
<![CDATA[	g_DCI.Invert]]>
<![CDATA[
]]>
<![CDATA[	lHBitMap = g_DCI.GetHBITMAP]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If g_dictAnchors.Exists(sTIDFileName & vAnchor) then ]]>
<![CDATA[
]]>
<![CDATA[		Set g_oPM = g_dictAnchors.Item(sTIDFileName & vAnchor)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Set g_oPM = CreateObject("Datacap.PatternMatch")]]>
<![CDATA[
]]>
<![CDATA[		MatchPattern = g_oPM.CreateAnchor(nL,nT,nR,nB,lHBitMap)]]>
<![CDATA[
]]>
<![CDATA[		Set g_dictAnchors(sTIDFileName & vAnchor) = g_oPM]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	g_DCI.FileName = oCurPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Search Image: '" & g_DCI.FileName & "' ")]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.filename = g_DCI.FileName ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call g_DCI.Invert]]>
<![CDATA[
]]>
<![CDATA[	lHBitMap = g_DCI.GetHBITMAP]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nResult = g_DCI.GetImageInfo(nWidth, nHeight, nResolution)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If clng(mR) > clng(nWidth) then mR = clng(nWidth)]]>
<![CDATA[
]]>
<![CDATA[	If clng(mB) > clng(nHeight) then mB = clng(nHeight)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Search Area: " & mL & "," & mT & "," & mR & "," & mB)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MatchPattern = g_oPM.SearchForAnchor(mL, mT, mR, mB, lHBitMap)', nBH, nSub ,nX, nY, nC)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Set oSA = g_oPM.StatUP]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Writelog("X:" & oSA.X & ", Y:" & oSA.Y & " diff:" & oSA.Diff & " white:" & oSA.White & " black:" & oSA.Black & "  w_diff:" & oSA.w_diff & " w_white:" & oSA.w_White & " w_black:" & oSA.w_black)                                                                       ]]>
<![CDATA[
]]>
<![CDATA[	'nRectIndex = ImageCtrl.DrawRect(nL,nT,nR,nB,3,RGB(0,0,255),RGB(255,0,0),"")]]>
<![CDATA[
]]>
<![CDATA[	'nRectIndex = ImageCtrl.DrawRect(oSA.X ,oSA.Y ,oSA.X + (nR-nL),oSA.Y + (nB-nT),3,RGB(255,0,0),RGB(255,0,0),"")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nConf = g_oPM.Confidence]]>
<![CDATA[
]]>
<![CDATA[	writelog("Match Confidence: " & nConf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_DCI.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if clng(nConf)<clng(g_MatchConf) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Confidence too low - match requires conf " & clng(g_MatchConf))]]>
<![CDATA[
]]>
<![CDATA[		MatchPattern = False	]]>
<![CDATA[
]]>
<![CDATA[		Set oSA = Nothing]]>
<![CDATA[
]]>
<![CDATA[    pm_ReleaseLock()                                               ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.Variable("Req"&nTID) = "1" Or CurrentObj.Variable("Required") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[    	CurrentObj.Variable("STATUS") = 1]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Calculate Offset for found Pattern]]>
<![CDATA[
]]>
<![CDATA[	Dim xOffset, yOffset]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	xOffset = abs(clng(aAnchor(0)) - clng(mL+oSA.X))]]>
<![CDATA[
]]>
<![CDATA[	yOffset = abs(clng(aAnchor(1)) - clng(mT+oSA.Y))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If clng(aAnchor(0))>clng(mL+oSA.X) then xOffset = (xOffset * -1)]]>
<![CDATA[
]]>
<![CDATA[	If clng(aAnchor(1))>clng(mT+oSA.Y) then yOffset = (yOffset * -1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Calculated offset is: (" & xOffset & "," & yOffset & ")") ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("Image_Offset") = xOffset & "," & yOffset ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("Zone_Offset") = xOffset & "," & yOffset ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("Position") = CStr(nL+xOffset) & "," & CStr(nT+yOffset) & "," & CStr(nR+xOffset) & "," & CStr(nB+yOffset)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oSA = Nothing ]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()                                               ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="PatternMatch_Identify" access="public" bInter="bInter" bDebug="bDebug" qi="Identifies a page using image pattern matching.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    PatternMatch_Identify identifies a page's type and fingerprint using geometric pattern matching. The locations of unique patterns are configured as Anchor Fields for each fingerprint in the Document Hierarchy. One or more Anchor fields can be used to match geometric shapes on a fingerprint to the current image. If one or more Anchor fields on the current page match a fingerprint, at or above the configured confidence level, the page is identified with that fingerprint. The action does not require all defined anchors to match - the first match is used.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    The action loads all Anchor field patterns from the fingerprint library, then searches on the current image for each of the patterns in the associated zones. The search area for each zone is increased by the dimensions specified in the page METRIC variable. If METRIC is not specified, the default is 500 pixels horizontal and vertical.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    When this action finds a match, it sets the matching Fingerprint ID and Page Type. It will also create page-level fields and update the Anchor fields with Anchor-specific pattern offset values in a field-level Image_Offset variable. The offset can be used subsequent to matching a fingerprint. The pat_RegisterZones action can be used to align the zones in the fingerprint to the current image, providing more accurately positioned text in each field.]]>
<![CDATA[
]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    This action requires the current page image to be bitonal (black and white), grayscale or color images will cause the action to fail. The fingerprint image must have the same resolution (DPI) as the current page image. The geometric shape contained in each Anchor field should be bold and well defined with clear edges, with crisp black and white markings, producing a distinct shape. The shape should be thick and compact, not composed of long thin lines. To avoid false positive matches, the shape should not match other shapes or black areas that may exist nearby within the same image.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[PatternMatch_Identify()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<lit>
<![CDATA[False]]>
			</lit>
<![CDATA[ if the rule containing this action was not applied to a Page object of the Document Hierarchy; if a pattern match is not found; or if fingerprints do not exist. Otherwise, ]]>
			<lit>
<![CDATA[True]]>
			</lit>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatch	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On error resume next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_Identify = False]]>
<![CDATA[
]]>
<![CDATA[	bMatch = False]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<>2 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Current DCO is not a Page.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()]]>
<![CDATA[
]]>
<![CDATA[  If g_dictPMID.Count = 0 then Call pm_LoadDict("*")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = g_dictPMID.Keys]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_Identify = pm_Match(aStrParam)	]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="PatternMatch_Fingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Identifies a page from a specified list of fingerprints.">
		<ap>
<![CDATA[
]]>
<![CDATA[    A comma-separated list of one or more Fingerprint ID's.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    PatternMatch_Fingerprint identifies a page's type and fingerprint using geometric pattern matching. The locations of unique patterns are configured as Anchor Fields for each fingerprint in the Document Hierarchy. One or more Anchor fields can be used to match geometric shapes on a fingerprint to the current image. If one or more Anchor fields on the current page match a fingerprint, at or above the configured confidence level, the page is identified with that fingerprint. The action does not require all defined anchors to match - the first match is used.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    The action loads all Anchor field patterns from the specified fingerprints, then searches on the current image for each of the patterns in the associated zones. The search area for each zone is increased by the dimensions specified in the page METRIC variable. If METRIC is not specified, the default is 500 pixels horizontal and vertical.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    When this action finds a match, it sets the matching Fingerprint ID and Page Type. It will also create page-level fields and update the Anchor fields with Anchor-specific pattern offset values in a field-level Image_Offset variable. The offset can be used subsequent to matching a fingerprint. The pat_RegisterZones action can be used to align the zones in the fingerprint to the current image, providing more accurately positioned text in each field.]]>
<![CDATA[
]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    This action requires the current page image to be bitonal (black and white), grayscale or color images will cause the action to fail. The fingerprint image must have the same resolution (DPI) as the current page image. The geometric shape contained in each Anchor field should be bold and well defined with clear edges, with crisp black and white markings, producing a distinct shape. The shape should be thick and compact, not composed of long thin lines. To avoid false positive matches, the shape should not match other shapes or black areas that may exist nearby within the same image.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[PatternMatch_Fingerprint(1024,1034,1035,1036)]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      This example compares the current page to the four fingerprints specified by their IDs.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the rule containing this action was not applied to a Page object of ]]>
<![CDATA[
]]>
<![CDATA[    the Document Hierarchy; if a parameter is invalid; if a match does not occur; ]]>
<![CDATA[
]]>
<![CDATA[    or if one or more of the specified fingerprints do not exist. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[  Dim k]]>
<![CDATA[
]]>
<![CDATA[  Dim nTID]]>
<![CDATA[
]]>
<![CDATA[	Dim aResult	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatch	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_Fingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	bMatch = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'StrParam is a Comma delineated list of Fingerprint ID's. A Match to a listed ]]>
<![CDATA[
]]>
<![CDATA[	'Fingerprint id for the current obj's image returns true.]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<>2 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Current DCO is not a Page.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,Chr(32),"")]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Ubound(aStrParam) = -1 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Parameter")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                     ' Now get the lock for PatternMatch]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Unload fingerprints not found in the parameter  ]]>
<![CDATA[
]]>
<![CDATA[  Call pm_UnloadDict(StrParam)  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	'Check if Dictionary has loaded	templates]]>
<![CDATA[
]]>
<![CDATA[	bFound = TRUE]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 to ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[		nTID = aStrParam(k)]]>
<![CDATA[
]]>
<![CDATA[		If Not(g_dictPMID.Exists(nTID)) and Trim(nTID)<>"" Then bFound = False 	]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If bFound=False or g_dictPMID.Count = 0 then]]>
<![CDATA[
]]>
<![CDATA[    Call pm_LoadDict(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_Fingerprint = pm_Match(aStrParam) ]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()                                 ' Done with PatternMatch]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="PatternMatch_PageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Identifies a page according to its Page Type. ">
		<ap>
<![CDATA[
]]>
<![CDATA[    One or more Page Types defined in the Document Hierarchy]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    PatternMatch_PageType identifies a page's type and fingerprint using geometric pattern matching. The locations of unique patterns are configured as Anchor Fields for each fingerprint in the Document Hierarchy. One or more Anchor fields can be used to match geometric shapes on a fingerprint to the current image. If one or more Anchor fields on the current page match a fingerprint, at or above the configured confidence level, the page is identified with that fingerprint. The action does not require all defined anchors to match - the first match is used.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    The action loads all Anchor field patterns from fingerprints with the specified page types, then searches on the current image for each of the patterns in the associated zones. The search area for each zone is increased by the dimensions specified in the page METRIC variable. If METRIC is not specified, the default is 500 pixels horizontal and vertical.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    When this action finds a match, it sets the matching Fingerprint ID and Page Type. It will also create page-level fields and update the Anchor fields with Anchor-specific pattern offset values in a field-level Image_Offset variable. The offset can be used subsequent to matching a fingerprint. The pat_RegisterZones action can be used to align the zones in the fingerprint to the current image, providing more accurately positioned text in each field.]]>
<![CDATA[
]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    This action requires the current page image to be bitonal (black and white), grayscale or color images will cause the action to fail. The fingerprint image must have the same resolution (DPI) as the current page image. The geometric shape contained in each Anchor field should be bold and well defined with clear edges, with crisp black and white markings, producing a distinct shape. The shape should be thick and compact, not composed of long thin lines. To avoid false positive matches, the shape should not match other shapes or black areas that may exist nearby within the same image.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[PatternMatch_PageType(HCFA 1500)]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      This action looks for a match among the inventory of fingerprints that have a ]]>
<![CDATA[
]]>
<![CDATA[      page type of "HCFA 1500".]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the rule containing this action was not applied to a Page ]]>
<![CDATA[
]]>
<![CDATA[    object of the Document Hierarchy; if the parameter is invalid; if a match ]]>
<![CDATA[
]]>
<![CDATA[    does not occur; or if fingerprints do not yet exist. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	Dim sTID]]>
<![CDATA[
]]>
<![CDATA[	Dim DCOsetup]]>
<![CDATA[
]]>
<![CDATA[	Dim ChildNode]]>
<![CDATA[
]]>
<![CDATA[	Dim i,j]]>
<![CDATA[
]]>
<![CDATA[	Dim nTID	]]>
<![CDATA[
]]>
<![CDATA[	Dim aResult	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam()]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim lHBitMap	]]>
<![CDATA[
]]>
<![CDATA[	Dim iBitMapObj]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatch	]]>
<![CDATA[
]]>
<![CDATA[	Dim aPageTypes]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_PageType = False]]>
<![CDATA[
]]>
<![CDATA[	bMatch = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'StrParam is a comma-separated list of PageTypes. A Match to any PageType associated ]]>
<![CDATA[
]]>
<![CDATA[	'Fingerprint id for the current obj's image returns true.]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<>2 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Current DCO is not a Page.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,Chr(32),"")]]>
<![CDATA[
]]>
<![CDATA[	aPageTypes = Split(StrParam,",")	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Ubound(aPageTypes) = -1 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Parameter")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                                  ' Now get the PM Lock ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	'Get FingerPrints associated with specified pagetypes from RulesDB	]]>
<![CDATA[
]]>
<![CDATA[	sSQL = "SELECT tp_TemplateID FROM TEMPLATE, PAGETYPE WHERE TP_PAGETYPE=PT_PAGETYPEID AND PT_PAGETYPE IN ('" & Join(aPageTypes,"','") & "'); "]]>
<![CDATA[
]]>
<![CDATA[	'sSQL = "SELECT tp_TemplateID FROM TEMPLATE, PAGETYPE WHERE TP_PAGETYPE=PT_PAGETYPEID AND PT_PAGETYPE='" & TRIM(StrParam) & "'; "]]>
<![CDATA[
]]>
<![CDATA[	Writelog("SQL:>> " & sSQL & " <<")]]>
<![CDATA[
]]>
<![CDATA[	aResult = GetDataArray(sSQL) ]]>
<![CDATA[
]]>
<![CDATA[	If Not(IsArray(aResult)) Then	]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No FingerPrint ID's Found.")]]>
<![CDATA[
]]>
<![CDATA[    pm_ReleaseLock()                                             ' No results, release the PM Lock.]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	ReDim aStrParam(uBound(aResult,1))		]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 to ubound(aResult,1)	]]>
<![CDATA[
]]>
<![CDATA[		aStrParam(k) = cstr(aResult(k,0))]]>
<![CDATA[
]]>
<![CDATA[	Next 'k	]]>
<![CDATA[
]]>
<![CDATA[	'aStrParam now is an array of FingerPrint IDs associated with specified pagetypes]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  'Remove fingerprint ID number not in Search array    ]]>
<![CDATA[
]]>
<![CDATA[  Call pm_UnloadDict(join(aStrparam,","))]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	'Check if Dictionary has loaded	fingerprint ID numbers]]>
<![CDATA[
]]>
<![CDATA[	bFound = TRUE]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 to ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[		nTID = aStrParam(k)]]>
<![CDATA[
]]>
<![CDATA[		If Not(g_dictPMID.Exists(nTID)) and Trim(nTID)<>"" Then bFound = False ]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'bFound is True only if ALL specified PageTypes with associated Templates have loaded PatternMatch dictionary]]>
<![CDATA[
]]>
<![CDATA[	If bFound=False or g_dictPMID.Count = 0 then]]>
<![CDATA[
]]>
<![CDATA[    Call pm_LoadDict(join(aStrparam,","))]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_PageType = pm_Match(aStrParam) ]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()                                                ' Remove the PM lock.]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SetMatchConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the confidence threshold for pattern matching.">
		<ap>
<![CDATA[
]]>
<![CDATA[    The value of the confidence threshold.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  	The value must be between 0 (lowest confidence) and 9 (highest confidence).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Higher values require fewer differences between the compared areas to return a positive match value.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[     Sets the confidence threshold for pattern matching.]]>
<![CDATA[
]]>
<![CDATA[		]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[SetMatchConfidence(9)]]>
				</b>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[		]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the parameter is not a number between 0 and 9.  Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	SetMatchConfidence = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = clng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If StrParam < 0 or StrParam > 9 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Match Confidence Must be a value between 0 and 9.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetMatchConfidence = True]]>
<![CDATA[
]]>
<![CDATA[	g_MatchConf = StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
		</g>
	</af>
	<g>
<![CDATA[
]]>
<![CDATA['Anchor Actions ]]>
<![CDATA[
]]>
	</g>
	<af name="pat_RegisterZones" access="public" bInter="bInter" bDebug="bDebug" qi="Registers and adjusts the positions of all fields on the current source page, based on the positions of the page's designated Anchor field(s).">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    pat_RegisterZones registers and adjusts the positions of all fields on the current page, based on the previously matched positions of the page's designated Anchor field(s). Anchor fields are determined by the Anchor Field setting in Datacap Studio, for each field.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Prior to calling pat_RegisterZones, usually in a different task or ruleset, one of the PatternMatch actions that performs Anchor matching must be called. Then, when the pat_RegisterZones action is called, the expected positions of the Anchor fields on the image (taking into account the Fingerprint classification) are compared with the recognized positions of the fields identified as an Anchor field. The action ReadZones must be called prior to pat_RegisterZones. If any required Anchors are not matched, an operator may be required to update the Anchor position in a verify or fixup task.]]>
<![CDATA[
]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    All matched or manually adjusted Anchor positions are used for adjustment, Anchors that are not matched are ignored.  ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    If one Anchor is found, the field positions are all shifted by the same amount.]]>
<![CDATA[
]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    If two or more Anchors are found, the field positions are shifted by different amounts, depending on their distance from each Anchor. This process is called Interpolation.]]>
<![CDATA[
]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    The expected positions of the Anchor fields on the image (taking into]]>
<![CDATA[
]]>
<![CDATA[    account the Fingerprint classification) are compared with the recognized positions]]>
<![CDATA[
]]>
<![CDATA[    of those Anchor fields - or the Anchor positions set manually by a Fixup task's operator.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[
]]>
<![CDATA[        ReadZones()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        pat_RegisterZones()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        PrecognizePageFieldsOCR_S()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the ruleset with this action is bound to a Page object of the Document Hierarchy, ]]>
<![CDATA[
]]>
<![CDATA[    and if the action can find all designated Anchor fields. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim oPg]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	pat_RegisterZones = False]]>
<![CDATA[
]]>
<![CDATA[	counter = 0]]>
<![CDATA[
]]>
<![CDATA[	xScale = 1]]>
<![CDATA[
]]>
<![CDATA[	yScale = 1]]>
<![CDATA[
]]>
<![CDATA[	xOff = 0]]>
<![CDATA[
]]>
<![CDATA[	yOff = 0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	set oPg = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	if (CurrentObj.ObjectType <> 2) then Exit Function ' must be a page]]>
<![CDATA[
]]>
<![CDATA[	If (oPg.NumOfChildren <= 0) Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("No fields in current page, RegisterPageAnchors fails")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                          ' Get pattern match object lock]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sName = ""	]]>
<![CDATA[
]]>
<![CDATA[	sName = oPg.Variable("TemplateID") ' needed to find expected positions?]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	if (sName = "") then]]>
<![CDATA[
]]>
<![CDATA[		sPosName = "Position"]]>
<![CDATA[
]]>
<![CDATA[	else]]>
<![CDATA[
]]>
<![CDATA[		sPosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' make a list of all found anchors]]>
<![CDATA[
]]>
<![CDATA[	For i = 0 To oPg.NumOfChildren -1]]>
<![CDATA[
]]>
<![CDATA[		Set oAnc = oPg.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		If Not oAnc Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[			If oAnc.Variable("PatternMatch") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[				AnchorsFound = False]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Anchor " & oAnc.Type & " found. Looking for offset...")]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				Set oSetupNode = oAnc.SetupNode()]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[				' get expected loc]]>
<![CDATA[
]]>
<![CDATA[				sExp = oSetupNode.Variable(sPosName)]]>
<![CDATA[
]]>
<![CDATA[				If (len(sExp) <= 1) Then sExp = oSetupNode.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[				If (len(sExp) > 1) then]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("Expected " & sExp)]]>
<![CDATA[
]]>
<![CDATA[					arExp = split(sExp, ",", -1, 1)]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("Image_Offset " & oAnc.Variable("Image_Offset"))]]>
<![CDATA[
]]>
<![CDATA[					sOff = oAnc.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[					If Len(sOff) < 1 Then]]>
<![CDATA[
]]>
<![CDATA[						WriteLog("Zone_Offset " & oAnc.Variable("Zone_Offset"))]]>
<![CDATA[
]]>
<![CDATA[						sOff = oAnc.Variable("Zone_Offset")]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[					' Anchor was found, we can tell because offset was set]]>
<![CDATA[
]]>
<![CDATA[					If Len(sOff) >= 1 Then]]>
<![CDATA[
]]>
<![CDATA[						arOff = split(sOff, ",", -1, 1)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						sExp = CStr(CInt((CInt(arExp(0)) + CInt(arExp(2)) + .5)/2.)) & "," & CStr(CInt((CInt(arExp(1)) + CInt(arExp(3)) + .5)/2.))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						Redim Preserve arAnchors(2, counter+1)]]>
<![CDATA[
]]>
<![CDATA[						sFnd = CStr(CInt(arOff(0) + (CInt(arExp(0)) + CInt(arExp(2)) + .5)/2.)) & "," & CStr(CInt(arOff(1) + (CInt(arExp(1)) + CInt(arExp(3)) + .5)/2.))]]>
<![CDATA[
]]>
<![CDATA[						arAnchors(0, counter) = CStr(sExp)]]>
<![CDATA[
]]>
<![CDATA[						arAnchors(1, counter) = CStr(sFnd)]]>
<![CDATA[
]]>
<![CDATA[						counter = counter + 1]]>
<![CDATA[
]]>
<![CDATA[					End If	' found an anchor that is set on this image]]>
<![CDATA[
]]>
<![CDATA[				End If		' found an anchor that has an expected location POSnnnn for this fingerprint]]>
<![CDATA[
]]>
<![CDATA[			End If			' found a pattern match (anchor) field]]>
<![CDATA[
]]>
<![CDATA[		End If				' found a field in this runtime DCO]]>
<![CDATA[
]]>
<![CDATA[	Next ' i				' loop through fields in this runtime DCO]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If counter = 3 Then]]>
<![CDATA[
]]>
<![CDATA[		' special case for 3 FOUND anchors - calculate linear scale and offset X & Y]]>
<![CDATA[
]]>
<![CDATA[		' use found anchor pair with biggest X difference, and pair with biggest Y difference]]>
<![CDATA[
]]>
<![CDATA[		'Writelog("Linear anchor calculate")]]>
<![CDATA[
]]>
<![CDATA[		xMax = 0]]>
<![CDATA[
]]>
<![CDATA[		yMax = 0]]>
<![CDATA[
]]>
<![CDATA[		' match up all anchor pairs to find the most distant pair in X and Y axes]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 To counter-1]]>
<![CDATA[
]]>
<![CDATA[			For j = 0 To counter-1]]>
<![CDATA[
]]>
<![CDATA[				If i <> j Then]]>
<![CDATA[
]]>
<![CDATA[					arAnchExp1 = split(arAnchors(0, i), ",")]]>
<![CDATA[
]]>
<![CDATA[					arAnchFnd1 = split(arAnchors(1, i), ",")]]>
<![CDATA[
]]>
<![CDATA[					arAnchExp2 = split(arAnchors(0, j), ",")]]>
<![CDATA[
]]>
<![CDATA[					arAnchFnd2 = split(arAnchors(1, j), ",")]]>
<![CDATA[
]]>
<![CDATA[					xdiff = ABS(arAnchFnd1(0)-arAnchFnd2(0))]]>
<![CDATA[
]]>
<![CDATA[					ydiff = ABS(arAnchFnd1(1)-arAnchFnd2(1))]]>
<![CDATA[
]]>
<![CDATA[					if xdiff > xMax then]]>
<![CDATA[
]]>
<![CDATA[						xMax = xdiff]]>
<![CDATA[
]]>
<![CDATA[						xScale = xdiff / ABS(arAnchExp1(0)-arAnchExp2(0))]]>
<![CDATA[
]]>
<![CDATA[					end if]]>
<![CDATA[
]]>
<![CDATA[					if ydiff > yMax then]]>
<![CDATA[
]]>
<![CDATA[						yMax = ydiff]]>
<![CDATA[
]]>
<![CDATA[						yScale = ydiff / ABS(arAnchExp1(1)-arAnchExp2(1))]]>
<![CDATA[
]]>
<![CDATA[					end if]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next ' j]]>
<![CDATA[
]]>
<![CDATA[		Next ' i]]>
<![CDATA[
]]>
<![CDATA[		'WriteLog("X scale " + CStr(xScale) + " span " + CStr(xMax))]]>
<![CDATA[
]]>
<![CDATA[		'WriteLog("Y scale " + CStr(yScale) + " span " + CStr(yMax))]]>
<![CDATA[
]]>
<![CDATA[		' we have found the X and Y scale, now calculate offset]]>
<![CDATA[
]]>
<![CDATA[		' negative of average distance from expected to found]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 To counter-1	]]>
<![CDATA[
]]>
<![CDATA[			arAnchExp1 = split(arAnchors(0, i), ",")]]>
<![CDATA[
]]>
<![CDATA[			arAnchExp1(0) = arAnchExp1(0)*xScale]]>
<![CDATA[
]]>
<![CDATA[			arAnchFnd1 = split(arAnchors(1, i), ",")]]>
<![CDATA[
]]>
<![CDATA[			arAnchExp1(1) = arAnchExp1(1)*yScale]]>
<![CDATA[
]]>
<![CDATA[			xOff = xOff + (arAnchFnd1(0)-arAnchExp1(0))]]>
<![CDATA[
]]>
<![CDATA[			yOff = yOff + (arAnchFnd1(1)-arAnchExp1(1))]]>
<![CDATA[
]]>
<![CDATA[		Next ' i]]>
<![CDATA[
]]>
<![CDATA[		xOff = xOff / counter]]>
<![CDATA[
]]>
<![CDATA[		yOff = yOff / counter]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Linear scale ("+ CStr(xScale) + ","+ CStr(yScale) +") offset ("+ CStr(xOff) +","+ CStr(yOff) +")")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' now adjust all the fields using the found anchors]]>
<![CDATA[
]]>
<![CDATA[	If counter > 0 Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Register using " & counter & " anchors")]]>
<![CDATA[
]]>
<![CDATA[		temp = AZoneChildren(CurrentObj, sPosName)]]>
<![CDATA[
]]>
<![CDATA[		pat_RegisterZones = temp]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("No anchors set on this page")]]>
<![CDATA[
]]>
<![CDATA[		pat_RegisterZones = True			' this is OK, not an error]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()                                               ' Release Pattern Match lock	  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="pat_ReleasePageAnchors" access="public" bInter="bInter" bDebug="bDebug" qi="An action that can be called at the end of a batch to release information about the identity and location of a page's Anchor field(s).">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action can be optionally called to release the small amount of Anchor memory that]]>
<![CDATA[
]]>
<![CDATA[    was allocated by the action pat_RegisterZones.  If pat_ReleasePageAnchors is not called,]]>
<![CDATA[
]]>
<![CDATA[    the memory will be released at the end of the batch or the next time pat_RegisterZones is called.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[pat_ReleasePageAnchors()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<ret>
<![CDATA[Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	Redim arAnchors(2, 0)]]>
<![CDATA[
]]>
<![CDATA[	pat_ReleasePageAnchors = True]]>
<![CDATA[
]]>
		</g>
	</af>
	<g>
<![CDATA[
]]>
<![CDATA['Recogmatch Actions]]>
<![CDATA[
]]>
	</g>
	<af name="pat_RecogMatch_Id" access="public" bInter="bInter" bDebug="bDebug" qi="Identifies the current page type by matching OCR results in any fingerprint Anchor zone with OCR results for the corresponding zone on the current page.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    pat_RecogMatch_Id identifies the page by matching text from any fingerprint Anchor field with the corresponding text on the current page.  Fuzzy matching is used. Full-page OCR or ICR must be performed prior to calling this action.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<br>
			</br>
<![CDATA[ ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    If any Anchor field text in the current page matches the zonal text of any fingerprint, the page is identified by that fingerprint (first match).]]>
<![CDATA[
]]>
<![CDATA[    The Type of the current page is set to the fingerprint page type if a match is found.]]>
<![CDATA[
]]>
<![CDATA[    Full page OCR or ICR must be performed on both the fingerprints and the current image prior to calling this action.]]>
<![CDATA[
]]>
<![CDATA[    Text to be matched is extracted from each fingerprint's Anchor field, which should be defined tightly around the text in the fingerprint. The search area in the current image is the fingerprint-specific field zone in the Document Hierarchy, extended by any associated METRIC variable.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<br>
			</br>
<![CDATA[ ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    Page identification using pat_RecogMatch_ID (text matching) is mutually exclusive with identification using graphical pattern matching actions (PatternMatch_Identify, etc.).  ]]>
<![CDATA[
]]>
<![CDATA[    Anchor fields in the Document Hierarchy should be selected carefully so that false positive text matches do not occur.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<br>
			</br>
<![CDATA[ ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[pat_RecogMatch_Id()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[	]]>
		</h>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the ruleset is bound to a Page, and a fingerprint matching the text of at least one Anchor field is found. Otherwise, and in case of any errors, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[In addition, the page variable TemplateID is set to the matching Fingerprint ID.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[	Dim sTID]]>
<![CDATA[
]]>
<![CDATA[	Dim DCOsetup]]>
<![CDATA[
]]>
<![CDATA[	Dim ChildNode]]>
<![CDATA[
]]>
<![CDATA[	Dim i,j]]>
<![CDATA[
]]>
<![CDATA[	Dim nTID	]]>
<![CDATA[
]]>
<![CDATA[	Dim aResult	]]>
<![CDATA[
]]>
<![CDATA[	Dim lHBitMap]]>
<![CDATA[
]]>
<![CDATA[	Dim oSA ]]>
<![CDATA[
]]>
<![CDATA[	Dim iCCOobj]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCOCreator]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatch]]>
<![CDATA[
]]>
<![CDATA[	Dim aAnchor]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On error resume next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	pat_RecogMatch_Id = False]]>
<![CDATA[
]]>
<![CDATA[	bMatch = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<>2 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Current DCO is not a Page.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                      ' Get Pattern Match object lock]]>
<![CDATA[
]]>
<![CDATA[	Set oSA = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCCOCreator	= CreateObject("CCO._CCOCreator")]]>
<![CDATA[
]]>
<![CDATA[	Set iCCOobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check if Dictionary is already loaded	]]>
<![CDATA[
]]>
<![CDATA[	If g_dictRMID.Count = 0 then	]]>
<![CDATA[
]]>
<![CDATA[		'Read Setup DCO and a Create Dictionary of CCO Recognition Match Objects]]>
<![CDATA[
]]>
<![CDATA[		Set DCOsetup = DCO.SetupObject	]]>
<![CDATA[
]]>
<![CDATA[		If DCOsetup is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[       pm_ReleaseLock()                              ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[       Exit Function       ]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Set ChildNode = Nothing]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		For i = 1 to DCOsetup.NumOfNodes(3)]]>
<![CDATA[
]]>
<![CDATA[			Set ChildNode = DCOsetup.GetNode(3,i-1)]]>
<![CDATA[
]]>
<![CDATA[			If Not(ChildNode is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[				If ChildNode.Variable("PatternMatch")="1" Then		]]>
<![CDATA[
]]>
<![CDATA[					For j = 0 to ChildNode.NumOfVariables]]>
<![CDATA[
]]>
<![CDATA[						If left(ChildNode.VariableName(j) & Space(3),3)="Pos" And isnumeric(replace(ChildNode.VariableName(j),"Pos","")) then	]]>
<![CDATA[
]]>
<![CDATA[							nTID = trim(replace(ChildNode.VariableName(j),"Pos",""))]]>
<![CDATA[
]]>
<![CDATA[							If isNumeric(nTID) and len(nTID)>=1 then ]]>
<![CDATA[
]]>
<![CDATA[																	]]>
<![CDATA[
]]>
<![CDATA[								'Add to Dictionary]]>
<![CDATA[
]]>
<![CDATA[								If Not(g_dictRMID.Exists(nTID)) then ]]>
<![CDATA[
]]>
<![CDATA[									Set g_dictRMID(nTID) = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[								End if	]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[								Set dictZone = g_dictRMID(nTID)]]>
<![CDATA[
]]>
<![CDATA[																	]]>
<![CDATA[
]]>
<![CDATA[								If Not(dictZone.Exists(ChildNode.Variable("Pos" & nTID))) then ]]>
<![CDATA[
]]>
<![CDATA[									Call dictZone.Add(ChildNode.Variable("Pos" & nTID),cstr(""))]]>
<![CDATA[
]]>
<![CDATA[								End if	]]>
<![CDATA[
]]>
<![CDATA[															]]>
<![CDATA[
]]>
<![CDATA[								Set g_dictRMID(nTID) = dictZone]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					Next 'j					]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				Set ChildNode = Nothing]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Next 'i]]>
<![CDATA[
]]>
<![CDATA[		Set DCOsetup = Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If g_dictRMID.Count <> 0 then ]]>
<![CDATA[
]]>
<![CDATA[			'Load All Template records based on Key Values]]>
<![CDATA[
]]>
<![CDATA[			aKeys = g_dictRMID.Keys]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			sKeys = join(aKeys,",")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			sSQL = "SELECT tp_TemplateID, tp_CCOPath FROM Template WHERE tp_TemplateID IN (" & sKeys & "); "]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			aResult = GetDataArray(sSQL) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If isArray(aResult) then]]>
<![CDATA[
]]>
<![CDATA[				For k = 0 to ubound(aResult,1)]]>
<![CDATA[
]]>
<![CDATA[					Writelog("#" & aResult(k,0) & ", path:'" & aResult(k,1) & "' ")]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'Ensure CCO file exists]]>
<![CDATA[
]]>
<![CDATA[					If FileMgr.FileExists(aResult(k,1)) Then ]]>
<![CDATA[
]]>
<![CDATA[																	]]>
<![CDATA[
]]>
<![CDATA[						'Load CCO file as Object into dictionary						]]>
<![CDATA[
]]>
<![CDATA[						Set iCCOobj = oCCOCreator.Load(aResult(k,1))				]]>
<![CDATA[
]]>
<![CDATA[													]]>
<![CDATA[
]]>
<![CDATA[						If g_dictRMID.Exists(cstr(aResult(k,0))) then ]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							If Not(iCCOobj is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[								Set dictZone = g_dictRMID.item(cstr(aResult(k,0)))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[								For Each zoneKey in dictZone.Keys]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[									aAnchor = pm_SplitNumber(zoneKey)]]>
<![CDATA[
]]>
<![CDATA[																					]]>
<![CDATA[
]]>
<![CDATA[									'***Find Recognition Text for FingerPrint CCO Area....]]>
<![CDATA[
]]>
<![CDATA[									AnchorText=Trim(rm_ZoneText(aAnchor,iCCOObj))]]>
<![CDATA[
]]>
<![CDATA[									If len(AnchorText)>0 Then]]>
<![CDATA[
]]>
<![CDATA[										Writelog(Space(5) & "FPZone:'" & zoneKey & "' TXTZone:'" & Join(aAnchor,",") & "' Value:'" & AnchorText & "'")]]>
<![CDATA[
]]>
<![CDATA[										Call dictZone.Remove(zoneKey)]]>
<![CDATA[
]]>
<![CDATA[										Call dictZone.Add(Join(aAnchor,","),cstr(AnchorText))]]>
<![CDATA[
]]>
<![CDATA[									Else	]]>
<![CDATA[
]]>
<![CDATA[										dictZone(zoneKey)=cstr(AnchorText) 			]]>
<![CDATA[
]]>
<![CDATA[									End if]]>
<![CDATA[
]]>
<![CDATA[								Next 'zoneKey]]>
<![CDATA[
]]>
<![CDATA[							Else]]>
<![CDATA[
]]>
<![CDATA[								Writelog("CCO file did not load!")		]]>
<![CDATA[
]]>
<![CDATA[								Call g_dictRMID.Remove(cstr(aResult(k,0)))	]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						End if			]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						Set iCCOobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[					Else]]>
<![CDATA[
]]>
<![CDATA[						Writelog("File '" & aResult(k,1) & " not found. CCO File Missing while loading Patterns.")	]]>
<![CDATA[
]]>
<![CDATA[						If g_dictRMID.Exists(cstr(aResult(k,0))) then g_dictRMID.Remove(cstr(aResult(k,0)))]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[																	]]>
<![CDATA[
]]>
<![CDATA[				Next 'k]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				Writelog("No results retrieved from Template Table Lookup.")]]>
<![CDATA[
]]>
<![CDATA[				set oCCOCreator = Nothing]]>
<![CDATA[
]]>
<![CDATA[        pm_ReleaseLock()                                          ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	set oCCOCreator = Nothing]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = g_dictRMID.Keys]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	pat_RecogMatch_Id = rm_Match(aStrParam)		]]>
<![CDATA[
]]>
<![CDATA[	pm_ReleaseLock()                                               ' Release Pattern Match lock	]]>
<![CDATA[
]]>
		</g>
	</af>
</rrx>
<rrx namespace="Recog_Shared" v="8.1.0.64">
	<i ref="rrunner">
	</i>
	<i ref="cco2cco">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' recog_shared.rrx - Shared Recognition Actions and Functions]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Copyright Datacap Inc. 2001-2011, All rights Reserved]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.2" ]]>
<![CDATA[
]]>
<![CDATA[' Updated NSK]]>
<![CDATA[
]]>
<![CDATA['	- ReleaseImage action is added]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.4" ]]>
<![CDATA[
]]>
<![CDATA[' Updated NSK]]>
<![CDATA[
]]>
<![CDATA['	- SnapCCO2DCO space after the word]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.5" ]]>
<![CDATA[
]]>
<![CDATA[' Updated NSK]]>
<![CDATA[
]]>
<![CDATA['	- RecogOMRThresh now enforces SinglePunch (anytime MultiPunch is not set or <>1) ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.6" ]]>
<![CDATA[
]]>
<![CDATA[' Updated NSK]]>
<![CDATA[
]]>
<![CDATA['	- RotateImage moved to ocr_s.rrx]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.2.01" ]]>
<![CDATA[
]]>
<![CDATA[' Updated NSK]]>
<![CDATA[
]]>
<![CDATA['	- uses oDCO.Variable other then oDCO.SetupNode.Variable]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.2.2" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/23/2008 NSK]]>
<![CDATA[
]]>
<![CDATA['	- RecogOMRThresh clips field to image bounds, lowers confidence to 0 if outside image at all ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.2.3" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/23/2008 NSK]]>
<![CDATA[
]]>
<![CDATA['	- RecogOMRThresh width and height check corrected]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.1" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/23/2008 NSK]]>
<![CDATA[
]]>
<![CDATA['	- SnapCCO2DCO action is allowed to run at the field level]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.2" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/07/2008 TScholl]]>
<![CDATA[
]]>
<![CDATA['	- Updated action help text for these actions: AnalyzeImage, CreateTextFile, IsBlankPage, RecogOMRThresh, RegisterPageFields, ReleaseImage, RotateTio,   - SetFingerprintRecogPriority,SetFullPageRecogArea, SnapCCOToDCO, SnapDCOToCCO]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.3" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/17/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['- Added new action 'UseDCOProcessor' and helper function 'LogDCOProcessorState']]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.4" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/16/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Modified actions:]]>
<![CDATA[
]]>
<![CDATA['     ReleaseImage - no longer calls method "ReleaseImage" from class go_OCRS_Engine. Images are now automatically released when recognition is done.  ]]>
<![CDATA[
]]>
<![CDATA['     SetFingerprintRecogPriority - global m_bCreateCCO now stored as a page variable]]>
<![CDATA[
]]>
<![CDATA['     RotateTIO - global m_bRotateTio now stored as a page variable]]>
<![CDATA[
]]>
<![CDATA['     UseDCOProcessor - Modified to create a DCOProcessor instance if one doesn’t already exist. ]]>
<![CDATA[
]]>
<![CDATA['                       If one already exists, free its resources then re-initialize the instance.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.5"]]>
<![CDATA[
]]>
<![CDATA['  Updated 04/10/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  - Action SetFingerprintRecogPriority now sets the correct parameter for the option to ]]>
<![CDATA[
]]>
<![CDATA['  recreate the CCO if one already exists. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.6"]]>
<![CDATA[
]]>
<![CDATA['  Updated 04/22/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  - Added helper function 'DCOProcessorExecute" to manage all calls made to DCOProcessor. Implements a second attempt when DCOProcessor]]>
<![CDATA[
]]>
<![CDATA['    returns with a failure on the first attempt. The second attempt happens after DCOProcessor is reinitialized.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.7"]]>
<![CDATA[
]]>
<![CDATA['  Updated 04/23/2008 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  - Added new action SetDCOProcessorSpawnTime which sets the amount of seconds to wait before DCOProcessor is initialized again after a failure.]]>
<![CDATA[
]]>
<![CDATA['  The value is stored as batch variable "dcprsp". If this action is not called the spawn time defaults to 5 seconds.]]>
<![CDATA[
]]>
<![CDATA['  - Uses new helper dll dctimer.dll to pause for the amount of time specified in spawn time.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.8"]]>
<![CDATA[
]]>
<![CDATA['  Updated 04/23/2008 02:35 PM JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Renamed action 'SetDCOProcessorSpawnTime' to 'SetRecogFailureRetryDelay']]>
<![CDATA[
]]>
<![CDATA[' - Renamed action 'UseDCOProcessor' to 'UseOutOfProcessRecog']]>
<![CDATA[
]]>
<![CDATA[' - Action 'SetRecogFailureRetryDelay' always returns true]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/24/2008 1:12 TScholl ]]>
<![CDATA[
]]>
<![CDATA[' Checked and updated Information for UseOutOfProcessRecog and SetRecogFailureRetryDelay actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/07/2008 2:15 JMartinez ]]>
<![CDATA[
]]>
<![CDATA[' - Removed old references]]>
<![CDATA[
]]>
<![CDATA[' - Added DCOProcessor support for action ReleaseImage. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/08/2008 8:47 AM JMartinez ]]>
<![CDATA[
]]>
<![CDATA[' - Added new action "CCONormalization_OFF " can be used prevent the automatic running of CCONormalize after full page recog]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/03/2008 9:45 AM TScholl]]>
<![CDATA[
]]>
<![CDATA[' - Corrects the order of the actions in the examples for the SetRecogFailureRetry and UseOutOfProcessRecog actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/18/08 T Scholl]]>
<![CDATA[
]]>
<![CDATA[' Updates Information for the RecogOMRThresh action to provide details and examples that clearly explain how the action works, and how to use it, per SPR 21953.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/13/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated the DCOProcessorExecute helper function to support the latest ICRC\OCRS engine wrapper architecture]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/21/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Helper function UseOutOfProcessRecog now uses existing DCOProcessor instance instead of creating a new on each time the function is invoked.]]>
<![CDATA[
]]>
<![CDATA['When DCOProcessor fails we now invoked its "Unload" and "FullStop" methods to unload the engines.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/26/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA['The OutOfProcessRecognition handled in the DCOProcessorExecute function now aborts the batch when the seconds attempt fails.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/02/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Added helper function UpdateCCO]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/02/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Now obtaining correct image information from DCImage for CCO Update]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/03/08 TScholl]]>
<![CDATA[
]]>
<![CDATA[' Corrects Information for the ReleaseImage action to indicate that the action does not take a parameter (SPR 22626), ]]>
<![CDATA[
]]>
<![CDATA[' and details of the CCONormalize_Off action. Corrects Information for the RecogOMRThresh action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/04/08 TScholl]]>
<![CDATA[
]]>
<![CDATA[' Corrects Information for the UseOutOfProcessRecog and SetRecogFailureRetryDelay actions. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/11/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added new action "SetOutOfProcessRecogTimeout" which takes a numeric parameter, in seconds. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.22"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/20/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - DCOProcessor enabled by default. ]]>
<![CDATA[
]]>
<![CDATA[' - By default, if a recognition fails, the batch will be set to abort and the action will return true]]>
<![CDATA[
]]>
<![CDATA[' - Added action "RecogContinueOnFailure". If the action is not called, it will default to false and the batch will abort if there is a failure from recognition (with or without DCOProcessor enabled).  RecogContiueOnFailure(“True”) will prevent the batch from aborting, allowing an application to check the RecogStatus and perform its own error processing.]]>
<![CDATA[
]]>
<![CDATA[' - Action "ReleaseImage" now passes the current DCO Object ID instead of the full DCO object]]>
<![CDATA[
]]>
<![CDATA[' - UseOutOfProcessRecog now unloads the DCOProcessor instance if its alive and if the parameter passed to the action is "FALSE". DCOProcessor timeouts set to 0 before unloading.]]>
<![CDATA[
]]>
<![CDATA[' - SetOutOfProcessRecog timeout now defaults to 5 minutes, SetRecogFailureRetryDelay defaults to 10 minutes]]>
<![CDATA[
]]>
<![CDATA[' - Action SetrecogfailureRetryDelay now saves the timeout in a global variable instead of the current DCO node]]>
<![CDATA[
]]>
<![CDATA[' - Renamed action DCOPRocessor execute to a more descriptive name "IN_OUT_RECOG_PROCESS_EXECUTE" since it now handles in process and our-of-process calls]]>
<![CDATA[
]]>
<![CDATA[' - Added new helper function IN_OUT_RECOG_PROCESS_EXECUTE_RETRY]]>
<![CDATA[
]]>
<![CDATA[' - When DCOProcessor timeout is reached (SetOutOfProcessTimeout), DCOProcessor is unloaded and the system waits for RetryDelay to complete before returning to action result.  This is regardless of whether this is the first or second try to perform the recog, and regardless of whether or not RecogContinueOnFailure was called or not.  This guarantees that the Engine will be reset at some point before the next recog attempt is made with that engine.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.23"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/22/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - IN_OUT_RECOG_PROCESS_EXECUTE now uses the global variable g_sParentObjectXML for passing a current object's parent XML to the ICRC wrapper. ]]>
<![CDATA[
]]>
<![CDATA[' - Fixed recognition failure that would happen when out-of-process recognition is turned OFF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.24"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/24/08 TScholl]]>
<![CDATA[
]]>
<![CDATA[' - Updated Information text for the UseOutOfProcessRecog, SetRecordFailureRetryDelay, RecogContinueOnFailure,and SetOutOfProcessRecogTimeOut actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.25"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/24/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added helper function "SetParentObjectXML" which handles loading of the DCO XML to the global 'g_sParentObjectXML in RRA. Since the XML parser used in RRA is different than in RRX, the XML returned has to be parsed by removing newlines. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.26"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/25/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Batch aborts now happen immediately when set programmatically. Fixes the issue where a recognition actions sets the batch to abort, but the batch is only aborted after the ruleset runs. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.27"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/26/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - changed global g_DCOPROCESSORERROR from "-1" to "13". This is the generic DCOProcessor error code that gets assigned to an object's "RecogStatus" variable when a crash in DCOProcessor happens and there is no real return coming back value.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.28"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/29/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Modified SetParentObjectXML to remove both "end of line" and "carriage return" characters when run under RRA. Previously only removed character 13.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.29"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/29/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Modified the helper function "IN_OUT_RECOG_PROCESS_EXECUTE" to NOT automatically retry a failed operation since the calling action already does so. Solves issue where three attempts would be made when DCOProcessor is ON and firsdt attempt fails.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.30"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/09/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Added helper function "ValidateRecogResult" to check the validity of the XML returned by the call to the engine wrapper, in particular field level recognition.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.31"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/15/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Changed default DCOProcessor timeout to 185 seconds.]]>
<![CDATA[
]]>
<![CDATA[' - Removed logging of the parent XML]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.32"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/11/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Now storing the different error code descriptions in the g_ErrDescr array. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.33"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/12/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Action "AnalyzeImage" now supports running out of process via DCOProcessor. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.34"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/02/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Helper function UpdateCCO no longer updates the CCO dimensions, now it only updates the runtime CCO. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.35"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/24/08 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - Solves issue where calling UseOutOfProcessRecog(false) and UseOutOfProcessRecog(true) consecutively does not restart ]]>
<![CDATA[
]]>
<![CDATA['   the DCOProcessor object because the latter would think that the object is still valid. The action now uses the more ]]>
<![CDATA[
]]>
<![CDATA['   robust "IsAlive" helper function to determine if the DCOprocessor object is valid or not (replacing "IsObject").]]>
<![CDATA[
]]>
<![CDATA[' - IN_OUT_RECOG_PROCESS_EXECUTE and IN_OUT_RECOG_PROCESS_EXECUTE_RETRY updated to use "IsAlive" instead of "IsObject"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.36"]]>
<![CDATA[
]]>
<![CDATA[' - Solves issue where Generic DCO Processor error would show up randomly when running multiple threads under TMQuattro, caused by restarting DCOProcessor by using the action UseOutOfProcessRecog(false).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.37"]]>
<![CDATA[
]]>
<![CDATA[' Updated 2/5/2009 TPeters]]>
<![CDATA[
]]>
<![CDATA[' - Made minor spelling and grammar corrections to logging and error messages]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.38"]]>
<![CDATA[
]]>
<![CDATA[' Updated 2/27/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - The RecogOMRThresh action now pays attention to the skip OMR recognition variable (d_sr=1) and adds a log entry when]]>
<![CDATA[
]]>
<![CDATA['   recognition is skipped by the settings for the field.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.39"]]>
<![CDATA[
]]>
<![CDATA[' Updated 3/04/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' - Fixed spelling errors in the help for SetRecogFailureRetryDelay and SetOutOfProcessRecogTimeout.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.40"]]>
<![CDATA[
]]>
<![CDATA[' Updated 3/25/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' - SnapCCOToDCO now only clears/updates fields' text when all of the following conditions are met :]]>
<![CDATA[
]]>
<![CDATA[' - Field is not an OMR field (i.e. var RecogType=4)]]>
<![CDATA[
]]>
<![CDATA[' - Field has positions assigned]]>
<![CDATA[
]]>
<![CDATA[' - Field does not have the variable "v_skipsnap" set to 1]]>
<![CDATA[
]]>
<![CDATA[' - Field has data mapping to the CCO (at least one character)]]>
<![CDATA[
]]>
<![CDATA[' - Fixes issue that would affect processing of reserved fields (i.e. fields that are used for anchor finding followed by snapping of data).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.41"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/1/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' - Improved descriptions for SetFingerprintRecogPriority (22645) SnapCCOtoDCO (24572) and RecogOMRThresh.  ]]>
<![CDATA[
]]>
<![CDATA['   Made help formatting consistent for all actions. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.42"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/10/2009 PHofle]]>
<![CDATA[
]]>
<![CDATA[' - Fixed SnapCCOToDCO bug introduced in version 7.5.40 where first line of multiline field would be cleared when populating]]>
<![CDATA[
]]>
<![CDATA['   trailing lines to DCO. Code is in Class 'CSnapper', under method 'SnapField'. Fix sets variable 'bFieldCleared = True' ]]>
<![CDATA[
]]>
<![CDATA['   after adding first word to field, prevents clearing code from executing on second line in multiline field.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.43" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/11/2009 RFERIN]]>
<![CDATA[
]]>
<![CDATA['	  19745 Added G tags to make the XML format more compliant and help with editing.  Minor help ]]>
<![CDATA[
]]>
<![CDATA['   formatting fixes and modified some help text.  Requires the new buildvbs.rls 1.0.2.2.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.44" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/23/2009 RFERIN]]>
<![CDATA[
]]>
<![CDATA['	  22141 - Added new helper function "RemoveSpaces" used to remove spaces out of recognized data inside of fields.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.45"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/30/2009 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Added action 'SetAdjustFieldToChars' to enable/disable option in Snapfield utility function to re-adjust field to existing]]>
<![CDATA[
]]>
<![CDATA['   character positions. Action parameter is True or False, option is disabled by default (legacy logic). ]]>
<![CDATA[
]]>
<![CDATA[' * Fixed issue where snapfield would exit function during internal overlap routine, changed to exit for loop (overlap routine).]]>
<![CDATA[
]]>
<![CDATA['   Allows post processing logic to follow snapping of character values and positions to dco.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.46"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/06/2010]]>
<![CDATA[
]]>
<![CDATA[' - 26919 Moved location of writelog so the proper Recog_shared version number is listed in log files.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.47"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/21/2010]]>
<![CDATA[
]]>
<![CDATA[' * Added Action 'SnapFieldtoChars' to shrink Field Position to match Field character position. SPR 24691]]>
<![CDATA[
]]>
<![CDATA[' * Fixed bug in Action 'SetAdjustFieldtoChars' which prevented this option from setting the property in ]]>
<![CDATA[
]]>
<![CDATA['   CSnapper class to enable adjusting field zones to match field's character positions.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.48"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/28/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated to contain all fixes and enhancements included in v7.6.3 (TM7.6)]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.49"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/09/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 26883 Replaced RecogOMRThresh with RecogOMRThreshold, which takes unique parameters.  RecogOMRThresh is still public, but deprecated.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.1.50"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/07/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.1.51"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/21/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * 31461 fixed help for action SetAdjustFieldToChars.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.52"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/18/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added IBM Copyright notice.]]>
<![CDATA[
]]>
<![CDATA[' No longer uses DCTimer.dll to create pauses between recognition attempts. Pause is now achieved using VBScript methods. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.53"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/18/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Replaced instances of CHR with CHRW and instances of ASC with ASCW for Unicode support]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.54"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/1/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Deprecated action 'RegisterPageFields' SPR 31567]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.55"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/07/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * Corrected help text for action CCONormalizationOFF, to reflect correct placement of the action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.56"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/07/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * Updated action CreateTextFile with the the following enhancements]]>
<![CDATA[
]]>
<![CDATA['   - Characters are queried from the CCO instead of words. Each character's code is converted to its Unicode character representation]]>
<![CDATA[
]]>
<![CDATA['     using the ChrW function and then used to build the string that is output to the text file. Works around the issue where querying words from the CCO]]>
<![CDATA[
]]>
<![CDATA['     using the CCOCollection's "Value" property does not return correct representation of Unicode characters.]]>
<![CDATA[
]]>
<![CDATA['   - Creates a Unicode text file.]]>
<![CDATA[
]]>
<![CDATA['   - Updated help text to reflect that a Unicode text file is now created.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.57"]]>
<![CDATA[
]]>
<![CDATA[' * Rolled back the following change in the CreateTextFile: "Characters are queried from the CCO instead of words...". ]]>
<![CDATA[
]]>
<![CDATA['   This special handling is not needed with CCO.dll v8.1.0.8 and above.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.58"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/27/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * The dctimerPause subroutine has been updated with a more robust algorithm to execute the pauses. Solve a a limitation with the previous algorithm where]]>
<![CDATA[
]]>
<![CDATA['   calculating times during a midnight tick would generate an invalid pause time.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.59"]]>
<![CDATA[
]]>
<![CDATA['Updated 07/06/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * The action CreateTextFile now creates a UTF-8 encoded text file with recognition results.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.60"]]>
<![CDATA[
]]>
<![CDATA['Updated 08/02/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * 31440 changed help for action RecogOMRThreshold to remove references to earlier version where parameter values could not use comma as decimal separator.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.61"]]>
<![CDATA[
]]>
<![CDATA['Updated 08/03/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * 31440 Changed Action RecogOMRThreshold parameters to call DCGlobalCurrency.NormalizeNumber method to allow locale independance deciaml number formatting.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.62"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/05/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' Action RecogOMRThreshold updated for use with dynamic locale. Requires dcglobal.dll 8.0.1.16 or newer ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[rr_Version = "8.1.0.63"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/20/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Changed references to dco variable 'locale' to use 'hr_locale', enabling hierarchical dco logic.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.64"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/05/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * Action IsBlankPage returns false when an invalid parameter is specified. ]]>
<![CDATA[
]]>
<![CDATA[' * Updated help text for action IsBlankPage to reflect valid parameter values.]]>
<![CDATA[
]]>
<![CDATA['********************************************************************]]>
<![CDATA[
]]>
<![CDATA[' LOG RRX VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("Recog_shared " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['--------- RuleRunner global objects: ------------]]>
<![CDATA[
]]>
<![CDATA['		Pilot: Pilot object]]>
<![CDATA[
]]>
<![CDATA['		FileMgr: FileSystem object]]>
<![CDATA[
]]>
<![CDATA['		DCO: DCO object]]>
<![CDATA[
]]>
<![CDATA['		CCOCreator: CCOCreator object]]>
<![CDATA[
]]>
<![CDATA['		ImageCtrl: DCImage object ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Global entries ---------------------------------------------------->]]>
<![CDATA[
]]>
<![CDATA[Dim goSnapper]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[Set goSnapper = new CSnapper]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[If Err.number <> 0 Then ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Couldn't create Snapper object.")]]>
<![CDATA[
]]>
<![CDATA[	nTaskStatus=retAbort 'Set the task to abort]]>
<![CDATA[
]]>
<![CDATA[	Err.Clear	]]>
<![CDATA[
]]>
<![CDATA[End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[On Error GoTo 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_bUseDCOPRocessor]]>
<![CDATA[
]]>
<![CDATA[Dim goDCOProcessor]]>
<![CDATA[
]]>
<![CDATA[Dim g_lOutOfProcessTimeout]]>
<![CDATA[
]]>
<![CDATA[Dim g_lDefaultOutOfProcessTimeout]]>
<![CDATA[
]]>
<![CDATA[Dim g_bContinueOnFailure]]>
<![CDATA[
]]>
<![CDATA[Dim g_iRecogFailureRetryDelay]]>
<![CDATA[
]]>
<![CDATA[Dim g_iRes]]>
<![CDATA[
]]>
<![CDATA[Dim g_bOCRSRecogON]]>
<![CDATA[
]]>
<![CDATA[Dim g_bICRCRecogON]]>
<![CDATA[
]]>
<![CDATA[Dim g_sParentObjectXML]]>
<![CDATA[
]]>
<![CDATA[Dim g_iOCRSEngineTimeout]]>
<![CDATA[
]]>
<![CDATA[Dim g_DCOPROCESSORERROR]]>
<![CDATA[
]]>
<![CDATA[Dim g_DCOProcessorStartTimeout]]>
<![CDATA[
]]>
<![CDATA[Dim g_DCOProcessorNewObjectTimeout]]>
<![CDATA[
]]>
<![CDATA[Dim g_DCOProcessorFinalizersTimeout]]>
<![CDATA[
]]>
<![CDATA[Dim g_oFileReader]]>
<![CDATA[
]]>
<![CDATA[Dim g_iDCOProcessorProceduresTimeout]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Set g_oFileReader = Nothing]]>
<![CDATA[
]]>
<![CDATA[g_iOCRSEngineTimeout = 0]]>
<![CDATA[
]]>
<![CDATA[g_lDefaultOutOfProcessTimeout = 185000]]>
<![CDATA[
]]>
<![CDATA[g_lOutOfProcessTimeout = g_lDefaultOutOfProcessTimeout]]>
<![CDATA[
]]>
<![CDATA[g_iRecogFailureRetryDelay = 0]]>
<![CDATA[
]]>
<![CDATA[g_bUseDCOPRocessor = TRUE]]>
<![CDATA[
]]>
<![CDATA[g_bContinueOnFailure = FALSE]]>
<![CDATA[
]]>
<![CDATA[g_bOCRSRecogON = FALSE]]>
<![CDATA[
]]>
<![CDATA[g_bICRCRecogON = FALSE]]>
<![CDATA[
]]>
<![CDATA[g_DCOPROCESSORERROR = 13]]>
<![CDATA[
]]>
<![CDATA[g_DCOProcessorStartTimeout = 10000]]>
<![CDATA[
]]>
<![CDATA[g_DCOProcessorNewObjectTimeout = 10000]]>
<![CDATA[
]]>
<![CDATA[g_DCOProcessorFinalizersTimeout = 10000]]>
<![CDATA[
]]>
<![CDATA[g_iDCOProcessorProceduresTimeout = 1000]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim g_ErrDescr(13)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim SUCCESS_RECOGRESULTS ]]>
<![CDATA[
]]>
<![CDATA[SUCCESS_RECOGRESULTS = 0]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(SUCCESS_RECOGRESULTS) = "Recognition successful"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim SUCCESS_NORECOGRESULTS]]>
<![CDATA[
]]>
<![CDATA[SUCCESS_NORECOGRESULTS = 1]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(SUCCESS_NORECOGRESULTS) = "Recognition successful no recognition data returned"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim SUCCESS_GENERAL]]>
<![CDATA[
]]>
<![CDATA[SUCCESS_GENERAL = 2]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(SUCCESS_GENERAL) = "Success (internal to wrappers)"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim SUCCESS_IMAGELOADED]]>
<![CDATA[
]]>
<![CDATA[SUCCESS_IMAGELOADED = 3]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(SUCCESS_IMAGELOADED) = "Success: The image loaded (internal to wrappers)"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim FAIL_ENGINENOTALIVE]]>
<![CDATA[
]]>
<![CDATA[FAIL_ENGINENOTALIVE = 4]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(FAIL_ENGINENOTALIVE) = "The recognition engine could not be initialized"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim FAIL_ENGINETIMEOUT ]]>
<![CDATA[
]]>
<![CDATA[FAIL_ENGINETIMEOUT = 5]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(FAIL_ENGINETIMEOUT) = "The recognition time exceeded the maximum allowed"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim  FAIL_IMAGEFAILTOLOAD]]>
<![CDATA[
]]>
<![CDATA[ FAIL_IMAGEFAILTOLOAD = 6]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(FAIL_IMAGEFAILTOLOAD) = "The image file could not be loaded into the engine"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim FAIL_IMAGEFAILTOLOAD_PATHNOTFOUND]]>
<![CDATA[
]]>
<![CDATA[ FAIL_IMAGEFAILTOLOAD_PATHNOTFOUND = 7]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(FAIL_IMAGEFAILTOLOAD_PATHNOTFOUND) = "The image file failed to load because its path could not be found"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim FAIL_ROTATEFAIL ]]>
<![CDATA[
]]>
<![CDATA[FAIL_ROTATEFAIL = 8]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(FAIL_ROTATEFAIL) = "The image could not be rotated (OCRS)"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim FAIL_IMAGENOEXIST_TIO]]>
<![CDATA[
]]>
<![CDATA[FAIL_IMAGENOEXIST_TIO = 9]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(FAIL_IMAGENOEXIST_TIO) = "The TIO file could not be rotated because its path could not be found (OCRS)"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim FAIL_GENERAL]]>
<![CDATA[
]]>
<![CDATA[FAIL_GENERAL = 10]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(FAIL_GENERAL) = "General Error encountered when invoking recognition (wrapper side)"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim FAIL_CCONOTINITIALIZED]]>
<![CDATA[
]]>
<![CDATA[FAIL_CCONOTINITIALIZED = 11]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(FAIL_CCONOTINITIALIZED) = "The CCO object could not be created"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(12) = "Not defined (not used)"]]>
<![CDATA[
]]>
<![CDATA[g_ErrDescr(g_DCOPROCESSORERROR) = "General Error encountered when invoking recognition (action side)"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['___________________________________________________________________________________________________]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['	CSnapper]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['___________________________________________________________________________________________________]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Class CSnapper]]>
<![CDATA[
]]>
<![CDATA[	Public m_bRecogCreateCCO]]>
<![CDATA[
]]>
<![CDATA[	Private m_nLastField]]>
<![CDATA[
]]>
<![CDATA[  Public m_bDoPostProcessSnap]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Construction & Destruction -----------------------------------------]]>
<![CDATA[
]]>
<![CDATA[	Private Sub Class_Initialize	' Initialize event.]]>
<![CDATA[
]]>
<![CDATA[		m_nLastField = 0]]>
<![CDATA[
]]>
<![CDATA[		m_bRecogCreateCCO = False]]>
<![CDATA[
]]>
<![CDATA[    m_bDoPostProcessSnap = False]]>
<![CDATA[
]]>
<![CDATA[	End Sub]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Private Sub Class_Terminate		' Terminate event.]]>
<![CDATA[
]]>
<![CDATA[	End Sub]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Public Function CorrectFieldPosition(oField)]]>
<![CDATA[
]]>
<![CDATA[		On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    CorrectFieldPosition = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If oField.NumOfChildren() = 0 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    If cbool(m_bDoPostProcessSnap) = cbool(False) then Exit Function]]>
<![CDATA[
]]>
<![CDATA[		Dim nLeft, nTop, nRight, nBottom, oDCOChar, nChar]]>
<![CDATA[
]]>
<![CDATA[		Dim nLeft1, nTop1, nRight1, nBottom1]]>
<![CDATA[
]]>
<![CDATA[		Set oDCOChar = oField.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[		oDCOChar.GetPosition nLeft, nTop, nRight, nBottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		For nChar = 0 To oField.NumOfChildren()-1]]>
<![CDATA[
]]>
<![CDATA[			Set oDCOChar = oField.GetChild(nChar)]]>
<![CDATA[
]]>
<![CDATA[			If(oDCOChar.ObjectType = 4)	Then 'char]]>
<![CDATA[
]]>
<![CDATA[				oDCOChar.GetPosition nLeft1, nTop1, nRight1, nBottom1 ]]>
<![CDATA[
]]>
<![CDATA[				If (nLeft > nLeft1) Then nLeft = nLeft1]]>
<![CDATA[
]]>
<![CDATA[				If (nTop > nTop1) Then nTop = nTop1]]>
<![CDATA[
]]>
<![CDATA[				If (nRight < nRight1) Then nRight = nRight1]]>
<![CDATA[
]]>
<![CDATA[				If (nBottom < nBottom1) Then nBottom = nBottom1]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		oField.SetPosition nLeft, nTop, nRight, nBottom]]>
<![CDATA[
]]>
<![CDATA[	End Function ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Public methods -----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Private Function SnapField(oField, oCCO)]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Snapping: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[		If Not oField.SetupNode Is Nothing Then ]]>
<![CDATA[
]]>
<![CDATA[			If(oField.Variable("RecogType") = "4") Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog(oField.ID & ": is skipped. OMR field -----")]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Dim bMultiline]]>
<![CDATA[
]]>
<![CDATA[		If oField.Variable("Multiline") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[			bMultiline = True]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Dim nLine, nWord, nChar, nLastLine, nLeft, nTop, nRight, nBottom, bSpace]]>
<![CDATA[
]]>
<![CDATA[		oField.GetPosition nLeft, nTop, nRight, nBottom]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If nLeft = 0 And nTop = 0 And nRight = 0 And nBottom  = 0 Then  ]]>
<![CDATA[
]]>
<![CDATA[        Writelog (oField.ID & ": is skipped. No positions found.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If oField.Variable("v_skipsnap") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog (oField.ID & ": is skipped. Explicitly set to skip (v_skipsnap=1).")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    bFieldCleared = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		nLastLine=1]]>
<![CDATA[
]]>
<![CDATA[		For nLine=1 To oCCO.count]]>
<![CDATA[
]]>
<![CDATA[			Set oCCOLine = oCCO.item(nLine)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If(oCCOLine.Top > nBottom) Then 			]]>
<![CDATA[
]]>
<![CDATA[				Exit For]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[			bSpace = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If(IsOverlapped(oCCOLine.Left, oCCOLine.Top, oCCOLine.Right, _]]>
<![CDATA[
]]>
<![CDATA[					oCCOLine.Bottom, nLeft, nTop, nRight, nBottom)) Then]]>
<![CDATA[
]]>
<![CDATA[				For nWord=1 To oCCOLine.count]]>
<![CDATA[
]]>
<![CDATA[					Set oCCOWord = oCCOLine.item(nWord)]]>
<![CDATA[
]]>
<![CDATA[					If ( IsHugeOverlapped(oCCOWord.Left, oCCOWord.Top, oCCOWord.Right, oCCOWord.Bottom,	nLeft, nTop, nRight, nBottom)) Then 'put cco word to dco field]]>
<![CDATA[
]]>
<![CDATA[						If(nLastLine < nLine And oField.NumOfChildren > 0) Then 'insert a line separator - LF]]>
<![CDATA[
]]>
<![CDATA[							If Not bFieldCleared Then]]>
<![CDATA[
]]>
<![CDATA[                    oField.Clear]]>
<![CDATA[
]]>
<![CDATA[                    bFieldCleared = True]]>
<![CDATA[
]]>
<![CDATA[              End If]]>
<![CDATA[
]]>
<![CDATA[              Set oDCOChar = oField.AddChild(4, "", -1)]]>
<![CDATA[
]]>
<![CDATA[							If Not oDCOChar Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[                oDCOChar.SetPosition oCCOWord.Right, oCCOWord.Top, oCCOWord.Right+1, oCCOWord.Bottom]]>
<![CDATA[
]]>
<![CDATA[								If bMultiline Then]]>
<![CDATA[
]]>
<![CDATA[									oDCOChar.AddValue 10, 10 ' line feed/newline]]>
<![CDATA[
]]>
<![CDATA[								Else]]>
<![CDATA[
]]>
<![CDATA[									oDCOChar.AddValue 32, 1 ' low confidence space]]>
<![CDATA[
]]>
<![CDATA[								End If]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							If (bSpace) Then		'add space after word is added]]>
<![CDATA[
]]>
<![CDATA[								Set oDCOChar = oField.AddChild(4, "", -1)	]]>
<![CDATA[
]]>
<![CDATA[								If Not oDCOChar Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[									oDCOChar.SetPosition oCCOWord.Right, oCCOWord.Top, oCCOWord.Right+1, oCCOWord.Bottom]]>
<![CDATA[
]]>
<![CDATA[									oDCOChar.AddValue 32, 10]]>
<![CDATA[
]]>
<![CDATA[								End If]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[                                                End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						For nChar = 1 To oCCOWord.count]]>
<![CDATA[
]]>
<![CDATA[							Set oCCOChar = oCCOWord.item(nChar)]]>
<![CDATA[
]]>
<![CDATA[							Set oDCOChar = oField.AddChild(4, "", -1)]]>
<![CDATA[
]]>
<![CDATA[							oDCOChar.AddValue oCCOChar.CharCode, oCCOChar.Confidence]]>
<![CDATA[
]]>
<![CDATA[							oDCOChar.SetPosition oCCOChar.Left, oCCOChar.Top, oCCOChar.Right, oCCOChar.Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							For nSubChar = 1 To oCCOChar.Count	'add all subchars to DCO char]]>
<![CDATA[
]]>
<![CDATA[								Set oCCOSubChar = oCCOChar.Item(nSubChar)]]>
<![CDATA[
]]>
<![CDATA[								oDCOChar.AddValue oCCOSubChar.CharCode, oCCOSubChar.Confidence]]>
<![CDATA[
]]>
<![CDATA[							Next]]>
<![CDATA[
]]>
<![CDATA[						Next]]>
<![CDATA[
]]>
<![CDATA[						bSpace = True]]>
<![CDATA[
]]>
<![CDATA[						nLastLine = nLine]]>
<![CDATA[
]]>
<![CDATA[            bFieldCleared = True 'for multiline fields. Prevents code from clearing first line]]>
<![CDATA[
]]>
<![CDATA[					End If 'IsHugeOverlapped]]>
<![CDATA[
]]>
<![CDATA[				Next]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		CorrectFieldPosition(oField)]]>
<![CDATA[
]]>
<![CDATA[		'RcFormatDCOField(oField)]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(oField.ID & ": " & nLeft & "," & nTop & "," & nRight & "," & nBottom & "; " & oField.Text)]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Public Function SnapCCOtoDCO(oDCO)		'Transfer Recog results	from CCO to DCO]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oDCO]]>
<![CDATA[
]]>
<![CDATA[		While (oPage.ImageName = "")]]>
<![CDATA[
]]>
<![CDATA[			Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[		Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Dim strCCOFile]]>
<![CDATA[
]]>
<![CDATA[		strCCOFile = Left(oPage.ImageName, Len(oPage.ImageName)-3)&"cco"]]>
<![CDATA[
]]>
<![CDATA[		If Not(FileMgr.FileExists(strCCOFile)) Then ]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("SnapCCO2DCO skipping. CCO file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oCCO = CCOCreator.Load(strCCOFile )]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Select Case oDCO.ObjectType ]]>
<![CDATA[
]]>
<![CDATA[			Case 2 'Page]]>
<![CDATA[
]]>
<![CDATA[				For i = 0 To oDCO.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[					Set oField = oDCO.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[					oField.GetPosition nLeft, nTop, nRight, nBottom]]>
<![CDATA[
]]>
<![CDATA[					If( (oField.ObjectType = 3) And (nBottom-nTop>0 And nRight-nLeft>0) ) Then SnapField oField, oCCO]]>
<![CDATA[
]]>
<![CDATA[					If (Err.Number <> 0) Then WriteLog("Clearing Page SnapField Error #" & CStr(Err.number) & ": " & err.description) : Err.Clear]]>
<![CDATA[
]]>
<![CDATA[				Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Case 3 'Field]]>
<![CDATA[
]]>
<![CDATA[				oDCO.GetPosition nLeft, nTop, nRight, nBottom]]>
<![CDATA[
]]>
<![CDATA[				If (nBottom-nTop > 0 And nRight-nLeft > 0) Then SnapField oDCO, oCCO]]>
<![CDATA[
]]>
<![CDATA[				If (Err.Number <> 0) Then WriteLog("Clearing SnapField Error #" & CStr(Err.number) & ": " & err.description) : Err.Clear]]>
<![CDATA[
]]>
<![CDATA[				Err.Clear]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Case Else Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End Select ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'-----------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Public Function SnapDCOtoCCO(oPage)		'Transfer Recog results	from DCO to CCO]]>
<![CDATA[
]]>
<![CDATA[		'Load CCO]]>
<![CDATA[
]]>
<![CDATA[		Dim strCCOName, bCreateCCO, bVote]]>
<![CDATA[
]]>
<![CDATA[		strCCOName = Left(oPage.ImageName, Len(oPage.ImageName)-3) & "cco"]]>
<![CDATA[
]]>
<![CDATA[		If Not(FileMgr.FileExists(strCCOName)) Then bCreateCCO = True]]>
<![CDATA[
]]>
<![CDATA[		If (m_bRecogCreateCCO) Then bCreateCCO = True]]>
<![CDATA[
]]>
<![CDATA[		If (bCreateCCO) Then]]>
<![CDATA[
]]>
<![CDATA[			Set oCCO = CCOCreator.Create()]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Set oCCO = CCOCreator.Load(strCCOName)]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Dim bNewWord]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 To oPage.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[			Set oField = oPage.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[			If (oField.ObjectType = 3) Then ]]>
<![CDATA[
]]>
<![CDATA[				bNewWord = True]]>
<![CDATA[
]]>
<![CDATA[				For nChar = 0 To oField.NumOfChildren()-1]]>
<![CDATA[
]]>
<![CDATA[					Set oDCOChar = oField.GetChild(nChar)]]>
<![CDATA[
]]>
<![CDATA[					If(oDCOChar.ObjectType=4)	Then 'char]]>
<![CDATA[
]]>
<![CDATA[						oDCOChar.GetPosition nLeft, nTop, nRight, nBottom ]]>
<![CDATA[
]]>
<![CDATA[						ChrCode = oDCOChar.CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[						If (bCreateCCO) Then]]>
<![CDATA[
]]>
<![CDATA[							If ( (ChrCode <> 10) Or (ChrCode <> 32) Or ((ChrCode <> 13))) Then]]>
<![CDATA[
]]>
<![CDATA[								oCCO.InsertChar ChrCode, oDCOChar.CharConfidence(0), bNewWord, nLeft, nTop, nRight, nBottom ]]>
<![CDATA[
]]>
<![CDATA[								bNewWord = False]]>
<![CDATA[
]]>
<![CDATA[							Else]]>
<![CDATA[
]]>
<![CDATA[								bNewWord = True]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							If ( (ChrCode <> 10) Or (ChrCode <> 32) Or ((ChrCode <> 13))) Then ]]>
<![CDATA[
]]>
<![CDATA[								oCCO.PutChar ChrCode, oDCOChar.CharConfidence(0), nLeft, nTop, nRight, nBottom ]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				Next]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		bSaved = oCCO.Save(strCCOName)]]>
<![CDATA[
]]>
<![CDATA[		Set CCO = oCCO		'Update RuleRunner global CCO]]>
<![CDATA[
]]>
<![CDATA[	End Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[End Class	'CSnapper]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
	<af name="AnalyzeImage" access="public" bInter="bInter" bDebug="bDebug" qi="Converts the Image file (.tif) that represents the current page to a Fingerprint file (.cco) file for the page.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action converts the Image file (.tif) that represents the current ]]>
<![CDATA[
]]>
<![CDATA[    page to a CCO file for the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    A ruleset with this action should be bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object that represents an ]]>
<![CDATA[
]]>
<![CDATA[    application's source page. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    The action is not required if full-page recognition takes place using actions such as ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[RecognizePageOCR_S]]>
			</b>
<![CDATA[or]]>
			<b>
<![CDATA[RecognizePageICR_C]]>
			</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[AnalyzeImage()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      RotateImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      SetProblemValue(0.5)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      SetSearchArea(0.5)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      FindFingerprint(True)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      This sequence generates a CCO file for the current page, then checks to see if rotation of the ]]>
<![CDATA[
]]>
<![CDATA[      image is needed. Finally, the sequence attempts to match the current page with a fingerprint. ]]>
<![CDATA[
]]>
<![CDATA[      (For more about the matching process, see the descriptions of the ]]>
				<b>
<![CDATA[AutoDoc]]>
				</b>
<![CDATA[actions.)]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the ]]>
<![CDATA[
]]>
<![CDATA[    Document Hierarchy. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	AnalyzeImage = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("Skipping analysis. Object is not a page.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim ImageName]]>
<![CDATA[
]]>
<![CDATA[	ImageName = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not(FileMgr.FileExists(ImageName)) Then WriteLog("Skipping analysis. Image file doesn't exist") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("----- Analysis of: "& ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim theTime, oCCO]]>
<![CDATA[
]]>
<![CDATA[	theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bUseDCOPRocessor Then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If Not IsAlive(goDCOProcessor) Then ]]>
<![CDATA[
]]>
<![CDATA[            UseOutOfProcessRecog FALSE,FALSE,"TRUE"]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If goDCOProcessor is nothing then ]]>
<![CDATA[
]]>
<![CDATA[			    writelog "DCOProcessor object is not initialized"]]>
<![CDATA[
]]>
<![CDATA[			    nTaskStatus=retAbort]]>
<![CDATA[
]]>
<![CDATA[	    Else]]>
<![CDATA[
]]>
<![CDATA[			    Set oCCO = goDCOProcessor.Process("CCO._CCOCreator", "Analyze", ImageName)]]>
<![CDATA[
]]>
<![CDATA[			    bSaved = oCCO.Save(Left(ImageName, Len(ImageName)-3)&"cco")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			    If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[				    Writelog("n: " & Err.Number & " ; m:" & Err.Message) ]]>
<![CDATA[
]]>
<![CDATA[			    End if]]>
<![CDATA[
]]>
<![CDATA[		  End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		  Set oCCO = CCOCreator.Analyze(ImageName)]]>
<![CDATA[
]]>
<![CDATA[		  bSaved = oCCO.Save(Left(ImageName, Len(ImageName)-3)&"cco")]]>
<![CDATA[
]]>
<![CDATA[		  Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Analysis time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[	AnalyzeImage = True 	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SetOutOfProcessRecogTimeout" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the number of seconds to wait before determining that a recognition action is no longer running properly.">
		<ap>
<![CDATA[
]]>
<![CDATA[    ]]>
			<i>
<![CDATA[Numeric]]>
			</i>
<![CDATA[value indicating the number of seconds to wait to determine that a]]>
<![CDATA[
]]>
<![CDATA[    recognition action has stalled or exited.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action sets the number of seconds to wait before assuming a recognition action is no longer]]>
<![CDATA[
]]>
<![CDATA[    running correctly.  When the timeout is reached, the recognition process is removed from memory.]]>
<![CDATA[
]]>
<![CDATA[    The ]]>
			<b>
<![CDATA[SetOutOfProcessRecogTimeout]]>
			</b>
<![CDATA[action only has an effect if out-of-process recognition is]]>
<![CDATA[
]]>
<![CDATA[    enabled by the use of a]]>
			<b>
<![CDATA[UseOutOfProcessRecog]]>
			</b>
<![CDATA[action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If a recognition action does not complete within the specified number of seconds indicated by]]>
<![CDATA[
]]>
<![CDATA[    a ]]>
			<b>
<![CDATA[SetOutOfProcessRecogTimeout]]>
			</b>
<![CDATA[action or a ]]>
			<b>
<![CDATA[SetEngineTimeout]]>
			</b>
<![CDATA[action, it is assumed]]>
<![CDATA[
]]>
<![CDATA[    that the recognition engine has encountered a severe error, is removed from memory, and]]>
<![CDATA[
]]>
<![CDATA[    recognition will automatically be re-started one more time.  If the recognition action completes]]>
<![CDATA[
]]>
<![CDATA[    successfully within the specified time on either the first or second attempt, that recognition]]>
<![CDATA[
]]>
<![CDATA[    action will be successful.  If the recognition action does not complete by the specified time]]>
<![CDATA[
]]>
<![CDATA[    on the second attempt, the recognition action will be set to abort]]>
<![CDATA[
]]>
<![CDATA[    if ]]>
			<b>
<![CDATA[RecogContinueOnFailure(False)]]>
			</b>
<![CDATA[was used.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If ]]>
			<b>
<![CDATA[SetOutOfProcessRecogTimeout]]>
			</b>
<![CDATA[is not called, the default value of 300 seconds will be]]>
<![CDATA[
]]>
<![CDATA[    used.  In normal conditions, the default value will be sufficient and does not need to be]]>
<![CDATA[
]]>
<![CDATA[    changed.  This value will need to be increased only if a single page consistently takes more]]>
<![CDATA[
]]>
<![CDATA[    than 5 minutes to complete, which is a very atypical situation.  The programmer can choose]]>
<![CDATA[
]]>
<![CDATA[    to shorten this time to reduce the time to detect failures earlier, provided there is time]]>
<![CDATA[
]]>
<![CDATA[    left to perform recognition in "worst case" scenarios.  For best results, this timeout should]]>
<![CDATA[
]]>
<![CDATA[    be set the same or longer than the value specified in a ]]>
			<b>
<![CDATA[SetEngineTimeout]]>
			</b>
<![CDATA[action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    When a ]]>
			<b>
<![CDATA[SetOutOfProcessRecogTimeout]]>
			</b>
<![CDATA[action is called, the setting will be in effect for the]]>
<![CDATA[
]]>
<![CDATA[    entire batch, allowing you to set the value once, then call as many recognition actions as]]>
<![CDATA[
]]>
<![CDATA[    necessary.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[SetOutOfProcessRecogTimeout(300)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      UseOutOfProcessRecog(True)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      RecognizePageOCR_S()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SetOutOfProcessRecogTimeout = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[        g_lOutOfProcessTimeout = CLng(StrParam) * 1000]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Invalid parameter type passed. This action expects a numeric value."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="RecogContinueOnFailure" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Determines if a batch will abort if page or field recognition fails.">
		<ap>
<![CDATA[
]]>
<![CDATA[    ]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[value: True or False.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[1.]]>
			</b>
<![CDATA[ True: a recognition failure will not be automatically re-tried if recognition fails. The batch will continue and the application can use the value assigned to the ]]>
			<b>
<![CDATA[RecogStatus]]>
			</b>
<![CDATA[variable to decide how to proceed on success or failure of recognition. (For more about the ]]>
			<b>
<![CDATA[RecogStatus]]>
			</b>
<![CDATA[variable, access Information about the ]]>
			<b>
<![CDATA[RecogContinueOnFailure]]>
			</b>
<![CDATA[action.) ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[2.]]>
			</b>
<![CDATA[ False: causes the batch to abort if a full-page or field-level recognition action fails. If ]]>
			<b>
<![CDATA[UseOutOfProcessRecog]]>
			</b>
<![CDATA[is enabled, the batch will abort only if the second recognition attempt fails.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action determines if a batch will abort if page or field recognition failed.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Please note: If ]]>
			<b>
<![CDATA[RecogContinueOnFailure]]>
			</b>
<![CDATA[is not specifically called, the default ]]>
			<i>
<![CDATA[False]]>
			</i>
<![CDATA[value is used. This means that batches will abort if recognition fails.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    After a recognition operation is complete, the variable ]]>
			<b>
<![CDATA[RecogStatus]]>
			</b>
<![CDATA[is set to indicate the success or failure of recognition. If page-level recognition is being performed, RecogStatus values of 0, 1 or 2 are considered successful. The full list of values includes:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    0 - Success]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    1 - Recognition was successful but there are no results...the page was empty.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    2 - Recognition was successful and additional processing such as "RotateImage" was performed.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    4 - Failure: the recognition engine cannot be instantiated.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    5 - Failure: the recognition engine timed out (the time specified by the ]]>
			<b>
<![CDATA[SetEngineTimeout]]>
			</b>
<![CDATA[action has expired.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    6 - Failure: could not load image to engine.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    7 - Failure: could not load image to engine (path not found).]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    8 - Failure: image could not be rotated.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    10 - Failure: general failure occurred and recognition was not completed.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[RecogContinueOnFailure(True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      RecognizePageOCR_S()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    RecogContinueOnFailure = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If lcase(StrParam) = "true" OR lcase(StrParam) = "false" Then]]>
<![CDATA[
]]>
<![CDATA[        g_bContinueOnFailure = cbool(strParam)]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Invalid parameter type passed. This action expects a boolean value."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SetRecogFailureRetryDelay" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the number of seconds to wait before restarting a failed recognition action.">
		<ap>
<![CDATA[
]]>
<![CDATA[    ]]>
			<i>
<![CDATA[Numeric ]]>
			</i>
<![CDATA[ value indicating the number of seconds to wait before restarting a failed recognition]]>
<![CDATA[
]]>
<![CDATA[    action, and automatically re-activating recognition one more time.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action sets the number of seconds to wait after the time specified in either a ]]>
			<b>
<![CDATA[SetOutOfProcessRecogTimeOut]]>
			</b>
<![CDATA[action]]>
<![CDATA[
]]>
<![CDATA[    or a ]]>
			<b>
<![CDATA[SetEngineTimeout]]>
			</b>
<![CDATA[action has expired. Once either timeout has occurred, the recognition engine]]>
<![CDATA[
]]>
<![CDATA[    will be removed from memory: the action will then wait the additional time specified by the ]]>
			<b>
<![CDATA[SetRecogFailureRetryDelay]]>
			</b>
<![CDATA[action]]>
<![CDATA[
]]>
<![CDATA[    to be sure that the engine has exited before restarting recognition. ]]>
			<b>
<![CDATA[SetRecogFailureRetryDelay]]>
			</b>
<![CDATA[only]]>
<![CDATA[
]]>
<![CDATA[    has an effect if out-of-process recognition has been enabled by a ]]>
			<b>
<![CDATA[UseOutOfProcessRecog]]>
			</b>
<![CDATA[action.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    If a recognition action does not complete within the number of seconds specified by]]>
<![CDATA[
]]>
<![CDATA[    a ]]>
			<b>
<![CDATA[SetOutOfProcessRecog]]>
			</b>
<![CDATA[action or a ]]>
			<b>
<![CDATA[SetEngineTimeout]]>
			</b>
<![CDATA[action, it is assumed that the]]>
<![CDATA[
]]>
<![CDATA[    recognition engine has encountered a severe error - and that recognition will automatically be]]>
<![CDATA[
]]>
<![CDATA[    restarted one more time. If the recognition action completes successfully within the specified]]>
<![CDATA[
]]>
<![CDATA[    time on either the first or second attempt, that recognition action will be successful. If the]]>
<![CDATA[
]]>
<![CDATA[    recognition action does not complete by the specified time on the second attempt, the]]>
<![CDATA[
]]>
<![CDATA[    recognition action will be set to abort if ]]>
			<b>
<![CDATA[RecogContinueOnFailure(False)]]>
			</b>
<![CDATA[has been]]>
<![CDATA[
]]>
<![CDATA[    used.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If ]]>
			<b>
<![CDATA[SetRecogFailureRetryDelay]]>
			</b>
<![CDATA[is not specifically called, the default value of 10]]>
<![CDATA[
]]>
<![CDATA[    seconds is used. Under normal conditions, the default value will be sufficient and does]]>
<![CDATA[
]]>
<![CDATA[    not need to be changed. This value needs to be increased only if a log indicates that errors]]>
<![CDATA[
]]>
<![CDATA[    are occurring when attempting to re-start a failed recognition action, and the problem can be]]>
<![CDATA[
]]>
<![CDATA[    diagnosed by setting the RecogStatus to "4".]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    When ]]>
			<b>
<![CDATA[SetRecogFailureRetryDelayDelay]]>
			</b>
<![CDATA[is called, its setting will be in effect for the]]>
<![CDATA[
]]>
<![CDATA[    entire batch. This allows you to set the value once, and call as many recognition actions]]>
<![CDATA[
]]>
<![CDATA[    as necessary.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[SetRecogFailureRetryDelay(10)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      UseOutOfProcessRecog(True)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      RecognizePageOCR_S()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SetRecogFailureRetryDelay = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[        g_iRecogFailureRetryDelay = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Invalid parameter type passed. This action expects a numeric value."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SetFullPageRecogArea" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="An optional action that sets the area of the current page that is to be the target of recognition procedures, when full-page recognition action is invoked.">
		<ap>
<![CDATA[
]]>
<![CDATA[    A decimal value indicating the percent of the page to be recognized in response to this action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    For example: "0.1" designates the first 10% of the page, while "1.0" calls for recognition]]>
<![CDATA[
]]>
<![CDATA[    of the entire page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    This action is helpful if you know that a page's values will always be in a particular location]]>
<![CDATA[
]]>
<![CDATA[    on the page, but recognition of the entire page is not necessary.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This optional action sets the area of the current page that will be the target of]]>
<![CDATA[
]]>
<![CDATA[    recognition procedures when full-page recognition action is called. For example: "0.1" indicates]]>
<![CDATA[
]]>
<![CDATA[    that the first 10% of the page is to be recognized; "1.00" indicates that the entire]]>
<![CDATA[
]]>
<![CDATA[    page is to be recognized.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[SetFullPageRecogArea(0.5)]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[ object of the]]>
<![CDATA[
]]>
<![CDATA[    Document Hierarchy, or if the action's parameter is not a decimal value. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	SetFullPageRecogArea = False]]>
<![CDATA[
]]>
<![CDATA[	If StrParam = "" Or Not IsNumeric(StrParam) Or Cdbl(StrParam)< 0 Or Cdbl(StrParam) > 1 Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("SetFullPageRecogArea: Parameter is invalid.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("sr_FullPageRecogArea") = Cdbl(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Err.Clear]]>
<![CDATA[
]]>
<![CDATA[	SetFullPageRecogArea = True ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="CCONormalization_OFF" access="public" bInter="bInter" bDebug="bDebug">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    Prevents the automatic running of NormalizeCCO procedures after a full-page recognition action has run.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    A full-page recognition action such as ]]>
			<b>
<![CDATA[RecognizePageICR_C]]>
			</b>
<![CDATA[automatically calls the]]>
<![CDATA[
]]>
<![CDATA[    thorough but time-consuming ]]>
			<b>
<![CDATA[NormalizeCCO]]>
			</b>
<![CDATA[action after recognition is complete]]>
<![CDATA[
]]>
<![CDATA[    (this action is part of the ]]>
			<b>
<![CDATA[cco2cco.rrx]]>
			</b>
<![CDATA[file.)]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    To by-pass this procedure, place ]]>
			<b>
<![CDATA[CCONormalization_OFF]]>
			</b>
<![CDATA[right before the recognition action.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[CCONormalization_OFF()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      RecognizePageICR_C()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the action does not run at the Page level. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[ CCONormalization_OFF = true]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ If CurrentObj.ObjectType <> 2 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Warning! This action is set to run only at the page level."]]>
<![CDATA[
]]>
<![CDATA[ Else]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable("v_ccoNormOFF") = 1 ]]>
<![CDATA[
]]>
<![CDATA[ End If]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SetFingerprintRecogPriority" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the option that controls whether a full-page recognition action is to create a Fingerprint file(.cco) - aka a CCO file - for the current page.">
		<ap>
<![CDATA[
]]>
<![CDATA[    String value: ]]>
			<i>
<![CDATA[True]]>
			</i>
<![CDATA[or ]]>
			<i>
<![CDATA[False]]>
			</i>
<![CDATA[ to control the creation of the CCO. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[True:]]>
			</b>
<![CDATA[ If a CCO already exists prior to recognition, it is replaced with a brand new one with]]>
<![CDATA[
]]>
<![CDATA[    recognition results.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False:]]>
			</b>
<![CDATA[ If SetFingerprintRecogPriority is not called (or is set to false) and a CCO already]]>
<![CDATA[
]]>
<![CDATA[    exists prior to recognition, the recognition results will be added to that CCO.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action sets the option that controls whether a full-page recognition action is to create]]>
<![CDATA[
]]>
<![CDATA[    a CCO file for the current page. When the option is On, processing is faster because the call]]>
<![CDATA[
]]>
<![CDATA[    to the ]]>
			<b>
<![CDATA[AnalyzeImage]]>
			</b>
<![CDATA[action is eliminated. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    The difference between creating a CCO from scratch with recognition results and adding the recognition]]>
<![CDATA[
]]>
<![CDATA[    results to the existing CCO created by AnalyzeImage is that in the "adding" case,]]>
<![CDATA[
]]>
<![CDATA[    the recognized characters are put into the CCO in a manner that uses a different fingerprinting technique.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Note:]]>
			</b>
<![CDATA[Be sure to place this action before a full-page recognition action.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[SetFingerprintRecogPriority(True)]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	If (StrParam = "true" Or StrParam = "1") Then]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("s_srCreateCCO") = "1"]]>
<![CDATA[
]]>
<![CDATA[		goSnapper.m_bRecogCreateCCO = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("s_srCreateCCO") = "0"]]>
<![CDATA[
]]>
<![CDATA[		goSnapper.m_bRecogCreateCCO = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Err.Clear]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintRecogPriority = True ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="ReleaseImage" access="public" bInter="bInter" bDebug="bDebug" qi="This action has been deprecated.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action has been deprecated.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[ReleaseImage()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog "This action has been deprecated."]]>
<![CDATA[
]]>
<![CDATA[	Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ReleaseImage = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="IsBlankPage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Counts the number of words in the Fingerprint file(.cco) file of the current page and returns True if the count is less than or equal to the number you enter as the parameter.">
		<ap>
<![CDATA[
]]>
<![CDATA[  Long value indicating the maximum number of words in the Fingerprint file(.cco) of a]]>
<![CDATA[
]]>
<![CDATA[  "blank" source page. "50", for example, tells the action that if a CCO file has 50 words or less,]]>
<![CDATA[
]]>
<![CDATA[  its page is ]]>
			<i>
<![CDATA[blank.]]>
			</i>
<![CDATA[ Valid values are 0 to 2,147,483,647.]]>
<![CDATA[
]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action counts the number of words in the CCO file of the current page and returns True if]]>
<![CDATA[
]]>
<![CDATA[    the count is less than or equal to the number you enter as the parameter. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    A rule containing this action should apply to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object; within the rule, this]]>
<![CDATA[
]]>
<![CDATA[    action should come after one of the actions that creates a fingerprint, such as]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[AnalyzeImage]]>
			</b>
<![CDATA[, ]]>
			<b>
<![CDATA[RecognizePageOCR_S]]>
			</b>
<![CDATA[, or ]]>
			<b>
<![CDATA[RecognizePageICR_C]]>
			</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[IsBlankPage(5)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      SetPageType(Separator)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      This sequence uses ]]>
				<b>
<![CDATA[AnalyzeImage]]>
				</b>
<![CDATA[to create a CCO file, then checks to see]]>
<![CDATA[
]]>
<![CDATA[      if the file contains less than six words. If so, the ]]>
				<b>
<![CDATA[IsBlankPage(5)]]>
				</b>
<![CDATA[action]]>
<![CDATA[
]]>
<![CDATA[      returns True. The final action, a DCO action, establishes the page as a Separator page.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the action parameter is invalid or if the action is unable to locate the Image file for the]]>
<![CDATA[
]]>
<![CDATA[    current page or its CCO file. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	IsBlankPage = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If StrParam = "" Or Not IsNumeric(StrParam) Then WriteLog("Skipping. Parameter isn't an integer"): Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = CLng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Invalid parameter entered, value must be between 0 and 2,147,483,647. Exiting."]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("IsBlankPage : Exiting. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- IsBlankPage of: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim strCCOFile]]>
<![CDATA[
]]>
<![CDATA[	strCCOFile = Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-3)&"cco"]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(strCCOFile)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("IsBlankPage skipping. CCO file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = CCOCreator.Load(strCCOFile )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Count words]]>
<![CDATA[
]]>
<![CDATA[	Dim i, nWord]]>
<![CDATA[
]]>
<![CDATA[	For i=1 To oCCO.count]]>
<![CDATA[
]]>
<![CDATA[		nWord = nWord + oCCO.item(i).count ]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (nWord<=StrParam) Then IsBlankPage = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = Nothing ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="RotateTio" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Checks if an Image file processed by the ImageFix action that assigns a .tio extension to the file needs to be rotated by 90, 180, or 270 degrees.  If so, the action rotates and then saves the Image file with the same .tio extension. ">
		<ap>
<![CDATA[
]]>
<![CDATA[    A ]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[value to initiate rotation (True) or prevent rotation (False.)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action checks if an Image file processed by the ]]>
			<b>
<![CDATA[ImageFix]]>
			</b>
<![CDATA[action that assigns]]>
<![CDATA[
]]>
<![CDATA[    the .tio extension needs to be rotated by 90, 180, or 270 degrees.  If rotation is necessary,]]>
<![CDATA[
]]>
<![CDATA[    the action saves the Image file with the same .tio extension.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      AnalyzeImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[RotateTio(True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      RotateImage()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      RecognizePageICR_C()]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	RotateTio = False]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If (StrParam = "true") Then]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("s_srRotateTIO") = CInt(True)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("s_srRotateTIO") = CInt(False)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	RotateTio = True ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="CreateTextFile" access="public" bInter="bInter" bDebug="bDebug" qi="Creates a Text file(.txt) for the current page; adds the page's recognized values to the file; and places the file in the current batch, in your application's Batches directory.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action creates a UTF-8 encoded Text file (.txt)for the current page; adds the page's recognized values to the file;]]>
<![CDATA[
]]>
<![CDATA[    and places the file in the current batch, in your application's ]]>
			<b>
<![CDATA[Batches]]>
			</b>
<![CDATA[ directory. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Alert!]]>
			</b>
<![CDATA[ The Text file generated by this action is handy for debugging purposes - to]]>
<![CDATA[
]]>
<![CDATA[    see what recognition is placing into the page's Fingerprint file(.cco) file. The action should]]>
<![CDATA[
]]>
<![CDATA[    follow a full-page recognition action such as ]]>
			<b>
<![CDATA[RecognizePageOCR_S]]>
			</b>
<![CDATA[, in a rule applied]]>
<![CDATA[
]]>
<![CDATA[    to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      RecognizePageOCR_S()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[CreateTextFile()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      SetProblemValue(0.7)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      SetSearchArea(0.5)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      FindFingerprint(True)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      After the full-page recognition action (]]>
				<b>
<![CDATA[RecognizePageOCR_S]]>
				</b>
<![CDATA[), the ]]>
				<b>
<![CDATA[CreateTextFile()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      action places the recognized values into a Text file that it has set up for the page, and]]>
<![CDATA[
]]>
<![CDATA[      adds the file to the current batch, in the application's ]]>
				<b>
<![CDATA[Batches]]>
				</b>
<![CDATA[ directory.  ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The text file that is created has the same filename as the image, but is assigned a .txt]]>
<![CDATA[
]]>
<![CDATA[      filename extension.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[object of]]>
<![CDATA[
]]>
<![CDATA[    the Document Hierarchy, or if an Image file for the current page is not available. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[		CreateTextFile = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oFile]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("CreateTextFile skipping. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- CreateTextFile for: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim strCCOFile]]>
<![CDATA[
]]>
<![CDATA[	strCCOFile = Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-3)&"cco"]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(strCCOFile)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("CreateTextFile skipping. CCO file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = CCOCreator.Load(strCCOFile )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set l_sStreamUTF8 = CreateObject("ADODB.Stream")]]>
<![CDATA[
]]>
<![CDATA[	With l_sStreamUTF8]]>
<![CDATA[
]]>
<![CDATA[    .Open        ]]>
<![CDATA[
]]>
<![CDATA[		.Type = 2 'text]]>
<![CDATA[
]]>
<![CDATA[    .LineSeparator = -1 'crlf]]>
<![CDATA[
]]>
<![CDATA[		.CharSet = "UTF-8"        ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	  'Recog results	]]>
<![CDATA[
]]>
<![CDATA[	  Dim Line, i, j]]>
<![CDATA[
]]>
<![CDATA[	  For i=1 To oCCO.count]]>
<![CDATA[
]]>
<![CDATA[		  For j=1 To oCCO.item(i).count]]>
<![CDATA[
]]>
<![CDATA[			  Line = Line & oCCO.item(i).item(j).value & " " ]]>
<![CDATA[
]]>
<![CDATA[		  Next]]>
<![CDATA[
]]>
<![CDATA[		  .WriteText Line,1 'append line separator at end of string]]>
<![CDATA[
]]>
<![CDATA[		  Line = ""]]>
<![CDATA[
]]>
<![CDATA[	  Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	  .SaveToFile Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-3) & "txt", 2 ' save to file create/overwrite existing]]>
<![CDATA[
]]>
<![CDATA[	  .Close  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End With]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set l_sStreamUTF8 = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CreateTextFile = True  ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SnapCCOtoDCO" access="public" bInter="bInter" bDebug="bDebug" qi="Transfers the recognition results in the current page's CCO file - its Fingerprint file - to the appropriate Field objects of the Document Hierarchy...its setup DCO.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action transfers the recognition results of the current page's CCO file to the]]>
<![CDATA[
]]>
<![CDATA[    appropriate ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[ objects of the Document Hierarchy (DCO). Note that the action only]]>
<![CDATA[
]]>
<![CDATA[    transfers values to ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[ objects.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    SnapCCOToDCO will only clear / update field text when all of the following conditions are met:]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    - Field is not an OMR field (i.e. var RecogType=4).]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    - Field has positions assigned.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    - Field does not have the variable "v_skipsnap" set to 1.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    - Field has data mapping to the CCO (at least one character).]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    - Fixes issue that would affect processing of reserved fields (i.e. fields that are used for anchor finding followed by snapping of data).]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[SnapCCOtoDCO()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page or Field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if a ruleset with this action is not bound to a ]]>
			<b>
<![CDATA[Page]]>
			</b>
<![CDATA[ object or]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[ object of the Document Hierarchy. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	SnapCCOtoDCO = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType <> 2 And CurrentObj.ObjectType <> 3) Then Exit Function	'must be a page or a field]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- SnapCCO2DCO for: " & CurrentObj.ID & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim theTime]]>
<![CDATA[
]]>
<![CDATA[	theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	goSnapper.SnapCCOtoDCO CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Snapping Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	SnapCCOtoDCO = True]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SetAdjustFieldToChars" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Optional setting for SnapCCOToDCO to adjust the field position the its character positions.">
		<ap>
<![CDATA[A ]]>
			<i>
<![CDATA[String]]>
			</i>
<![CDATA[value to snap character positions (True) or disable snapping (False).]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action has SnapCCOtoDCO adjust the field position (parameter True) to the character positions results after snapping the charater values to the field.   ]]>
<![CDATA[
]]>
<![CDATA[      Off by Default]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetAdjustFieldToChars(TRUE)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SnapCCOtoDCO()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page or Field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim bStrParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetAdjustFieldToChars = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam=replace(StrParam," ","")]]>
<![CDATA[
]]>
<![CDATA[  StrParam=ucase(trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  bStrParam = cbool(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Invalid Parameter '" & StrParam & "' Must be 'True' or 'False'")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    goSnapper.m_bDoPostProcessSnap=bStrParam]]>
<![CDATA[
]]>
<![CDATA[    Writelog("SetAdjustFieldToChars is set to '" & cstr(goSnapper.m_bDoPostProcessSnap) & "'")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="SnapDCOtoCCO" access="public" bInter="bInter" bDebug="bDebug" qi="Transfers the recognition results assigned to Field objects of the Document Hierarchy (aka the setup DCO) to the current page's CCO file...also known as its Fingerprint file.">
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action transfers the recognition results assigned to ]]>
			<b>
<![CDATA[Field]]>
			</b>
<![CDATA[objects of the]]>
<![CDATA[
]]>
<![CDATA[    Document Hierarchy(DCO) to the current page's CCO file. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If zonal recognition is used instead of full-page recognition, the action will populate]]>
<![CDATA[
]]>
<![CDATA[    the current page's CCO file with the results of zonal recognition.  Then, when the Verify]]>
<![CDATA[
]]>
<![CDATA[    task runs, a user can use the ClickNKey option to populate fields.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[SnapDCOtoCCO()]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if a rule with this action is not applied to a page. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	SnapDCOtoCCO = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("SnapDCOtoCCO: Object is not a page.") : Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- SnapDCOtoCCO for: " & CurrentObj.ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	goSnapper.SnapDCOtoCCO CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SnapDCOtoCCO = True]]>
<![CDATA[
]]>
		</g>
	</af>
	<f name="SnapFieldtoChars" access="public" qi="Adjusts the zone position of the passed dco field to the field's character positions.">
		<p name="Smartparam" type="string">
		</p>
		<ap>
<![CDATA[A SmartParamter value representing a valid Field location.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action adjusts the field position of the passed DCO to the DCO's character positions. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    If the field does not have a text value, no adjustment to the field zone is performed.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[SnapFieldtoChars(@F)]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Any level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if a valid DCO field is not returned from the Smart parameter value. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	Dim oField]]>
<![CDATA[
]]>
<![CDATA[	Dim RemSet]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SnapFieldtoChars = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oField = DcoNav(Smartparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oField) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Valid DCO not found.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oField.ObjectType<>3 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO must a field")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	RemSet = goSnapper.m_bDoPostProcessSnap ]]>
<![CDATA[
]]>
<![CDATA[	goSnapper.m_bDoPostProcessSnap = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SnapFieldtoChars = goSnapper.CorrectFieldPosition(oField)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oField = Nothing	]]>
<![CDATA[
]]>
<![CDATA[      goSnapper.m_bDoPostProcessSnap = RemSet]]>
<![CDATA[
]]>
<![CDATA[
]]>
		</g>
	</f>
	<f name="RecogOMRThreshold" access="public" qi="Performs OMR checkbox recognition by counting black pixels within each OMR box area in a Field with one or more OMR boxes.">
		<p name="threshold">
		</p>
		<p name="background">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[    ]]>
			<i>
<![CDATA[Floating Point]]>
			</i>
<![CDATA[ or ]]>
			<i>
<![CDATA[Integer]]>
			</i>
<![CDATA[values that specify the count of black]]>
<![CDATA[
]]>
<![CDATA[    pixels in OMR boxes:  ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    1. ]]>
			<b>
<![CDATA[Threshold:]]>
			</b>
<![CDATA[the percentage of pixels in the zone - the field zone not the printed box]]>
<![CDATA[
]]>
<![CDATA[    that should be considered "checked", i.e. the lightest box that is not just noise, but should]]>
<![CDATA[
]]>
<![CDATA[    be considered a check mark.  ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    2. ]]>
			<b>
<![CDATA[Background:]]>
			</b>
<![CDATA[ the percentage of pixels in the zone that might be due to scanner noise]]>
<![CDATA[
]]>
<![CDATA[    and/or the border of the printed box. This value also controls the range on either side of the]]>
<![CDATA[
]]>
<![CDATA[    Threshold value that is “low confidence”.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Please note: The action also accepts parameters that are fractional percentages which are needed]]>
<![CDATA[
]]>
<![CDATA[    to detect marks in very large zones.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    The parameters should be experimentally adjusted on real-world scanned forms.]]>
<![CDATA[
]]>
<![CDATA[    First, determine the Threshold value that correctly identifies a light mark as “checked”, and]]>
<![CDATA[
]]>
<![CDATA[    correctly identifies noisy zones as “unchecked”.]]>
<![CDATA[
]]>
<![CDATA[    Second, adjust the Background parameter’s value to achieve an acceptable confidence interval.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action performs OMR checkbox recognition by counting black pixels within each OMR box area in a]]>
<![CDATA[
]]>
<![CDATA[    Field with one or more OMR boxes. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Text Boxes]]>
			</b>
			<br>
			</br>
<![CDATA[The action sets the text value of the field to a string of 0's and 1's]]>
<![CDATA[
]]>
<![CDATA[    (one digit per OMR box); and assigns a Confidence String to the string of digits: '4' for Low Confidence up to '9' for High Confidence.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[Density String and Confidence Value]]>
			</b>
			<br>
			</br>
<![CDATA[The action also establishes a "DensityString"]]>
<![CDATA[
]]>
<![CDATA[    variable for the Character String, indicating percentage-filled, from ASCII 48 ('0') through 148. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    For each possible OMR box, there will be a character. The character's ASCII value minus 48 is the percentage-filled.]]>
<![CDATA[
]]>
<![CDATA[    If the Density String=0X, the first OMR field was blank, and the second was 40% filled. The ASCII value for X is 88. 88 minus 48 = 40.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[MultiPunch and Confidence Values]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    If the MultiPunch setting is set to 1 and multiple OMR's were filled beyond the threshold, the one that was filled the most will be marked and set to Low Confidence.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If the percentage-filled is below the second parameter, the OMR box will not be selected and the confidence will be high.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If the percentage-filled is between the two parameters, the OMR box will not be selected and the confidence will be low.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If the percentage-filled is above the first parameter and below double the first parameter minus the second parameter, the OMR box will be selected and the confidence will be low.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If the percentage-filled is above double the first parameter minus the second parameter, the OMR box will be selected and the confidence will be high.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Note: The ]]>
			<b>
<![CDATA[RecogOMRThreshold]]>
			</b>
<![CDATA[action works best on dropout boxes, but with an appropriate background value can work effectively with boxes that]]>
<![CDATA[
]]>
<![CDATA[    are visible in the scanned image.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If you are using small visible boxes on your image, it is best to zone the area by surrounding the entire]]>
<![CDATA[
]]>
<![CDATA[    visible box with room for alignment movement, then factor out the black from the box using the parameters.]]>
<![CDATA[
]]>
<![CDATA[    If you attempt to zone inside the borders of a visible box, you can get a false positive if the page]]>
<![CDATA[
]]>
<![CDATA[    does not align exactly.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    This action requires ]]>
			<i>
<![CDATA[dcimage.ocx.v.6.03.22]]>
			</i>
<![CDATA[or above.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      RecogOMRThreshold("10","5")]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      For a small to medium size zone, “10% filled” may be considered a deliberate mark. Anything below 5% (Background) is definitely ]]>
				<b>
<![CDATA[
]]>
<![CDATA[        ]]>
					<i>
<![CDATA[not]]>
					</i>
<![CDATA[
]]>
<![CDATA[      ]]>
				</b>
<![CDATA[a mark. Anything above 15% (Threshold + (Threshold – Background)) is a high confidence mark.]]>
<![CDATA[
]]>
<![CDATA[      This would work with a non-dropout OMR field where the box’s printed outline takes up less than 5% of the zone area. It would also work for dropout forms.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      RecogOMRThreshold("2","0")]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      This is for a signature line, or a large zone where the percentage-filled is usually much lower than for a small zone. This assumes very little background or noise.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Field level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[	Dim oChar]]>
<![CDATA[
]]>
<![CDATA[	Dim ImageCtrl]]>
<![CDATA[
]]>
<![CDATA[	Dim ImageFile]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft]]>
<![CDATA[
]]>
<![CDATA[	Dim nTop]]>
<![CDATA[
]]>
<![CDATA[	Dim nRight]]>
<![CDATA[
]]>
<![CDATA[	Dim nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim area]]>
<![CDATA[
]]>
<![CDATA[	Dim PixelCount]]>
<![CDATA[
]]>
<![CDATA[	Dim BlackPercent]]>
<![CDATA[
]]>
<![CDATA[	Dim Bl]]>
<![CDATA[
]]>
<![CDATA[	Dim nRet]]>
<![CDATA[
]]>
<![CDATA[	Dim HCMarkVal]]>
<![CDATA[
]]>
<![CDATA[	Dim TextVal]]>
<![CDATA[
]]>
<![CDATA[	Dim ConfVal]]>
<![CDATA[
]]>
<![CDATA[	Dim WhiteCount]]>
<![CDATA[
]]>
<![CDATA[	Dim DensityString]]>
<![CDATA[
]]>
<![CDATA[	Dim BoxCoordinates]]>
<![CDATA[
]]>
<![CDATA[	Dim fThreshPct]]>
<![CDATA[
]]>
<![CDATA[	Dim fBkgndPct]]>
<![CDATA[
]]>
<![CDATA[	Dim darkestPct]]>
<![CDATA[
]]>
<![CDATA[	Dim darkestBox]]>
<![CDATA[
]]>
<![CDATA[	Dim nchecked]]>
<![CDATA[
]]>
<![CDATA[	Dim bCorrected]]>
<![CDATA[
]]>
<![CDATA[  Dim slocale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecogOMRThreshold = False]]>
<![CDATA[
]]>
<![CDATA[	bCorrected = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType <> 3 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("This action must operate on a field.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.Variable("d_sr") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog ( "Field '" & CurrentObj.ID & "' OMR recognition is skipped by the settings.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  slocale = currentobj.variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  threshold = Trim(threshold)]]>
<![CDATA[
]]>
<![CDATA[  background = Trim(background)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  threshold = DCGlobalCurrency.NormalizeNumber(threshold,slocale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(threshold) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("First argument threshold must be numeric, representing the percentage of black to call the box marked.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		fThreshPct = Cdbl(threshold)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  background = DCGlobalCurrency.NormalizeNumber(background,slocale)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsNumeric(background) Then]]>
<![CDATA[
]]>
<![CDATA[		' should also check 0 <= bkgnd <= thresh <= 100)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Second Argument background must be numeric, representing the Background percentage to ignore. Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		fBkgndPct = Cdbl(background)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If fThreshPct < 0 Or fThreshPct > 100 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Threshold must be between 0 and 100. Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If fBkgndPct < 0 Or fBkgndPct > fThreshPct Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Background percentage must be between 0 and threshold.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.NumOfChildren = 0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("This field has no OMR Boxes defined.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set ImageCtrl = CreateObject("DCImage.DCImageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	imagefile = CurrentObj.Parent.Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.FileName = imagefile]]>
<![CDATA[
]]>
<![CDATA[	If ImageCtrl.Filename = "" Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot load image: " & imagefile)]]>
<![CDATA[
]]>
<![CDATA[		nTaskStatus=retAbort ''Set the task to abort]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	bl = Space(28)]]>
<![CDATA[
]]>
<![CDATA[  b2 = Space(4)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	HCMarkVal = fThreshPct + fThreshPct - fBkgndPct]]>
<![CDATA[
]]>
<![CDATA['	Writelog("High Confidence mark set to: " & CStr(HCMarkVal))]]>
<![CDATA[
]]>
<![CDATA['	Writelog("OMR Results: " & CurrentObj.Parent.ID & "-" & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA['	Writelog("Checkbox    Adjusted Coordinates              Area   Count        Density")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	darkestPct = 0]]>
<![CDATA[
]]>
<![CDATA[	nchecked = 0]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.GetImageInfo Width, Height, DPI]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("OMR Zone       Coordinates          Area   PixelCount   Percent Blk") ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("--------   -------------------      ----   ----------   -----------")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For i = 0 To CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[		Set oChar = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		nRet= oChar.GetPosition(nLeft,nTop,nRight,nBottom)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If (nLeft < 0) Then nLeft = 0 : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nTop < 0) Then nLeft = 0 : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nRight < nLeft) Then nRight = nLeft : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nBottom < nTop) Then nBottom = nTop : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If (nLeft > Width) Then nLeft = Width : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nTop > Height) Then nLeft = Height : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nRight > Width) Then nRight = Width : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nBottom > Height) Then nBottom = Height : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[		area = (nRight - nLeft) * (nBottom - nTop)]]>
<![CDATA[
]]>
<![CDATA[		If (area <= 0) Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Invalid field bounds")]]>
<![CDATA[
]]>
<![CDATA[			Set ImageCtrl = Nothing]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		PixelCount = ImageCtrl.NumOfPixels(nLeft,nTop,nRight,nBottom,1)]]>
<![CDATA[
]]>
<![CDATA[		BoxCoordinates = left(CStr(nLeft)+b2,4) & "," & left(CStr(nTop)+b2,4) & "," & left(CStr(nRight)+b2,4) & "," & CStr(nBottom)]]>
<![CDATA[
]]>
<![CDATA[		BlackPercent = PixelCount/Area * 100  		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Left(b2 & CStr(i+1) & bl,12) & Left(BoxCoordinates & bl,20) & Right(bl & CStr(Area),8) & Right(bl & CStr(PixelCount),10) & Left(bl,10) & CStr(BlackPercent)) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If BlackPercent >= fThreshPct Then ]]>
<![CDATA[
]]>
<![CDATA[			TextVal = TextVal & "1"]]>
<![CDATA[
]]>
<![CDATA[			nchecked = nchecked + 1]]>
<![CDATA[
]]>
<![CDATA[			If BlackPercent > darkestPct Then]]>
<![CDATA[
]]>
<![CDATA[				darkestPct = BlackPercent]]>
<![CDATA[
]]>
<![CDATA[				darkestBox = i]]>
<![CDATA[
]]>
<![CDATA[			End If		]]>
<![CDATA[
]]>
<![CDATA[		Else ]]>
<![CDATA[
]]>
<![CDATA[			TextVal = TextVal & "0"]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		DensityString=DensityString & Chr(CInt(BlackPercent) + 48)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If bCorrected Then]]>
<![CDATA[
]]>
<![CDATA[			Confval = ConfVal & "0"]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			If BlackPercent > fBkgndPct And BlackPercent < HcMarkVal Then]]>
<![CDATA[
]]>
<![CDATA[				Confval = ConfVal &  "4"]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				ConfVal = ConfVal & "9"]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.Variable("MultiPunch") <> "1" And nchecked > 1 Then]]>
<![CDATA[
]]>
<![CDATA[		TextVal = ""]]>
<![CDATA[
]]>
<![CDATA[		ConfVal = ""]]>
<![CDATA[
]]>
<![CDATA[		' multiple marks in single punch field - choose darkest and lower confidence]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 To CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[			If i = darkestBox Then]]>
<![CDATA[
]]>
<![CDATA[				TextVal = TextVal & "1"]]>
<![CDATA[
]]>
<![CDATA[				Confval = ConfVal & "1"]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				TextVal = TextVal & "0"]]>
<![CDATA[
]]>
<![CDATA[				Confval = ConfVal & "1"]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next 'i]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text = TextVal]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.ConfidenceString = ConfVal]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("DensityString") = DensityString  ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("  ") ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Field Value:       " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ConfidenceString:  " & CurrentObj.ConfidenceString)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("DensityString:     " & DensityString)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("  ")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Set ImageCtrl = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	RecogOMRThreshold = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
		</g>
	</f>
	<af name="RecogOMRThresh" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by RecogOMRThreshold.">
		<ap>
<![CDATA[
]]>
<![CDATA[    Two comma-separated ]]>
			<i>
<![CDATA[Floating Point]]>
			</i>
<![CDATA[or ]]>
			<i>
<![CDATA[Integer]]>
			</i>
<![CDATA[values that specify the count of black]]>
<![CDATA[
]]>
<![CDATA[    pixels in OMR boxes:  ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    1. ]]>
			<b>
<![CDATA[Threshold:]]>
			</b>
<![CDATA[the percentage of pixels in the zone - the field zone not the printed box]]>
<![CDATA[
]]>
<![CDATA[    that should be considered "checked", i.e. the lightest box that is not just noise, but should]]>
<![CDATA[
]]>
<![CDATA[    be considered a check mark.  ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    2. ]]>
			<b>
<![CDATA[Background:]]>
			</b>
<![CDATA[ the percentage of pixels in the zone that might be due to scanner noise]]>
<![CDATA[
]]>
<![CDATA[    and/or the border of the printed box. This value also controls the range on either side of the]]>
<![CDATA[
]]>
<![CDATA[    Threshold value that is “low confidence”.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action has been replaced by RecogOMRThreshold.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<see>
<![CDATA[RecogOMRThreshold]]>
		</see>
		<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecogOMRThresh= False]]>
<![CDATA[
]]>
<![CDATA[	ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If UBound(ParamAr) <> 1 Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Wrong number of arguments.  Expecting (Threshold, Background).  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Param 1: '" & ParamAr(0) & "'. Param 2: '" & ParamAr(1) & "'.") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecogOMRThresh = RecogOMRThreshold(ParamAr(0), ParamAr(1))]]>
<![CDATA[
]]>
		</g>
	</af>
	<af name="UseOutOfProcessRecog" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Causes recognition to be performed in a process that is separate from the process that is running the recognition actions. ">
		<ap>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[True:]]>
			</b>
<![CDATA[ Recognition actions should run in a separate process.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[False:]]>
			</b>
<![CDATA[ Recognition should run in the same process as the recognition actions.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[    This action determines in which process recognition will be performed. Using a separate process]]>
<![CDATA[
]]>
<![CDATA[    for recognition provides an additional stability and automatic recovery ability as it will automatically]]>
<![CDATA[
]]>
<![CDATA[    retry a recognition action that runs into trouble, such as recognition that has stalled or unexpectedly]]>
<![CDATA[
]]>
<![CDATA[    terminated. The action must be placed before a full-page or field-level recognition action such as]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<b>
<![CDATA[RecognizePageOCR_S.]]>
			</b>
<![CDATA[ ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    The action is also directly tied to the ]]>
			<b>
<![CDATA[SetRecogFailureRetryDelay]]>
			</b>
<![CDATA[action, which determines how]]>
<![CDATA[
]]>
<![CDATA[    long (in seconds) the ]]>
			<b>
<![CDATA[UseOutOfProcessRecog]]>
			</b>
<![CDATA[action waits to determine that recognition has stopped]]>
<![CDATA[
]]>
<![CDATA[    responding and must be retried.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If the ]]>
			<b>
<![CDATA[UseOutOfProcessRecog]]>
			</b>
<![CDATA[action is not specifically called, its default True setting will be]]>
<![CDATA[
]]>
<![CDATA[    used. If the action is called specifically, the True or False setting will be in effect for the entire]]>
<![CDATA[
]]>
<![CDATA[    batch. This allows you to set the value once, and call as many recognition actions as necessary.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[UseOutOfProcessRecog(True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      SetRecogFailureRetryDelay(10)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      RecognizePageOCR_S()]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  UseOutOfProcessRecog = false]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog "Current DCOProcessor state: " & g_bUseDCOPRocessor]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If LCase(Trim(strParam)) <> "true" And LCase(strParam) <> "false" Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Invalid parameter passed: '" & strParam & "'."]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    g_bUseDCOPRocessor = strParam]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If g_bUseDCOPRocessor then]]>
<![CDATA[
]]>
<![CDATA[        On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If Not IsAlive(goDCOProcessor) Then ]]>
<![CDATA[
]]>
<![CDATA[	          Set goDCOProcessor = CreateObject("Datacap.DCOProcessor")]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If g_lOutOfProcessTimeout = 0 Then]]>
<![CDATA[
]]>
<![CDATA[                goDCOProcessor.RunTimeout = g_lDefaultOutOfProcessTimeout 'default to 185 seconds minutes]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[                goDCOProcessor.RunTimeout = g_lOutOfProcessTimeout]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.StartTimeout = g_DCOProcessorStartTimeout]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.NewObjectTimeout =  g_DCOProcessorNewObjectTimeout]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.FinalizersTimeout = g_DCOProcessorFinalizersTimeout]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[            If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[                Writelog "DCOProcessor could not be initialized: " & Err.Description]]>
<![CDATA[
]]>
<![CDATA[                g_bUseDCOPRocessor = False]]>
<![CDATA[
]]>
<![CDATA[                Err.Clear]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[                Writelog "DCOProcessor has been initialized."]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        If IsALive(goDCOProcessor) Then]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[            Writelog "Unloading DCOProcessor..."]]>
<![CDATA[
]]>
<![CDATA[            On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If (CurrentObj.Variable("r_procedTimeout") <> "") AND IsNumeric(CurrentObj.Variable("r_procedTimeout")) Then]]>
<![CDATA[
]]>
<![CDATA[                g_iDCOProcessorProceduresTimeout = CInt(CurrentObj.Variable("r_procedTimeout"))]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.StartTimeout = g_iDCOProcessorProceduresTimeout]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.NewObjectTimeout = g_iDCOProcessorProceduresTimeout]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.RunTimeout = g_iDCOProcessorProceduresTimeout]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.FinalizersTimeout = g_iDCOProcessorProceduresTimeout]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.FullStop]]>
<![CDATA[
]]>
<![CDATA[            Set goDCOProcessor = Nothing]]>
<![CDATA[
]]>
<![CDATA[            If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[                Err.Clear]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[            Writelog "DCOProcessor unloaded."]]>
<![CDATA[
]]>
<![CDATA[         End If]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Updated DCOProcessor state: " & g_bUseDCOPRocessor]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	UseOutOfProcessRecog=true]]>
<![CDATA[
]]>
<![CDATA[ ]]>
		</g>
	</af>
</rrx><rrx namespace="autodoc" src="c:\datacap\RRS\autodoc.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<g>
</g>
<af name="FindFingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['Attempts to match the current page to a fingerprint and creates a new fingerprint if a match does not occur."]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Two comma-separated values (the second is optional):<br/>]]>
<![CDATA[
]]>
<![CDATA['	<b>1.</b>A <b>True</b> / <b>False</b> value:<br/> ]]>
<![CDATA[
]]>
<![CDATA['     <b>True</b> if a task is to create a new fingerprint and add it to the fingerprint directory when ]]>
<![CDATA[
]]>
<![CDATA['     a match does not occur; <br/>]]>
<![CDATA[
]]>
<![CDATA['     <b>False</b> if the task is to proceed without creating a new fingerprint.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['	<b>2.</b>Optional:<br/>  The Page Type that is to be assigned to the newly-created fingerprint.  If ]]>
<![CDATA[
]]>
<![CDATA['     omitted, the current Page Type of the current page will be used.</ap>]]>
<![CDATA[
]]>
<![CDATA['	Page level only.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Autodoc " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("FindFingerprint skipping. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam, ",", -1, 1) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) > 1) Then WriteLog("FindFingerprint: Parameter is invalid.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	strPageType = CurrentObj.Type]]>
<![CDATA[
]]>
<![CDATA[	strFingerprintCreation = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) = 1) Then strPageType = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bFingerprintCreation = False]]>
<![CDATA[
]]>
<![CDATA[	If (LCase(strFingerprintCreation)="false") Then oFingerprint.m_bFingerprintCreation = False]]>
<![CDATA[
]]>
<![CDATA[	If (LCase(strFingerprintCreation)="true") Then oFingerprint.m_bFingerprintCreation = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- FindFingerprint of: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim strCCOFile]]>
<![CDATA[
]]>
<![CDATA[	strCCOFile = Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-3)&"cco"]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(strCCOFile)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("FindFingerprint skipping. CCO file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = CCOCreator.Load(strCCOFile )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.UpdateSearchArea]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bBlackFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.Process oCCO, CurrentObj, oFingerprint.m_ProblemValue, strPageType]]>
<![CDATA[
]]>
<![CDATA[	If oFingerprint.m_bFailRule = True Then]]>
<![CDATA[
]]>
<![CDATA[		FindFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		FindFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("FindFingerprint returns " & FindFingerprint) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CreateFingerprint" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[' Creates a fingerprint for the current source page. The resulting fingerprint will]]>
<![CDATA[
]]>
<![CDATA[' consist of two files: the page's Image file (.tif) and its Processing file (.cco)."]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CreateFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("CreateFingerprint skipping. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- CreateFingerprint for: "& CurrentObj.ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	retn = oFingerprint.AddNewFingerprint(CurrentObj, CurrentObj.Type)]]>
<![CDATA[
]]>
<![CDATA[	If retn = False Then]]>
<![CDATA[
]]>
<![CDATA[		CreateFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CreateFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("CreateFingerprint returns " & CreateFingerprint) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteFingerprint" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  'Deletes the Image file (.tif) and Processing file (.cco) of the current page's fingerprint from ]]>
<![CDATA[
]]>
<![CDATA[  'the application's fingerprint directory, and its record from the Rules database.]]>
<![CDATA[
]]>
<![CDATA[  'A SetFingerprintDir action must precede this action."]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  DeleteFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("DeleteFingerprint invalid. This Action should be used on Page level Objects only")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("DeleteFingerprint invalid. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- DeleteFingerprint for: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	retn = oFingerprint.DeleteFingerprint(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	If retn <> True Then]]>
<![CDATA[
]]>
<![CDATA[		'DeleteFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("DeleteFingerprint failed, returning True")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		'DeleteFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("DeleteFingerprint Action successful")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['Sets a newly created fingerprint's Fingerprint Class and Fingerprint Class ID values. "]]>
<![CDATA[
]]>
<![CDATA['    A two-part, comma-separated value consisting of:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['	  <b>1.</b>The Fingerprint Class value.  Smart parameters are supported.  Alternatively, the name of the Field on this page that specifies the Fingerprint Class.<br/>]]>
<![CDATA[
]]>
<![CDATA['	  <b>2.</b>(optional) The Fingerprint ID value. Smart parameters are supported. Alternatively, the name of the Field on this page that specifies the Fingerprint ID.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'StrParam is a CSV Value:]]>
<![CDATA[
]]>
<![CDATA[	' (0) is the HostNameField]]>
<![CDATA[
]]>
<![CDATA[	' (1) is the optional HostIDField]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam, sHostName, sHostRefID, sTmp]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam, ",", 2, 1) ]]>
<![CDATA[
]]>
<![CDATA[	sHostName = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(aStrParam) = 1 Then sHostRefID = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	sTmp = MetaWord(sHostRefID)]]>
<![CDATA[
]]>
<![CDATA[	If (sTmp = "") Then	'Field Value]]>
<![CDATA[
]]>
<![CDATA[				Set oChild = CurrentObj.FindChild(Right(sHostRefID, Len(sHostRefID)-1))]]>
<![CDATA[
]]>
<![CDATA[				If Not(oChild Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[					sTmp = oChild.Text]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("HostID from field")]]>
<![CDATA[
]]>
<![CDATA[					Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	sHostRefID = sTmp]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sTmp = MetaWord(sHostName)]]>
<![CDATA[
]]>
<![CDATA[	If (sTmp = "") Then	'Field Value]]>
<![CDATA[
]]>
<![CDATA[				Set oChild = CurrentObj.FindChild(Right(sHostName, Len(sHostName)-1))]]>
<![CDATA[
]]>
<![CDATA[				If Not(oChild Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("Hostname from field")]]>
<![CDATA[
]]>
<![CDATA[					sTmp = oChild.Text]]>
<![CDATA[
]]>
<![CDATA[					Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	sHostName = sTmp]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (sHostName = "" And sHostRefID = "") Then WriteLog("Host Name and Host ID are Empty.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	sHostName = Replace(sHostName, "'", "''" )]]>
<![CDATA[
]]>
<![CDATA[	sHostRefID = Replace(sHostRefID, "'", "''" )]]>
<![CDATA[
]]>
<![CDATA[	if err.number <> 0 then Writelog("Setfingerprint err " & err.description)]]>
<![CDATA[
]]>
<![CDATA[	err.clear]]>
<![CDATA[
]]>
<![CDATA[	on error goto 0]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprint = oFingerprint.SetFingerprint(sHostName, sHostRefID, CurrentObj) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetProblemValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['Uses the decimal value you supply as a parameter to set a minimum Matching Tolerance Rating."]]>
<![CDATA[
]]>
<![CDATA['A decimal value from 0.00 (Lowest Tolerance) to 0.99 (Highest Tolerance).</ap>]]>
<![CDATA[
]]>
<![CDATA['	<lvl>All, but generally at the Page level.</lvl>]]>
<![CDATA[
]]>
<![CDATA[	Dim slocale]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetProblemValue = False]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'filter and add leading zero]]>
<![CDATA[
]]>
<![CDATA[  strparam=trim(strparam)  ]]>
<![CDATA[
]]>
<![CDATA[	if len(strparam)<=2 then strparam = "0" & strparam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'normalize number]]>
<![CDATA[
]]>
<![CDATA[  slocale = currentobj.variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  StrParam=DCGlobalCurrency.NormalizeNumber(strparam,slocale)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If StrParam = "" Or Not IsNumeric(StrParam) Then WriteLog("SetProblemValue: Parameter isn't a numeric"): Exit Function]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_ProblemValue = Cdbl(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	SetProblemValue = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="SetFingerprintSearchArea" access="public">
	<p name="matchStart">
	</p>
	<p name="matchEnd">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Controls the portion of the current page that will be used to find a matching fingerprint."]]>
<![CDATA[
]]>
<![CDATA[  '  Two parameters:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    <b>1.</b> A decimal value from 0.01 (1%) to 1.00 (all) to indicate how much of the page is to be matched.  If only]]>
<![CDATA[
]]>
<![CDATA['    one parameter is used, the range for fingerprint matching will be 0 to x, where x is the parameter.]]>
<![CDATA[
]]>
<![CDATA['    For example, 0.5 indicates that fingerprint matching will be limited to the first half of the page (0 to 50%).]]>
<![CDATA[
]]>
<![CDATA['    <br/><br/>']]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    <b>2.</b> Optional: A decimal value from 0.01 (1%) to 1.0 (all) to indicate the end point on the page to be]]>
<![CDATA[
]]>
<![CDATA['    used for fingerprint matching.  For example: if the first parameter is 0.6, and the second parameter is 1.0,]]>
<![CDATA[
]]>
<![CDATA['    the last 40% of the page will be used for fingerprint matching (60-100%).<br/>]]>
<![CDATA[
]]>
<![CDATA['    <br/>]]>
<![CDATA[
]]>
<![CDATA['    <b><i>Note.</i></b> In both cases, you can replace a decimal value with a percentage or metric measurement.]]>
<![CDATA[
]]>
<![CDATA['    To indicate the value is a "Percentage" the action can use a number followed by "p" - 50p, for example - to represent 50%.<br/>]]>
<![CDATA[
]]>
<![CDATA['    Alternatively, a value can be expressed in millimeters, if the number is immediately followed by a lower]]>
<![CDATA[
]]>
<![CDATA['    case "m": 20m, for example.<br/>]]>
<![CDATA[
]]>
<![CDATA['    When using the percentage or metric values, the number must be a whole number, ]]>
<![CDATA[
]]>
<![CDATA['    and cannot contain a decimal point.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' SetSearchArea was replaced by SetFingerprintSearchArea so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[  Dim strTop]]>
<![CDATA[
]]>
<![CDATA[  Dim strBottom]]>
<![CDATA[
]]>
<![CDATA[  Dim slocale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintSearchArea = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  matchStart = Trim(matchStart)]]>
<![CDATA[
]]>
<![CDATA[  matchEnd = Trim(matchEnd)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If ( Len(matchStart) = 0 ) Then ]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetFingerprintSearchArea: Parameter matchStart must be specified."):]]>
<![CDATA[
]]>
<![CDATA[    Exit Function		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if (Len(matchEnd) = 0) then]]>
<![CDATA[
]]>
<![CDATA[    ' Only one parameter was passed in.  Use it as the amount to match starting from the top.]]>
<![CDATA[
]]>
<![CDATA[    strTop = 0]]>
<![CDATA[
]]>
<![CDATA[    strBottom = matchStart]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[    ' Two parameters were passed.  Use them as start and end.]]>
<![CDATA[
]]>
<![CDATA[    strTop = matchStart ]]>
<![CDATA[
]]>
<![CDATA[    strBottom = matchEnd  ]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'look for percentage or millimeter flags]]>
<![CDATA[
]]>
<![CDATA[  strTop=SetFingerprintSearchArea_utility(strTop)]]>
<![CDATA[
]]>
<![CDATA[  strBottom=SetFingerprintSearchArea_utility(strBottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'normalize number - pass as string]]>
<![CDATA[
]]>
<![CDATA[  slocale = currentobj.variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  strTop=DCGlobalCurrency.NormalizeNumber(strTop,slocale)]]>
<![CDATA[
]]>
<![CDATA[  strBottom=DCGlobalCurrency.NormalizeNumber(strBottom,slocale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Convert string to double]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_SearchAreaTop = Cdbl(strTop)]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_SearchAreaBottom = Cdbl(strBottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("SetFingerprintSearchArea: Top: '" & cstr(oFingerprint.m_SearchAreaTop) & "' Bottom: '" & cstr(oFingerprint.m_SearchAreaBottom) & "'.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	m_SearchArea = 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintSearchArea = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<af name="SetSearchArea" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ ' This action has been replaced by SetFingerprintSearchArea."]]>
<![CDATA[
]]>
<![CDATA[ '    Two comma-separated parameters.  See SetFingerprintSearchArea for details.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[  Dim result]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  SetSearchArea = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam, ",", -1, 1) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) > 1) Then WriteLog("SetSearchArea: Parameter is invalid.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	strTop = 0]]>
<![CDATA[
]]>
<![CDATA[	strBottom = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) = 1) Then strTop = Trim(aStrParam(0)) : strBottom = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Call the function that has replaced SetSearchArea]]>
<![CDATA[
]]>
<![CDATA[  SetSearchArea = SetFingerprintSearchArea(strTop, strBottom)    ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFingerprintDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[' Sets the Fingerprint directory of your application."]]>
<![CDATA[
]]>
<![CDATA['    A String value specifying the directory's name and its path.  Smart parameters are supported.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter(1) parsing. Using original parameter '" & StrParam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Right(StrParam,1) <> "\" Then StrParam = StrParam & "\"]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.SetFingerprintDir StrParam]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintDir = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindBlackFingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[' Attempts to match black forms to fingerprints in the fingerprints directory of an application.]]>
<![CDATA[
]]>
<![CDATA[' If a match does not occur, the action will respond according to the parameter(s) you enter."]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['      Two comma-separated values (the second is optional)<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['      <b>1. True or False.</b><br/>]]>
<![CDATA[
]]>
<![CDATA['         <b>True</b> If a fingerprint match is not found, a new fingerprint is created and the two fingerprint files ]]>
<![CDATA[
]]>
<![CDATA['         (.tif and .cco) are placed in the fingerprint directory.<br/>]]>
<![CDATA[
]]>
<![CDATA['         <b>False</b> if the task is to proceed without creating a new fingerprint.<br/>]]>
<![CDATA[
]]>
<![CDATA['         <br/>    ]]>
<![CDATA[
]]>
<![CDATA['      <b>2. Optional.</b> <br/>]]>
<![CDATA[
]]>
<![CDATA['         The Page Type that is to be assigned to the newly created fingerprint if the first parameter ]]>
<![CDATA[
]]>
<![CDATA['         is <b>True.</b>  If you do not include this parameter, the action will assign the Page ]]>
<![CDATA[
]]>
<![CDATA['         Type of the current page.]]>
<![CDATA[
]]>
<![CDATA['    </ap>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindBlackFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("FindBlackFingerprint skipping. " & CurrentObj.ImageName & " doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam, ",", -1, 1) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) > 1) Then WriteLog("FindFingerprint: Parameter is invalid.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	strPageType = CurrentObj.Type]]>
<![CDATA[
]]>
<![CDATA[	strFingerprintCreation = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) = 1) Then strPageType = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bFingerprintCreation = False]]>
<![CDATA[
]]>
<![CDATA[	If (LCase(strFingerprintCreation)="false") Then oFingerprint.m_bFingerprintCreation = False]]>
<![CDATA[
]]>
<![CDATA[	If (LCase(strFingerprintCreation)="true") Then oFingerprint.m_bFingerprintCreation = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- FindBlackFingerprint of: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim strCCOFile]]>
<![CDATA[
]]>
<![CDATA[	strCCOFile = Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-3)&"cco"]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(strCCOFile)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("FindBlackFingerprint skipping. CCO file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = CCOCreator.Load(strCCOFile )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.UpdateSearchArea]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bBlackFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.Process oCCO, CurrentObj, oFingerprint.m_ProblemValue, strPageType]]>
<![CDATA[
]]>
<![CDATA[	If oFingerprint.m_bFailRule = True Then]]>
<![CDATA[
]]>
<![CDATA[		FindBlackFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		FindBlackFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("FindBlackFingerprint returns " & FindBlackFingerprint) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFilter_PageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['Sets the Page Type filter for the identification (matching) algorithm.  The filter will force the]]>
<![CDATA[
]]>
<![CDATA[' fingerprint-matching algorithm to use only fingerprints associated with that Page Type.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['The String value of the Page Type you want to use as the filter.</ap>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetFilter_PageType = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("No result from Smart Parameter parsing. Using original parameter.") 	]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- SetFilter_PageType: " & StrParam & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.SetFilterID(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	SetFilter_PageType = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFilter_HostName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['Sets the Fingerprint Class filter for the identification (matching) algorithm.  The filter will force ]]>
<![CDATA[
]]>
<![CDATA['the fingerprint-matching algorithm to use only fingerprints associated with the specified Fingerprint Class."]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['The String value of the Fingerprint Class you want to use as the filter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFilter_HostName = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("No result from Smart Parameter parsing. Using original parameter.") 	]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- SetFilter_HostName: " & StrParam & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.SetFilterHostName(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	SetFilter_HostName = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetMaxOffset" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[' Sets the Maximum Offset value while matching source pages to fingerprints. The actual shift is four times the maximum offset value in pixels (4 * MaxOffset)."]]>
<![CDATA[
]]>
<![CDATA[' Integer value between 1 and 255.</ap>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetMaxOffset = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If ( Not IsNumeric(StrParam) ) Then WriteLog("MaxOffset: Parameter must be integer between 1 and 255.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	MaxOffset = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If ( MaxOffset < 1 Or MaxOffset > 255 ) Then WriteLog("MaxOffset: Parameter must be integer between 1 and 255.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_oCCOFingerprints.MaxShift = MaxOffset]]>
<![CDATA[
]]>
<![CDATA[	SetMaxOffset = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetTemplateDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'qi="Sets the Template directory of your application. This directory contains the application's fingerprint templates."]]>
<![CDATA[
]]>
<![CDATA[    '  <i>String</i> value specifying the directory's name and path. <br/><br/>]]>
<![CDATA[
]]>
<![CDATA[    '  <b>Note:</b>A Drive ID (such as c:\) is optional. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("No result from Smart Parameter parsing. Using original parameter.") 	]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetTemplateDir = SetFingerprintDir(bInter, bDeBug, StrParam) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFingerprintWebServiceURL" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['"Provides the Uniform Resource Locator (URL) that is a link to a pre-established Fingerprint Service."<ap>]]>
<![CDATA[
]]>
<![CDATA[' <i>String</i> value specifying the URL that is the link to the Fingerprint Web Service.  Accepts a Smart Parameter.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintWebServiceURL = False]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Set oFingerprint.m_oCCO_WSClient = CreateObject("CCO_WSClient.Interface")]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_oCCO_WSClient.SetURL StrParam]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	if (Pilot.GetProfileString("Fingerprints","UseAppID","0",Pilot.ProjectPath) = "1" or DCO.Variable("FPAPPID") = "1")  then]]>
<![CDATA[
]]>
<![CDATA[		On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		oFingerprint.m_oCCO_WSClient.SetApplicationID(oFingerprint.m_AppID)]]>
<![CDATA[
]]>
<![CDATA[		Err.Clear]]>
<![CDATA[
]]>
<![CDATA[		On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bCCO_WS = True]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_oCCO_WSClient.SetFilterID(-1)]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintWebServiceURL = True	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindTemplate" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['Finds the fingerprint that a preceding FindFingerprint action matched to the current source page, or created instead."]]>
<![CDATA[
]]>
<![CDATA['  <i>String</i> boolean value:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['  <b>True</b> if the action is to create a new fingerprint if the current <b>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindTemplate = FindFingerprint(bInter, bDeBug, StrParam) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CalculateOffset" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['"Sets the standard Offset value to be used when matching source pages to fingerprints."]]>
<![CDATA[
]]>
<![CDATA[' Integer value between 1 and 255.</i>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CalculateOffset = False]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("CalculateOffset: this action works on a page level only.") : Exit Function 'must be a page]]>
<![CDATA[
]]>
<![CDATA[	CalculateOffset = oFingerprint.CalculateOffset(CurrentObj)]]>
<![CDATA[
]]>
	</g>
</af>
<af name="MergeCCOs_ByType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[' "Merges the Fingerprint files (.cco) associated with Page objects of the Document Hierarchy."]]>
<![CDATA[
]]>
<![CDATA['  Comma-separated String values indicating the Page Types of the Document Hierarchy objects to be merged.</ap>]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	Dim sMultFile]]>
<![CDATA[
]]>
<![CDATA[	Dim nDCOchildren, i, j]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild, nCount]]>
<![CDATA[
]]>
<![CDATA[	Dim oPrimaryPg]]>
<![CDATA[
]]>
<![CDATA[	Dim sPPD]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileExtn]]>
<![CDATA[
]]>
<![CDATA[	Dim sFilePath]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileName]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim pCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim dcImageTemp,Wx,Hx,Bx]]>
<![CDATA[
]]>
<![CDATA[	Dim nCounter ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	Set dcImageTemp = CreateObject("DCIMAGE.DCImageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'This Action should run from the DCO Page to which all additional pages are to be appended.]]>
<![CDATA[
]]>
<![CDATA[	'Will use first page of specified type as root page if called from document object.]]>
<![CDATA[
]]>
<![CDATA[	'Appended Page will be first page of a valid Type in document by default. ]]>
<![CDATA[
]]>
<![CDATA[	'StrParam is a CSV of all the valid PageTypes to Append.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    MergeCCOs_ByType = False]]>
<![CDATA[
]]>
<![CDATA[    sMultFile=""]]>
<![CDATA[
]]>
<![CDATA[	nCounter=CInt(0)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Find Parent Document     ]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Currentobj]]>
<![CDATA[
]]>
<![CDATA[	If oParent.ObjectType>1 Then ]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    For i = 1 To oParent.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[        Set oChild = CurrentObj.GetChild(i - 1)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If Not(oChild Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[			If oChild.ObjectType = 2 And InStr(Ucase(StrParam),Ucase(oChild.Type))>0 Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog ("Processing '" & oChild.ID & "' ")]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[				'Create MultiCCO file]]>
<![CDATA[
]]>
<![CDATA[                If sMultFile = "" Then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[                    sOrigFile = oChild.ImageName]]>
<![CDATA[
]]>
<![CDATA[                    sFileExtn = Ucase(FileMgr.GetExtensionName(sOrigFile))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[                    If (sFileExtn = "TIF" Or sFileExtn = "TIFF") And FileMgr.FileExists(sOrigFile) Then]]>
<![CDATA[
]]>
<![CDATA[                    	'Log the image height]]>
<![CDATA[
]]>
<![CDATA[                    	sFilePath = FileMgr.GetParentFolderName(sOrigFile)]]>
<![CDATA[
]]>
<![CDATA[						dcImageTemp.FileName = sOrigfile]]>
<![CDATA[
]]>
<![CDATA[						Call dcImageTemp.GetImageInfo(Wx,Hx,Bx)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Image " & sOrigFile & " Height:" & Hx)]]>
<![CDATA[
]]>
<![CDATA[						dcImageTemp.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						'Set CCO filename to 1st Page ID											]]>
<![CDATA[
]]>
<![CDATA[						sMultFile = Left(sOrigFile,Len(sOrigFile)-Len(sFileExtn)) & "CCO"]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						If Not FileMgr.FileExists(sMultFile) Then		]]>
<![CDATA[
]]>
<![CDATA[							WriteLog("----- Analysis of: " & sOrigFile & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							Set oCCO = CCOCreator.Analyze(sOrigFile)]]>
<![CDATA[
]]>
<![CDATA[							bSaved = oCCO.Save(sMultFile)]]>
<![CDATA[
]]>
<![CDATA[							If bSaved=False Then ]]>
<![CDATA[
]]>
<![CDATA[								Writelog("ERROR saving File. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[								Exit Function]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[							Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						'Setup Primary Page Ref]]>
<![CDATA[
]]>
<![CDATA[						Set oPrimaryPg = oChild]]>
<![CDATA[
]]>
<![CDATA[						pCounter = 1]]>
<![CDATA[
]]>
<![CDATA[						oPrimaryPg.Variable("CCOBlock")=Trim(sMultFile)		]]>
<![CDATA[
]]>
<![CDATA[						oPrimaryPg.Variable(Trim(FileMgr.GetFileName(sMultFile)) & "_" & CStr(pCounter))=FileMgr.GetFileName(oChild.ImageName)]]>
<![CDATA[
]]>
<![CDATA[						oPrimaryPg.Variable(Ucase(FileMgr.GetFileName(oChild.ImageName)))=nCounter]]>
<![CDATA[
]]>
<![CDATA[						nCounter=CInt(Hx)]]>
<![CDATA[
]]>
<![CDATA[																			]]>
<![CDATA[
]]>
<![CDATA[						WriteLog ("MultiPage CCO file name : '" & sMultFile & "' ")]]>
<![CDATA[
]]>
<![CDATA[												]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Unexpected File Name Extension: '" & sFileExtn & "' ")]]>
<![CDATA[
]]>
<![CDATA[                    End If]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[					sAppendFile = oChild.ImageName]]>
<![CDATA[
]]>
<![CDATA[         			sExt = Ucase(FileMgr.GetExtensionName(sAppendFile))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[                    If (sExt = "TIF" Or sExt = "TIFF") Then]]>
<![CDATA[
]]>
<![CDATA[                    	'Log the image height					]]>
<![CDATA[
]]>
<![CDATA[                    	dcImageTemp.FileName = sAppendFile]]>
<![CDATA[
]]>
<![CDATA[						Call dcImageTemp.GetImageInfo(Wx,Hx,Bx)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Image " & sAppendFile & " Height:" & Hx)]]>
<![CDATA[
]]>
<![CDATA[						dcImageTemp.FileName = ""					]]>
<![CDATA[
]]>
<![CDATA[                    						                    						]]>
<![CDATA[
]]>
<![CDATA[						sAppendCCO = Left(sAppendFile,Len(sAppendFile)-Len(sExt)) & "CCO"]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						If Not FileMgr.FileExists(sAppendCCO) Then		]]>
<![CDATA[
]]>
<![CDATA[							WriteLog("----- Analysis of: " & sAppendFile & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							Set oCCO = CCOCreator.Analyze(sAppendFile)]]>
<![CDATA[
]]>
<![CDATA[							bSaved = oCCO.Save(sAppendCCO)]]>
<![CDATA[
]]>
<![CDATA[							If bSaved=False Then ]]>
<![CDATA[
]]>
<![CDATA[								Writelog("ERROR saving File. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[								Exit Function]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[							Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						bRes=CCOCreator.Merge(sMultFile, sAppendCCO)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Merging CCO : '" & sAppendCCO & "' to the end of '" & sMultFile & "' returns " & bRes)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						If bRes = False Then ]]>
<![CDATA[
]]>
<![CDATA[							If Not FileMgr.FileExists(sMultFile) Then Writelog("File Not Found:" & sMultFile)]]>
<![CDATA[
]]>
<![CDATA[							If Not FileMgr.FileExists(sAppendCCO) Then Writelog("File Not Found:" & sAppendCCO)]]>
<![CDATA[
]]>
<![CDATA[							Exit Function]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							pCounter = pCounter + 1		]]>
<![CDATA[
]]>
<![CDATA[							oPrimaryPg.Variable(Trim(FileMgr.GetFileName(sMultFile)) & "_" & CStr(pCounter))=FileMgr.GetFileName(oChild.ImageName)	]]>
<![CDATA[
]]>
<![CDATA[							oPrimaryPg.Variable(Ucase(FileMgr.GetFileName(oChild.ImageName)))=nCounter]]>
<![CDATA[
]]>
<![CDATA[							nCounter = nCounter + CInt(Hx)		]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[                        'oChild.Type = "Attachment"]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Unexpected File Name Extension: '" & sExt & "' ")    ]]>
<![CDATA[
]]>
<![CDATA[                    End If]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[     Next 'i]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[     Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[     Set oPrimaryPg = Nothing]]>
<![CDATA[
]]>
<![CDATA[     Set dcImageTemp = Nothing]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[	If Not Err Then MergeCCOs_ByType = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="BlankPagesIDBySize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    "Uses the Image file's size to determine if the file represents a 'blank' page."]]>
<![CDATA[
]]>
<![CDATA['    A three-part, comma-separated value consisting of:<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>1.</b> Numeric value indicating the maximum size in bytes that qualifies a page as a blank page.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>2.</b> String value representing the Page Type of a blank page.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>3.</b>Numeric value (0, 1 or 2) to designate which pages in a multi-page Image file are to be evaluated.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <br/>]]>
<![CDATA[
]]>
<![CDATA['    The third parameter is optional.<br/>]]>
<![CDATA[
]]>
<![CDATA['    0 = both sides of a two-page Image file.<br/>]]>
<![CDATA[
]]>
<![CDATA['    1 = odd pages only.<br/>]]>
<![CDATA[
]]>
<![CDATA['    2 = even images only.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim iMinSize]]>
<![CDATA[
]]>
<![CDATA[	Dim sPageType]]>
<![CDATA[
]]>
<![CDATA[	Dim iSide]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	BlankPagesIDBySize = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	iMinSize = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sPageType = CStr(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	iSide = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(iMinSize) Then ]]>
<![CDATA[
]]>
<![CDATA[		iMinSize = CInt(iMinSize)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Minimum size paramater must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(sPageType)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("sPageType paramater must contain a value.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(iSide)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[		iSide = CInt(0)]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(iSide) Then ]]>
<![CDATA[
]]>
<![CDATA[		iSide = CInt(iSide)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("iSide paramater must be numeric {0,1,2} or blank.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	BlankPagesIDBySize = BlankPageID(CurrentObj, iMinsize, sPageType, iSide)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetApplicationID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   String parameter that represents unique Application ID.  Smart parameters are supported.<br/>]]>
<![CDATA[
]]>
<![CDATA[ '   This value used to retrieve correct list of fingerprints loaded to the server.<br/>]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter(1) parsing. Using original parameter '" & StrParam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (oFingerprint.m_bCCO_WS) Then]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_AppID = StrParam]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_oCCO_WSClient.SetApplicationID(oFingerprint.m_AppID)]]>
<![CDATA[
]]>
<![CDATA[	Err.Clear]]>
<![CDATA[
]]>
<![CDATA[	On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[	SetApplicationID = false]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFingerprintFailureThreshold" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Int parameter that represents percent threshold of fingerprint upload failures to ignore.  Smart parameters are supported.<br/>]]>
<![CDATA[
]]>
<![CDATA[  '  The batch aborts if the percentage of fingerprints that are failed to load exceeds this value.<br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  Dim m_nThreshold]]>
<![CDATA[
]]>
<![CDATA[  SetFingerpirntFailureThreshold = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("No result from Smart Parameter(1) parsing. Using original parameter '" & StrParam & "'") 	]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If ((Cint(StrParam)<0) OR (Cint(StrParam)>100)) Then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Error. Value has to be between values 0 and 100 original parameter value:'" & StrParam & "' . Aborting batch") ]]>
<![CDATA[
]]>
<![CDATA[     nTaskStatus=retAbort     ]]>
<![CDATA[
]]>
<![CDATA[     SetFingerpirntFailureThreshold = false]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (oFingerprint.m_bCCO_WS) Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    m_nThreshold  = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    DIM xml]]>
<![CDATA[
]]>
<![CDATA[    Dim oXmlDoc, oNodeList, name]]>
<![CDATA[
]]>
<![CDATA[    Dim oLoaded, oFailed]]>
<![CDATA[
]]>
<![CDATA[    Dim Loaded, Failed]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    xml = oFingerprint.m_oCCO_WSClient.GetFingerprintStatistics]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Set oXmlDoc = CreateObject("Msxml2.DOMDocument")]]>
<![CDATA[
]]>
<![CDATA[    oXmlDoc.loadXML(xml)                               ]]>
<![CDATA[
]]>
<![CDATA[    Set oNodeList = oXmlDoc.getElementsByTagName("application")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    If oNodeList.length > 0 then]]>
<![CDATA[
]]>
<![CDATA[      For each x in oNodeList]]>
<![CDATA[
]]>
<![CDATA[        name=x.getAttribute("name")]]>
<![CDATA[
]]>
<![CDATA[        if (name=oFingerprint.m_AppID)Then]]>
<![CDATA[
]]>
<![CDATA[          set oLoaded = x.selectSingleNode("//fploaded")]]>
<![CDATA[
]]>
<![CDATA[          set oFailed = x.selectSingleNode("//fpfailed")]]>
<![CDATA[
]]>
<![CDATA[          Loaded = CInt(oLoaded.text)]]>
<![CDATA[
]]>
<![CDATA[          Failed = CInt(oFailed.text)				]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[      Next]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog ("No fingerprints selected to load. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    if((Loaded+Failed)>0) Then]]>
<![CDATA[
]]>
<![CDATA[      if (Loaded<1) Then]]>
<![CDATA[
]]>
<![CDATA[        nTaskStatus=retAbort]]>
<![CDATA[
]]>
<![CDATA[        SetFingerpirntFailureThreshold = false	]]>
<![CDATA[
]]>
<![CDATA[        Writelog ("Aborting the batch. None of the fingerprints loaded successfully. Failed to load: '"&Failed&"' fingerprints. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        Dim percent]]>
<![CDATA[
]]>
<![CDATA[        percent = (Failed*100/(Loaded+Failed))]]>
<![CDATA[
]]>
<![CDATA[        If (percent>m_nThreshold) Then]]>
<![CDATA[
]]>
<![CDATA[          nTaskStatus=retAbort]]>
<![CDATA[
]]>
<![CDATA[          SetFingerpirntFailureThreshold = false	                                ]]>
<![CDATA[
]]>
<![CDATA[          Writelog ("Aborting the batch. Threshold is set to:'" & m_nThreshold &"%' and '"&percent&"%' of fingerprints failed to load. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog ("Using fingerprint service, but no Fingerprints are loaded or failed. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Else]]>
<![CDATA[
]]>
<![CDATA[   Writelog ("Fingerprints service is not used. Input value ignored. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[   SetFingerpirntFailureThreshold = false]]>
<![CDATA[
]]>
<![CDATA[ End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="UpdateFingerprintStats" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim oCmd]]>
<![CDATA[
]]>
<![CDATA[	Dim oParam1]]>
<![CDATA[
]]>
<![CDATA[	Dim oParam2]]>
<![CDATA[
]]>
<![CDATA[	Dim DateHit]]>
<![CDATA[
]]>
<![CDATA[	Dim oRS]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	UpdateFingerprintStats = false]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['	ON ERROR RESUME NEXT]]>
<![CDATA[
]]>
<![CDATA[	 If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	if oFingerprint.m_oAdoCnn.State = 0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Connection to the rules/fingerprint database was not found.Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if CurrentObj.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("This action was designed to operate on a page level object only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCmd = CreateObject("ADODB.Command")]]>
<![CDATA[
]]>
<![CDATA[	Set oParam1 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[	Set oParam2 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	sSQL = "UPDATE Template SET tp_HitCount = tp_HitCOunt + 1, tp_LastHit = ? WHERE tp_TemplateID = ?"]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	oCmd.CommandText = sSQL]]>
<![CDATA[
]]>
<![CDATA[	oCmd.CommandType = 1]]>
<![CDATA[
]]>
<![CDATA[	oCmd.ActiveConnection = oConn]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Connection set")]]>
<![CDATA[
]]>
<![CDATA[	oCmd.Parameters.Append oParam1]]>
<![CDATA[
]]>
<![CDATA[	oCmd.Parameters.Append oParam2]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Parameters set")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("TemplateID = " & CurrentObj.Variable("TemplateID"))]]>
<![CDATA[
]]>
<![CDATA[	oCmd(0).Value = Date()]]>
<![CDATA[
]]>
<![CDATA[	oCmd(1).Value = CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if oCmd(1).Value = "" then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No TemplateID found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Ready to do oCmd.Execute")]]>
<![CDATA[
]]>
<![CDATA[	oRS = oCmd.Execute]]>
<![CDATA[
]]>
<![CDATA[	Writelog("SQL Executed")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCmd = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oParam1 = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oParam2 = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[	UpdateFingerprintStats = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<help>

 <![CDATA[
'************************************************************************
' AutoDoc.rrx - AutoDoc Actions
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'------------------------------------------------------------------------
'
]]>

<ref id="FindFingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Attempts to match the current page to a fingerprint and creates a new fingerprint if a match does not occur.">
	<ap>Two comma-separated values (the second is optional):<br/>
	<b>1.</b>A <b>True</b> / <b>False</b> value:<br/> 
     <b>True</b> if a task is to create a new fingerprint and add it to the fingerprint directory when 
     a match does not occur; <br/>
     <b>False</b> if the task is to proceed without creating a new fingerprint.<br/><br/>
	<b>2.</b>Optional:<br/>  The Page Type that is to be assigned to the newly-created fingerprint.  If 
     omitted, the current Page Type of the current page will be used.</ap>
	<lvl>Page level only.</lvl>
  
	<h>This action attempts to match the current
    <b><i>source</i></b>page to a fingerprint, and creates a new fingerprint if a match does not occur.<br/><br/>
    Include this action after a rule's SetSearchArea, SetProblemValue and SetFingerprintDir actions.
		<e><scr>AnalyzeImage()</scr><br/>
		<scr>RotateImage()</scr><br/>
		<scr>RecognizePageOCR_S()</scr><br/>
		<scr>SetSearchArea("0.5")</scr><br/>
		<scr>SetProblemValue("0.7")</scr><br/>
		<scr>SetFingerprintDir("\ParentDirectory\Application\Fingerprint")</scr><br/> 
		<scr>
      <b>FindFingerprint("True,Invoice_Page")</b></scr><br/><br/>

		In this sequence, the FindFingerprint action will only use the top 50% of the current page to 
    search for a match.  However, it will accept a match of 0.7 or higher.  If no match is found, 
    the sequence will create a new fingerprint and store it in the location specified by the 
    <scr>SetFingerprintDir</scr> action.  If the parameter has been set to False, a new fingerprint 
    will not be created in case there is no match.
		</e>
	</h>
  <ret>
    <b>False</b> if the action is not applied at the Page level, or if the parameter is False and a
    fingerprint match does not occur. Otherwise, True.  If a new Fingerprint cannot be added, the
    action still returns <b>True.</b>
  </ret>
</ref>

<ref id="CreateFingerprint" access="public" bInter="bInter" bDebug="bDebug" qi="Creates a fingerprint for the current source page. The resulting fingerprint will consist of two files: the page's Image file (.tif) and its Processing file (.cco).">
	<ap>None.</ap>
	<lvl>Page level only.</lvl>
	<ret>
    <b>False</b> if the rule with this action is not bound to a Page object of the Document Hierarchy; 
    if the current page does not have an Image file; or if the fingerprint's two files cannot be created.  
    Otherwise, <b>True.</b>
  </ret>
	<h>Creates a fingerprint for the current source page.<br/><br/>
		
	The resulting fingerprint will consist of two files: the page's Image file (.tif) and its Processing file (.cco).<br/><br/>
		
	<b>Alert!</b> A <scr>SetFingerprintDir</scr> action must precede this action.
		<e>
      <scr>SetFingerprintDir("C:\ParentDirectory\Application\fingerprint")</scr><br/>
      <b>CreateFingerprint()</b>
		</e>
	</h>
	<see><scr>SetFingerprintDir</scr>, <scr>DeleteFingerprint</scr></see>
</ref>

<ref id="DeleteFingerprint" access="public" bInter="bInter" bDebug="bDebug" qi="Deletes the Image file (.tif) and Processing file (.cco) of the current page's fingerprint from the application's fingerprint directory, and its record from the Rules database. A SetFingerprintDir action must precede this action.">
	<ap>None.</ap>
	<lvl>Page level only.</lvl>
	<ret>
    Always returns <b>True.</b> Under certain conditions the action will be unable to delete the fingerprint
    but will still return True. For example if the action is not applied at the Page level or if the 
    fingerprint's Image file cannot be found. Please review the log file if DeleteFingerprint does not perform as expected.
  </ret>
	<h>
    Deletes the Image file (.tif) And Processing file (.cco) of the current page's fingerprint from the 
    application's fingerprint directory, and its record from the Rules database.<br/><br/>
	
	<b>Alert!</b> A <scr>SetFingerprintDir</scr> action must precede this action.
		<e>
      <scr>SetFingerprintDir("C:\ParentDirectory\Application\fingerprint")</scr><br/>
      <b>DeleteFingerprint()</b> 
		</e>
	</h>
	<see><scr>SetFingerprintDir, CreateFingerprint</scr></see>
</ref>

<ref id="SetFingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets a newly created fingerprint's Fingerprint Class and Fingerprint Class ID values. ">
	<ap>
    A two-part, comma-separated value consisting of:<br/><br/>
	  <b>1.</b>The Fingerprint Class value.  Smart parameters are supported.  Alternatively, the name of the Field on this page that specifies the Fingerprint Class.<br/>
	  <b>2.</b>(optional) The Fingerprint ID value. Smart parameters are supported. Alternatively, the name of the Field on this page that specifies the Fingerprint ID.<br/><br/>
	</ap>
	<lvl>Page level only.</lvl>
	<ret><b>False</b> if either parameter is invalid.  Otherwise, <b>True.</b></ret>
	<h>Sets a newly created fingerprint's Fingerprint Class and Fingerprint Class ID values.<br/><br/>

	  After the mandatory Fingerprint Class value and optional Fingerprint Class ID have been manually assigned 
    by a fingerprint creation task, this action places these values into the Host table of the 
    application's Rules database - as RefName and RefID values.
		<e>
      <b>SetFingerprint("@P\VendorName,@P\VendorID")</b><br/><br/>
      
		In this example, runtime values of the VendorName and VendorID Field objects will populate the Host table of the application's Rules Database. 
		Alternative method: SetFingerprint("@VendorName,@VendorID")
		</e>
	</h>
</ref>

<ref id="SetProblemValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Uses the decimal value you supply as a parameter to set a minimum Matching Tolerance Rating.">
	<ap>A decimal value from 0.00 (Lowest Tolerance) to 0.99 (Highest Tolerance). The decimal separator must be appropriate for the locale.</ap>
	<lvl>All, but generally at the Page level.</lvl>
	<ret><b>False</b> if the parameter is missing or the parameter is not numeric. Otherwise, <b>True.</b></ret>
	<h>Uses the decimal value you supply as a parameter to set a minimum Matching Tolerance Rating.<br/><br/>

	<b>Important!</b> A lower rating results in lower tolerance and a greater chance for a match, but also a greater chance for a <b>False</b> match.
		<e><scr>AnalyzeImage()</scr><br/> 
		<scr>CreateFields()</scr><br/>
		<scr>RotateImage()</scr><br/>
		<scr>RecognizePageOCR-S()</scr><br/>
		<scr>SetSearchArea("0.5")</scr><br/>
		<b>SetProblemValue("0.70")</b><br/>
		<scr>SetFingerprintDir("\ParentDirectory\Application\Fingerprint")</scr><br/>
		<scr>FindFingerprint("True")</scr><br/><br/>

		In this sequence, the <scr>FindFingerprint</scr> action assigns a Matching Tolerance Rating that is neither overly restrictive nor unrealistically accepting.<br/><br/>

		If the rule's conditions do not result in a match, and <b>True</b> is used as the parameter for the <scr>FindFingerprint</scr> action, a new fingerprint will be added to the library. 
		</e>
	</h>
</ref>


<ref id="SetFingerprintSearchArea" access="public" qi="Controls the portion of the current page that will be used to find a matching fingerprint.">
  <p name="matchStart"/>
  <p name="matchEnd"/>
  <ap>
    Two parameters:<br/><br/>

    <b>1.</b> A decimal value from 0.01 (1%) to 1.00 (all) to indicate how much of the page is to be matched.
    If the second parameter is empty the first parameter represents the bottom of the area for matching, starting from the top of the page.
    If the second parameter is not empty, the first parameter is the top or start of the area for matching.
    For example, a single parameter of 0.5 indicates that fingerprint matching will be limited to the first half of the page (0 to 50%).
    Decimal separators must be appropriate for the current locale.  In applications which might be used in locales with different decimal separators, use percentage notation.
    <br/><br/>

    <b>2.</b> Optional: A decimal value from 0.01 (1%) to 1.0 (all) to indicate the end point on the page to be
    used for fingerprint matching.  If this parameter is supplied, the fist parameter is the starting point.  
    For example: if the first parameter is 0.6, and the second parameter is 1.0,
    the last 40% of the page will be used for fingerprint matching (60-100%).<br/>
    <br/>
    <b><i>Note.</i></b> In both cases, you can replace a decimal value with a percentage.
    To indicate the value is a "Percentage" the action can use a number followed by "p" - 50p, for example - to represent 50%.<br/>
    When using the percentage values, the number must be a whole number, and cannot contain a decimal separator.<br/>
    Decimal separators must be appropriate for the current locale.  In applications which might be used in locales with different decimal separators, use percentage notation.
  </ap>
  <h>
    This action uses the numeric value(s) you supply to determine the portion of the current page
    that will be used to find a matching fingerprint.
    <e>
      <b>SetFingerprintSearchArea("0.5","")</b><br/><br/>

      The example above compares lines and words in the upper 50% of the current page to the lines and
      words in the same portion of each fingerprint.  Notice the second parameter has been left blank.<br/><br/>

      <b>SetFingerprintSearchArea("0.5","1.0")</b><br/><br/>

      This example compares lines and words in the lower 50% of the current page to the lines and
      words in the same portion of each fingerprint. Remember: you can replace a parameter's decimal
      value with a percentage(p) or metric(m) number.
    </e>
  </h>
  <lvl>All levels, but generally at the Page level.</lvl>
  <ret>
    <b>False</b> if the first parameter is missing or is not numeric. Also returns <b>False</b>
    if the second parameter is not numeric.  Otherwise, <b>True.</b>
  </ret>
  <see>
    <scr>SetProblemValue</scr>
  </see>
</ref>
  
<ref id="SetSearchArea" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="This action has been replaced by SetFingerprintSearchArea.">
  <ap>
    Two comma-separated parameters.  See SetFingerprintSearchArea for details.<br/><br/>
  </ap>
	<h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by SetFingerprintSearchArea.    
  </h>
	<see><scr>SetFingerprintSearchArea</scr></see>
</ref>

<ref id="SetFingerprintDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the Fingerprint directory of your application.">
	<ap>
    A String value specifying the directory's name and its path.  Smart parameters are supported.<br/><br/>

	  <b>Note:</b> A Drive ID (such as C:\) is optional.
  </ap>
	<lvl>All levels, but generally applied at the Page level.</lvl>
	<ret>Always <b>True.</b></ret>
	<h>Sets the Fingerprint directory of your application. This directory contains the application's fingerprints.
		<e><b>SetFingerprintDir("C:\ParentDirectory\Application\Fingerprint")</b><br/><br/>

		The action above identifies the location and path of an application's Fingerprint directory. 
		</e>
	</h>
</ref>


 <ref id="FindBlackFingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Attempts to match black forms to fingerprints in the fingerprints directory of an application. If a match does not occur, the action will respond according to the parameter(s) you enter.">
    <ap>
      Two comma-separated values (the second is optional)<br/><br/>
      <b>1. True or False.</b><br/>
         <b>True</b> If a fingerprint match is not found, a new fingerprint is created and the two fingerprint files 
         (.tif and .cco) are placed in the fingerprint directory.<br/>
         <b>False</b> if the task is to proceed without creating a new fingerprint.<br/>
         <br/>    
      <b>2. Optional.</b> <br/>
         The Page Type that is to be assigned to the newly created fingerprint if the first parameter 
         is <b>True.</b>  If you do not include this parameter, the action will assign the Page 
         Type of the current page.
    </ap>
    <h>
      This action attempts to match black forms to fingerprints in the fingerprints directory of an application.<br/><br/>

      If a match does not occur, the action will respond according to the parameter(s) you enter.
      <e>
        <scr>AnalyzeImage()</scr><br/>
        <scr>SetSearchArea("0.5")</scr><br/>
        <scr>SetProblemValue("0.7")</scr><br/>
        <scr>SetFingerprintDir("ParentDirectory\Application\fingerprint")</scr><br/>
        <b>FindBlackFingerprint("True,PageType")</b><br/><br/>

        In this sequence, the <scr>FindBlackFingerprint</scr> action will only use the top 50% of the fingerprint to search for a match.  
        It will accept a match of 0.7 or higher.<br/><br/>

        If no match is found, the sequence will create a new fingerprint and store it in the location specified by the 
        <scr>SetFingerprintDir</scr> action.<br/><br/>

        If the parameter has been set to False, no fingerprint will be created if a match is not found.
      </e>
    </h>
   <lvl>Page level only.</lvl>
   <ret>
     <b>False</b> if the action is not applied at the Page level or if the first parameter is <b>False</b> and
     a fingerprint match does not occur. Otherwise, <b>True.</b>
   </ret>
</ref>


<ref id="SetFilter_PageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the Page Type filter for the identification (matching) algorithm.  The filter will force the fingerprint-matching algorithm to use only fingerprints associated with that Page Type.">
	<ap>The String value of the Page Type you want to use as the filter.</ap>
	<lvl>All levels, but generally at the Page level.</lvl>
	<ret>Always <b>True.</b></ret>
	<h>Sets the Page Type Filter For the identification (matching) algorithm. Smart Parameters are supported.<br/><br/>

	  The filter will force the fingerprint-matching algorithm to use only fingerprints associated with that Page Type.
		<e><b>SetFilter_PageType("Invoice_Page")</b> 
		</e>
	</h>
</ref>

<ref id="SetFilter_HostName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the Fingerprint Class filter for the identification (matching) algorithm.  The filter will force the fingerprint-matching algorithm to use only fingerprints associated with the specified Fingerprint Class.">
	<ap>The String value of the Fingerprint Class you want to use as the filter.</ap>
	<lvl>Page level.</lvl>
	<ret>Always <b>True.</b></ret>
	<h> Sets the Fingerprint Class filter for the identification (matching) algorithm. Smart Parameters are supported.<br/><br/>

	The filter will force the fingerprint-matching algorithm to use only fingerprints associated with the specified Fingerprint Class.<br/><br/>
    
  To disable this filter, call with an empty string as the parameter.
		<e><b>SetFilter_HostName("MyFingerprintClass")</b>
		</e>
	</h>
</ref>
	


<ref id="SetMaxOffset" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the Maximum Offset value while matching source pages to fingerprints. The actual shift is four times the maximum offset value in pixels (4 * MaxOffset).">
	<ap>Integer value between 1 and 255.</ap>
	<lvl>All levels.</lvl>
	<ret><b>False</b> if the parameter is invalid.  Otherwise, <b>True.</b></ret>
	<h>Sets the Maximum Offset value while matching source pages to fingerprints.<br/><br/>

	The actual shift is four times the maximum offset value in pixels (4 * MaxOffset).  Increasing this value improves but slows the matching process.<br/><br/>

	The default value is 6: 4 * 6 = 24 pixels.
		<e><b>SetMaxOffset("12")</b><br/><br/>

		This example results in a Maximum Offset value of 48 pixels, well above the 24 pixel default. 
		</e>
	</h>
</ref>



<ref id="SetTemplateDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="This action should not be used, it will be removed in future versions. It has been replaced by SetFingerprintDir.">
    <ap>
      <i>String</i> value specifying the directory's name and path. <br/><br/>
      <b>Note:</b>A Drive ID (such as c:\) is optional.
    </ap>
    <lvl>All levels, but generally at the Page level.</lvl>
    <ret>Always True.</ret>
  <h>
    This action has been replaced by SetFingerprintDir.
  </h>
  <see>SetFingerprintDir</see>
</ref>



<ref id="SetFingerprintWebServiceURL" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" 
      qi="Provides the Uniform Resource Locator (URL) that is a link to a pre-established Fingerprint Service.">
  <ap>
    <i>String</i> value specifying the URL that is the link to the Fingerprint Web Service. Smart parameters are supported.
  </ap>
  <lvl>All levels.</lvl>
  <ret>Always <b>True.</b></ret>
  <h>
    Add SetFingerprintWebService URL with its single parameter to the function and move so it is prior to SetFingerprintDir action.<br/><br/>
    Note: this action is not effective unless the Fingerprint Service has been installed and configured.
    <br/>
    <br/>
    <e>
      <br/><scr>
      <b>SetFingerprintWebServiceURL("http://www.grandcorp.AR.com/fpservice/")</b>
  </scr><br/>
      <scr>SetFingerprintDir("\ParentDirectory\Application\Fingerprint")</scr><br/>
      <br/>
    </e>
  </h>
</ref>


<ref id="FindTemplate" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="This action has been replaced by FindFingerprint.">
  <ap>
    <i>String</i> boolean value:<br/><br/>
    <b>True</b> if the action is to create a new fingerprint if the current <b>
      <i>source</i>
    </b>page does not match the target fingerprint.<br/><br/>
    <b>False</b> if the action is not to create a new fingerprint if there is not a match.
  </ap>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the action is not applied at the Page level. Otherwise, <b>True.</b>
  </ret>
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by FindFingerprint.
  </h>
  <see>
    <scr>FindFingerprint</scr>
  </see>
</ref>



<ref id="CalculateOffset" access="public" bInter="bInter" bDebug="bDebug" qi="Sets the standard Offset value to be used when matching source pages to fingerprints.">
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the action is not applied at the Page level or an error occurs. Otherwise, <b>True.</b>
  </ret>
  <h>
    Calculates the Confidence and Image_Offset variables (similarity with the Fingerprint and image shift compared with the Fingerprint image) for the page based on its relation to the page's fingerprint.  The fingerprint ID must previously be set using Findfingerprint, SetFingerprint or some other method.
    <e>
      <b>CalculateOffset()</b>
    </e>
  </h>
</ref>


	
<ref id="MergeCCOs_ByType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Merges the Fingerprint files (.cco) associated with Page objects of the Document Hierarchy.">
  <ap>Comma-separated String values indicating the Page Types of the Document Hierarchy objects to be merged.</ap>
  <lvl>Document level only.</lvl>
  <ret>
    <b>False</b> if a Fingerprint file (.cco) for one of the Page Types is not available. Otherwise, <b>True.</b>
  </ret>
  <h>
    Merges the Fingerprint files (.cco) associated with Page objects of the Document Hierarchy.
    <e>
      <b>MergeCCOs_ByType("Invoice_Page,Invoice_Cont")</b><br/><br/>

      The <b>MergeCCOs_ByType</b> action above permits all values of the source pages to be assigned to 
      a single, searchable Fingerprint Processing file (.cco). 
		</e>
	</h>
</ref>
	


<ref id="BlankPagesIDBySize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Uses the Image file's size to determine if the file represents a 'blank' page.">
  <ap>
    A three-part, comma-separated value consisting of:<br/>
    <b>1.</b> Numeric value indicating the maximum size in bytes that qualifies a page as a blank page.<br/>
    <b>2.</b> String value representing the Page Type of a blank page.<br/>
    <b>3.</b>Numeric value (0, 1 or 2) to designate which pages in a multi-page Image file are to be evaluated.<br/>
    <br/>
    The third parameter is optional.<br/>
    0 = both sides of a two-page Image file.<br/>
    1 = odd pages only.<br/>
    2 = even images only.
  </ap>
  <lvl>Batch, Document, or Page levels.</lvl>
  <ret>
     <b>False</b> if any parameter is invalid, or the rule with this action is bound to a Field object of the Document Hierarchy.  Otherwise, <b>True.</b>
  </ret>
  <h>
    Uses the Image file's size to determine if the file represents a 'blank' page.<br/><br/>

    Any page with an Image file smaller than the size parameter (in bytes) will be assigned the Page Type value you enter as a parameter.
    <e>
      <b>BlankPagesIDBySize("1000,Blank_Page")</b>
    </e>
  </h>
</ref>

<ref id="SetApplicationID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Use this action to specify unique application ID.">
  <ap>
    String parameter that represents unique Application ID.  Smart parameters are supported.<br/>
    This value used to retrieve correct list of fingerprints loaded to the server.<br/>
  </ap>
  <lvl>Batch, Document, or Page levels.</lvl>
  <ret>
     <b>False</b> if action SetFingerprintWebServiceURL() has not been called.  Otherwise, <b>True.</b>
  </ret>
  <h>
    Uses this action to specify unique application name if multiple applications using the same <br/>

    Fingerprint Service.<br/><br/>

    <e>
      SetFingerprintWebServiceURL(http://'FPSERVERNAME'/fpservice/Service.asmx?WSDL)<br/>
      <b>SetApplicationID("1040ez")</b>
    </e>
  </h>
</ref>

<ref id="SetFingerprintFailureThreshold" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Uses this action to specify percentage of fingerprint upload failures to ignore.">
  <ap>
    Int parameter that represents percent threshold of fingerprint upload failures to ignore.  Smart parameters are supported.<br/>
    The batch aborts if the percentage of fingerprints that are failed to load exceeds this value.<br/>
  </ap>
  <lvl>Batch, Document, or Page levels.</lvl>
  <ret>
    Returns <b>False</b> when:<br/>
    The fingerprint service is not configured using action SetFingerprintWebServiceURL().<br/>

    Returns <b>False</b> and aborts the batch when:<br/>
    The input parameter is not a value from 0 to 100<br/>
    If the percentage of fingerprints that failed to load is greater than the threshold.<br/>
    If no fingerprints have been loaded and at least one has failed to load.<br/><br/>

    Otherwise, <b>True.</b>
  </ret>
  <h>
    Uses this action to set the maximum number of fingerprint upload failures to ignore.
    If the application has been set using the action SetApplicationID, then the threshold
    will be set for that specific application only.<br/><br/>
    <e>
      FindFingerprint(True)<br/>        
      <b>SetFingerprintFailureThreshold("10")</b>
    </e>
  </h>
</ref>

<ref id="UpdateFingerprintStats" access="public" bInter="bInter" bDebug="bDebug" qi="Updates the Fingerprint hit statistics.">
  <ap>
    None.
  </ap>
  <lvl>Page level.</lvl>
  <ret>
     <b>False</b> if action SetFingerprintWebServiceURL() has not been called or
     if called at the wrong level.  Otherwise, <b>True.</b>
  </ret>
  <h>
    Use this action to increment the count for the current page and update the fingerprint statistics
    in the fingerprint database.<br/><br/>
    <e>
      <b>UpdateFingerprintStats()</b>
    </e>
  </h>
</ref>

</help>
</rrx>
<rrx namespace="ColorToBW" src="c:\datacap\RRS\ColorToBW.dll">

<i ref="rrunner">
</i>
<af name="C2BW_Convert" access="public" bInter="bInter" bDebug="bDebug" strParam="sParam">
</af>
<f name="C2BW_SetAttributes" access="public">
	<p name="BitsPerPixel">
	</p>
	<p name="Palette">
	</p>
	<p name="Dither">
	</p>
</f>
<help>
<![CDATA[
'************************************************************************
' Actions help for ColorToBW
'------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
]]>

<ref id="C2BW_Convert" access="public" bInter="bInter" bDebug="bDebug" strParam="sParam" qi="Changes the color depth of an image.">
  <ap>
    Three letter extension to use for a backup of the original file.  If not provided, the default is "tio".
    Smart parameters are supported.
  </ap>
  <h>
     Changes the color depth of an image based on a set of defined attributes.<br/><br/>
     If action C2BW_SetAttributes is not called first, a black and white image will be created.
     If called at the batch level converts all images.  If called at the document level,
     images within the document are converted.  If called on the page, or field level the page is converted.
     <e>
       C2BW_SetAttributes("1","0","3")<br/>
       <b>C2BW_Convert("tic")</b>
     </e>
  </h>
  <lvl>All Levels.</lvl>
  <ret>
     Always <b>True.</b>
  </ret>
  <see>
    C2BW_SetAttributes
  </see>
</ref>


<ref id="C2BW_SetAttributes" access="public" qi="Adjusts the output of the action C2BW_Convert.">
  <p name="BitsPerPixel"/>
  <p name="Palette"/>
  <p name="Dither"/>
  <ap>
    Requires 3 numeric values to configure the output image specifications:<br/>
    1. Bits per pixel - 1 BW, 4, 8 Gray Scale, 24 color.<br/>
    2. Palette - 0 Optimized, 1 Fixed, 2 Grayscale, 3 Palette File, 
       4 User Defined, 5 Optimized with Dither, 6 Gray Scale with Dither, 7 Palette File with Dither.<br/>
    3. Dither - 0 None, 1 Floyd-Steinberg, 2 Ordered, 3 Optimized.<br/><br/>
    Smart parameters are supported.
  </ap>
  <h>
    Optionally called before C2BW_Convert to configure the desired image output specifications.
    If this action is not called, these default values are used:<br/>
    BitsPerPixel = 1 (Black and White)<br/>
    Palette = 0 (Optimized)<br/>
    Dither = 0 (None)<br/>
    <e>
      <b>C2BW_SetAttributes("1","0","3")</b><br/>
      C2BW_Convert(tic)
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    C2BW_Convert
  </see>
  </ref>
</help>
</rrx>
<rrx namespace="Datacap.Libraries.IBMCM" src="c:\datacap\RRS\Datacap.Libraries.IBMCM.dll">

<g>
</g>
<net ref="Datacap.Libraries.IBMCM.Actions" qi="Description of action library">
	<method name="IBMCM_Logon" qi="Logs on to a IBM CM Server">
		<p name="connectioninfo" type="string" qi="A comma-separated string consisting of three values:           1) the ID of the IBM Content Manager server (Smartparameters are supported)           2) a valid Content Manager User ID (Smartparameters are supported)           3) the user’s Password (Smartparameters are supported)">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        A comma-separated string consisting of three values: ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        1) the ID of the IBM Content Manager server (Smartparameters are supported)]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        2) a valid Content Manager User ID (Smartparameters are supported)]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        3) the user’s Password (Smartparameters are supported)"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Works on all levels but in general should be called at the Batch level.]]>
<![CDATA[
]]>
<![CDATA[        Action returns True if the log on succeeds; False if the log on is unsuccessful.]]>
<![CDATA[
]]>
<![CDATA[        The log on will be unsuccessful if the action cannot find the specified server, or if the user ID or password is invalid.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        IBMCM_Logon(ibmcmserver,user1,password)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[IBMCM_Logon(ibmcmserver,user1,password)]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_CreateItem" qi="Creates a IBM CM document based on the item type">
		<p name="itemtype" type="string" qi="Creates a IBM CM document based on the item type">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        The following values are allowed:]]>
			<br>
			</br>
			<b>
<![CDATA[1.]]>
			</b>
<![CDATA[String value of a valid IBM Content Manager Item Type – NOINDEX, for example. A CM8 Item Type is equivalent to a Document Class (Index Class).]]>
			<br>
			</br>
			<b>
<![CDATA[2.]]>
			</b>
<![CDATA[A predefined Smart Parameter variable containing a valid IBM Content Manager Item Type.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The allowed predefined variables are: @BATCHID, @ID, @STATUS, @TYPE, @VALUE,]]>
<![CDATA[
]]>
<![CDATA[        @JOBID, @JOBNAME, @OPERATOR, @STATION, @TASKID, @TASKNAME and @name.  Please refer to]]>
<![CDATA[
]]>
<![CDATA[        the documentation for more information on these values.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Action works at the Document or Page level.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateItem("NOINDEX")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manager document based on the NOINDEX item type.]]>
				<br>
				</br>
				<b>
<![CDATA[IBMCM_CreateItem(@name)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manager document based on the value contained inside the Smart Parameter @name.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Typically, there is one item for each processed document represented by a Document object of the Document Hierarchy, or for a processed page represented by a Page object.]]>
<![CDATA[
]]>
<![CDATA[          Although a page item can accept only one file for uploading to IBM Content Manager, a document item can accept a multi-page TIF file that is part of a single document.]]>
<![CDATA[
]]>
<![CDATA[          Datacap provides TiffMerge actions that create a multi-page TIF file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the document is successfully created.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_SetAttributeValue" qi="Sets the attribute value on a CM document">
		<p name="attributesvalues" type="string" qi="Sets the attribute value on a CM document">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        The following values are allowed:]]>
			<br>
			</br>
			<b>
<![CDATA[1.]]>
			</b>
<![CDATA[String value of a valid IBM Content Manager Item Type – NOINDEX, for example. A CM8 Item Type is equivalent to a Document Class (Index Class).]]>
			<br>
			</br>
			<b>
<![CDATA[2.]]>
			</b>
<![CDATA[A predefined Smart Parameter variable containing a valid IBM Content Manager Item Type.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The allowed predefined variables are: @BATCHID, @ID, @STATUS, @TYPE, @VALUE,]]>
<![CDATA[
]]>
<![CDATA[        @JOBID, @JOBNAME, @OPERATOR, @STATION, @TASKID, @TASKNAME and @name.  Please refer to]]>
<![CDATA[
]]>
<![CDATA[        the documentation for more information on these values.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Action works at the Document or Page level.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateItem("NOINDEX")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manager document based on the NOINDEX item type.]]>
				<br>
				</br>
				<b>
<![CDATA[IBMCM_CreateItem(@name)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manager document based on the value contained inside the Smart Parameter @name.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Typically, there is one item for each processed document represented by a Document object of the Document Hierarchy, or for a processed page represented by a Page object.]]>
<![CDATA[
]]>
<![CDATA[          Although a page item can accept only one file for uploading to IBM Content Manager, a document item can accept a multi-page TIF file that is part of a single document.]]>
<![CDATA[
]]>
<![CDATA[          Datacap provides TiffMerge actions that create a multi-page TIF file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the document is successfully created.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_UploadDCO_Page" qi="Uploads Image files associated with the current Page object of the Document Hierarchy to IBM Content Manager">
		<h>
<![CDATA[
]]>
<![CDATA[        Uploads the Image file associated with current Page object of the Document Hierarchy to the IBM Content Manager server. Additionally, all attributes set using IBMCM_SetAttributeValue will also be persisted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Action works at the Document or Page level.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_Logon(cmserver,adminPWD,adminUID)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateItem(NOINDEX)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue(USERID, @OPERATOR)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_UploadDCO_Page()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This sequence uploads Image files associated with the current Page object of the Document Hierarchy to IBM Content Manager, and assigns the name of the object – the value of its Type property]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page level only]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ If the action successfully sends the image to the server; False if the action is unable to save the image. ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_UploadDCO_DOC" qi="Uploades the set of Images files associated with the current document object of the Document Hierarchy to the IBM Content Manager">
		<h>
<![CDATA[
]]>
<![CDATA[        Uploads the Image file(s) associated with current Document object of the Document Hierarchy to IBM Content Manager.]]>
			<b>
			</b>
<![CDATA[
]]>
<![CDATA[        If a document can contain multiple images, the actions can not upload them unless they have all been previously merged into a single, multi-page TIF file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_Logon(cmserver,adminPWD,adminUID)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateItem(NOINDEX)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue(USERID, @OPERATOR)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_UploadDCO_DOC()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This sequence uploades the set of Images files associated with the current document object of the Document Hierarchy to the IBM Content Manager Server. Additionally, all attributes set using IBMCM_SetAttributeValue will also be persisted.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the document is successfully created.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_StoreItemIDinDCO" qi="Stores the Item ID of the most recently uploaded IBM Content Manager item into a variable of the current object of the Document Hierarchy.">
		<p name="itemID" type="string" qi="Sets the attribute value on a CM document">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        Stores the Item ID of the most recently uploaded IBM Content Manager item into a variable of the current object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_StoreItemIDinDCO(Item)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The action above assumes that “Item” is a variable of the current object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ If the Item ID is returned successfully ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
</net>
</rrx>
<rrx namespace="dcclip" src="c:\datacap\RRS\dcclip.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="dci_clipfield" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ 'During processing, clips the field on the Image file (.tif) of every source page represented by the bound Field object of the Document Hierarchy and generates a separate Image file (.tif) displaying the clipped field's contents. "]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   Two comma-separated string values:<br/>]]>
<![CDATA[
]]>
<![CDATA[ '   <b>1.</b> The Page Type that is to be assigned to the Image file containing the clipped field and its value. <b>Remember!</b>  The new Image file is represented by a new page in the current Page file.  The Page Type value you assign will be used to identify pages with clipped fields.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[ '   <b>2.</b> The Page Status to be assigned to pages with clipped images of the bound Field object of the Document Hierarchy. <b>Alert!</b> Be sure that the status you assign conforms to Page Status specifications used throughout your application.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   Both values will be picked up by the Page file (.xml) generated by the RuleRunner task that applies a rule containing this action.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  dci_clipfield = False ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim arParam ]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim arPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim L,T,R,B]]>
<![CDATA[
]]>
<![CDATA[  Dim PageObj]]>
<![CDATA[
]]>
<![CDATA[  Dim DocObj]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  arparam = split(strParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If(UBound(arParam) <> 1) Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Parameter should be comma delimited: (pagetype,pagestatus)")]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if ("" = Trim(arParam(0))) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Page type must not be blank")]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if ("" = Trim(arParam(1))) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Page status must not be blank")]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if (not IsNumeric(Trim(arParam(1)))) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Page status must be numeric.  Value: '" & arParam(1) & "'.")]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  writelog("Page type: '" & Trim(arParam(0)) & "'.  Page Status: '" & Trim(arParam(1)) & "'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sPosition = CurrentObj.Variable("Position") & ",0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[  arPos = split(sPosition,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	L = arPos(0)]]>
<![CDATA[
]]>
<![CDATA[	T = arPos(1)]]>
<![CDATA[
]]>
<![CDATA[	R = arPos(2)]]>
<![CDATA[
]]>
<![CDATA[	B = arPos(3)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sClipNo           ' enumerator for clips (for reading)]]>
<![CDATA[
]]>
<![CDATA[	Dim sClipEnumerator   ' enumerator for clips (for writing)]]>
<![CDATA[
]]>
<![CDATA[  Dim nIndex            ' the position where the clip page will be added]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Position values should be greater than zero]]>
<![CDATA[
]]>
<![CDATA[  If cInt(L)<0 then L=0]]>
<![CDATA[
]]>
<![CDATA[  If cInt(R)<0 then R=0]]>
<![CDATA[
]]>
<![CDATA[  If cInt(T)<0 then T=0]]>
<![CDATA[
]]>
<![CDATA[  If cInt(B)<0 then B=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If the Right and Bottom are 0,0 then the Zone has no area]]>
<![CDATA[
]]>
<![CDATA[  if( cInt(R) = 0 or cInt(B) = 0 ) Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position is 0,0,0,0. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  'Left and Right or Top and Bottom expected postions are reversed]]>
<![CDATA[
]]>
<![CDATA[  if( cInt(L) >= cInt(R) or cInt(T) >= cInt(B) ) Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position is inconsistent. Left and Right or Top and Bottom position values reversed. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Get the Parent Page for the calling field]]>
<![CDATA[
]]>
<![CDATA[	Set PageObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While PageObj.ObjectType > 2			]]>
<![CDATA[
]]>
<![CDATA[		Set PageObj = PageObj.Parent]]>
<![CDATA[
]]>
<![CDATA[		If PageObj.ObjectType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Parent Page Found. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Get the Source Image Name]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.FileName = PageObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Get the Parent Document for the calling field/Page]]>
<![CDATA[
]]>
<![CDATA[	Set DocObj = PageObj]]>
<![CDATA[
]]>
<![CDATA[	While DocObj.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[		Set DocObj = DocObj.Parent]]>
<![CDATA[
]]>
<![CDATA[		If DocObj.ObjectType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Parent Document Found. Using Parent Page as Root Node.")]]>
<![CDATA[
]]>
<![CDATA[      'Check for ClipNo enumeration variable. Stores counter for clip page numbering.]]>
<![CDATA[
]]>
<![CDATA[      sClipNo = PageObj.Variable("ClipNo")]]>
<![CDATA[
]]>
<![CDATA[    ElseIf DocObj.ObjectType = 1 Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Parent Document Found. Using Document as Root Node.")]]>
<![CDATA[
]]>
<![CDATA[      'Check for ClipNo enumeration variable. Stores counter for clip page numbering.]]>
<![CDATA[
]]>
<![CDATA[      sClipNo = DocObj.Variable("ClipNo")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If len(sClipNo)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[    ' set initial enumerator]]>
<![CDATA[
]]>
<![CDATA[    sClipEnumerator = "01"]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[      If len(sClipNo) <> 2 Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Unexpected counter value. Must be a two character numeric value.")]]>
<![CDATA[
]]>
<![CDATA[        ' free resource]]>
<![CDATA[
]]>
<![CDATA[        ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[        exit function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[      if(lCase(sClipNo)="zz") Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Counter limit has been reached. (00 thru ZZ)")]]>
<![CDATA[
]]>
<![CDATA[        ' free resource]]>
<![CDATA[
]]>
<![CDATA[        ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[        exit function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      sClipEnumerator = IncrementDigits(sClipNo)]]>
<![CDATA[
]]>
<![CDATA[      if sClipEnumerator = "-1" Then]]>
<![CDATA[
]]>
<![CDATA[        ' free resource]]>
<![CDATA[
]]>
<![CDATA[        ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Counter limit has been reached. (00 thru ZZ)")]]>
<![CDATA[
]]>
<![CDATA[        exit function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  'Create New Page name      ]]>
<![CDATA[
]]>
<![CDATA[  sClipName = Mid(PageObj.ImageName,1,Len(PageObj.ImageName) - 4) & "_" & sClipEnumerator & Mid(PageObj.ImageName,Len(PageObj.ImageName) - 3,Len(PageObj.ImageName))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Create new Page object]]>
<![CDATA[
]]>
<![CDATA[  Select Case cstr(DocObj.ObjectType)]]>
<![CDATA[
]]>
<![CDATA[    Case "1"]]>
<![CDATA[
]]>
<![CDATA[      'Create as last page in document]]>
<![CDATA[
]]>
<![CDATA[      nIndex = DocObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[    Case "0"]]>
<![CDATA[
]]>
<![CDATA[      'Create as new trailing sibling page to parent page of calling field]]>
<![CDATA[
]]>
<![CDATA[      nIndex = DocObj.FindChildIndex(PageObj.id)+1]]>
<![CDATA[
]]>
<![CDATA[    Case Else]]>
<![CDATA[
]]>
<![CDATA[      'Unexpected objecttype, default index to 'last']]>
<![CDATA[
]]>
<![CDATA[      nIndex=-1]]>
<![CDATA[
]]>
<![CDATA[  End Select]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("New Page index:" & nIndex)]]>
<![CDATA[
]]>
<![CDATA[  Set oClipPage = DocObj.AddChild(2, PageObj.ID & "_" & sClipEnumerator,nIndex)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If oClipPage is Nothing  Then]]>
<![CDATA[
]]>
<![CDATA[    ' free resource]]>
<![CDATA[
]]>
<![CDATA[    ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Unable to add clip page")]]>
<![CDATA[
]]>
<![CDATA[    Exit function		]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set type, status and new image name]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("TYPE") = Trim(arParam(0))]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("STATUS") = Trim(arParam(1))]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.ImageName = sClipName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Add some info about the calling object and source page]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("SourcePage") = PageObj.ID]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("SourceImage") = PageObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("SourceField") = CurrentObj.ID]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("SourceValue") = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ImageCtrl.saveZone(L,T,R-L,B-T,sClipName,10)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Select Case cstr(DocObj.ObjectType)]]>
<![CDATA[
]]>
<![CDATA[    Case "1"]]>
<![CDATA[
]]>
<![CDATA[      'Save counter to document]]>
<![CDATA[
]]>
<![CDATA[      DocObj.Variable("ClipNo") = sClipEnumerator]]>
<![CDATA[
]]>
<![CDATA[    Case "0"]]>
<![CDATA[
]]>
<![CDATA[      'Save counter to page]]>
<![CDATA[
]]>
<![CDATA[      PageObj.Variable("ClipNo") = sClipEnumerator]]>
<![CDATA[
]]>
<![CDATA[    Case Else]]>
<![CDATA[
]]>
<![CDATA[      'Unexpected objecttype, do not save counter]]>
<![CDATA[
]]>
<![CDATA[  End Select]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'free resource]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[	dci_clipfield = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<help>
<![CDATA[
'************************************************************************
' DCclip Action help
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'************************************************************************
]]>
  
<ref id="dci_clipfield" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="During processing, clips the field on the Image file (.tif) of every source page represented by the bound Field object of the Document Hierarchy and generates a separate Image file (.tif) displaying the clipped field's contents. ">
  <ap>
    Two comma-separated string values:<br/>
    <b>1.</b> The Page Type that is to be assigned to the Image file containing the clipped field and its value. <b>Remember!</b>  The new Image file is represented by a new page in the current Page file.  The Page Type value you assign will be used to identify pages with clipped fields.<br/><br/>
    <b>2.</b> The Page Status to be assigned to pages with clipped images of the bound Field object of the Document Hierarchy. <b>Alert!</b> Be sure that the status you assign conforms to Page Status specifications used throughout your application.<br/><br/>
  </ap>
  <lvl>Field level only.</lvl>
  <ret>
    <b>False</b> if either parameter is invalid.  Otherwise <b>True.</b><br/><br/>

    If the dci_clipfield action cannot locate the target field on a source page, the action will not generate an Image file for the clipped field and will not add a corresponding page to the current Page file (.xml).
  </ret>
  <h>
    During processing, clips the field on the Image file (.tif) of every source page represented by the bound Field object of the Document Hierarchy and generates a separate Image file (.tif) displaying the clipped field's contents.<br/><br/>

    The action also adds a page representing the new Image file to the current Page file.<br/><br/>

    <b>Alert!</b> If the Image ID assigned to the Image file representing the source page has this format: tm000001.tif. The Image ID of a clipped field's Image file adds one underscore character and a two digit index and has this format: tm000001_01.tif<br/><br/>

    The second pair in the batch will have these ID's:  tm000002.tif. and tm000002_01.tif. (This assumes that a source page has only one clipped field.)	   
    <e>
      <b>dci_clipfield(OfficePens_Page, 0)</b><br/><br/>
    </e>
  </h>
</ref>
</help>

</rrx>
<rrx namespace="DCO" src="c:\datacap\RRS\DCO.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="SetDCOStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	SetDCOStatus = False]]>
<![CDATA[
]]>
<![CDATA[    If Not(Isnumeric(StrParam)) then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be Numeric.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Status = CLng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	SetDCOStatus = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	status = CurrentObj.Status ]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Type = StrParam]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Status = CLng(status)]]>
<![CDATA[
]]>
<![CDATA[	strDCOType = StrParam]]>
<![CDATA[
]]>
<![CDATA[	SetDCOType = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetPageStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetPageStatus = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If Not(Isnumeric(Strparam)) then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be Numeric.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oParent.ObjectType>2]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If (oParent.ObjectType=2) Then ]]>
<![CDATA[
]]>
<![CDATA[		oParent.Status = CLng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		SetPageStatus = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Page Object or Parent Page object found.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Nothing ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetPageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim PageObj]]>
<![CDATA[
]]>
<![CDATA[	Dim sNode]]>
<![CDATA[
]]>
<![CDATA[	Dim bNode]]>
<![CDATA[
]]>
<![CDATA[	Dim sType]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetPageType = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set PageObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While PageObj.ObjectType > 2			]]>
<![CDATA[
]]>
<![CDATA[		Set PageObj = PageObj.Parent]]>
<![CDATA[
]]>
<![CDATA[		If PageObj.ObjectType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Page Object Found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	status = PageObj.Status ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	bNode = False	]]>
<![CDATA[
]]>
<![CDATA[	'Ensure Min Length requirement ]]>
<![CDATA[
]]>
<![CDATA[	If Len(Trim(StrParam))>0 Then]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[		'replace dbl quotes with single	]]>
<![CDATA[
]]>
<![CDATA[		sNode = Replace(StrParam,Chrw(34),Chrw(39))		]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		'Check If quoted value]]>
<![CDATA[
]]>
<![CDATA[		If Left(Trim(sNode),1)=Chrw(39) And Right(Trim(sNode),1)=Chrw(39) Then ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			sNode = Trim(Replace(StrParam,Chrw(39),""))]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			'Check If self]]>
<![CDATA[
]]>
<![CDATA[			If sNode = CurrentObj.Type Then ]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Current Object is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[				If(Trim(CurrentObj.Text) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[					sType = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[					bNode = True]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Node is CurrentObj. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Check If Child of Self]]>
<![CDATA[
]]>
<![CDATA[			If Not(bNode) Then]]>
<![CDATA[
]]>
<![CDATA[				Set iChild = CurrentObj.FindChild(sNode)]]>
<![CDATA[
]]>
<![CDATA[				If Not(iChild Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Child Object is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[					If(Trim(iChild.Text) <> "" ) Then ]]>
<![CDATA[
]]>
<![CDATA[						sType = iChild.Text]]>
<![CDATA[
]]>
<![CDATA[						bNode = True]]>
<![CDATA[
]]>
<![CDATA[						debuglog("Node is Property Object. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Check If Variable of Self]]>
<![CDATA[
]]>
<![CDATA[			If Not(bNode) Then]]>
<![CDATA[
]]>
<![CDATA[				If CurrentObj.FindVariable(sNode) >= 0 Then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Current Object Variable is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[					If(Trim(CurrentObj.Variable(sNode)) <> "" ) Then ]]>
<![CDATA[
]]>
<![CDATA[						sType = CurrentObj.Variable(sNode)]]>
<![CDATA[
]]>
<![CDATA[						bNode = True]]>
<![CDATA[
]]>
<![CDATA[						debuglog("Node is Property Object. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Assign PageType as StrParam]]>
<![CDATA[
]]>
<![CDATA[			sType = StrParam	]]>
<![CDATA[
]]>
<![CDATA[			bNode = True				]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If(PageObj.ObjectType = 2) And bNode Then PageObj.Type = sType]]>
<![CDATA[
]]>
<![CDATA[	PageObj.Status = CLng(status)]]>
<![CDATA[
]]>
<![CDATA[	SetPageType = bNode ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetDocStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetDocStatus = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oParent.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If (oParent.ObjectType=1) Then ]]>
<![CDATA[
]]>
<![CDATA[		oParent.Status = CLng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		SetDocStatus = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Doc Object or Parent Doc object found.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Nothing ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetDocumentType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim DocObj]]>
<![CDATA[
]]>
<![CDATA[    dim stype]]>
<![CDATA[
]]>
<![CDATA[	SetDocumentType = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Action must be called from Document, Page or Field DCO.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set DocObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While DocObj.ObjectType > 1		]]>
<![CDATA[
]]>
<![CDATA[		Set DocObj = DocObj.Parent]]>
<![CDATA[
]]>
<![CDATA[		If DocObj.ObjectType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Document Object Found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	status = DocObj.Status ]]>
<![CDATA[
]]>
<![CDATA[	sType=""]]>
<![CDATA[
]]>
<![CDATA[	bNode = False	]]>
<![CDATA[
]]>
<![CDATA[	'Ensure Min Length requirement ]]>
<![CDATA[
]]>
<![CDATA[	If Len(Trim(StrParam))>0 Then]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[		'replace dbl quotes with single	]]>
<![CDATA[
]]>
<![CDATA[		sNode = Replace(StrParam,Chrw(34),Chrw(39))		]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		'Check If quoted value]]>
<![CDATA[
]]>
<![CDATA[		If Left(Trim(sNode),1)=Chrw(39) And Right(Trim(sNode),1)=Chrw(39) Then ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			sNode = Trim(Replace(StrParam,Chrw(39),""))]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			'Check If self]]>
<![CDATA[
]]>
<![CDATA[			If sNode = CurrentObj.Type Then ]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Current Object is Source DCO.")]]>
<![CDATA[
]]>
<![CDATA[				If(Trim(CurrentObj.Text) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[					sType = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[					bNode = True]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Node is CurrentObj. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[                    Writelog("CurrentObj has no Value.")]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Check If Child of Self]]>
<![CDATA[
]]>
<![CDATA[			If Not(bNode) Then]]>
<![CDATA[
]]>
<![CDATA[				Set iChild = CurrentObj.FindChild(sNode)]]>
<![CDATA[
]]>
<![CDATA[				If Not(iChild Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Child Object is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[					If(Trim(iChild.Text) <> "" ) Then ]]>
<![CDATA[
]]>
<![CDATA[						sType = iChild.Text]]>
<![CDATA[
]]>
<![CDATA[						bNode = True]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Node is Property Object. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[                        Writelog("Child has no Value.")]]>
<![CDATA[
]]>
<![CDATA[                    End If]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Check If Variable of Self]]>
<![CDATA[
]]>
<![CDATA[			If Not(bNode) Then]]>
<![CDATA[
]]>
<![CDATA[				If CurrentObj.FindVariable(sNode) >= 0 Then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Current Object Variable is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[					If(Trim(CurrentObj.Variable(sNode)) <> "" ) Then ]]>
<![CDATA[
]]>
<![CDATA[						sType = CurrentObj.Variable(sNode)]]>
<![CDATA[
]]>
<![CDATA[						bNode = True]]>
<![CDATA[
]]>
<![CDATA[						debuglog("Node is Property Object. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[                        Writelog("Child Object Variable has no Value.")]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[            If bNode = False and sType="" then]]>
<![CDATA[
]]>
<![CDATA[                Writelog("No value found to assign as DocType. Setting Action to Return false.")]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Assign PageType as StrParam]]>
<![CDATA[
]]>
<![CDATA[			sType = StrParam	]]>
<![CDATA[
]]>
<![CDATA[			bNode = True				]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If(DocObj.ObjectType = 1) And bNode Then DocObj.Type = sType]]>
<![CDATA[
]]>
<![CDATA[	DocObj.Status = CLng(status)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetDocumentType = bNode ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ChkDCOStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStatus]]>
<![CDATA[
]]>
<![CDATA[	Dim n]]>
<![CDATA[
]]>
<![CDATA[	aStatus=Split(StrParam&",",",")]]>
<![CDATA[
]]>
<![CDATA[	ChkDCOStatus = False]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Current Component Status='" & Currentobj.Status & "'")]]>
<![CDATA[
]]>
<![CDATA[	For n = 0 to (ubound(aStatus)-1)]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.Status = CLng(Trim(aStatus(n))) Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Matched status '" & aStatus(n) & "'")]]>
<![CDATA[
]]>
<![CDATA[			ChkDCOStatus = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'n ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ChkDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ChkDCOType = False]]>
<![CDATA[
]]>
<![CDATA[	If(CurrentObj.Type = StrParam) Then ChkDCOType = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("DCO type: " & CurrentObj.Type & "; Returning: " & ChkDCOType) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ChkLastDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim nCurIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim oPrevObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ChkLastDCOType = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType=0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Calling Object is ROOT object for BATCH.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = CurrentObj.Parent()]]>
<![CDATA[
]]>
<![CDATA[	If oParent is Nothing then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Parent Object Returned.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	strDCOType = oParent.Type]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Parent Type is: '" & strDCOtype & "'.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nCurrIndex = oParent.FindChildIndex(CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[	If nCurrIndex>0 Then]]>
<![CDATA[
]]>
<![CDATA[		Set oPrevObj = oParent.GetChild(nCurrIndex-1)]]>
<![CDATA[
]]>
<![CDATA[		If Not(oPrevObj is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[			strDCOtype = oPrevObj.Type]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Prev Obj Type is: '" & strDCOtype & "'.")]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If (strDCOType = StrParam) Then ChkLastDCOType = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("DCO last type: " & strDCOType & "; Returning: " & ChkLastDCOType)		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oPrevObj = Nothing ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="CreateDocuments" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Dim nType]]>
<![CDATA[
]]>
<![CDATA[    Dim oChild]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[    Dim DCount]]>
<![CDATA[
]]>
<![CDATA[    Dim PCount]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    DCount=0]]>
<![CDATA[
]]>
<![CDATA[    PCount=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    CreateDocuments = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Check for existing document objects, return false if found (exit action)]]>
<![CDATA[
]]>
<![CDATA[    For i = 1 to DCO.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[        Set oChild = DCO.GetChild(i-1)]]>
<![CDATA[
]]>
<![CDATA[        If Not(oChild is nothing) then]]>
<![CDATA[
]]>
<![CDATA[            nType=oChild.ObjectType]]>
<![CDATA[
]]>
<![CDATA[            Set oChild=nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            If nType=1 then]]>
<![CDATA[
]]>
<![CDATA[                DCount=DCount+1         ]]>
<![CDATA[
]]>
<![CDATA[            ElseIf nType=2 then]]>
<![CDATA[
]]>
<![CDATA[                PCount=PCount+1                ]]>
<![CDATA[
]]>
<![CDATA[            End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            If DCount>1 then]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Batch Already Contains a Multi-Document structure.") ]]>
<![CDATA[
]]>
<![CDATA[                Exit Function     ]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            If DCount=1 and PCount>=1 then]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Batch root contains Page and Document components. Must have all Pages at Batch Root or under a single Document at Batch Root.")]]>
<![CDATA[
]]>
<![CDATA[                Exit Function]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[    Next 'i ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CreateDocuments = CBool(DCO.CreateDocuments()) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="CreateFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CreateFields = CBool(CurrentObj.CreateFields())]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("Num of Children:" & CurrentObj.numofchildren()) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetPageFingerprintID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	SetPageFingerprintID = False]]>
<![CDATA[
]]>
<![CDATA[	If(CurrentObj.ObjectType = 2) Then]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.Variable("TemplateID") = StrParam]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Setting TemplateID to: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Current object is not a page. Action Failed")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	SetPageFingerprintID = True ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ChkIntegrity" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim rValue]]>
<![CDATA[
]]>
<![CDATA[	Dim oProbParent]]>
<![CDATA[
]]>
<![CDATA[	Dim sMsg]]>
<![CDATA[
]]>
<![CDATA[	Dim oProbObj]]>
<![CDATA[
]]>
<![CDATA[	Dim index]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ChkIntegrity = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	rValue = DCO.CheckIntegrity(oProbObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If rValue > 0 Then]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Structure check failed")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Select Case rValue ]]>
<![CDATA[
]]>
<![CDATA[			'Case 0: sMsg="No Integrity Problems Found."]]>
<![CDATA[
]]>
<![CDATA[			Case 1: sMsg="More Children than expected."]]>
<![CDATA[
]]>
<![CDATA[			Case 2: sMsg="Less Children than expected."]]>
<![CDATA[
]]>
<![CDATA[			Case 3: sMsg="an Invalid or unexpected Child object."]]>
<![CDATA[
]]>
<![CDATA[			Case 4: sMsg="a Wrong Child Position."]]>
<![CDATA[
]]>
<![CDATA[		End Select]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Set oProbParent = oProbObj.parent()]]>
<![CDATA[
]]>
<![CDATA[		If Not(oProbParent is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[			If oProbParent.GetChild(oProbParent.NumOfChildren-1) is oProbObj Then ]]>
<![CDATA[
]]>
<![CDATA[				Set oProbObj = oProbParent]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				index = oProbParent.FindChildIndex(oProbObj.ID)]]>
<![CDATA[
]]>
<![CDATA[				Set oProbObj = oProbParent.GetChild(clng(Index+1))]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		ChkIntegrity = False]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Integrity Failed. '" & oProbObj.ID & "' has " & sMsg)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Set oProbObj = Nothing ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="CopyPD2DD" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[ 	nChild = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	for i=0 to nChild -1]]>
<![CDATA[
]]>
<![CDATA[	  Set oChild = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[	  if(Not oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		if(oChild.ObjectType = 2) Then]]>
<![CDATA[
]]>
<![CDATA[		   if( oChild.Variable("PD") <> "" ) Then]]>
<![CDATA[
]]>
<![CDATA[		      CurrentObj.Variable("DD") = oChild.Variable("PD")]]>
<![CDATA[
]]>
<![CDATA[                      writelog("Set DD(DocumentData) as PD(PageData)")]]>
<![CDATA[
]]>
<![CDATA[ 	              CopyPD2DD = True		   ]]>
<![CDATA[
]]>
<![CDATA[		      Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[		      exit function]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[          end if]]>
<![CDATA[
]]>
<![CDATA[        next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyPD2DD = False ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="PropagateToAltText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	sVal = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	sConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	n = Cint(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltText(n) = sVal]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltConfidenceString(n) = sConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AltText(" & strParam & ") set to: " & sVal)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AltConf(" & strParam & ") set to: " & sConf)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	PropagateToAltText = True ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ClearAltText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	n = Cint(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltText(n) = ""]]>
<![CDATA[
]]>
<![CDATA[	'CurrentObj.AltConfidenceString(n) = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ClearAltText = True ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetPageTemplateID" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	SetPageTemplateID=SetPageFingerprintID(bInter, bDebug, strParam) ]]>
	</g>
</af>
<af name="ClearDCO" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim nNumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim nNumOfVars]]>
<![CDATA[
]]>
<![CDATA[	Dim nIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim nObjCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim nVarCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim sVarname]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ClearDCO = False]]>
<![CDATA[
]]>
<![CDATA[	nObjCounter = 0]]>
<![CDATA[
]]>
<![CDATA[	nVarCounter = 0]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Clear/Remove all Fields & Characters]]>
<![CDATA[
]]>
<![CDATA[	nNumOfChildren = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Child Objects to Delete:'" & nNumOfChildren & "'")	]]>
<![CDATA[
]]>
<![CDATA[	For nIndex = nNumOfChildren to 1 Step -1]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.Deletechild(nIndex-1)=True then]]>
<![CDATA[
]]>
<![CDATA[			nObjCounter = nObjCounter + 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'nIndex]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Child Objects Deleted: '" & nObjCounter & "'")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[       'Clear/Remove all Variables ]]>
<![CDATA[
]]>
<![CDATA[	nNumOfVars = CurrentObj.NumOfVars	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Variables to Delete:'" & nNumOfVars & "'")]]>
<![CDATA[
]]>
<![CDATA[	For nIndex = nNumOfVars to 1 Step -1]]>
<![CDATA[
]]>
<![CDATA[        sVarname = CurrentObj.GetVariableName(nIndex-1)]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.DeleteVariable(sVarname)=True then]]>
<![CDATA[
]]>
<![CDATA[			nVarCounter = nVarCounter + 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'nIndex]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Variables Deleted: '" & nVarCounter & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (nVarCounter + nObjCounter) = (nNumOfVars + nNumOfChildren) then]]>
<![CDATA[
]]>
<![CDATA[		ClearDCO = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Deleted Counts do not match Child + Variable count.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ErrorHandler("End Function ClearDCO") ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="DeleteFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim nNumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim nNumOfVars]]>
<![CDATA[
]]>
<![CDATA[	Dim nIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim nObjCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim nVarCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileName]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	DeleteFields = False]]>
<![CDATA[
]]>
<![CDATA[	nObjCounter = 0]]>
<![CDATA[
]]>
<![CDATA[	sFileName = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType = 2 Then]]>
<![CDATA[
]]>
<![CDATA[		sFileName = Trim(CurrentObj.Variable("DATAFILE"))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	nNumOfChildren = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Clear/Remove all Fields & Characters]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Child Objects to Delete:'" & nNumOfChildren & "'")	]]>
<![CDATA[
]]>
<![CDATA[	For nIndex = nNumOfChildren to 1 Step -1]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.Deletechild(nIndex-1)=True then]]>
<![CDATA[
]]>
<![CDATA[			nObjCounter = nObjCounter + 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'nIndex]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Child Objects Deleted: '" & nObjCounter & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If (nObjCounter = nNumOfChildren) then]]>
<![CDATA[
]]>
<![CDATA[		DeleteFields = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Deleted Count does not match original Child count.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Len(sFileName)<>0 then]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If isobject(pTM) Then]]>
<![CDATA[
]]>
<![CDATA[			'TM web Session]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Web DATAFILE:'" & sFileName & "'")]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Web sLocalBatchDir:'" & sLocalBatchDir & "'")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			'? temp for test]]>
<![CDATA[
]]>
<![CDATA[			'bRes = pTM.FSIO.RemoveFile(sFileName)]]>
<![CDATA[
]]>
<![CDATA[			'If bRes = False Then Writelog("Unable to Delete Data File:'" & sFileName & "'")	]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Thick Client Session]]>
<![CDATA[
]]>
<![CDATA[			If FileMgr.FileExists(sFileName) then]]>
<![CDATA[
]]>
<![CDATA[				Call FileMgr.DeleteFile(sFileName,True)]]>
<![CDATA[
]]>
<![CDATA[				If Err.number<>0 Then Writelog("Unable to Delete Data File:'" & sFileName & "'")			]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Unable to Find Data File:'" & sFileName & "'")]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ErrorHandler("End Function DeleteFields") ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ChkConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim MinLevel]]>
<![CDATA[
]]>
<![CDATA[	Dim LCStatus]]>
<![CDATA[
]]>
<![CDATA[	Dim HCStatus]]>
<![CDATA[
]]>
<![CDATA[	Dim bExit]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim dNodeDict]]>
<![CDATA[
]]>
<![CDATA[	Dim oSetupDCO]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[	Dim RegEx]]>
<![CDATA[
]]>
<![CDATA[	Dim sReqConf]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ChkConfidence=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	MinLevel = trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	LCStatus = trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsNumeric(MinLevel) then MinLevel=-1]]>
<![CDATA[
]]>
<![CDATA[	If cint(MinLevel)<1 or cint(MinLevel)>10 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("First Parameter 'MinLevel' must be a numeric value between 1 and 10.")]]>
<![CDATA[
]]>
<![CDATA[		bExit = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(LCStatus) and len(LCStatus)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Second Parameter 'Low Confidence Status' must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[		bExit = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Pages with status Failed (" & cstr(nFail) & ") will NOT be checked for low confidence fields.")]]>
<![CDATA[
]]>
<![CDATA[	ChkStatus=""]]>
<![CDATA[
]]>
<![CDATA[	For i = 2 to Ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[		If len(Trim(aStrParam(i)))>0 And isNumeric(Trim(aStrParam(i))) Then]]>
<![CDATA[
]]>
<![CDATA[			ChkStatus = ChkStatus & trim(aStrParam(i)) & ","]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Pages with status '" & aStrParam(i) & "' will be checked for low confidence fields.")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If len(ChkStatus)=0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Pages with status '" & cstr(nPass) & "' will be checked for low confidence fields.")	]]>
<![CDATA[
]]>
<![CDATA[                ChkStatus=nPass & ","]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If bExit = True then ]]>
<![CDATA[
]]>
<![CDATA[		ChkConfidence=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Populate Dictionary object with list of Fields and ReqConf pattern value.]]>
<![CDATA[
]]>
<![CDATA[	Set dNodeDict = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[	Set oSetupDCO = DCO.SetupObject]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Reading Setup DCO confidence settings...")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to oSetupDCO.NumOfNodes(3)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = oSetupDCO.GetNode(3,i-1)]]>
<![CDATA[
]]>
<![CDATA[		If oChild is Nothing then]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Child " & i & " returned as Nothing")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			If cstr(oChild.Variable("STATUS"))<>"-1" then]]>
<![CDATA[
]]>
<![CDATA[				sReqConf = Trim(oChild.Variable("ReqConf"))]]>
<![CDATA[
]]>
<![CDATA[				If IsNumeric(sReqConf) Then]]>
<![CDATA[
]]>
<![CDATA[					Call dNodeDict.Add(oChild.Name,"[" & sReqConf-1 & "-9]*")]]>
<![CDATA[
]]>
<![CDATA[					Writelog(Space(5) & "Child '" & ochild.Name & "' added to dictionary. ReqConf: [" & sReqConf & "-9].")]]>
<![CDATA[
]]>
<![CDATA[				Else]]>
<![CDATA[
]]>
<![CDATA[					Call dNodeDict.Add(oChild.Name,"[" & MinLevel-1 & "-9]*")]]>
<![CDATA[
]]>
<![CDATA[					Writelog(Space(5) & "Child '" & ochild.Name & "' added to dictionary. ReqConf: [" & MinLevel & "-9].")]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oSetupDCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Writelog("---------------------------------------------")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Set	RegEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Loop through DCO tree]]>
<![CDATA[
]]>
<![CDATA[	ChkConfidence = EvalDCOConf(CurrentObj, LCStatus, ChkStatus, dNodeDict, RegEx)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set dNodeDict = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set RegEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetFldConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim sFieldName     'String of the field name to change, (empty means current field.???)]]>
<![CDATA[
]]>
<![CDATA[  Dim sNewConf       'Confidence Level 1 - 10.  Sets all confidence characters to this value.]]>
<![CDATA[
]]>
<![CDATA[  Dim aParam         'Split Input "field name" "Confidence"]]>
<![CDATA[
]]>
<![CDATA[  Dim numChars       'Length of the value which implies the length of the confidence string.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' If setting of the confidence fails, we will still return success, but log that the confidence]]>
<![CDATA[
]]>
<![CDATA[  ' was not adjusted.]]>
<![CDATA[
]]>
<![CDATA[  SetFldConfidence = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' A little trick to guarantee that there are two parameters by appending an extra blank parameter.]]>
<![CDATA[
]]>
<![CDATA[  ' Default the 2nd parameter to 10 if only a single parameter is passed in.]]>
<![CDATA[
]]>
<![CDATA[  aParam = Split(StrParam & ",10",",") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Pull out the 1st and 2nd parameters]]>
<![CDATA[
]]>
<![CDATA[  sFieldName = trim(aParam(0))]]>
<![CDATA[
]]>
<![CDATA[  sNewConf   = trim(aParam(1))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (sFieldName = "") Then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Field Parameter is empty.  Character confidence values were not changed.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Validate that sNewConf is 1 or 2 characters]]>
<![CDATA[
]]>
<![CDATA[  numChars = Len(sNewConf)]]>
<![CDATA[
]]>
<![CDATA[  if ((NumChars <> 1) and (NumChars <> 2)) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Field Parameter length is wrong, must be value 1-10:" & sNewConf)]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Character confidence values for field: " & sFieldName & " were not changed!")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Validate that cConfidence is between 1 and 10]]>
<![CDATA[
]]>
<![CDATA[  if (not IsNumeric(sNewConf)) Then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Field Parameter must be a single digit:" & sNewConf)]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Character confidence values for field: " & sFieldName & " were not changed!")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  iConfidence = CInt(sNewConf) - 1]]>
<![CDATA[
]]>
<![CDATA[  if ((iConfidence < 0) or (iConfidence > 9)) Then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Field Parameter must be a 1-10:" & sNewConf)]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Character confidence values for field: " & sFieldName & " were not changed!")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDcoObj = DCONav(sFieldName)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Check that oDcoObj is not empty, Not Null and nothing]]>
<![CDATA[
]]>
<![CDATA[  if (not IsAlive(oDcoObj)) then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Could not locate field:" & sFieldName & ".  Character confidence values were not changed!")]]>
<![CDATA[
]]>
<![CDATA[     oDcoObj = NULL]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Located Field: " & sFieldName & " containing value: " & oDcoObj.text)]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Original Confidence: " & oDcoObj.ConfidenceString & ". New character confidence: " & iConfidence)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' Obtain the length of the field so we can set the confidence for each character.]]>
<![CDATA[
]]>
<![CDATA[  numChars = len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' Set new confidence value]]>
<![CDATA[
]]>
<![CDATA[  oDcoObj.ConfidenceString = String(clng(numChars), trim(cStr(iConfidence)))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SetFldConfidence")]]>
<![CDATA[
]]>
<![CDATA[  oDcoObj = NULL]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************************************************
' DCO help.xml

' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'Version = "8.1.1" 
' Updated 09/07/2011 RFERIN
'	  29867 Changed a reference of "kscan" to "scan".
'
'****************************************************************************************
]]>
  
<ref id="SetDCOStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns a value to the Status property of the current object of the Document Hierarchy.">
  <ap>An Integer representing the new status.</ap>
  <h>
    Assigns a value to the Status property of the current object of the Document Hierarchy.
    <e>
      <scr>ChkDCOType(Invoice)</scr><br/>
      <b>SetDCOStatus(1)</b><br/><br/>

      This sequence checks to see if the current object of the Document Hierarchy is a Page
      object - in this example, an Invoices page.  If so, the value of the Page object's Status
      property is set to "1".
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>SetDCOType, SetPageType</scr>
  </see>
</ref>
	
<ref id="SetDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns a value to the Type property of the current object of the Document Hierarchy.">
  <ap>A String value you're assigning to the current object's Type property.</ap>
  <h>
    Assigns a value to the Type property of the current object of the Document Hierarchy.
    <e>
      <scr>ChkLastDCOType(Separator)</scr><br/>
      <b>SetDCOType(Invoice)</b><br/><br/>

      This sequence checks to see if the previous object of the Invoices application's 
      Document Hierarchy was a Page object - in this case, a Separator page. If so, it 
      sets Invoice as the Type property of the current object.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>SetDCOStatus, SetPageStatus, SetDocumentType</scr>
  </see>
</ref>
	
<ref id="SetPageStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="The action assigns a page status to an object of the Document Hierarchy.">
  <ap>
    Numeric value representing the status.<br/><br/>

    The Invoices application (as an example) employs three default Page Statuses:<br/>
    49 = ScanOK<br/>
    1 = Incomplete/Not validated<br/><br/>
    0 = Complete<br/>

    You can define your own statuses by using the Filter tab of a task's Task Settings dialog.
  </ap>
  <h>
    The action assigns the page status you enter to the page object of the Document Hierarchy.
    The current object can be the page or field.  If the current object is a field object,
    it will set the page status for its parent page object.
    <e>
      A scan task might assign Other as the Page Type and 49 as the default Page Status
      for every successfully scanned image in the batch.<br/><br/>

      The sequence below is an example of a rule that converts Other pages to Invoices pages,
      and assigns a Page Status to each:<br/>
      <scr>SetPageType(Invoice)</scr><br/>
      <b>SetPageStatus(1)</b><br/><br/>

      This combination establishes the page as an Invoices page, and gives it a status of 1.
      This means that the page has not yet been validated and must be processed by a task which
      applies Validation rules (a Recognition or Verification task, for example).
    </e>
  </h>
  <lvl>Page or field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>SetPageType, SetDCOStatus, SetDCOType, SetDocumentStatus</scr>
  </see>
</ref>
	
<ref id="SetPageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="The action assigns a Page Type to the current Page object of the Document Hierarchy.">
  <ap>
    A String value representing the Page Type.<br/><br/>

    You can also designate a field in a Page object's Data file, and use its text value to set the Page Type.  Simply enter the name of a valid Field object and surround it with single quotes. For example: 'PageCode'.
  </ap>
  <h>
    Similar to the <scr>SetDCOType</scr> action, but works at the Page or Field level.<br/><br/>

    The action assigns the Page Type you enter as a parameter to the current Page object of the Document Hierarchy.  You can also use a Field object's value to set the Page Type. (See the Parameter section above.)
    <e>
      The application's scan task typically assigns Other as the Page Type and 49 as the default
      Page Status for every successfully scanned image in the batch.<br/><br/>

      The sequence below is an example of a rule that converts Other pages to Invoices pages, and assigns a Page Status to each:<br/>
      <b>SetPageType(Invoice)</b><br/>
      <scr>SetPageStatus(1)</scr><br/><br/>

      This combination sets the page as an Invoices page, and gives it a status of 1. This means that the page has not yet been validated and must be processed by a task which applies Validation rules (a RuleRunner Task, for example).
    </e>
  </h>
  <lvl>Page and Field levels.</lvl>
  <ret>
    <b>False</b> if there are no Page objects in the Page file, or if the parameter 
    is invalid.  Otherwise, <b>True.</b>
  </ret>
  <see>
    <scr>SetPageStatus, SetDCOStatus, SetDCOType</scr>
  </see>
</ref>
	
<ref id="SetDocStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns a status to the current document.">
  <ap>
    String value representing the status to be assigned to the current document.<br/>
    Typically:<br/>
    "0" = Complete.<br/>
    "1" = Incomplete.
  </ap>
  <h>
    Assigns a status to the current document.
    <e>
      <b>SetDocStatus(DocOK)</b>
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False</b> if the ruleset is not bound to a Document object, or the current
    object is not a document. Otherwise, <b>True.</b>
  </ret>
</ref>
	
<ref id="SetDocumentType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="The action assigns a Document Type to the current Document object of the Document Hierarchy.">
  <ap>
    The value you want to assign as the Document object's Type property.<br/><br/>

    You can also designate a field in a Page object's Data file, and use its text
    value to set the Document Type.  Simply enter the name of a valid Field object and surround
    it with single quotes. For example: 'Number'.
  </ap>
  <h>
    Similar to the <scr>SetDCOType</scr> action but works at the Document, Page or Field level.<br/><br/>

    The action assigns the Document Type you enter as a parameter to the current Document object of
    the Document Hierarchy. You can also use a Field object's value to set the Document Type.
    (Refer to the Parameter section.)
    <e>
      <b>SetDocumentType('Number')</b><br/>
      or<br/>
      <b>SetDocumentType(Invoice_Document)</b>
    </e>
  </h>
  <lvl>Document, Page, and Field levels.</lvl>
  <ret>
    <b>False</b> if there are no Document objects in the Data file, or if the parameter is invalid.  Otherwise, <b>True.</b>
  </ret>
  <see>
    <scr>SetDCOType, SetPageType</scr>
  </see>
</ref>
	
<ref id="ChkDCOStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Confirms that the status of the Document Hierarchy's current object is identical to the status entered as the parameter.">
  <ap>The Numeric value of the status you're checking.</ap>
  <h>
    Confirms that the status of the Document Hierarchy's current object is identical
    to the status entered as the parameter.
    <e>
      <b>ChkDCOStatus(0)</b> returns <b>True</b> if the current object has a
      status equal to 0, and <b>False</b> if it does not.<br/><br/>

      <b>ChkDCOStatus(48)</b> returns <b>True</b> if the current object has a status
      equal to 48, and <b>False</b> if it does not.
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>True</b> if the DCO status matches the parameter value. Otherwise, <b>False.</b>
  </ret>
  <see>
    <scr>SetDCOStatus, ChkDCOType</scr>
  </see>
</ref>
	
<ref id="ChkDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Confirms that the Type property of the Document Hierarchy's current object is identical to the type entered as the parameter.">
  <ap>The String value of the Type property of the object you're checking.</ap>
  <h>
    Confirms that the Type property of the Document Hierarchy's current object is identical
    to the type entered as the parameter.
    <e>
      <b>ChkDCOType(Invoice)</b><br/><br/>
      <scr>SetPageStatus(1)</scr><br/><br/>

      Applied at the Page level, the action above returns <lit>True</lit> if the current
      object is an Invoices Page object (using the Invoices application as an example),
      and <lit>False</lit> if it is not.  This action will confirm the current DCO Type matches
      an expected type and take additional subsequent actions that follow this action.  In this
      case, if the current DCO Type is "Invoice", the page status is set to 1.
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>True</b> if the value of the DCO Type matches the parameter.  Otherwise, <b>False.</b>
  </ret>
  <see>
    <scr>SetDCOType, ChkDCOStatus, ChkLastDCOType</scr>
  </see>
</ref>
	
<ref id="ChkLastDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Checks that the Type property of the Document Hierarchy's previous object is identical to the type entered as the parameter.">
  <ap>The previous object's DCO Type to compare.</ap>
  <h>
    Checks that the Type property of the Document Hierarchy's previous object is identical to 
    the type entered as the parameter.  This action allows you to test the last DCO Type 
    encountered so you can take specific subsequent steps based on that type.<br/><br/>

    The example below is applied at the Page level and checks to see if the previous Page 
    object's type matches the parameter (Separator).
    <e>
      <b>ChkLastDCOType(Separator)</b><br/>
      <scr>SetPageType(Invoice)</scr><br/>
      <scr>SetPageStatus(1)</scr><br/><br/>

      Applied at the Page level, this sequence checks to see if the previous Page object was a 
      Separator page. If so, the type of the current page is set to Invoice, and its status is set to "1." 
      If the previous document type was not a separator, the subsequent actions will not execute.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if the Type property of the Document Hierarchy's previous object
    matches the parameter. Otherwise, <b>False.</b>
  </ret>
  <see>
    <scr>SetDCOType, ChkDCOType</scr>
  </see>
</ref>
	
<ref id="CreateDocuments" access="public" bInter="bInter" bDebug="bDebug" qi="Arranges the contents of a task's Page file (for example, Recognition.xml,) into documents based on the Document Integrity rules (min, max and order)specified in your application's Document Hierarchy, and assembles documents from the pages in the batch. ">
  <ap>None.</ap>
  <h>
    Arranges the contents of a task's Page file (for example, Recognition.xml) into documents
    based on the Document Integrity rules for <b>min</b>, <b>max</b>, and <b>order</b> properties
    specified in your application's Document Hierarchy, and assembles documents from the pages in the batch.<br/><br/>

    Batches containing existing document structures will cause this action to return False,
    with no affect to the existing document structure.<br/><br/>

    Note: During document creation, temporary IDs are assigned (with a different format than real Document IDs) , 
    and if the action fails, these temporary IDs remain.<br/><br/>

    <b>Alert!</b> This action is applied at the Batch level, and generally in its own Ruleset (in a CreateDocs ruleset, for example.)
    <e>
      <b>CreateDocuments()</b>
    </e>
  </h>
  <lvl>Batch level only.</lvl>
  <ret>
    <b>True</b> if successful. Otherwise, <b>False.</b>
  </ret>
</ref>

<ref id="CreateFields" access="public" bInter="bInter" bDebug="bDebug" qi="Creates the Data file for a page in a batch. The Data file for the first page in the batch, tm000001, as an example, is tm000001.xml.">
  <ap>None.</ap>
  <h>
    Creates the Data file for a page in a batch. The Data file for the first page
    in the batch, tm000001, as an example, is tm000001.xml.<br/><br/>

    This Data file lists all fields for the current page based on the fields listed
    in the setup Document Hierarchy. Each field has an ID (for an Invoices page, for
    example, the Date field's ID is Date), and three properties with default values:
    TYPE, Position, and Status.<br/><br/>

    Later, actions of various kinds (Locate, Zone, Validation, DCO, etc.) can assign
    other values to these properties.  These actions can also add properties (variables)
    and values to the Data file, or remove properties and values.
    <e>
      <scr>AnalyzeImage()</scr><br/>
      <scr>RotateImageRecognizePageOCR_S()</scr><br/>
      <scr>SetSearchArea(0.5)</scr><br/>
      <scr>SetProblemValue(0.3)</scr><br/>
      <scr>SetTemplateDir(\ParentDirectory\Invoice\Template)</scr><br/>
      <scr>FindFingerprint(True)</scr><br/>
      <b>CreateFields()</b><br/><br/>

      This Invoices application sequence sets up the current page for processing,
      recognizes the words on the page, associates the page with a fingerprint,
      and finally creates a Data file with blank fields for the page.
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if successful. Otherwise, <b>False.</b>
  </ret>
</ref>
	
<ref id="SetPageFingerprintID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns a value to the FingerprintID property of the selected Page object of the Document Hierarchy.">
  <ap>The String value of the Fingerprint ID.</ap>
  <h>
    Assigns a value to the FingerprintID property of the selected Page object of the Document Hierarchy.<br/><br/>

    <b>Alert!</b> <scr>
      The <b>SetPageFingerprintID</b> action
    </scr> will create a FingerprintID property of the current Page object if it does not already exist.
    <e>
      <scr>WordFind(MQSW)</scr><br/>
      <b>SetPageFingerprintID(1010)</b><br/><br/>

      In this sequence, if the WordFind action locates "MQSW" on the current page, 
      the <scr>SetPageFingerprintID</scr> action assigns "1010" as the page's 
      Fingerprint ID. This links the page to a fingerprint with a Fingerprint ID of "1010".
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if the rule is applied at the Page level.  Otherwise, <b>False.</b>
  </ret>
</ref>
	
<ref id="ChkIntegrity" access="public" bInter="bInter" bDebug="bDebug" qi="Checks that  the integrity of the batch, as detailed in the Page file of the current task, meets the integrity requirements set within the Document Hierarchy (Setup DCO).">
  <ap>None.</ap>
  <h>
    Checks that the integrity of the batch, as detailed in the Page file
    of the current task, meets the integrity requirements set within the
    Document Hierarchy (Setup DCO).<br/><br/>

    "Integrity" refers to the correct types and numbers of pages within each document
    in the batch and the correct order of the pages in each document.
    <e>
      <b>ChkIntegrity()</b>
    </e>
  </h>
  <lvl>Batch and Document levels.</lvl>
  <ret>
    Returns <b>True</b> if no integrity problems are found.  Otherwise, <b>False.</b>
  </ret>
</ref>
	
<ref id="CopyPD2DD" access="public" bInter="bInter" bDebug="bDebug" qi="Assigns the value in a Page object's PD(Page Data) variable to the Document object's DD (Doc Data) variable.">
  <ap>None.</ap>
  <h>
    Assigns the value in a Page object's PD (Page Data) variable to the 
    Document object's DD (Doc Data) variable.
    <e>
      <b>CopyPD2DD()</b>
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False</b> if the action is not at the Document level, or if the PD 
    variable at page level has no value.  Otherwise, <b>True.</b>
  </ret>
</ref>
	
<ref id="PropagateToAltText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Copies the character and confidence values from the first index of the Character Array (index 0) to the index specified by the parameter.">
  <ap>The index of the Character Array where you want to copy the character and confidence values. 0 is the first index, followed by 1, etc.</ap>  
  <h>
    Copies the character and confidence values from the first index of the Character Array (index 0)
    to the index specified by the parameter. (The character "node" of a page's Data file is an array
    that can hold many recognized character values, and their corresponding confidence values.)<br/><br/>

    <b>Note:</b> Rules will only work with characters and confidence values located in the 
    first position of the Character Array (index 0).<br/><br/>

    The <scr>PropagateToAltText</scr> action is used with the User Application 
    Web's Advanced Index task, for "Double Blind" data entry.
    <e>
      <b>PropagateToAltText(1)</b><br/>
      <scr>ClearAltText(0)</scr><br/><br/>

      All characters in the first index of the Character Array will be copied to the second index.
      Then, the second action will clear the character and confidence values from the first index.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>ClearAltText</scr>
  </see>
</ref>
	
<ref id="ClearAltText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Clears character and confidence values from the Character Array position specified by the parameter. ">
  <ap>
    The index in the Character Array where you want to clear the character and confidence values.  0 is the first index, followed by 1, etc.
  </ap>  
  <h>
    Clears character and confidence values from the Character Array position specified by the parameter.  
    When cleared, the confidence values are set to 10 (high confidence).
    (A field in the Data file can hold more than one representation of the field's value.
    Values other than the current, visible value are accessed via an index number.
    The current value is at index 0, the next value is at index 1.  Each additional
    value also has corresponding character confidences.)<br/><br/>

    <b>Note:</b> Most actions only work with characters and confidence values located in the first position of the Character Array (position 0).
    The ClearAltTex action is used with User Application Web's Advanced Index task, for "Double Blind" data entry.
    <e>
      PropagateToAltText(1)<br/>
      <b>ClearAltText(0)</b><br/><br/>

      In this example, all characters at the first index (0) of the Character Array will be copied to the second index (1).  
      The second action will then clear character and confidence values from the first index in the Character Array.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>PropagateToAltText</scr>
  </see>
</ref>
	
<ref id="SetPageTemplateID" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
  <ap>The String value of the Fingerprint ID.</ap>
  <h>
    Assigns a value to the FingerprintID property of the selected Page object of the Document Hierarchy.<br/><br/>

    <b>Alert!</b> The <b>SetPageTemplateID</b> action will create a FingerprintID 
    property of the current Page object if it does not already exist.
    <e>
      <scr>WordFind(MQSW)</scr><br/>
      <b>SetPageTemplateID(1010)</b><br/><br/>

      In this sequence, if the WordFind action locates "MQSW" on the current 
      page, the <scr>SetPageTemplateID</scr> action assigns "1010" as the page's 
      Fingerprint ID. This links the page to a fingerprint with a Fingerprint ID of "1010".
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if the rule is applied at the Page level.  Otherwise, <b>False.</b>
  </ret>
</ref>
	
<ref id="ClearDCO" access="public" bInter="bInter" bDebug="bDebug" qi="Clears all objects of the Document Hierarchy which are children of the bound object, and their variables.">
  <ap>None.</ap>
  <h>
    Removes all DCO children and variable references from the bound object.
    <e>
      CreateFields()<br/>
      <b>ClearDCO()</b><br/><br/>

      Applied at the Page level, the example will first add fields to the page and then remove them.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if all child objects and their variables are removed, otherwise <b>False.</b>
  </ret>
</ref>
	
<ref id="DeleteFields" access="public" bInter="bInter" bDebug="bDebug" qi="Deletes all child fields and characters from calling object of the Document Hierarchy.">
  <ap>None.</ap>
  <h>
    Deletes all fields and characters that are children of the bound object of the Document
    Hierarchy. This action will also remove the Data file (.xml) from the batch 
    if called from a Page object.
    <e>
      <b>DeleteFields()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if successful, otherwise <b>False.</b>
  </ret>
</ref>
	
<ref id="ChkConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Checks the confidence of all field data on child pages against a minimum acceptable confidence value (Parameter 1). If any fields in a page contain Low Confidence data, assigns the Page Status specified in Parameter 2 to the page.">
  <ap>
    Two or three comma-separated values:<br/><br/>
    <b>1.</b> The Numeric value of the minimum confidence required. This value will be superseded on a field-by-field basis, if the field's ReqConf variable is set.<br/>
    <b>2.</b> The Numeric Page Status code to assign to any page that has one or more fields with Low Confidence data: if a field's ConfidenceString property contains a value lower than the first parameter.  Subfields, line items, etc are included.  Typically, "1" (Problem) is the value of this parameter.

    If only two parameters are specified, only pages with Status=0 will be checked by this action.<br/>
    <b>3.</b> If a third parameter is supplied, these parameters specify the list of Page Statuses to be checked.
  </ap>
  <h>
    Checks the confidence of all field data on selected pages, selected by Page Status, against a minimum acceptable confidence value (Parameter 1).
    If any fields contain Low Confidence data, the page is marked with the status specified as a parameter.<br/>
    Optionally, checks only pages of the status specified as Parameter 3.
    <e>
      <b>ChkConfidence(8,1)</b>
    </e>
  </h>
  <lvl>
    All levels. This action operates on the entire batch regardless of the level 
    to which its rule is bound. 
  </lvl>
  <ret>
    <b>True</b> if all fields in all source pages are High Confidence.<br/>
    <b>False</b> if any field has Low Confidence data, or if the parameters are not Numeric.
  </ret>
  <see>
    <scr>ChkDocStatus</scr>
  </see>
</ref>

<ref id="SetFldConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam"
     qi="For a specific field, sets the confidence for all characters in the field to the same value.">
  <ap>
    A comma-separated value consisting of: <br/>
    <br/>
    <b>1.</b> The field's name, or a Smart Parameter that designates the field.<br/><br/>
    <b>2.</b> The confidence value (1-10) to be assigned to the field's characters.
  </ap>
  <h>
    This action unconditionally sets the confidence values for every character within a field to a specific level.  This action can help
    change confidence levels when the preceding actions are all successful.<br/><br/>
    For example, if a set of calculations involving one or more fields is
    successful, this may indicate that the confidence level of those fields' values should be high - regardless of the
    confidence set by the recognition engine.  After the success of the calculation, you can call
    <b>SetFldConfidence</b>to unconditionally re-set the confidence values of the fields.<br/><br/>
    The first parameter is the name of the field that will have its confidence level set.<br/>
    The second parameter is the desired confidence level, between 1 and 10.  If the second parameter is not passed in, 10 is used as the default.<br/><br/>
    <b>Please note:</b>This function supports smart parameters for the field name (see the examples below).<br/>
    <e>

      Example 1:<br/>
      To set all characters in the field "GrossSalary" to a confidence of 9.<br/>
      <b>SetFldConfidence(@P\GrossSalary,10)</b><br/><br/>

      Example 2:<br/>
      To set all characters in the field "AdjustedPay" to a confidence of 1.<br/>
      <b>SetFldConfidence(@P\AdjustedPay,1)</b><br/><br/>

      Example 3: <br/>
      In the context of a test run before setting the confidence.<br/><br/>
      Calculate("'1TotalWages' + '2TaxableInterest' + "3Unemployment' = '4AdjustedGross'")<br/><br/>
      If this calculation works, the application can assume that all of the characters are read
      correctly and <b>SetFldConfidence</b> can adjust the fields to high confidence.<br/><br/>
      Note, you might also want to add a check
      that the values are all non-zero just to eliminate a completely "bad read".<br/><br/>
      <b>SetFldConfidence("@P\1totalWages,10")</b><br/>
      <b>SetFldConfidence("@P\2TaxableInterest,10")</b><br/>
      <b>SetFldConfidence("@P\3Unemployment,10")</b><br/>
      <b>SetFldConfidence("@P\4AdjustedGross,10")</b><br/>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b> If an input parameter is invalid, no confidence levels 
    are changed and a message is logged.
  </ret>
  </ref>

</help>
</rrx>
<rrx namespace="Documentum" src="c:\datacap\RRS\Documentum.dll">

<i ref="rrunner">
</i>
<f name="DM_Logon" access="public">
	<p name="sRepositoryDomain">
	</p>
	<p name="sRepositoryName">
	</p>
	<p name="sUserID">
	</p>
	<p name="sPassword">
	</p>
</f>
<af name="DM_UploadPage" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="DM_UploadDocument" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="DM_SetFolderName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="DM_SetObjectName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="DM_SetContentType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<help>
<![CDATA[

'************************************************************************
' Documentum.rrx - Documentum Content Server Upload Actions
' Based on the Documentum Foundation Classes 
' Requires DFC Version 6.x installed on a computer where these actions are running.  Earlier versions *may* work.

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
'
' Initial Help.xml created 5/24/2012 PHofle
'
]]>
  
  <ref id="DM_Logon" >
  <p name="sRepositoryDomain"/>
  <p name="sRepositoryName"/>
  <p name="sUserID"/>
  <p name="sPassword"/>
  <ap>
    sRepositoryDomain : The machine name for the repository.<br/>
    sRepositoryName : The name of the repository.<br/>
    sUserID : The userid for logon.<br/>
    sPassword : The password.<br/><br/>
    
    The parameters cannot be blank.
    Smart parameters are supported.<br/>
    Note: Use a smart parameter to obtain the password from
    the appliation service instead of hard coding it in the rules.
  </ap>
  <lvl>
    This action can be called at any level but is recommended to be called at the batch level.
    It should be called only once per task.
  </lvl>
  <ret>
    <b>True,</b> if the logon is successful.  Otherwise, <b>False.</b>
  </ret>
    <h>
      Creates the connection to the repository where the pages will be uploaded.  This action must
      be called prior to DM_UploadPage or DM_UploadDocument.  The user ID must have
      write permission or files cannot be uploaded.<br/><br/>
      
      It is recommended that you create an advanced value in the custom values tab in the
      Applicaiton Manager to store your password.      
      <e>
        <b>DM_Logon("machinename", "repository", "userid", "password")</b><br/><br/>

        <b>DM_Logon("machinename", "repository", "userid", "@APPVAR(values/adv/MyPassword)")</b><br/>
        This example uses the smart paramter @APPVAR to obtain the password from the
        advanced value section of the applicaiton manager.  The custom value name is "MyPassword".
      </e>
    </h>
  <see>DM_UploadPage DM_UploadDocument</see>
</ref>


  <ref id="DM_UploadPage">
    <ap>
      None.
    </ap>
    <lvl>
      Page level.
    </lvl>
    <ret>
      <b>True,</b> if the page is uploaded to the repository.  Otherwise, <b>False.</b><br/><br/>

      If the file fails to upload or if the file is missing from the batch, the batch will be set to abort.
    </ret>
    <h>
      This action uploads the current page to the repository.
      An XML file called DM_Uploaded.xml is created in the batch directory.
      This file lists all of pages that have been uploaded.<br/><br/>

      DM_Logon must have been previously called.
      Additionally, the destination folder,
      final object name and content type must have been previously set.
      <e>
        DM_SetFolderName("/folder1/folder2")<br/>
        DM_SetContentType("tiff")<br/>
        DM_SetObjectName("@ID")<br/>
        <b>DM_UploadPage()</b><br/>
      </e>
    </h>
    <see>DM_SetFolderName DM_SetContentType DM_SetObjectName</see>
  </ref>

<ref id="DM_UploadDocument" >
  <ap>
    None.
  </ap>
  <lvl>
    Document level.
  </lvl>
  <ret>
    <b>True,</b> if all of the pages within the document are uploaded to the repository.  Otherwise, <b>False.</b><br/><br/>

    If any of the files for the document are missing from the batch, it is not considered an 
    error and the batch will not abort. If the upload to Documentum fails due to a different reason, 
    the document upload will stop and the batch will be set to abort.
  </ret>
  <h>
    This action will upload all of the pages that are attached to a document.
    An XML file called DM_Uploaded.xml is created in the batch directory.
    This file lists all of pages that have been uploaded.<br/><br/>

    DM_Logon must have been previously called.  Additionally, the destination folder,
    final object name and content type must have been previously set.  When uploading a document
    using this action, all pages must be of the same type.
    <e>
      DM_SetFolderName("/folder1/folder2")<br/>
      DM_SetContentType("tiff")<br/>
      DM_SetObjectName("@ID")<br/>
      <b>DM_UploadDocument()</b><br/>
    </e>
  </h>
  <see>DM_SetFolderName DM_SetContentType DM_SetObjectName</see>
</ref>

  <ref id="DM_SetFolderName">
  <ap>
    Repository folder where the file will be uploaded.
    Smart parameters are supported.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    The name of the cabinet / folder that will hold the uploaded file.  The path specification to the folder
    can be specified using a typical folder syntax separated by forward slashes, such as
    /folder/anotherfolder/finalfolder.  Alternatively, the target folder can be specified
    by the object ID of the folder as defined in the repository, without any slashes.<br/><br/>

    This action does not confirm that the folder actually exists in the repository.
    If the specified content type is incorrect, the upload action will report the error.
    This action must be called prior to DM_UploadPage or DM_UploadDocument.
    <e>
      <b>DM_SetFolderName("/folder1/folder2")</b><br/>
      DM_SetContentType("tiff")<br/>
      DM_SetObjectName("@ID")<br/>
      DM_UploadPage()<br/>
      This example shows the folder path as it exists in the repository.<br/><br/>

      <b>DM_SetFolderName("0c0022538000252d")</b><br/>
      DM_SetContentType("tiff")<br/>
      DM_SetObjectName("@ID")<br/>
      DM_UploadPage()<br/>
      This example uses the object ID of the destination folder in the repository.
    </e>
  </h>
  <see>DM_UploadPage DM_UploadDocument</see>
</ref>

  <ref id="DM_SetObjectName">
  <ap>
    The name for the uploaded file as it will appear in repository.
    Smart parameters are supported.
  </ap>
  <lvl>Any level.</lvl>
  <ret>Always <b>True.</b></ret>
  <h>
    This action is used to set the name of the uploaded file.  This is not the file name as it exists in the batch,
    but the final name that will be used when viewed in the repository.<br/><br/>

    This action must be called prior to DM_UploadPage or DM_UploadDocument.
    <e>
      DM_SetFolderName("/folder1/folder2")<br/>
      DM_SetContentType("tiff")<br/>
      <b>DM_SetObjectName("@ID")</b><br/>
      DM_UploadDocument()<br/>      
    </e>
  </h>
  <see>DM_UploadPage DM_UploadDocument</see>
</ref>

  <ref id="DM_SetContentType">
  <ap>
    The repository defined type for this page. 
    Smart parameters are supported.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Sets the type for the page to be uploaded.  This type must be pre-defined in the repository.
    This action does not test that the specified type exists in the repository.
    If the specified content type is incorrect, the upload action will report the error.<br/><br/>

    This action must be called prior to DM_UploadPage or DM_UploadDocument.
    <e>
      DM_SetFolderName("/folder1/folder2")<br/>
      <b>DM_SetContentType("tiff")</b><br/>
      DM_SetObjectName("@ID")<br/>
      DM_UploadDocument()<br/>
    </e>
  </h>
  <see>DM_UploadPage DM_UploadDocument</see>
</ref>
</help>
</rrx>
<rrx namespace="Email" src="c:\datacap\RRS\Email.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="SetMailServer" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ 'Configures the mail server to use for sending mail."]]>
<![CDATA[
]]>
<![CDATA[ '  The IP or DNS address of the outgoing mail (SMTP) server.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   SetMailServer = true]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if (gOutlookInit) then]]>
<![CDATA[
]]>
<![CDATA[     ' When not set, these actions will always create an outlook email object.]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Warning, SetMailServer was called while the Outlook object is in use.")]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Setting for IP or DNS address of SMTP server is:" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[   gMailServer=trim(StrParam)]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetRecipients" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Sets email recipients' address(es)."]]>
<![CDATA[
]]>
<![CDATA[  'Email address(es) of recipient(s).  You can either call this action multiple times to add multiple recipients,]]>
<![CDATA[
]]>
<![CDATA[  'or you can enter multiple email addresses separated by commas.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   SetRecipients = true]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if (Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Error: SetRecipients was called with no recipients")]]>
<![CDATA[
]]>
<![CDATA[      SetRecipients = false  ]]>
<![CDATA[
]]>
<![CDATA[      Call ErrorHandler("Function SetRecipients")  ]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if ( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Error: SetRecipients could not create email object")]]>
<![CDATA[
]]>
<![CDATA[      SetRecipients = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then             ' Using Outlook]]>
<![CDATA[
]]>
<![CDATA[      g_MailItem.Recipients.Add StrParam]]>
<![CDATA[
]]>
<![CDATA[      writelog("Setting Recipient for Outlook")]]>
<![CDATA[
]]>
<![CDATA[      if(ParseError("can not set Recipients for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[         WriteLog("Error: SetRecipients could not set outlook recipient")]]>
<![CDATA[
]]>
<![CDATA[         SetRecipients = false]]>
<![CDATA[
]]>
<![CDATA[         ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[         gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[         gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Not g_MailItem.Recipients.ResolveAll Then ]]>
<![CDATA[
]]>
<![CDATA[         WriteLog("Unknown recipient: " + StrParam)]]>
<![CDATA[
]]>
<![CDATA[         SetRecipients = false]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      writelog("Setting Recipient for CDOSYS")]]>
<![CDATA[
]]>
<![CDATA[      Dim Ub]]>
<![CDATA[
]]>
<![CDATA[      Ub = Ubound(arRecipients,1) ]]>
<![CDATA[
]]>
<![CDATA[      Redim Preserve arRecipients(Ub + 1)]]>
<![CDATA[
]]>
<![CDATA[      arRecipients(Ub + 1) = StrParam]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetRecipients")  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetCarbonCopyRcpts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ 'Set Carbon Copy recipients' email address(es)."]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '  Email addresses to receive a copy of the email as a carbon copy.]]>
<![CDATA[
]]>
<![CDATA[ '  You can enter multiple email addresses separated by commas.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  SetCarbonCopyRcpts = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if(Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Error: SetCarbonCopyRcpts was called with no recipients")]]>
<![CDATA[
]]>
<![CDATA[    SetCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Error: SetCarbonCopyRcpts CheckExistingMailItem failed")]]>
<![CDATA[
]]>
<![CDATA[    SetCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if(g_CDOSYS_NotPresent = TRUE) Then              ' Using Outlook Object]]>
<![CDATA[
]]>
<![CDATA[    g_MailItem.CC = StrParam]]>
<![CDATA[
]]>
<![CDATA[    if(ParseError("can not sets SenderName for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Error: SetCarbonCopyRcpts could not set Outlook CC")]]>
<![CDATA[
]]>
<![CDATA[      SetCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[      ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[      gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[      gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[      Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[      exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[  else                                            ' Using CDOSYS Object]]>
<![CDATA[
]]>
<![CDATA[    if(trim(MessageHeaders(cCarbonCopy)) <> "" ) Then]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cCarbonCopy) = MessageHeaders(cCarbonCopy) & "," & StrParam]]>
<![CDATA[
]]>
<![CDATA[    else]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cCarbonCopy) = StrParam]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function SetCarbonCopyRcpts")        ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetBlindCarbonCopyRcpts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sets Blind Carbon Copy recipients' email address(es)."]]>
<![CDATA[
]]>
<![CDATA[  ' The email addresses to receive a copy of the email as a blind carbon copy.]]>
<![CDATA[
]]>
<![CDATA[  '  You can enter multiple email addresses separated by commas.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   SetBlindCarbonCopyRcpts = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if(Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error: SetBlindCarbonCopyRcpts was called with no recipients"]]>
<![CDATA[
]]>
<![CDATA[      SetBlindCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      SetBlindCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[      writelog("SetBlindCarbonCopyRcpts CheckExistingMailItem failed")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then                   ' Using Outlook object]]>
<![CDATA[
]]>
<![CDATA[      g_MailItem.BCC = StrParam]]>
<![CDATA[
]]>
<![CDATA[      if(ParseError("can not set BCC for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[         writelog("SetBlindCarbonCopyRcpts Setting BCC value failed")]]>
<![CDATA[
]]>
<![CDATA[         SetBlindCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[         ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[         gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[         gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else                                                  ' Using CDOSYS Object]]>
<![CDATA[
]]>
<![CDATA[      if(trim(MessageHeaders(cBlindCarbonCopy)) <> "" ) Then]]>
<![CDATA[
]]>
<![CDATA[         MessageHeaders(cBlindCarbonCopy) = MessageHeaders(cBlindCarbonCopy) & "," & StrParam]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         MessageHeaders(cBlindCarbonCopy) = StrParam]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetBlindCarbonCopyRcpts")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetAttachment" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Adds a file attachment to an email."]]>
<![CDATA[
]]>
<![CDATA[  '  The file’s path and name.  Smart Parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Dim g_ExportName_email]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ' this function sets attachment from g_ExportName_email, which is set up by the same function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   g_ExportName_email = MetaWord(Trim(StrParamMW)) ' Smart Parameters are allowed.  Process them if any are present.	  ]]>
<![CDATA[
]]>
<![CDATA[   Dim StrPath ' actual path to file;  StrParam is file name]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if(Trim(CStr(g_ExportName_email)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      writelog(space(2) & "SetAttachment get empty PathName")]]>
<![CDATA[
]]>
<![CDATA[      SetAttachment = false]]>
<![CDATA[
]]>
<![CDATA[      exit function  ]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   StrPath = Pilot.BatchDir & "\" & Trim(g_ExportName_email)]]>
<![CDATA[
]]>
<![CDATA[   StrPath = Trim(g_ExportName_email)]]>
<![CDATA[
]]>
<![CDATA[   if(FileMgr.FileExists(StrPath)) Then]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[         writelog(space(2) & "SetAttachment CheckExistingMailItem failed")]]>
<![CDATA[
]]>
<![CDATA[         SetAttachment = false]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if(g_CDOSYS_NotPresent = TRUE) Then	              ' Using Outlook email object]]>
<![CDATA[
]]>
<![CDATA[         g_MailItem.Attachments.Add Trim(CStr(StrPath))]]>
<![CDATA[
]]>
<![CDATA[         if(ParseError("can not add Attachments for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[            writelog(space(2) & "SetAttachment Cannot add outlook attachment")]]>
<![CDATA[
]]>
<![CDATA[            SetAttachment = false]]>
<![CDATA[
]]>
<![CDATA[            ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[            gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[            gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[            Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[            exit Function]]>
<![CDATA[
]]>
<![CDATA[         end if]]>
<![CDATA[
]]>
<![CDATA[      else                                              ' Using CDOSYS]]>
<![CDATA[
]]>
<![CDATA[         writelog(space(2) & "Setting CDOSYS attachment: " & strPath)]]>
<![CDATA[
]]>
<![CDATA[         'call g_MailItem.AttachFile(Trim(CStr(StrPath)),g_ExportName_email )]]>
<![CDATA[
]]>
<![CDATA[         call g_MailItem.AddAttachment(Trim(CStr(StrPath)),"","")]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      writelog(space(2) & "SetAttachment get unexisting file:" & StrPath)]]>
<![CDATA[
]]>
<![CDATA[      SetAttachment = false]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetAttachment")]]>
<![CDATA[
]]>
<![CDATA[   SetAttachment = true]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetEmailBody" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sets the text of the email’s body."]]>
<![CDATA[
]]>
<![CDATA[  '  The email message text.  Smart Parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(Trim(StrParamMW)) ' Smart Parameters are allowed.  Process them if any are present.	  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if(Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("SetEmailBody empty StrParam")]]>
<![CDATA[
]]>
<![CDATA[      SetEmailBody = true]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("SetEmailBody could not create email item")]]>
<![CDATA[
]]>
<![CDATA[      SetEmailBody = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then]]>
<![CDATA[
]]>
<![CDATA[      g_MailItem.body = StrParam]]>
<![CDATA[
]]>
<![CDATA[      if(ParseError("can not set Body for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[         SetEmailBody = false]]>
<![CDATA[
]]>
<![CDATA[         ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[         gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[         gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cBody) = StrParam]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetEmailBody")]]>
<![CDATA[
]]>
<![CDATA[   SetEmailBody = true]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetSubject" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Sets the text for the email's Subject field."]]>
<![CDATA[
]]>
<![CDATA[  '  The subject line of the email.  Smart Parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Dim StrParam   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(Trim(StrParamMW)) ' Smart Parameters are allowed.  Process them if any are present.	  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if(Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetSubject parameter is blank.")]]>
<![CDATA[
]]>
<![CDATA[      SetSubject = true]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then       ]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetSubject CheckExistingMailItem returned false.")]]>
<![CDATA[
]]>
<![CDATA[      SetSubject = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then              ' Using Outlook Object]]>
<![CDATA[
]]>
<![CDATA[      g_MailItem.Subject = StrParam]]>
<![CDATA[
]]>
<![CDATA[      if(ParseError("can not set Subject for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[         SetSubject = false]]>
<![CDATA[
]]>
<![CDATA[         ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[         gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[         gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cSubject) = StrParam]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function SetSubject")]]>
<![CDATA[
]]>
<![CDATA[  SetSubject = true]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetSender" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sets the sending email address."]]>
<![CDATA[
]]>
<![CDATA[  '  The sender’s email address.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if (Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("SetSender Parameter is Blank")]]>
<![CDATA[
]]>
<![CDATA[      SetSender = true]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("SetSender could not create email object")]]>
<![CDATA[
]]>
<![CDATA[      SetSender = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then                     ' Using Outlook Object]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Outlook object will use current email account as Sender")]]>
<![CDATA[
]]>
<![CDATA[      SetSender = true]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cFrom) = StrParam]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetSender")]]>
<![CDATA[
]]>
<![CDATA[   SetSender = true]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SendEMail" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sends an email."]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if (Not IsObject(g_MailItem)) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Fatal Error: call SetRecipients() first")]]>
<![CDATA[
]]>
<![CDATA[      SendEMail = false]]>
<![CDATA[
]]>
<![CDATA[      gInitProcedurePassed = FALSE]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   End If   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If(g_MailItem Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SendEmail Error: email object is not created, first call actions to set email parameters")]]>
<![CDATA[
]]>
<![CDATA[      SendEMail = false]]>
<![CDATA[
]]>
<![CDATA[      gInitProcedurePassed = FALSE]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   End If   ]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SendEmail Error: CheckExistingMailItem failed")]]>
<![CDATA[
]]>
<![CDATA[      SendEmail = false]]>
<![CDATA[
]]>
<![CDATA[      gInitProcedurePassed = FALSE]]>
<![CDATA[
]]>
<![CDATA[      Set g_MailItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) then      ' Using Outlook Object]]>
<![CDATA[
]]>
<![CDATA[      call SendEMailThroughOutlook()]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Sent with Outlook")]]>
<![CDATA[
]]>
<![CDATA[   else                                     ' Using CDOSYS Object]]>
<![CDATA[
]]>
<![CDATA[      call SendEMailThroughCDOSYS()]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Sent with CDOSYS")]]>
<![CDATA[
]]>
<![CDATA[   end if   ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   ' After Sending, reset everything to inital state to create a new e-mail for next calls to the actions]]>
<![CDATA[
]]>
<![CDATA[   Set g_MailItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   gCDOSYSinit = FALSE]]>
<![CDATA[
]]>
<![CDATA[   gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[   gInitProcedurePassed = FALSE]]>
<![CDATA[
]]>
<![CDATA[   g_CDOSYS_NotPresent = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cSubject) = ""]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cFrom) = ""]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cBody) = ""]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cImportance) = 1]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cCarbonCopy) = ""   ]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cBlindCarbonCopy) = ""]]>
<![CDATA[
]]>
<![CDATA[   Redim Preserve arRecipients(0)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SendEMail")]]>
<![CDATA[
]]>
<![CDATA[   gInitProcedurePassed = FALSE]]>
<![CDATA[
]]>
<![CDATA[   SendEMail = true]]>
<![CDATA[
]]>
	</g>
</af>
<help>
<![CDATA[
'************************************************************************
' EMail Actions
' 
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'Version = "8.1.0.14"
' Updated 07/13/2011 RFerin
' 31793 Added information regarding email subject lengths.
'
'Version = "8.1.0.15"
' Updated 08/04/2011 RFerin
' 31600 Added "extension" to help for SetAttachment.
'
'************************************************************************
]]>

  <ref id="SetMailServer" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Configures the mail server to use for sending mail.">
    <ap>
      The IP or DNS address of the outgoing mail (SMTP) server.
    </ap>
    <h>
      Sets the address of the outgoing mail (SMTP) server.
      This may be the same mail server you configure in your mail program.
      The server must be accessible from the computer running the email actions.
      This action should be the first action in an email rule if the CDOSYS object is being used.<br/><br/>

      Use this action only if you are sending emails with CDOSYS.
      To use CDOSYS, this action must be called prior to any of the other email actions.
      If this action is not called prior to other email actions, these actions
      will use Outlook for sending emails.<br/><br/>

      You can use Email actions to direct a task to compose and send emails containing information and attachments.
      Email actions use the Windows CDOSYS library to send email via your preferred SMTP mail server.
      The CDOSYS object is included with Windows 2000 and above. Alternatively, Email actions can use the
      Outlook object but this is not recommended.<br/><br/>

      One of these two libraries (CDOSYS or Outlook) must be registered on the computer that runs rules employing email actions.<br/><br/>

      Outlook is primarily useful for demonstration purposes, as it is not suitable for unattended operation:
      it requires the Outlook user to be logged into the computer, and security prompts may be displayed for each message sent.
      <e>
        <b>SetMailServer("mail.YourISP.com")</b><br/>
        SetSender("paul@adomain.com")<br/>
        SetRecipients("lisa@adomain.com")<br/>
        SetSubject("Document Integrity")<br/>
        SetEMailBody("Document Page Types and counts are accurate. Thanks for your help.")<br/>
        SendEMail()
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>


  <ref id="SetRecipients" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets email recipients' address(es).">
    <ap>
      Email address(es) of recipient(s).  You can either call this action multiple times to add multiple recipients,
      or you can enter multiple email addresses separated by commas.
    </ap>
    <h>
      The email address of the email’s primary recipients.
      <e>
        <b>SetRecipients("lisa@adomain.com,Joe@adomain.com")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if you do not enter an email addresses parameter,
      if the address is rejected by the mail system or if the email object cannot be initialized.
      Otherwise, <b>True.</b><br/><br/>

      Invalid email addresses may not be reported until SendEMail is called.
    </ret>
    <see>SetCarbonCopyRcpts, SetBlindCarbonCopyRcpts</see>
  </ref>


  <ref id="SetCarbonCopyRcpts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set Carbon Copy recipients' email address(es).">
    <ap>
      Email addresses to receive a copy of the email as a carbon copy.
      You can enter multiple email addresses separated by commas.
    </ap>
    <h>
      Adds addresses to the Cc (Carbon Copy) portion of the email’s header.
      <e>
        SetRecipients("lisa@adomain.com")<br/>
        <b>SetCarbonCopyRcpts("cindy@anotherdomain.org")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if you do not enter an email addresses parameter,
      if the address is rejected by the mail system or if the email object cannot be initialized.
      Otherwise, <b>True.</b><br/><br/>

      Invalid email addresses may not be reported until SendEMail is called.
    </ret>
    <see>SetBlindCarbonCopyRcpts, SetRecipients</see>
</ref>


  <ref id="SetBlindCarbonCopyRcpts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets Blind Carbon Copy recipients' email address(es).">
    <ap>
      The email addresses to receive a copy of the email as a blind carbon copy.
      You can enter multiple email addresses separated by commas.
    </ap>
    <h>
      Adds addresses to the Bcc (Blind Carbon Copy) portion of the email’s header.
      <e>
        SetRecipients("lisa@monarchy.com")<br/>
        <b>SetBlindCarbonCopyRcpts("james@regency.com")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if you do not enter an email addresses parameter,
      if the address is rejected by the mail system or if the email object cannot be initialized.
      Otherwise, <b>True.</b><br/><br/>

      Invalid email addresses may not be reported until SendEMail is called.
    </ret>
    <see>SetCarbonCopyRcpts, SetRecipients</see>
</ref>


  <ref id="SetAttachment" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Adds a file attachment to an email.">
    <ap>
      The file’s path, name and extension.  Smart Parameters are supported.
    </ap>
    <h>
      Attaches the specified file to the current email.
      <e>
        <b>SetAttachment("h:\MyDir\MQSW\export\+@BATCHID+.txt")</b><br/>
        This example attaches the Export file of the current batch to the email.
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the file does not exist or cannot be attached. Otherwise, <b>True.</b>
    </ret>
</ref>


  <ref id="SetEmailBody" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Sets the text of the email’s body.">
    <ap>
      The email message text.  Smart Parameters are supported.
    </ap>
    <h>
      Sets the text of the email’s body.
      <e>
        SetSubject("Document Integrity")<br/>
        <b>SetEMailBody("Document Page Types and counts are accurate. Thanks for your help.")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the mail object cannot be initialized.  Otherwise, <b>True.</b>
    </ret>
    <see>SetAttachment</see>
  </ref>


  <ref id="SetSubject" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Sets the text for the email's Subject field.">
    <ap>
      The subject line of the email.  Smart Parameters are supported.
    </ap>
    <h>
      Sets the text for the email Subject field.
      It is recommended that the subject line be no longer than 78 characters as this is a 
      common subject line length limitation.  Some systems may support even shorter lengths, 
      truncating the subject.  Our testing has been successful with lengths up to 255 characters.  
      It is recommended to test your settings and use lengths appropriate for your systems.<br/>
      <e>
        <b>SetSubject("Document Integrity")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the mail object cannot be initialized.  Otherwise, <b>True.</b>
    </ret>
   
  </ref>


  <ref id="SetSender" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the sending email address.">
    <ap>
      The sender’s email address.
    </ap>
    <h>
      Sets the email address of the sender for the current email.
      When using the CDOSYS object, use this action.
      When using the Outlook object, the current email account is used as the sender.
      <e>
        SetRecipients("lisa@adomain.com")<br/>
        <b>SetSender("paul@adomain.com")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the mail object cannot be initialized.  Otherwise, <b>True.</b><br/><br/>

      Invalid email addresses may not be reported until SendEMail is called.
    </ret>
  
  </ref>


  <ref id="SendEMail" access="public" bInter="bInter" bDebug="bDebug" qi="Sends an email.">
    <ap>
      None.
    </ap>
    <h>
      Sends an email assembled by previous actions.
      Typically, this is the final action in an email ruleset.  At a minimum, the SetSender and SetRecipients
      actions must be called prior to sending an email.<br/><br/>

      After sending, this action will discard the contents of the email in memory.  Calls to the email actions
      after SendEMaill will cause the creation of a new email message.
      <e>
        SetSender("paul@adomain.com")<br/>
        SetRecipients("lisa@adomain.com,beth@adomain.com")<br/>
        SetSubject("Document Integrity")<br/>
        SetEMailBody("Document Page Types and counts are accurate. Thanks for your help.")<br/>
        SendEMail()
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the rule does not include a previous SetRecipients action, or if the email cannot be sent. Otherwise, <b>True.</b>
      If the email cannot be sent, the batch will be set to abort.
    </ret>
  </ref>
</help>

</rrx>
<rrx namespace="equalize" src="c:\datacap\RRS\equalize.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="EqualizeUnbalancedImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 'Resolves differences in the dpi (dots per inch) resolutions along the horizontal (X) and vertical (Y) planes of one ore more faxed images in a batch."]]>
<![CDATA[
]]>
<![CDATA[  'Integer value which determines the cut-off point for the resolution which should be equalized:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  <scr>EqualizeUnbalancedImage(0)</scr>, for example, specifies that there is no cut-off point: ]]>
<![CDATA[
]]>
<![CDATA[  '  all images will be subject to equalization. <br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  <scr>EqualizeUnbalancedImage(20)</scr> establishes a cut-off point of 200(x)/180(y). This ]]>
<![CDATA[
]]>
<![CDATA[  '  means that the action will equalize all images with this resolution ratio and more (200/180, ]]>
<![CDATA[
]]>
<![CDATA[  '  200/160 etc.) - but will ignore all images with balance ratios less than 200/180 (in this example.)<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  <b>Alert!</b> Standard Mode fax resolution in Dots per Inch (DPI) is 204/98; Fine Mode fax ]]>
<![CDATA[
]]>
<![CDATA[  '  resolution is 204/196.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Dim percent]]>
<![CDATA[
]]>
<![CDATA[   Dim nWidth, nHeight, nBits]]>
<![CDATA[
]]>
<![CDATA[   Dim nX,nY]]>
<![CDATA[
]]>
<![CDATA[   Dim Ratio]]>
<![CDATA[
]]>
<![CDATA[   const Ratio200100 = 2 ]]>
<![CDATA[
]]>
<![CDATA[   Dim GoodRatio]]>
<![CDATA[
]]>
<![CDATA[   Dim m_Image]]>
<![CDATA[
]]>
<![CDATA[   Dim m_ProcessedImage,m_EmergCopy]]>
<![CDATA[
]]>
<![CDATA[   EqualizeUnbalancedImage = false]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If(CurrentObj.ObjectType <> DCO_PAGE) Then]]>
<![CDATA[
]]>
<![CDATA[       writelog("This action needs to be called at the page level. Returning false.")]]>
<![CDATA[
]]>
<![CDATA[       exit function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(Not IsNumeric(StrParam)) Then ]]>
<![CDATA[
]]>
<![CDATA[	    writelog ("Invalid parameter passed. The action expects a parameter of numeric type. Valid values: 0-99. Returning false.")]]>
<![CDATA[
]]>
<![CDATA[        exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   percent = cInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if(percent < 0 or percent > 99) Then]]>
<![CDATA[
]]>
<![CDATA[	    writelog ("Parameter should be numeric value of unbalancing in percentage 0..99. Returning false.")]]>
<![CDATA[
]]>
<![CDATA[        exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   GoodRatio = Ratio200100 - (Ratio200100 - 1)*percent/100]]>
<![CDATA[
]]>
<![CDATA[   ' ratio >= GoodRatio or ratio <= 1/GoodRatio   is processed]]>
<![CDATA[
]]>
<![CDATA[   'ratio, which belongs to [1/GoodRatio , GoodRatio] is good and image will not be processed]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(CurrentObj.ImageName="") Then]]>
<![CDATA[
]]>
<![CDATA[       writelog("Warning: Current object is not assosciated with an image.")]]>
<![CDATA[
]]>
<![CDATA[       exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Set m_Image=CreateObject("DCImage.DCImageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   m_ProcessedImage = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[   m_Image.FileName=m_ProcessedImage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(m_Image.FileName<>m_ProcessedImage) Then]]>
<![CDATA[
]]>
<![CDATA[	    writelog("error in reading image file: " & m_Image.GetLastError())]]>
<![CDATA[
]]>
<![CDATA[	    Set m_Image = Nothing]]>
<![CDATA[
]]>
<![CDATA[        exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Call m_Image.GetImageInfo(nWidth, nHeight, nBits)]]>
<![CDATA[
]]>
<![CDATA[   Call m_Image.GetRes(nX, nY)]]>
<![CDATA[
]]>
<![CDATA[   strInfo = "width: " & nWidth & "height: " & nHeight & "bits: " & nbits & Vbcrlf &_]]>
<![CDATA[
]]>
<![CDATA[	"res X: " & nX & "res Y: " & nY]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   WriteLog ("Image attriutes: " & strInfo)]]>
<![CDATA[
]]>
<![CDATA[   ' if image has resolution 100x200 the ratio nX/nY = 1/2 or nX/nY = 2 = 1/(1/2)]]>
<![CDATA[
]]>
<![CDATA[   ' we will check]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   If nY = 0 Then]]>
<![CDATA[
]]>
<![CDATA[        WriteLog "Warning: the current image's Y resolution is less than or equal to zero. Skipping image...Action returns FALSE." ]]>
<![CDATA[
]]>
<![CDATA[	    Set m_Image = Nothing]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[   Ratio = nX/nY]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if(ratio >= GoodRatio or ratio <= 1/GoodRatio) Then]]>
<![CDATA[
]]>
<![CDATA[        If nX > nY Then]]>
<![CDATA[
]]>
<![CDATA[            Call m_Image.SetRes(nX, nY*2)]]>
<![CDATA[
]]>
<![CDATA[            Call m_Image.ResizeImage(nWidth, nHeight*2)]]>
<![CDATA[
]]>
<![CDATA[        else]]>
<![CDATA[
]]>
<![CDATA[            Call m_Image.SetRes(2*nX, nY)]]>
<![CDATA[
]]>
<![CDATA[            Call m_Image.ResizeImage(2*nWidth, nHeight)]]>
<![CDATA[
]]>
<![CDATA[         end if]]>
<![CDATA[
]]>
<![CDATA[        ' save image]]>
<![CDATA[
]]>
<![CDATA[        ' create emergency copy]]>
<![CDATA[
]]>
<![CDATA[        m_EmergCopy = Mid(m_ProcessedImage,len(m_ProcessedImage)-1) & "0"]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[	    Call FileMgr.CopyFile(m_ProcessedImage, m_EmergCopy)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Call FileMgr.DeleteFile(m_ProcessedImage, True)]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[	    if(Not m_Image.Save(m_ProcessedImage)) Then ]]>
<![CDATA[
]]>
<![CDATA[	        writelog("Unable to save: " & m_Image.GetLastError())]]>
<![CDATA[
]]>
<![CDATA[            ' restore file from emegrency copy]]>
<![CDATA[
]]>
<![CDATA[            Call FileMgr.MoveFile(m_EmergCopy,m_ProcessedImage)]]>
<![CDATA[
]]>
<![CDATA[            EqualizeUnbalancedImage = false]]>
<![CDATA[
]]>
<![CDATA[        else]]>
<![CDATA[
]]>
<![CDATA[            Call FileMgr.DeleteFile(m_EmergCopy, True)]]>
<![CDATA[
]]>
<![CDATA[            EqualizeUnbalancedImage = true]]>
<![CDATA[
]]>
<![CDATA[        end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[        writelog "The image is already balanced."]]>
<![CDATA[
]]>
<![CDATA[        EqualizeUnbalancedImage = true]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set m_Image = Nothing]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' Equalize Actions help
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
]]>
     
<ref id="EqualizeUnbalancedImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Resolves differences in the dpi (dots per inch) resolutions along the horizontal (X) and vertical (Y) planes of one ore more faxed images in a batch.">
  <ap>
    Integer value which determines the cut-off point for the resolution which should be equalized:<br/><br/>

    <scr>EqualizeUnbalancedImage(0)</scr>, for example, specifies that there is no cut-off point: 
    all images will be subject to equalization. <br/><br/>

    <scr>EqualizeUnbalancedImage(20)</scr> establishes a cut-off point of 200(x)/180(y). This 
    means that the action will equalize all images with this resolution ratio and more (200/180, 
    200/160 etc.) - but will ignore all images with balance ratios less than 200/180 (in this example.)<br/><br/>

    <b>Alert!</b> Standard Mode fax resolution in Dots per Inch (DPI) is 204/98; Fine Mode fax 
    resolution is 204/196.
  </ap>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the parameter is not numeric or if the rule containing the action is not bound 
    to a Page object of the Document Hierarchy. Otherwise, <b>True.</b>
  </ret>
  <h>
    Resolves differences in the dpi (dots per inch) resolutions along the horizontal (X) and 
    vertical (Y) planes of one ore more faxed images in a batch.<br/><br/>

    The action selects images from the batch in response to the parameter you enter, and 
    produces new images with 200 x 200 dpi.
    <e>
      <b>EqualizeUnbalanceImage(0)</b> 
    </e>
  </h>
</ref>
</help>

</rrx>
<rrx namespace="Export" src="c:\datacap\RRS\Export.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="BatchVariable_ExportValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oBatch]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT Batch Variable")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oBatch = currentobj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While Not (oBatch.ObjectType <= 0)]]>
<![CDATA[
]]>
<![CDATA[		Set oBatch = oBatch.Parent()		]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Variable Value is :'" & oBatch.Variable(StrParam) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDebug, oBatch.Variable(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	BatchVariable_ExportValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("BatchVariable_ExportValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "BatchVariable_ExportValue returns " & BatchVariable_ExportValue) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DocumentVariable_ExportValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT Document Variable Input: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set odoc = currentobj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While Not (oDoc.ObjectType <= 1)]]>
<![CDATA[
]]>
<![CDATA[		Set oDoc = oDoc.Parent()		]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Variable Value is :'" & oDoc.Variable(StrParam) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDebug, oDoc.Variable(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	DocumentVariable_ExportValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("DocumentVariable_ExportValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "DocumentVariable_ExportValue returns " & DocumentVariable_ExportValue) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PageVariable_ExportValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT Page Variable")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While Not (oPage.ObjectType <= 2)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()		]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Variable Value of " & StrParam & " is :'" & oPage.Variable(StrParam) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDebug, oPage.Variable(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	PageVariable_ExportValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("PageVariable_ExportValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "PageVariable_ExportValue returns " & PageVariable_ExportValue) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="BlankFields" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim Cntr]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("ADD Blank Field")]]>
<![CDATA[
]]>
<![CDATA[	BlankFields = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(Strparam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(StrParam) then Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Cntr = 1 to StrParam]]>
<![CDATA[
]]>
<![CDATA[		Call WriteExport(bInter, bDeBug, "")]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Added " & cstr(StrParam) & " BlankFields to the Export.")]]>
<![CDATA[
]]>
<![CDATA[	BlankFields = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function BlankFields") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="BlankLines" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sFileContent]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    Strparam=replace(Strparam,Chrw(32),"")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) or len(Trim(Strparam))=0 Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be numeric. Defaulting to 1") ]]>
<![CDATA[
]]>
<![CDATA[        StrParam = 1]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    StrParam = abs(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    If StrParam-cint(Strparam)>0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be an Integer. Parameter will be rounded to nearest integer.") ]]>
<![CDATA[
]]>
<![CDATA[        StrParam = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If StrParam <= 0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be an Integer greater than Zero. Defaulting to 1") ]]>
<![CDATA[
]]>
<![CDATA[        StrParam = 1]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsObject(g_ExportFile) Then ]]>
<![CDATA[
]]>
<![CDATA[		Call OpenExportFile(bInter, bDebug)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsObject(g_ExportFile) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Unable to find open file.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Adding Blank LINE x " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(g_LastExportValue)>0 then]]>
<![CDATA[
]]>
<![CDATA[        If NOT(right(g_LastExportValue,1)=Chrw(10) or right(g_LastExportValue,1)=Chrw(13)) then]]>
<![CDATA[
]]>
<![CDATA[            StrParam=StrParam+1]]>
<![CDATA[
]]>
<![CDATA[        end if    ]]>
<![CDATA[
]]>
<![CDATA[    End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    g_LastExportValue=vbcrlf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call g_ExportFile.WriteBlankLines(Cint(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	BlankLines = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function BlankLines") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="BPilot" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("BPilot Input: " & strparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Value = Eval("Pilot." & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<> 0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("'" & Strparam & "' is not a valid BPilot Property. Please use a valid BPilot property for this Action.")]]>
<![CDATA[
]]>
<![CDATA[    BPilot=False]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call WriteExport(bInter, bDebug, Value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  BPilot = True]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function BPilot") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CloseExportFile" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	g_bnewLine = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 	CloseExportFile = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsAlive(g_ExportFile) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Closing Export file...")]]>
<![CDATA[
]]>
<![CDATA[		g_ExportFile.Close]]>
<![CDATA[
]]>
<![CDATA[		g_ExportFile = Null]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "File Closed")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("Export File is not Open.")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function CloseExportFile") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DCOProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  Writelog("DCOProperty Input: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Value = Eval("CurrentObj." & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("'" & StrParam & "' is not a valid DCO Property. Please use a valid DCO property for the calling Object.")]]>
<![CDATA[
]]>
<![CDATA[    Err.clear]]>
<![CDATA[
]]>
<![CDATA[    DCOProperty=False]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call WriteExport(bInter, bDebug, Value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  DCOProperty = True]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function DCOProperty") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportAllFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ExportAllFields = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Calling ExportAllFields")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType <> 2 then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called from a DCO Page. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call u_ExportChildren(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call NewLine(bInter, bDebug)		'add new line for next page]]>
<![CDATA[
]]>
<![CDATA[	ExportAllFields = True ]]>
	</g>
</af>
<af name="ExportFieldValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim setupObj]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld]]>
<![CDATA[
]]>
<![CDATA[	Dim nCount]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim VarId]]>
<![CDATA[
]]>
<![CDATA[	Dim aObjID	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    ExportFieldValue= False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(trim(StrParam))=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("This action requires a parameter.")]]>
<![CDATA[
]]>
<![CDATA[        Exit function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    writelog("EXPORT FIELD " & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(CurrentObj) Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If CurrentObj.Objecttype<>2 then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Action must be called from a DCO Page.") ]]>
<![CDATA[
]]>
<![CDATA[            Exit Function]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Finding DCO Value:'" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Set oFld = RReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If NOT(oFld is nothing) then]]>
<![CDATA[
]]>
<![CDATA[			'Check for variable in sFindObjID argument. Flag is the Decimal '.' character (period).]]>
<![CDATA[
]]>
<![CDATA[			aObjID = split(StrParam & ".",".")]]>
<![CDATA[
]]>
<![CDATA[			VarID = trim(aObjID(1))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			If Len(VarID)=0 then]]>
<![CDATA[
]]>
<![CDATA[				sValue = CheckDICT(oFld)]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				sValue = oFld.Variable(VarID)]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "DCO Value is :'" & sValue & "' ")]]>
<![CDATA[
]]>
<![CDATA[            If u_CheckNoExportStatus(oFld)=TRUE then]]>
<![CDATA[
]]>
<![CDATA[  			    Call WriteExport(bInter, False, sValue)]]>
<![CDATA[
]]>
<![CDATA[	        End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[			ExportFieldValue= True]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Object '" & StrParam & "' Not Found.")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			ExportFieldValue = False]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(Space(5) & "There is No Current Object.")]]>
<![CDATA[
]]>
<![CDATA[		ExportFieldValue= False	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("END Export Field. Returns: " & ExportFieldValue)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ExportFieldValue") ]]>
	</g>
</af>
<af name="ExportMYValue" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT MY Value" & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "MY Value is :'" & CurrentObj.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[  If u_CheckNoExportStatus(CurrentObj)=TRUE then]]>
<![CDATA[
]]>
<![CDATA[  	Call WriteExport(bInter, bDebug, CheckDICT(CurrentObj))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ExportMYValue= True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ExportMYValue") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportSmartParameter" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  Dim oVal]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Writelog(Space(5) & "Finding Smart Parameter Value...")]]>
<![CDATA[
]]>
<![CDATA[  oVal = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not(oVal = "") Then	 ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(Space(5) & "Found Value is :'" & oVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog(Space(5) & "No results from smart parameter evaluation.")]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Call WriteExport(bInter, bDebug, oVal)]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  ExportSmartParameter=True]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function ExportSmartParameter") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportToBatchDir" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sBatchPath]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sBatchPath = Pilot.BatchDir]]>
<![CDATA[
]]>
<![CDATA[	ExportToBatchDir = SetExportPath(bInter, bDebug, sBatchPath) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GetDATE" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim dd,ddd,mm,yyyy,yy,y,m,d]]>
<![CDATA[
]]>
<![CDATA[	Dim DateText]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with current Date value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to update the field with]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to default value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(trim(StrParam))=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[        GetDATE = False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    GetDATE = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If InStr(StrParam,"*")>0 Then StrParam = "mm/dd/yyyy"]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"c","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam," "," & Chrw(32) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"/"," & Chrw(47) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"day","dd")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"month","mm")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"year","yyyy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"julian","y")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("DateStamp Strparam= '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	d = Day(Now)]]>
<![CDATA[
]]>
<![CDATA[	dd = Right("0" & d,2)]]>
<![CDATA[
]]>
<![CDATA[	yyyy = Year(Now)]]>
<![CDATA[
]]>
<![CDATA[	yy = Right(yyyy,2)]]>
<![CDATA[
]]>
<![CDATA[	m = Month(Now)]]>
<![CDATA[
]]>
<![CDATA[	mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[	ccyy = yyyy]]>
<![CDATA[
]]>
<![CDATA[	y = DatePart("y",Now)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  DateText = Eval(Strparam)]]>
<![CDATA[
]]>
<![CDATA[  Call WriteExport(bInter, bDeBug, DateText )]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("GetDATE returns true. Value: " & DateText)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GetDATE") ]]>
	</g>
</af>
<af name="GetProfileString" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim aParams]]>
<![CDATA[
]]>
<![CDATA[  Dim sHeader]]>
<![CDATA[
]]>
<![CDATA[  Dim sSubSection]]>
<![CDATA[
]]>
<![CDATA[  Dim sFileNameINI]]>
<![CDATA[
]]>
<![CDATA[  Dim INIvalue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("GetProfileString Input: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If len(Trim(StrParam))=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Parameter is Empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[     GetProfileString = False]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  aParams = Split(StrParam & ",," , ",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sHeader = aParams(0)]]>
<![CDATA[
]]>
<![CDATA[  sSubSection = aParams(1)]]>
<![CDATA[
]]>
<![CDATA[  sFileNameINI = aParams(2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If FileMgr.FileExists(Pilot.BatchDir & "\" & sFileNameINI) Then ]]>
<![CDATA[
]]>
<![CDATA[    ' Writelog("Getting section: " & sSubSection & " from file: " & Pilot.BatchDir & "\" & sFileNameINI)]]>
<![CDATA[
]]>
<![CDATA[    INIvalue = Pilot.GetProfileString(sHeader, sSubSection,"",Pilot.BatchDir & "\" & sFileNameINI)]]>
<![CDATA[
]]>
<![CDATA[    Call WriteExport(bInter, bDebug, INIvalue)]]>
<![CDATA[
]]>
<![CDATA[    GetProfileString = True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Could not locate file: " & Pilot.BatchDir & "\" & sFileNameINI)]]>
<![CDATA[
]]>
<![CDATA[    GetProfileString = False]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function GetProfileString") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GetTime" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim mm,ss,hh,hhhh,m,s,h]]>
<![CDATA[
]]>
<![CDATA[	Dim TimeText]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    GetTime = False  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    If len(trim(StrParam))=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ' Remove all valid parameters from input string.]]>
<![CDATA[
]]>
<![CDATA[    ' If sTest is empty at the end, then only valid input strings were passed in.]]>
<![CDATA[
]]>
<![CDATA[    sTest = LCASE(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"minute","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"second","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"hour","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"min","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"sec","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"hr","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"h","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"m","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"s","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,":","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"/","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest," ","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"&","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"-","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"'","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"*","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(sTest)>0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Invalid Parameter Characters '" & sTest & "' found. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with current Time value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to update the field with]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to default value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'WriteLog("Gettime Strparam= '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[  If instr(StrParam,"*")>0 Then StrParam = "HH:MM:SS"]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam," "," & CHRW(32) &")   'NOTE CHRW is upper case so the 'hr' replace does not change chrw to chhw]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"/"," & CHRW(47) &")  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,":"," & CHRW(58) &")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"-"," & CHRW(45) &")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"'"," & CHRW(39) &")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"minute","mm")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"min","mm")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"second","ss")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"sec","ss")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"hr","hh")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"hour","hh")]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("TimeStamp Strparam= '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	m = Minute(Now)]]>
<![CDATA[
]]>
<![CDATA[	s = Second(Now)]]>
<![CDATA[
]]>
<![CDATA[	h = Hour(Now)]]>
<![CDATA[
]]>
<![CDATA[	hhhh = hh]]>
<![CDATA[
]]>
<![CDATA[	mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[	ss = Right("0" & s,2)]]>
<![CDATA[
]]>
<![CDATA[	hh = Right("0" & h,2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TimeText = Eval(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If err.number=0 then GetTime = True]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDeBug, TimeText)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("GetTime returns " & GetTime & ". Value: " & TimeText)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GetTime") ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="LineItem_AddElement" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim Lie, nLie]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LineItem_AddElement = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	strParam = trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(2) & "Starting LineItem_AddElement")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For Lie = 0 to ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[		if g_aLineItems(Lie) = strParam then ]]>
<![CDATA[
]]>
<![CDATA[			writelog(space(7) & "Element already exists in Line Item Element Array.")	]]>
<![CDATA[
]]>
<![CDATA[			exit Function]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[	Next 'Lie]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(5) & "Adding Element '" & strparam & "' to Line Item Element Array.")	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nLie = ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[	Redim Preserve g_aLineItems(nLie + 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_aLineItems(nLie) = strParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_AddElement")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "LineItem_AddElement Finished TRUE. Added element " & nLie & " '" & strparam & "'.") ]]>
	</g>
</af>
<af name="LineItem_BlankFields" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim Lie, nLie]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LineItem_BlankFields = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Trim(Strparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(2) & "Starting LineItem_BlankFields")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(StrParam) then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter must be NUMERIC")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	LineItem_BlankFields = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(5) & "Adding '" & StrParam & "' blank field Elements to Line Item Element Array.")	]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	For Cntr = 1 to StrParam]]>
<![CDATA[
]]>
<![CDATA[    nLie = ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[	  Redim Preserve g_aLineItems(nLie + 1)  ]]>
<![CDATA[
]]>
<![CDATA[    g_aLineItems(nLie) = ""  ]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_BlankFields")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "LineItem_BlankFields Finished TRUE. Added element " & nLie & " '" & strparam & "'.") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LineItem_SmartParameter" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim nLie]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LineItem_SmartParameter = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 	WriteLog(Space(2) & "Starting LineItem_SmartParameter")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  For Lie = 0 to ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[		if g_aLineItems(Lie) = strParam then ]]>
<![CDATA[
]]>
<![CDATA[			writelog(space(7) & "Element already exists in Line Item Element Array.")	]]>
<![CDATA[
]]>
<![CDATA[			exit Function]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[  Next 'Lie]]>
<![CDATA[
]]>
<![CDATA[  	 ]]>
<![CDATA[
]]>
<![CDATA[  nLie = ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[  Redim Preserve g_aLineItems(nLie + 1)  ]]>
<![CDATA[
]]>
<![CDATA[  g_aLineItems(nLie) = StrParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog(Space(5) & "Adding SmartParameter " & StrParam & " to Line Item Array at position " & nLie)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If not g_dictLISmartParam.Exists(nLie) then]]>
<![CDATA[
]]>
<![CDATA[    call g_dictLISmartParam.Add(nLie,StrParam)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_SmartParameter")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "LineItem_SmartParameter Finished TRUE. Added element " & nLie & " '" & strparam & "'.") ]]>
	</g>
</af>
<af name="LineItem_ClearElements" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Redim g_aLineItems(0)]]>
<![CDATA[
]]>
<![CDATA[  Call g_dictLISmartParam.RemoveAll() ]]>
<![CDATA[
]]>
<![CDATA[	LineItem_ClearElements = True	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_ClearElements") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LineItem_ExportElements" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	LineItem_ExportElements = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "Starting LineItem_ExportElements")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim n]]>
<![CDATA[
]]>
<![CDATA[  Dim LieObj]]>
<![CDATA[
]]>
<![CDATA[  Dim oVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	For n = 0 to ubound(g_aLineItems)-1]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(space(5) & "Exporting element " & n & ": '" & g_aLineItems(n) & "'.")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If g_aLineItems(n)<>"" then ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      If g_dictLISmartParam.Exists(n) then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      	Writelog(Space(5) & "Finding Smart Parameter Value")]]>
<![CDATA[
]]>
<![CDATA[		    oVal = MetaWord(g_aLineItems(n))]]>
<![CDATA[
]]>
<![CDATA[				               ]]>
<![CDATA[
]]>
<![CDATA[        Call WriteExport(bInter, bDebug, oVal)]]>
<![CDATA[
]]>
<![CDATA[        WriteLog(space(7) & "Value '" & oVal & "'.")   ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    		Set LieObj = CurrentObj.FindChild(g_aLineItems(n))]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If not LieObj is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[		  	  Call WriteExport(bInter, bDebug, CheckDICT(LieObj))]]>
<![CDATA[
]]>
<![CDATA[			    WriteLog(space(7) & "Value '" & LieObj.text & "'.")]]>
<![CDATA[
]]>
<![CDATA[		    Else	]]>
<![CDATA[
]]>
<![CDATA[			    WriteLog(space(7) & "Element is NOTHING")]]>
<![CDATA[
]]>
<![CDATA[		    End if  ]]>
<![CDATA[
]]>
<![CDATA[      End if        ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      WriteLog(space(7) & "Exporting Blank field.")]]>
<![CDATA[
]]>
<![CDATA[      Call WriteExport(bInter, bDebug,"")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    		]]>
<![CDATA[
]]>
<![CDATA[	Next 'n]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_ExportElements")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "LineItem_ExportElements Returns TRUE") ]]>
	</g>
</af>
<af name="NewLine" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_bNewLine = True]]>
<![CDATA[
]]>
<![CDATA[	newLine = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function NewLine") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SaveFilePathAsVariable" access="public" bInter="bInter" bDebug="bDebug" strParam="strparam">
	<g>
<![CDATA[
]]>
<![CDATA[	sPath = g_ExportPath & "\" & g_ExportName & g_ExportExtn]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Saveing Export File Path as Variable " & strparam & "  Path: " & g_ExportPath & "\" & g_ExportName & g_ExportExtn)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable(StrParam) = g_ExportPath & "\" & g_ExportName & g_ExportExtn]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SaveFilePathAsVariable = True ]]>
	</g>
</af>
<af name="SetCSV" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	  dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    strParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(Trim(StrParam))=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[        SetCSV = False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If StrParam = "TRUE" Or StrParam = "FALSE" or StrParam = "ON" or StrParam = "OFF" Then]]>
<![CDATA[
]]>
<![CDATA[		g_CSVformat = strParam]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SetCSV = False]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	SetCSV = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Comma Separated file output is set to " & SetCSVformat)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetCSV") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetElementSeparator" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & StrParam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if ucase(trim(StrParam)) = "OFF" or ucase(trim(StrParam)) = "FALSE" then ]]>
<![CDATA[
]]>
<![CDATA[		g_ElementSeparator = Space(1)]]>
<![CDATA[
]]>
<![CDATA[    g_CSVformat = "OFF"]]>
<![CDATA[
]]>
<![CDATA[	else]]>
<![CDATA[
]]>
<![CDATA[		if ucase(trim(StrParam)) = "ON" or ucase(trim(StrParam)) = "TRUE" then ]]>
<![CDATA[
]]>
<![CDATA[      StrParam = Space(1)]]>
<![CDATA[
]]>
<![CDATA[    end if  ]]>
<![CDATA[
]]>
<![CDATA[		g_ElementSeparator = StrParam]]>
<![CDATA[
]]>
<![CDATA[    g_CSVformat = "OTHER"]]>
<![CDATA[
]]>
<![CDATA[	end if		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetElementSeparator= True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Element Separator is '" & StrParam & "'.")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetElementSeparator") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetExportPath" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sDriveName]]>
<![CDATA[
]]>
<![CDATA[	Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SET EXPORT PATH")]]>
<![CDATA[
]]>
<![CDATA[	SetExportPath = False]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    strParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	sDriveName = FileMgr.GetDriveName(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not FileMgr.DriveExists(sDriveName) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "SET EXPORT PATH FAILED. NO SUCH DRIVE : " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		SetExportPath = False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If FileMgr.FolderExists(strParam) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Folder Exists. Setting Export path to: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		g_ExportPath = strParam]]>
<![CDATA[
]]>
<![CDATA[		SetExportPath = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Folder does Not Exist. Beginning MakePath Function.")]]>
<![CDATA[
]]>
<![CDATA[		If MakePath(strParam) Then]]>
<![CDATA[
]]>
<![CDATA[			SetExportPath = True]]>
<![CDATA[
]]>
<![CDATA[			g_ExportPath = strParam 	]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("END Set Export Path")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetExportPath") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetExtensionName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		Dim i, nChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On error resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    SetExtensionName=False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[    sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[    If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     strParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    g_ExportExtn = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    If len(g_ExportExtn)>0 then]]>
<![CDATA[
]]>
<![CDATA[        While left(g_ExportExtn,1)="."  ]]>
<![CDATA[
]]>
<![CDATA[            g_ExportExtn = Right(g_ExportExtn,len(g_ExportExtn)-1)]]>
<![CDATA[
]]>
<![CDATA[        Wend]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Check for windows prohibited file name characters *<>[]"/|\:? and control characters '\p{C}']]>
<![CDATA[
]]>
<![CDATA[    sPattern = "\*\<\>\[\]\/\|\\:\?"""]]>
<![CDATA[
]]>
<![CDATA[    If DCGlobalStrings.RegExIsMatch(g_ExportExtn,"[" & sPattern & "\p{C}]") then]]>
<![CDATA[
]]>
<![CDATA[      Call writelog("Invalid Characters found in extension name '*<>[]""/|\:?' or control characters.  Exiting function with Status FAILED.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Setting Export File Extension Name to : " & g_ExportExtn)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    g_ExportExtn = "." & g_ExportExtn]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetExtensionName = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetExtensionName") ]]>
	</g>
</af>
<af name="SetFileName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	g_ExportName = ""]]>
<![CDATA[
]]>
<![CDATA[	on error resume next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    g_ExportName=Trim(sSmartParam)  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  If instr(strParam,",") > 0 or left(StrParam,1) = "@" or left(StrParam,1) = "#" then]]>
<![CDATA[
]]>
<![CDATA[		  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[		  Dim n]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		  aStrParam = Split(StrParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[		  For n = 0 to ubound(aStrParam) - 1]]>
<![CDATA[
]]>
<![CDATA[			  Dim sArg]]>
<![CDATA[
]]>
<![CDATA[			  sArg = ucase(trim(aStrParam(n)))	]]>
<![CDATA[
]]>
<![CDATA[			  WriteLog("Processing Arg# " & n & ". Argument: " & sArg)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			  if len(sArg) = 0 then exit For]]>
<![CDATA[
]]>
<![CDATA[			  if left(sArg,1) = "@" then ]]>
<![CDATA[
]]>
<![CDATA[				  Select Case sArg]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					  Case "@BATCHID"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & replace(Pilot.BatchID,".","") ]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding BatchID to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[					  Case "@ID"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & CurrentObj.ID]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding Object ID to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[					  Case "@STATUS"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & CurrentObj.Status]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding Object Status to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[					  Case "@TYPE"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & CurrentObj.Type]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding Object Type to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[					  Case "@DATE"]]>
<![CDATA[
]]>
<![CDATA[						  n = n + 1]]>
<![CDATA[
]]>
<![CDATA[						  sArg = Trim(aStrParam(n))]]>
<![CDATA[
]]>
<![CDATA[						  if len(sArg) = 0 then sArg= "mm/dd/yyyy"]]>
<![CDATA[
]]>
<![CDATA[						  If InStr(sArg,"*")>0 Then sArg= "mm/dd/yyyy"]]>
<![CDATA[
]]>
<![CDATA[							  sArg= LCase(sArg)]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"c","y")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg," "," & Chrw(32) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"/"," & Chrw(47) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"day","dd")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"month","mm")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"year","yyyy")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"julian","y")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"jjj","y")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  WriteLog("Export filename DateStamp = '" & sArg & "' ")]]>
<![CDATA[
]]>
<![CDATA[  														]]>
<![CDATA[
]]>
<![CDATA[							  d = Day(Now)]]>
<![CDATA[
]]>
<![CDATA[							  dd = Right("0" & d,2)]]>
<![CDATA[
]]>
<![CDATA[							  yyyy = Year(Now)]]>
<![CDATA[
]]>
<![CDATA[							  yy = Right(yyyy,2)]]>
<![CDATA[
]]>
<![CDATA[							  m = Month(Now)]]>
<![CDATA[
]]>
<![CDATA[							  mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[							  ccyy = yyyy]]>
<![CDATA[
]]>
<![CDATA[							  y = DatePart("y",Now)]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[  						   	  DateVal = Eval(sArg)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  DateVal = Replace(DateVal ," ","")]]>
<![CDATA[
]]>
<![CDATA[							  DateVal = Replace(DateVal ,"/","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & DateVal]]>
<![CDATA[
]]>
<![CDATA[  					]]>
<![CDATA[
]]>
<![CDATA[					  Case "@TIME"]]>
<![CDATA[
]]>
<![CDATA[						  n = n + 1]]>
<![CDATA[
]]>
<![CDATA[						  sArg = Trim(aStrParam(n))]]>
<![CDATA[
]]>
<![CDATA[						  if len(sArg) = 0 then sArg= "HH:MM:SS"]]>
<![CDATA[
]]>
<![CDATA[						  If Trim(sArg) = "*" Then sArg= "HH:MM:SS"]]>
<![CDATA[
]]>
<![CDATA[							  sArg= LCase(sArg)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"/"," & Chrw(47) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg," "," & Chrw(32) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,":"," & Chrw(58) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"min","mm")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"minute","mm")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"sec","ss")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"second","ss")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"hr","hh")]]>
<![CDATA[
]]>
<![CDATA[							  WriteLog("TimeStamp sArg= '" & sArg& "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  m = Minute(Now)]]>
<![CDATA[
]]>
<![CDATA[							  s = Second(Now)]]>
<![CDATA[
]]>
<![CDATA[							  h = Hour(Now)]]>
<![CDATA[
]]>
<![CDATA[							  hhhh = hh]]>
<![CDATA[
]]>
<![CDATA[							  mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[							  ss = Right("0" & s,2)]]>
<![CDATA[
]]>
<![CDATA[							  hh = Right("0" & h,2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  TimeText = Eval(sArg)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  TimeText = Replace(TimeText ,"/","")]]>
<![CDATA[
]]>
<![CDATA[							  TimeText = Replace(TimeText ," ","")]]>
<![CDATA[
]]>
<![CDATA[							  TimeText = Replace(TimeText ,":","")]]>
<![CDATA[
]]>
<![CDATA[  							]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & TimeText	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					  Case "@VALUE"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & CheckDICT(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding Object Text to Export File Name")		]]>
<![CDATA[
]]>
<![CDATA[				  End Select]]>
<![CDATA[
]]>
<![CDATA[			  elseif left(sArg,1) = "#" then ]]>
<![CDATA[
]]>
<![CDATA[				  Dim oObj]]>
<![CDATA[
]]>
<![CDATA[				  Set oObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[				  Set oObj = CurrentObj.FindChild(replace(sArg,"#",""))]]>
<![CDATA[
]]>
<![CDATA[				  if not oObj is Nothing then]]>
<![CDATA[
]]>
<![CDATA[					  g_ExportName = g_ExportName & CheckDICT(oObj)]]>
<![CDATA[
]]>
<![CDATA[					  WriteLog("Adding Field Value '" & oObj.Text & "' to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[				  end if]]>
<![CDATA[
]]>
<![CDATA[			  else]]>
<![CDATA[
]]>
<![CDATA[				  g_ExportName = g_ExportName & sArg	]]>
<![CDATA[
]]>
<![CDATA[			  end if]]>
<![CDATA[
]]>
<![CDATA[		  Next 'n 		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  else]]>
<![CDATA[
]]>
<![CDATA[		  g_ExportName = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	  end if]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if len(trim(g_ExportName))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Export Name has no value. Setting to Default 'Export'")]]>
<![CDATA[
]]>
<![CDATA[		g_ExportName = "Export"]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting Export File Name to : " & g_ExportName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFileName = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetFileName") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetOMR_Separator" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	g_OMRSepChar = StrParam]]>
<![CDATA[
]]>
<![CDATA[  DCO.Variable("g_OMRSepChar")=StrParam]]>
<![CDATA[
]]>
<![CDATA[	Writelog("OMR Separation Character is set to '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[	SetOMR_Separator = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Text" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim nLength]]>
<![CDATA[
]]>
<![CDATA[  Dim tLength]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  tLength = g_FixedLen]]>
<![CDATA[
]]>
<![CDATA[  g_FixedLen = len(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	writelog("ADD TEXT")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDeBug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Added Text: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Text = True ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function Text")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  g_FixedLen = tLength]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="Variable_ExportValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    Dim sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Variable_ExportValue = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(strParam)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT Variable: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    sValue = ""]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.FindVariable(Strparam)>0 then]]>
<![CDATA[
]]>
<![CDATA[        sValue = CurrentObj.Variable(Strparam)]]>
<![CDATA[
]]>
<![CDATA[        WriteLog(Space(5) & "Value is :'" & sValue & "' ")]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Variable Not Found.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDebug, sValue)]]>
<![CDATA[
]]>
<![CDATA[	Variable_ExportValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Variable_ExportValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "Variable_ExportValue returns " & Variable_ExportValue) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Variable_IsValue" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sVarName]]>
<![CDATA[
]]>
<![CDATA[	Dim sMatchVal]]>
<![CDATA[
]]>
<![CDATA[	Dim sCMD]]>
<![CDATA[
]]>
<![CDATA[	Dim sFoundVal]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Variable_IsValue = False]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "Starting Function Variable_IsValue")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If len(strParam)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & "," ,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sVarName = trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sMatchVal = trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(4) & "Find Variable: " & sVarName)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(4) & "  Match Value: " & sMatchVal) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(sVarName)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Variable name is Empty. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(sMatchVal)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Match value is Empty. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.FindVariable(sVarName)<=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Variable does not Exist. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sFoundVal = cstr(CurrentObj.Variable(sVarName))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(4) & "Variable Value: " & sFoundVal)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if sFoundVal = sMatchVal then Variable_IsValue = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function Variable_IsValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "Variable_IsValue returns " & Variable_IsValue)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<g>
</g>
<af name="SetFixedLength" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SetFixedLength = False]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Trim(strParam)) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Parameter '" & StrParam & "'. Numeric value expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		g_FixedLen = ""]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_FixedLen = CLng(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Fixed Length set to :" & g_FixedLen)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFixedLength = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetFixedLength") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetJustified" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetJustified = False]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Ucase(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Select Case Left(StrParam & space(1),1)  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Case "R"]]>
<![CDATA[
]]>
<![CDATA[			g_Justified = "Right"]]>
<![CDATA[
]]>
<![CDATA[		Case "L"]]>
<![CDATA[
]]>
<![CDATA[			g_Justified = "Left"]]>
<![CDATA[
]]>
<![CDATA[		Case Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid Parameter '" & StrParamm & "'. Value of 'Left'(L) or 'Right'(R) Expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Justification set to :" & g_Justified & ".  Returning True.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetJustified = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetJustified") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetZeroFill" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_SetFill = "0"]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Set to Zero Fill")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetZeroFill = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetZeroFill") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFill" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetFill = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(StrParam)<> 1 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Fill Character Parameter '" & sChar & "'. Single charcter expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_SetFill = StrParam]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Set to " & Strparam & " Fill")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFill = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetFill") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetSpaceFill" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_SetFill = " "]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Set to Space Fill")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetSpaceFill = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetSpaceFill") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetIgnoreFieldStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  SetIgnoreFieldStatus = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strparam = Trim(strparam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not(IsNumeric(Strparam)) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter Must be a numeric value.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	g_IgnoreFieldStatus = Strparam]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SetIgnoreFieldStatus is set to: " & Strparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetIgnoreFieldStatus = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetIgnoreFieldStatus") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ResetFieldVariables" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_FixedLen 	= ""]]>
<![CDATA[
]]>
<![CDATA[	g_Justified = "Left"]]>
<![CDATA[
]]>
<![CDATA[	g_SetFill	= Space(1)]]>
<![CDATA[
]]>
<![CDATA[  g_IgnoreFieldStatus=""]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Field Variables have been Reset." & vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ResetFieldVariables = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ResetFieldVariables") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FixedLenLJ" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aParams]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FixedLenLJ = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aParams = Split(StrParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If SetJustified(bInter, bDeBug, "L") = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If SetFixedLength(bInter, bDeBug, aParams(1)) = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If ExportFieldValue(bInter, bDebug, aParams(0)) = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FixedLenLJ = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function FixedLenLJ") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FixedLenRJ" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aParams]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FixedLenRJ = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aParams = Split(StrParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If SetJustified(bInter, bDeBug, "R")= False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If SetFixedLength(bInter, bDeBug, trim(aParams(1)))= False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If ExportFieldValue(bInter, bDebug, aParams(0))= False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FixedLenRJ = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function FixedLenRJ") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Filler" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'StrParams is a 2 part CSV of the length and optional character for export ]]>
<![CDATA[
]]>
<![CDATA[  'If no character is specified the last global Fill character setting is used.		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sFiller]]>
<![CDATA[
]]>
<![CDATA[	Dim sChar]]>
<![CDATA[
]]>
<![CDATA[	Dim aParams]]>
<![CDATA[
]]>
<![CDATA[	Dim nLength]]>
<![CDATA[
]]>
<![CDATA[	Dim tLength]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Filler Input: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Filler=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aParams = Split(StrParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nLength = Trim(aParams(0))]]>
<![CDATA[
]]>
<![CDATA[	sChar = Trim(aParams(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nLength) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Parameter '" & nLength & "'. Numeric value expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    tLength = g_FixedLen]]>
<![CDATA[
]]>
<![CDATA[    g_FixedLen = nLength]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Select Case len(sChar)]]>
<![CDATA[
]]>
<![CDATA[		Case 0]]>
<![CDATA[
]]>
<![CDATA[			sChar = g_SetFill]]>
<![CDATA[
]]>
<![CDATA[		Case 1]]>
<![CDATA[
]]>
<![CDATA[			'Value is ok. Continue Action.]]>
<![CDATA[
]]>
<![CDATA[		Case Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid Fill Character Parameter '" & sChar & "'. Single charcter expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[			Exit function]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sFiller = String(nLength,sChar)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Text(bInter, bDebug, sFiller) = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function Filler")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  g_FixedLen = tLength]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Filler = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************
' help.xml for Export 

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************
' Version 8.1.0.30 RFerin 05/24/2011
'  * 32032 Converted to .Net DLL
'
' Version 8.1.0.50 PHofle 07/06/2011
'  * Updated help for action SetExtensionName to include disallowed characters.
'
' Version 8.1.0.51 RFerin 01/19/2012
'  * 33559 Tweaked the help text, fixing spacing issues and minor text updates.
'
'************************************************************
]]>

<ref id="BatchVariable_ExportValue" qi="Exports the value contained in the specified batch-level variable.">
  <ap>The name of the Batch variable.</ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Exports the value contained in the specified batch-level variable.
    <e>
      <b>BatchVariable_ExportValue("ED")</b><br/><br/>

      This action will export the value located in the ED Batch variable to your Export file.
   </e>
  </h>
</ref>

<ref id="DocumentVariable_ExportValue" qi="Exports the value contained in the specified Document-level variable.">
  <ap>Document Variable Name.</ap>
  <h>
    Exports the value contained in the specified Document-level variable.
    <e>
      <b>DocumentVariable_ExportValue("PageCount")</b><br/><br/>

      A number of techniques can add variables to a Document object of the Document Hierarchy. These 
      variables are listed as properties of the object in the Document Hierarchy Setup window.<br/><br/>

      The example above reads the value assigned to the PageCount Document variable and places it in 
      the Export file.
    </e>
  </h>
  <lvl>Document, Page or Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="PageVariable_ExportValue" qi="Exports runtime values assigned to a variable of the bound Page object of the Document Hierarchy.">
  <ap>String value of the variable's name.</ap>
  <h>
    Exports runtime values assigned to a variable of the bound Page object of the Document Hierarchy.
    <e>
      <b>PageVariable_ExportValue("TemplateID")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="BlankFields" qi="Inserts n blank fields into the Export file, adjacent to the current field."> 
  <ap>
    A number indicating how many blank fields to add to the Export file.
  </ap>	
  <h>
    The <b>BlankFields</b> action adds the number of fields you specify. The fields are blank;
    other actions direct the Export task to fill the fields.<br/><br/>

    Note: Make sure you call SetCSV, and optionally SetElementSeparator, to set the separator values as 
    desired for your export file.  if neither of these actions are called before 
    the BlankFields action, no empty fields will be exported because
    the default separator is set to no separator.
    <e>
      SetCSV("TRUE")<br/>
		  <b>BlankFields("12")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    SetSCV, SetElementSeparator
  </see>
</ref>

<ref id="BlankLines" qi="Inserts n blank lines into the Export file.">
  <ap>
    A number <b>n</b> indicating how many blank lines to add below the current line.
  </ap>
  <h>
    Inserts <b>n</b> blank lines into the Export file.
    <e>
      <b>BlankLines("4")</b><br/><br/>

      This action inserts four empty lines, leaving the insertion point for the next output on 
      the following line. Additional output will begin on the fifth line.
    </e>
  </h>
  <lvl>All level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
	  NewLine
  </see>
</ref>

<ref id="BPilot" qi="Exports the value assigned to the Batch Pilot property designated as the parameter.">
  <ap>
    The name of the Batch Pilot <b><i>'Property'</i></b> whose value is to be included in the Export file.<br/><br/>
    <b>BatchDir</b> The name and location of the application’s Batches directory.<br/>
    <b>BatchID</b> The Batch Number of the current batch (20020072.003, for example.)<br/>
    <b>JobName</b> The name of the current User Application job (Main, for example.)<br/>
    <b>Operator</b> The User ID of the operator currently processing the batch.<br/>
    <b>PagesInBatch</b> A count of all pages in the batch.<br/>
    <b>DocsInBatch</b> A count of all documents in the batch. Remember: in most configurations, 
    a Recognition task reorganizes a batch into a series of documents and their pages.<br/>
    <b>Priority</b> 
      The processing priority assigned to the current batch (“10” = Low, “1 = High, “5” = Default). A task selects batches from its queue first according to Priority.
      Station	The Station ID of the workstation currently processing the batch.
    <br/>
    <b>TaskName</b> The name of the task with the batch in its queue.<br/>
    <b>XtraBatchFieldValue</b> The value in a custom field you’ve added to the Job Monitor’s Batch Information Table.<br/>
  </ap>  
  <h>
    Exports the value assigned to the Batch Pilot property that designated as the parameter.<br/><br/>
    <e>
      NewLine()<br/>
      Text("BatchID:")<br/>
      <b>BPilot("BatchID")</b><br/><br/>

      This sequence adds "BatchID: " followed by the current Batch ID into the Export file. For example:<br/><br/>
      BatchID: 20050019.001
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>False</b> if the parameter is not a Batch Pilot property.  Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="CloseExportFile" qi="Closes the currently opened Export file.">
  <ap>None.</ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Closes the currently opened Export file.<br/><br/>

    This action usually belongs to its own RuleSet (ExportClose, for example), and applies to 
    the Batch object of the Document Hierarchy.  However, it can be used at any level.
    <e>
      <b>CloseExportFile()</b>
    </e>
  </h>
  <see>
    OpenExportFile
  </see>
</ref>

<ref id="DCOProperty" qi="Exports the value assigned to the DCO property that you designate as the parameter.">
  <ap>
    The name of the DCO <b><i>'Property'</i></b> whose value is to be included in the Export file.<br/><br/>
    <b>ID</b> The value of an object’s ID property. For a Batch object, 
    this might be 20020072.003. You can apply this action at any level(s).<br/><br/>
    
    <b>ImageName</b> The name and location of a Page object’s Image file: 
    c:\ParentDirectory\Invoices\batches\20030145.001\TM000001.tif, for example.<br/><br/>
    
    <b>Status</b> The value assigned to an object’s Status property. You can apply this action at any level(s).<br/><br/>
    
    <b>Type</b> The value assigned to an object’s Status property. You can apply this action at any level(s).<br/>
  </ap>
  <h>
    Exports the value assigned to the DCO Property that you designate as the parameter.<br/><br/>
    <e>
      NewLine()<br/>
      Text("Document: ")<br/>
      <b>DCOProperty("ID")</b><br/><br/>

      If this sequence is applied to a Document object, the Export file for document 01 in batch 20050219.057 will look like:<br/><br/>
      Document: 20050219.057.01
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b> if the parameter is not a valid DCO Property.  Otherwise, <b>True.</b>
  </ret>
  <see>
    BPilot
  </see>
</ref>

  
<ref id="ExportAllFields" qi="Exports all field values on the current page, including values of Line Item Detail sub-fields - with exceptions.">
  <ap>None.</ap>  
  <h>
    This action exports all field values of the current page. However, the action does <b><i>not</i></b>
    export those values of <b>Field</b> objects of the Document Hierarchy with:<br/><br/>
    1. a setup <b>NOEXPORT</b> variable of "1", or <br/><br/>
    2. a value of a runtime <b>SetIgnoreStatus</b> a field status equal to the <i>Numeric</i> field 
    status defined by a previously-run <b>SetIgnoreFieldStatus</b> action. 
    (For details, see the description of that action.)
    <e>      
      <b>ExportAllFields()</b>      
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the action is not used at the Page level. Otherwise, <b>True.</b>
  </ret>
</ref>

  
<ref id="ExportFieldValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Exports the specified Field object's value to the Export file.">
  <ap>The name of the Field object whose value you want to export.</ap>  
  <h>
    Exports the specified Field object's value to the Export file. Will only export the 
    last Field if multiple fields of the same field type are found.
    <e>
      <b>ExportFieldValue("Date")</b><br/>
      <b>ExportFieldValue("Number")</b><br/>
      <b>ExportFieldValue("Total")</b><br/><br/>

      This sequence exports the current values stored in the Date, Number and Total fields.
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the parameter is not a Field object's name. Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="ExportMYValue" qi="Exports the current field value to the Export file.">
  <ap>None.</ap>  
  <h>
    Exports the current field value to the Export file.
    <e>
      <b>ExportMYValue()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="ExportSmartParameter" qi="Exports an evaluated smart parameter value to the Export file.">
  <ap>The value to export expressed with smart parameter syntax.</ap>  
  <h>
    Exports an evaluated smart parameter value to the Export file.  
    If the input parameter is not a smart parameter, it will export an empty field.
    <e>
      The example will export the value of a variable named
      <b><i>Expired</i></b> on field <b><i>DueDate</i></b> which is a child field on the parent page 
      <b><i>(@P)</i></b> of the calling node.<br/><br/>
      <b>ExportSmartParameter("@P\DueDate.Expired")</b>
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    SetSCV, SetElementSeparator
  </see>
</ref>
  
<ref id="ExportToBatchDir" qi="Specifies that the path for the current Export file(txt) is the Batch directory.">
  <ap>None.</ap>
  <h>
    This action sets the path for the Export file to the current Batch directory.<br/>
    <b>Note:</b> Usually, an Export file is placed in the application's Export folder instead 
    of in a Batch folder of the Batch directory.
    <e>
      <b>ExportToBatchDir()</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b>, if the Batch Directory is not accessible. Otherwise, <b>True.</b>
  </ret>
  <see>
    SetExportPath
  </see>
</ref>

<ref id="GetDATE" qi="Exports today's Date in the format specified as the parameter.">
  <ap>
    The Date's format. <br/><br/>

    "*" stipulates the default mm/dd/yyyy construction. However, you can combine any of the following String values to define a different format:<br/>
    d = day of the month, 1-31<br/>
    dd = two-digit day, 01-31<br/>
    yyyy = four-digit year<br/>
    yy = two-digit year<br/>
    m = month, 1-12<br/>
    mm = two-digit month, 01-12<br/>
    ccyy = four-digit year<br/>
    y = Julian day of the year<br/><br/>

    "." and "/" are valid separators.
  </ap>
  <h>
    Exports today's Date in the format specified as the parameter.
    <e>
      <b>GetDate("*")</b> inserts today's date into the Export file with this format:<br/>
      11/16/2005
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    GetTime
  </see>
</ref>

<ref id="GetProfileString" qi="Accesses a Settings file (.ini) and adds a value in that file to your Export file.">
  <ap>
    <b>1.</b> The [Section] within the Settings file.<br/>
    <b>2.</b> The Key entry within the section, with the value you want to retrieve.<br/>
    <b>3.</b> The name of the Settings file.
  </ap>
  <h>
    Accesses a Settings file (.ini), locates the specified key and adds the value of the key to your Export file.  If the key 
    cannot be read from the settings file, an empty string will be written to the export.  If the settings file
    cannot be found, nothing will be written to the export.<br/><br/>

    <b>Important:</b> The action assumes that the Settings file resides in the <i>current</i> batch directory.
    If you want the INI file to reside in the "Batches" directory, specify your file name with a relative path 
    like this: "..\myfile.ini".
    <e>
      <b>GetProfileString("General,MyValue,Batch.ini")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b> if the settings file cannot be found.  Otherwise, <b>True.</b>  If the settings file
    can be found but the key entry cannot be found within the file, this action will return <b>True.</b>
  </ret>
</ref>

<ref id="GetTime" qi="Exports the current Time in the format specified as the parameter.">
  <ap>
    The parameter specifies the display format for the current time. <br/><br/>

    * = A single asterisk will use the HH:MM:SS time format. However, you can combine any of the following String values to define a different format:<br/>
    m = minute 1-59<br/>
    s = second 1-59<br/>
    h = 1-23<br/>
    mm, min, minute = two-digit minute, 01-59<br/>
    ss, sec, second = two-digit second, 01-59<br/>
    hh, hr, hour = two-digit hour, 01-23<br/><br/>

    ":/'-" are the valid separators.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Exports the current Time in the format specified by the input parameter.
    <e>
      <b>GetTime("*")</b><br/>
      inserts the current time into the Export file with this format: 07:08:16<br/><br/>
      <b>GetTime("hh-mm-ss")</b><br/>
      inserts the current time into the Export file with this format: 07-08-16<br/><br/>
      <b>GetTime("ss:mm:hh")</b><br/>
      inserts the current time into the Export file with this format: 16:08:07
    </e>
  </h>
  <see>
    GetDate
  </see>
</ref>

<ref id="LineItem_AddElement" qi="Includes the specified Line Item Field object as an element of a Line Item Array. ">
  <ap>
    The name of the child <b>Field</b> object of the Document Hierarchy.
  </ap>
  <h>
    This action includes the specified Line Item field object as an element of a Line Item Array.<br/><br/>

    A Line Item Array accumulates and organizes captured line item values retrieved from the Data 
    file of a particular page.<br/><br/>

    <b>Note:</b> A rule using this action should be applied to the <i>LINEITEM</i> fields 
    of the Document Hierarchy.<br/><br/>

    This action is used for exporting Line Item values.
    <e>
      <b>LineItem_AddElement("Price")</b><br/>
      LineItem_ExportElements()<br/><br/>

      The action above expands the Line Item Array by one field: Price. <br/><br/>

      LineItem_ExportElements will populate this element and other elements 
      of the array with the captured values it finds in a page's Data file before exporting them.
    </e>
  </h>
  <lvl>
    The <b><i>parent</i></b> field that contains the child Line Item field.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    LineItem_ExportElements,  LineItem_ClearElements, LineItem_BlankFields
  </see>
</ref>

<ref id="LineItem_BlankFields" qi="Includes the specified number of blank fields as elements of a Line Item Array. ">
  <ap>
    The number of Blank fields to export as part of the Line Item Array.
  </ap>
  <h>
    This action includes the specified number of Blank Line Item fields as elements 
    of a Line Item Array.<br/><br/>

    A Line Item Array accumulates and organizes captured line item values retrieved 
    from the Data file of a particular page.<br/><br/>

    <b>Note:</b> A rule using this action should be applied to the <i>LINEITEM</i> fields of the Document Hierarchy.<br/><br/>

    This action is used for exporting Blank Line Item values.
    <e>
      <b>LineItem_BlankFields("6")</b><br/><br/>

      The action above expands the Line Item Array by six blank fields<br/><br/>

      <scr>LineItem_ExportElements</scr> will populate this element and other elements 
      of the array with the captured values it finds in a page's Data file before exporting them.
    </e>
  </h>
  <lvl>
    The <b><i>parent</i></b> field that contains the child Line Item field.  
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    LineItem_ExportElements, LineItem_ClearElements,LineItem_AddElements, LineItem_SmartParameter
  </see>
</ref>
  
<ref id="LineItem_SmartParameter" qi="Add a smart parameter algorithm as an element of a Line Item Array. ">
  <ap>Smart Parameter to be evaluated during processing of the Lineitem array.</ap>
  <h>
    This action permits adding a smart parameter as an element of a Line Item Array to be evaluated 
    during the Array processing.<br/><br/>

    A Line Item Array accumulates and organizes captured line item values retrieved 
    from the Data file of a particular page.<br/><br/>

    <b>Important!</b> A rule using this action should be applied to the <i>LINEITEM</i> fields of the Document Hierarchy.<br/><br/>

    This action is used for exporting Blank Line Item values.
    <e>
      <b>LineItem_SmartParameter("@F\Price+@TIME(HH:MM:SS)")</b><br/>
      LineItem_ExportElements()<br/><br/>

      The action above places a child field <b><i>Price</i></b> of the calling field node <b><i>(@F)</i></b> 
      appended with the current time in format HH:MM:SS to the export file. <br/><br/>

      LineItem_ExportElements will populate this element and other elements 
      of the array with the captured values it finds in a page's Data file before exporting them.
    </e>
  </h>
  <lvl>
    The <b><i>parent</i></b> field that contains the child Line Item field.  
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    LineItem_ExportElements, LineItem_ClearElements, LineItem_AddElements, LineItem_BlankFields
  </see>
</ref>


<ref id="LineItem_ClearElements" qi="Clears values in the Line Item Array.">
	<ap>None</ap>
	<h>
		This is mainly a housekeeping function you can use to be sure the array does not contain leftover values.
		<e>
      <b>LineItem_ClearElements()</b>
    </e>	
	</h>
  <lvl>
    The <b><i>parent</i></b> Field object of the Document Hierarchy that contains a <b><i>child</i></b>
    Line Item field, such as you may typically find in an invoice application.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    LineItem_AddElement, LineItem_ExportElements, LineItem_BlankFields, LineItem_SmartParameter
  </see>
</ref>

<ref id="LineItem_ExportElements" qi="Exports the captured values in a page's Line Item Array that have been populated with LineItem_AddElement actions.">
  <ap>None.</ap>
  <lvl>
    The parent field that contains the child Line Item sub-fields.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Exports the captured values in a page's Line Item Array that have been populated 
    with LineItem_AddElement actions.
    <e>
      LineItem_AddElement("Price")<br/>
      LineItem_AddElement("LineTotal")<br/>
      <b>LineItem_ExportElements()</b><br/>
      NewLine()<br/><br/>

      This example exports the values included in the Line Item Array to your Export file.
    </e>
  </h>
  <see>
    LineItem_ClearElements, LineItem_AddElement, LineItem_BlankFields, LineItem_SmartParameter
  </see>
</ref>

	<ref id="NewLine" qi="Starts a new line in your Export file.">
		<ap>None.</ap>
		<lvl>Any level.</lvl>
		<ret>
			Always <b>True.</b>
		</ret>
		<h>
			Starts a new line in your Export file.
			<e>
				<b>NewLine()</b><br/>
				Text("Export Output")<br/><br/>

				This sequence starts a new line and adds "Export Output" to the beginning of the line.
			</e>
		</h>
		<see>
			BlankLines
		</see>
</ref>

<ref id="SaveFilePathAsVariable" qi="Saves the path and name of your Export file to the variable specified by the parameter. ">
  <ap>Variable name specifying where the Export file name and path will be stored.</ap>
  <h>
    Saves the path and name of your Export file to the variable specified by the parameter.  If the 
    variable does not exist, it will be created.
    <e>
      <b>SaveFilePathAsVariable("Export_File")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="SetCSV" qi="Ensures that all exported values are delimited by a comma separator.">
  <ap>
    <b>TRUE or ON:</b> Enables CSV formatted output using a comma separator.<br/>
    <b>FALSE:</b> Uses a custom separator, as set by SetElementSeparator(), between output fields.<br/>
    <b>OFF:</b> Causes no separator to be placed between output fields.<br/><br/>
    Smart parameters are supported.
  </ap>
  <h>
    Ensures that all exported values are delimited by a comma separator.
    <e>
      <b>SetCSV("TRUE")</b><br/>      
      ExportFieldValue("Date")<br/>
      ExportFieldValue("Number")<br/>
      ExportFieldValue("Total")<br/>
      <b>SetCSV("FALSE")</b><br/><br/>

      This sequence will export the captured values of the Date, Number, and Total Field 
      objects into your Export file.  A comma will be added after each value to separate the fields.
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    SetElementSeparator
  </see>
</ref>

<ref id="SetElementSeparator" qi="Ensures that all exported values are delimited by a separator designated as the parameter.">
	<ap>
    The input parameter can be one of the following:<br/><br/>
    
    A field separator character: Uses the provided custom character as the separator between fields.
    Smart parameters are supported.<br/><br/>
    ON or TRUE: Sets the field element separator to a single space.  This is the default value.<br/>
    OFF or FALSE: No separator will be placed between fields.<br/><br/>
    Smart parameters are supported.
  </ap>	
	<h>
		Ensures that all exported values are delimited by a separator designated as the parameter.<br/><br/>
    Note: If you wish to set your own custom separator, SetCSV(FALSE) must be called prior to exporting fields.
    If SetCSV(FALSE) is not called, then your custom element separator will not be used for export.
		<e>
      SetCSV("FALSE")<br/> 
			<b>SetElementSeparator("|")</b><br/>
			This action uses "|" to delimit the Export file's values.<br/><br/>

			<b>SetElementSeparator("Off")</b> turns off the action.
		</e>
	</h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
	<see>
		SetCSV
	</see>
</ref>

<ref id="SetExportPath" qi="Specifies the path to the Export file's location. Alternatively, you can use a Smart Parameter to identify a Paths.ini file that has a set of path parameters for your application - see the Parameters and Details sections below.">
<ap>
  The complete path to the application's Export folder. Smart parameters are supported.
</ap>
<lvl>All</lvl>
<ret>
	<b>True</b> if the path specified by the parameter exists. Otherwise, <b>False.</b>
</ret>
<h>
	The action's parameter specifies the path to the Export file's location, or uses a Smart Parameter to retrieve a path's value from the application's Paths.ini file.
	<e>
		<b>SetExportPath("c:\ParentDirectory\Invoice\Export")</b>
		<br/>
		<br/>
    <b>SetExportPath("@APPPATH(export)")</b><br/>
    In the second example, a smart parameter is used to obtain the location of the Export Directory from the
    value configured in the Application Manager.
	</e>
</h>
</ref>

<ref id="SetExtensionName" qi="Assigns an extension to the current Export file.">
  <ap>
    The file extension you want to use, including the leading period.  If you do not want a file
    extension, do not pass any parameter to this action.
    Disallowed characters are *&gt;&lt;[]&quot;/|\:? and control characters.<br/><br/>
    
    Smart parameters are supported.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Assigns an extension to the current Export file. If this action is not called, the default value 
    of .TXT will be used.
    <e>
      SetFileName("Export_+@BATCHID")<br/>
      <b>SetExtensionName(".dat")</b><br/><br/>

      In this example, the Export file will have a .dat extension.
    </e>
  </h>
  <see>
    SetFileName
  </see>
</ref>

<ref id="SetFileName" qi="Assigns a name to the current Export file.">
	<ap>
		The file's name (without an extension). <br/><br/>
    Smart parameters are supported.
	</ap>
	<h>
    Assigns a name to the current Export file.  If SetExtensionName is not called, the file
    extension defaults to .TXT.  If you require a different file extension, use SetExtensionName.
    <e>
			<b>SetFileName("Export_+@BATCHID")</b><br/>
			SetExtensionName(".txt")<br/><br/>

			This sequence establishes a series of Export files with names such as<br/>
			Export_20021231.001.txt<br/>
			Export_20021231.002.txt<br/><br/>

			In contrast,<br/>
			<b>SetFileName("@BATCHID")</b><br/>
			SetExtensionName(".txt")<br/>
			will establish a series of Export files with Batch IDs only:<br/>
      20021231.001.txt<br/>
      20021231.002.txt
		</e>
	</h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
		SetExtensionName
	</see>
</ref>

<ref id="SetOMR_Separator" qi="For multi-punch OMR fields, uses the parameter's value as the separator character.">
  <ap>The separator character you want to use.</ap>
  <h>
    For multi-punch OMR fields, uses the parameter's value as the separator character.  When
    multi-punch fields are exported, you typically do not want to use the same separator
    that you are using for fields as these values are typically all within a single field.  This
    action allows you to specify a custom separator to be used when exporting.  If this
    action is not called, the default value is a space.
    <e>
      <b>SetOMR_Separator(";")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="Text" qi="Places a string into the Export file.">
	<ap>The string to write to the export file.</ap>	
	<h>
		This action unconditionally adds a string to the export file.  No character padding will be performed on this value.
		<e>
      SetFileName("Export_+@BatchID")<br/>
      SetExtensionName(".txt")<br/>
      <b>Text("This line will appear in the export file.")</b>
    </e>
	</h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="Variable_ExportValue" qi="Exports the value assigned to a variable of the current object of the Document Hierarchy.">
	<ap>The name of the variable with the value you want to export.</ap>
	<h>
		Exports the value assigned to a variable of the current object of the Document Hierarchy.
		<e>
			<b>Variable_ExportValue("ID")</b><br/><br/>

			This action exports the value assigned to the ID property of the current object of the Document Hierarchy.
		</e>
	</h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="Variable_IsValue" qi="Checks to see if the parameter value matches the value assigned to a variable of the current object of the Document Hierarchy.">
	<ap>
		<b>1.</b> The name of the variable with the value you want to compare.<br/>
		<b>2.</b> The value you want to match with the variable's value.
	</ap>
	<h>
		Checks to see if the parameter value matches the value assigned to a variable of the current object of the Document Hierarchy.
		<e>
			<b>Variable_IsValue("Invoice,Yes")</b><br/><br/>

			This action returns <b>True</b> if the value of the current Page object's Invoice variable is "Yes".
		</e>
	</h>
  <lvl>Any level.</lvl>
  <ret>
    <b>True</b> if the variable's value matches the parameter's value. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="SetFixedLength" qi="Uses the Numeric value you enter as a parameter to establish a fixed length of a value exported from the current field.">
<ap>
	<i>Numeric</i> value indicating the field's length.
</ap>
<lvl>Any level.</lvl>
<ret>
  <b>False</b> if the parameter is not <i>Numeric</i>; Otherwise, <b>True.</b>
</ret>
<h>
  Uses the Numeric value you enter as a parameter to establish a fixed length of a value exported from the current field.<br/><br/>
  Use ResetFieldVariables to clear this setting.
  <e>
    <b>SetFixedLength("12")</b>
  </e>
</h>
  <see>ResetFieldVariables</see>
</ref>

<ref id="SetJustified" qi="Right-justifies or left-justifies a field's exported values.">
<ap>An upper case R(right-justified) or L(left-justified).</ap>
<h>
  Right-justifies or left-justifies a field's exported values according to the parameter you enter.<br/><br/>
  Use ResetFieldVariables to clear this setting.
  SetFixedLength must also be used to set the maximum length of the field.
  <e>
    SetFixedLength("10")<br/>
    <b>SetJustified("R")</b>
  </e>
</h>
<lvl>Any level.</lvl>
<ret>
  <b>False</b> if the parameter is not an "R" or "L". Otherwise, <b>True.</b>
</ret>
</ref>

<ref id="SetZeroFill" qi="Sets the ASCII 48 zero as the global filler value to be used to expand the current value of a field in a flat file, if the field's allowable length is greater than the length of its current export value.">
 <ap>None.</ap>
 <lvl>Any level.</lvl>
 <ret>Always <b>True.</b></ret>
 <h>
   Sets the ASCII 48 zero as the global filler value to be used to expand the current
   value of a field in a flat file, if the field's allowable length is greater than the length of its current export value.<br/><br/>
   SetFixedLength, FixedLenRJ or FixedLenLJ must also be used to set the maximum length of the field.
   Use ResetFieldVariables to clear this setting.
   <e>
     SetFixedLength("10")<br/>
     <b>SetZeroFill()</b>
     <br/>
     <br/>
     <b>Note</b> that the action specifies the use of the ASCII 48 "zero" filler.
   </e>
 </h>  
</ref>

<ref id="SetFill" qi="Sets the filler character to be used to expand the current value of a field in a flat file, if the field's allowable length is greater than the length of its current export value.">
  <ap>
    Single <i>String</i> character to be used as the filler value.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    <b>False</b> if more than one character is entered as a parameter. Otherwise, <b>True.</b>
  </ret>
  <h>
    Sets the filler character to be used to expand the current value of a field in a flat file, 
    if the field's allowable length is greater than the length of its current export value.<br/><br/>
    Note: When using SetFill, the action SetFixedLength, FixedLenRJ or FixedLenLJ must also
    be used to set the maximum length of the field.  You can use SetSpaceFill if you wish
    to make the filler character a space.
    Use ResetFieldVariables to clear this setting.
    <e>
      SetFixedLength("10")<br/>
      <b>SetFill("$")</b>
      <br/>
      This example sets the fill character to a $.
    </e>
  </h>
</ref>

<ref id="SetSpaceFill" qi="Specifies the use of the ASCII 32 space as the global filler value to be used to expand the current value of a field in a flat file, if the field's allowable length is greater than the length of its current export value.">
  <ap>None.</ap>
  <h>
    Specifies the use of the ASCII 32 space as the global filler value to be used to 
    expand the current value of a field in a flat file, if the field's allowable length is 
    greater than the length of its current export value.<br/><br/>
    If you use SetSpaceFill, the action SetFixedLength, FixedLenRJ or FixedLenLJ must also be
    used to set the maximum length of the field.
    Use ResetFieldVariables to clear this setting.
    <e>
      <b>SetSpaceFill()</b>
      <br/><br/>
      <b>Note</b> that the action specifies the use of the ASCII 32 "space" as the filler character.
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="SetIgnoreFieldStatus" qi="Assigns a Numeric value to the application's SetIgnoreStatus variable. Any field with this status cannot export data to an Export file or database."> 
  <ap>
    A <i>Numeric</i> value that represents the status of fields to be "ignored" by Export tasks.
  </ap>
  <h>
    This action establishes the status that determines if an Export task will
    export a field's value.  If the status of the field being exported matches this set value,
    the field will not be exported.<br/><br/>
    Use ResetFieldVariables to clear this setting.
    <e>
      <b>SetIgnoreFieldStatus("1")</b><br/><br/>
      This example ensures that runtime values for fields with a "1" status will not
      be added to an Export file or update an Export database. (Typically, "1" denotes a problem field.)
   </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>False</b> if the parameter is not Numeric. Otherwise, <b>True.</b>
  </ret>
</ref>
  
 
<ref id="ResetFieldVariables" qi="Resets the variables of the bound Field object of the Document Hierarchy.">
	<ap>None.</ap>
	<h>
     This action resets some of the export settings that can be independently set by other actions.<br/><br/>
     The default field fill character is reset to a space.<br/>
     Field justification is reset to left.<br/>
     The ignore field status is reset to not ignore any fields based on the status.<br/>
     Fields are no longer set to a specific length.         
     <e>
       <b>ResetFieldVariables()</b>
     </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    SetFixedLength, SetJustified, SetZeroFill, SetFill, SetSpaceFill and SetIgnoreFieldStatus
  </see>
</ref>

<ref id="FixedLenLJ" qi="Exports a specified number of characters from a field's left end (left-justified.)"> 
  <ap>
    Two comma-separated values.<br/><br/>
    <b>1.</b> The field's name: this is the name of the corresponding <b>Field</b> object of the Document Hierarchy.<br/><br/>
    <b>2.</b> The number of characters that are to be exported, counting from the field's left end.
  </ap>  
  <h>
    This action is similar to the FixedLenRJ.  It exports a specified
    number of characters from a field's left end (left-justified.)    
    <e>
      <b>FixedLenLJ("Volume,8")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if either parameter is invalid or if the action is called at the wrong level.
    Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="FixedLenRJ" qi="Exports a specified number of characters from a field's right end (right-justified.)">
<ap>
	Two comma-separated values.<br/><br/>
  <b>1.</b> The field's name: this is the name of the corresponding <b>Field</b> object of the Document Hierarchy.<br/><br/>
  <b>2.</b> The number of characters that are to be exported, counting from the field's right end.
</ap>
<lvl>Page level.</lvl>
<ret>
  <b>False</b> if either parameter is invalid or if the action is called at the wrong level.  
  Otherwise, <b>True.</b>
</ret>
<h>
  Similar to the FixedLenLJ action, this action exports a specified number of characters from a field's right end (right-justified.)
  <e>
		<b>FixedLenRJ("InvoiceDate,12")</b><br/><br/>
    This exports 12 characters from the right end of the <i>InvoiceDate</i> field.
	</e>
</h>
</ref>

<ref id="Filler" qi="Adds a string of identical filler characters to the Export.">
  <ap>
    Two comma-separated values. The first is a number indicating the total length in characters of the filler.
    The second parameter is the filler's character.<br/><br/>
    The second parameter is optional: if you do not enter a value, the action will use the most 
    recent Global character setting.
  </ap>
  <h>
    Adds a single filler character to the Export, repeated by the number of times indicated in the
    first input parameter.  The second parameter cannot be a space.  The filler string is written
    regardless of the data in the current field.  If you wish to
    use a space as a filler character, use SetSpaceFill
    and then call Filler without the optional second parameter.
    <e>
      <b>Filler("12,n")</b><br/><br/>
      The action in the example fills the current field with 12 instances of the character "n".
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b> if the first parameter is not numeric or if the second parameter is more than 1 character.
    Otherwise, <b>True.</b>
  </ret>
	</ref>
</help>
</rrx>
<rrx namespace="ExportDB" src="c:\datacap\RRS\ExportDB.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="AddRecord" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[	Dim sClm]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AddRecord = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Add Record...")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("oConn.State = " & oConn.State)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Connection is Closed. Trying to open...")]]>
<![CDATA[
]]>
<![CDATA[		If Not ExportOpenConnection(bInteractive, bDebug, g_sDSN) Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Failed to open connection. Setting status to abort.")]]>
<![CDATA[
]]>
<![CDATA[			bAbort = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If			]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sClm = GetColumnNames]]>
<![CDATA[
]]>
<![CDATA[	If Len(sClm) <> 0 Then 	]]>
<![CDATA[
]]>
<![CDATA[		sSQL = "INSERT INTO " & g_sTableName & " (" & GetColumnNames() & ") VALUES (" & GetColumnValues() & ");"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Modify sSQL if DB type is Oracle - rrunner.rrx 7.6.42 function]]>
<![CDATA[
]]>
<![CDATA[    sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Post Execute")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If DBErrTrap(oConn,"ADD Record")= False then ]]>
<![CDATA[
]]>
<![CDATA[			AddRecord = True]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Err.Clear]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		dictFldColumn.RemoveAll()]]>
<![CDATA[
]]>
<![CDATA[	Else ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No values were found when building the SQL. INSERT was bypassed.")]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
	</g>
</af>
<af name="ExportCloseConnection" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' CloseConnection removed.  Replaced by ExportCloseConnection]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim i, sError]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ExportCloseConnection = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Close Connection...")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("oConn.State = " & oConn.State)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CloseDB()]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	If cstr(oConn.State) <> "0" Then ]]>
<![CDATA[
]]>
<![CDATA[    ' If the connection is already closed, just log the condition but still return true.]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(sError)]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("CloseConnection returns " & ExportCloseConnection )]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("Function ExportCloseConnection")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ExportCloseConnection") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportFieldToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sField]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[  Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ExportFieldToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sField = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sValue = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(strParam) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportFieldToColumn= False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	If IsAlive(CurrentObj) Then ]]>
<![CDATA[
]]>
<![CDATA[		  Writelog(Space(5) & "Finding Value of Field:" & sField)]]>
<![CDATA[
]]>
<![CDATA[		  Set oFld = CurrentObj.FindChild(sField)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  		If Not(oFld Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[        sValue=CheckDict(oFld)]]>
<![CDATA[
]]>
<![CDATA[	  		Writelog(Space(5) & "Field Value is :'" & sValue & "' ")]]>
<![CDATA[
]]>
<![CDATA[		  	ExportFieldToColumn= True       ]]>
<![CDATA[
]]>
<![CDATA[		  Else]]>
<![CDATA[
]]>
<![CDATA[			  Writelog(Space(5) & "Field Object Not Found.")]]>
<![CDATA[
]]>
<![CDATA[			  Writelog(Space(5) & "Current Obj is " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			  ExportFieldToColumn = False]]>
<![CDATA[
]]>
<![CDATA[		  End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "There is No Current Object.")]]>
<![CDATA[
]]>
<![CDATA[		ExportFieldToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	If (sStyle="2") AND sValue = "" then]]>
<![CDATA[
]]>
<![CDATA[    Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sValue = replace(sValue,"'","''")]]>
<![CDATA[
]]>
<![CDATA[	  Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ExportPropertyToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sProperty]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[  Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ExportPropertyToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sProperty = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(strParam) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportPropertyToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If sStyle = "3" Then ]]>
<![CDATA[
]]>
<![CDATA[    'Do Nothing --> Null value flag ]]>
<![CDATA[
]]>
<![CDATA[  'End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(CurrentObj) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Finding Property Value")]]>
<![CDATA[
]]>
<![CDATA[		oVal = CurrentObj.Variable(sProperty)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not(oVal = "") Then	 ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Field Value is :'" & oVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			ExportPropertyToColumn= True]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Property Value Not Found.")]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Current Obj is " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			ExportPropertyToColumn= False]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "There is No Current Object.")]]>
<![CDATA[
]]>
<![CDATA[		ExportPropertyToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (sStyle="2" OR sStyle="3") AND oVal = "" then]]>
<![CDATA[
]]>
<![CDATA[    Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sValue = replace(oVal,"'","''")]]>
<![CDATA[
]]>
<![CDATA[	  Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ExportToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim sCheckColumn]]>
<![CDATA[
]]>
<![CDATA[  Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ExportToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sValue = ""]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(strParam) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If sStyle = "3" Then ]]>
<![CDATA[
]]>
<![CDATA[    'Do Nothing --> Null value flag ]]>
<![CDATA[
]]>
<![CDATA[  'End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If IsAlive(CurrentObj) Then ]]>
<![CDATA[
]]>
<![CDATA[		sValue = replace(CheckDict(CurrentObj),"'","''")]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Field Value is :'" & sValue & "' ")		]]>
<![CDATA[
]]>
<![CDATA[    If len(sValue)>0 then ExportToColumn = True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (sStyle="2" OR sStyle="3") AND sValue = "" then]]>
<![CDATA[
]]>
<![CDATA[    sValue="NULL" ]]>
<![CDATA[
]]>
<![CDATA[    ExportToColumn = True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ExportOpenConnection" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ' OpenConnection was replaced by ExportOpenConnection.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On error resume next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[  Dim sError]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	oConn.Errors.Clear]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ExportOpenConnection = True	]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" and strParam<>sSmartParam Then ]]>
<![CDATA[
]]>
<![CDATA[    'attempt to decrypt value]]>
<![CDATA[
]]>
<![CDATA[    bRes = [securecall]sSmartParam,strParam[/securecall]   ]]>
<![CDATA[
]]>
<![CDATA[    If bRes=False Then Writelog("Value not Decrypted.")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using the original parameter string.") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	strParam = FormatADOConn(strParam)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 1 Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Connection is already Open, Function returns TRUE")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oConn.Open(strParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("oConn.State = " & oConn.State)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 1 Then ExportOpenConnection = True Else ExportOpenConnection = False : WriteLog(sError)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ExportOpenConnection returns " & ExportOpenConnection )]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("Function ExportOpenConnection")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ExportOpenConnection")  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetTableName" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	SetTableName = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_sTableName = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Trim(aStrParam(1))="1" Then]]>
<![CDATA[
]]>
<![CDATA[		SetTableName = CheckTableName(g_sTableName)   ]]>
<![CDATA[
]]>
<![CDATA[		If SetTableName = True then Writelog("Table Name '" & g_sTableName & "' is valid.")]]>
<![CDATA[
]]>
<![CDATA[		If SetTableName = False then Writelog("Table Name '" & g_sTableName & "' is invalid.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SetTableName = True]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
	</g>
</af>
<af name="ExportBatchIDToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim sCheckColumn]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[    Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue	]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	ExportBatchIDToColumn = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(sColumnName) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportBatchIDToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If sStyle = "3" Then ]]>
<![CDATA[
]]>
<![CDATA[    'Do Nothing --> Null value flag ]]>
<![CDATA[
]]>
<![CDATA[  'End if  ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  If (sStyle="2" OR sStyle="3") AND oVal = "" then]]>
<![CDATA[
]]>
<![CDATA[    Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sValue = replace(DCO.ID,"'","''")]]>
<![CDATA[
]]>
<![CDATA[	  Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ExportBatchIDToColumn = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportSmartParamToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sProperty]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[    Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[    Dim sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ExportSmartParamToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sProperty = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(strParam) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportSmartParamToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ExportSmartParamToColumn= True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If sStyle = "3" Then ]]>
<![CDATA[
]]>
<![CDATA[    'Do Nothing --> Null value flag ]]>
<![CDATA[
]]>
<![CDATA[  'End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(CurrentObj) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Finding Property Value")]]>
<![CDATA[
]]>
<![CDATA[		oVal = MetaWord(sProperty)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not(oVal = "") Then	 ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Found Value is :'" & oVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Smart Parameter Value Not Found.")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "There is No Current Object.")]]>
<![CDATA[
]]>
<![CDATA[		ExportSmartParamToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (sStyle="2" OR sStyle="3") AND oVal = "" then]]>
<![CDATA[
]]>
<![CDATA[    Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sValue = replace(oVal,"'","''")]]>
<![CDATA[
]]>
<![CDATA[	  Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ExportNodeXMLToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sProperty]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[    Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[    Dim sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ExportNodeXMLToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sProperty = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(strParam) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportNodeXMLToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ExportNodeXMLToColumn= True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        oval=""]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Finding Node Value")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[        Set oNode = DCONav(sProperty)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[        If Not oNode is Nothing then]]>
<![CDATA[
]]>
<![CDATA[            oVal = oNode.xml]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[		If Not(oVal = "") Then	 ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Found Value is :'" & oVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Smart Parameter Value Not Found.")		]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (sStyle="2" OR sStyle="3") AND oVal = "" then]]>
<![CDATA[
]]>
<![CDATA[    Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sValue = replace(oVal,"'","''")]]>
<![CDATA[
]]>
<![CDATA[	  Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************
' help.xml for Export 

' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
' Version 8.1.0.33 RFerin 05/25/2011
'  * 32032 Converted to .Net DLL
'
' Version 8.1.0.34 RFerin 05/25/2011
'  * 32032 Converted to .Net DLL
'
' Version 8.1.0.34 RFerin 07/13/2011
'  * 29425 Updated help to emphesize the use of the applicaiton service and removed examples of DSN usage.
'
' Version 8.1.0.35 RFerin 01/13/2012
'  * 33540 Numerous help tweaks to fix word spacing and consistency issues.
'
' Version 8.1.0.36 RFerin 08/07/2012
'  * 35141 Fixed the help for the parameters for most actions.
'
'
'************************************************************
]]>
  
	
<ref id="AddRecord" qi="Inserts assembled data into the database table specified by a previous SetTableName action.">
  <ap>None.</ap>
  <h>
    Inserts assembled data into the database table specified by a previous <b>SetTableName</b> action.<br/><br/>

    <b>Important.</b> This action must be placed after earlier actions that gather data, open the database, and access the correct table.
    <e>
      SetTableName("Invoice")<br/>
      ExportFieldToColumn("VendorID,db_Vendor")<br/>
      ExportFieldToColumn("Number,db_Number")<br/>
      ExportFieldToColumn("Total,db_Total")<br/>
      <b>AddRecord()</b><br/><br/>

      This ExportDB rule applies to a Page object of the Document Hierarchy.<br/><br/>

      The actions open the database and direct the rule's attention to the Invoice table. 
      The rule then sets up a record with three values - Vendor ID, Invoice Number and Total. 
      Afterwards, the AddRecord action updates the table with new information. <br/><br/>
      
      Note: A return of False means the record may not have been successfully exported, 
      and needs to be followed by a "failure check" rule that typically would call 
      SetTaskStatus(0) (or the rrunner action rr_AbortBatch) to ensure that the batch aborts.
    </e>
  </h>
  <lvl>All, but generally used at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if there is no connection to the database; if an error occurs when the action
    attempts to add the record to the database; or if a SetTableName action was not previously used.<br/><br/>
    Otherwise, <b>True</b>.
  </ret>
	<see>SetTableName, ExportFieldToColumn</see>
</ref>
	
<ref id="ExportCloseConnection" qi="Closes an open connection to your Export database.">
  <ap>None.</ap>
  <h>
    Closes an open connection to the previously opened Export database.<br/><br/>

    Usually, this action is placed in a RuleSet that is separate from the RuleSet that opens 
    the connection and stores the data.<br/><br/>

    For example this action could be placed into a RuleSet called ExportDBClose, 
    and attached to a batch level close event which executes after all data has been 
    exported from the batch to the specified database.
    <e>
      <b>ExportCloseConnection()</b><br/><br/>

      This action closes the previously opened connection to the Export database.<br/><br/>

      This action is usually part of a separate RuleSet that prevents the need to repeatedly
      open the connection to the Export database. (You can open the connection once in the first
      RuleSet, export data from all documents and pages in the batch, then close the connection once
      in the second RuleSet.)
    </e>
  </h>
  <lvl>All, but generally used as part of a separate RuleSet at the Batch level.</lvl>
  <ret>
    <b>True,</b> even if the connection is already closed.
  </ret>
  <see>ExportOpenConnection</see>
</ref>
 
	
<ref id="ExportFieldToColumn" qi="A page-level action that extracts the captured value of a Field object from the Data file of the current page, and specifies its target location within a table of the Export database.">
<ap>
  Three comma-separated values:<br/><br/>
  <b>1.</b> The name of the field whose value will be stored in the column.<br/><br/>

  <b>2.</b> The name of the database column that will hold the value.<br/><br/>

  <b>3.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.  If this parameter is not specified, 
  quotes will be placed around the value in the SQL query to update the table.<br/><br/>
  
  Setting the value to 1 causes this action to return False if the Table name is invalid; 
  otherwise the error will not be discovered until the action that performs the DB insert call, 
  such as an AddRecord action, is called.  This value would typically only be 
  used in a development environment as it will increase processing time.<br/><br/>
  
  Setting this value to 2 allows NULL column values and inserts no quotes around values 
  (for numeric) in the SQL query to update the database.<br/><br/>
  
  Setting the value to 3 allows NULL and if the column value is not NULL, 
  the column value will be surrounded in quotes in the SQL query to update the database.
</ap>
  <h>
    This is a page-level action that extracts the captured value of a Field object from the
    Data file of the current page, and specifies its target location within a table of the Export database.<br/><br/>

    Within a rule, this action should run before an AddRecord action, which commits the data
    to the database.
    <e>
      SetTableName("Export_Results")<br/>
      <b>
      ExportFieldToColumn("VendorID,db_Number,2")<br/>
      ExportFieldToColumn("Date,db_Date")<br/>
      ExportFieldToColumn("Total,db_Total")
      </b><br/>
      AddRecord()<br/><br/>

      This action exports the captured value of three Field objects from the Data file of the current page,
      to corresponding columns of the Export_Results table, within the open Export database. It also
      provides the action with an optional <i>Style</i> value.<br/><br/>

      <b>Important.</b> Make sure you use the ExportOpenConnection action to establish a connection
      to your Export database.  This is usually accomplished by a rule at the Batch level.
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if:<br/>
    <b>1.</b> There is no connection to the database.<br/>
    <b>2.</b> The database column specified as a parameter does not exist.<br/>
    <b>3.</b> The Field object identified by the parameter does not exist.<br/>
    <b>4.</b> A SetTableName action was not used previously.<br/><br/>

    Otherwise, <b>True.</b>
  </ret>
  <see>SetTableName, ExportToColumn</see>
</ref>

<ref id="ExportPropertyToColumn" qi="Adds the value of a property (variable) of the selected object to a column of the Export database">
  <ap>
    Three comma-separated values:<br/><br/>

    <b>1.</b> The property name whose value will be stored in the column.<br/><br/>

    <b>2.</b> The name of the database column that will hold the value.<br/><br/>

    <b>3.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.  <br/><br/>
    
    If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>
    Setting the value to 1 causes this action to return False if the Table name is invalid; 
    otherwise the error will not be discovered until the action that performs the DB 
    insert call, such as an AddRecord action, is called.  This value would 
    typically only be used in a development environment as it will increase processing time.<br/><br/>
    
    Setting this value to 2 allows NULL column values and inserts no quotes around values 
    (for numeric) in the SQL query to update the database.<br/><br/>
    
    Setting the value to 3 allows NULL and if the column value is not NULL, 
    the column value will be surrounded in quotes in the SQL query to update the database.
    
  </ap>
  <h>
    Adds the value of a property (variable) of the selected object to a column of the Export database.
    <e>
      SetTableName("Export_Results")<br/>
      ExportFieldToColumn("VendorID,db_Number")<br/>
      <b>ExportPropertyToColumn("Status,db_PageStatus,2")</b><br/>
      ExportFieldToColumn("Total,db_Total")<br/>
      AddRecord()<br/><br/>

      This sequence updates the db_PageStatus column of the Export_Results table with the value of
      the selected object's Status property. It also uses the optional third parameter to define
      a <i>Style</i> for the action.
    </e>
  </h>
  <lvl>All, but generally used at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if:<br/><br/>
    <b>1.</b> There is no connection to the Export database.<br/>
    <b>2.</b> The column of the database does not exist.<br/>
    <b>3.</b> The property (variable) identified by the parameter does not exist.<br/>
    <b>4.</b> A SetTableName action was not used previously.<br/><br/>

    Otherwise, <b>True.</b>
  </ret>
  <see>ExportToColumn, ExportFieldToColumn, ExportBatchIDToColumn</see>
</ref>
	
<ref id="ExportToColumn" qi="A field-level action that exports the captured value of the current Field object from the page's Data file to a target column within a previously designated table of an open Export database.">
<ap>
  Two comma-separated values:<br/><br/>

  <b>1.</b> The name of the database column that will hold the value of the current field.<br/><br/>

  <b>2.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.  <br/>
  
  If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>
  Setting the value to 1 causes this action to return False if the Table name is invalid; 
  otherwise the error will not be discovered until the action that performs the DB insert call, 
  such as an AddRecord action, is called.  This value would typically only be used 
  in a development environment as it will increase processing time.<br/><br/>
  
  Setting this value to 2 allows NULL column values and inserts no quotes around values (for numeric) in the SQL query to update the database.<br/><br/>
  
  Setting the value to 3 allows NULL and if the column value is not NULL, the column value will be 
  surrounded in quotes in the SQL query to update the database.

</ap>
	<h>
    This field-level action exports the captured value of the current Field object from the page's 
    Data file to a target column within a previously designated table of an open Export database. 
    Optionally, it can assign a <i>Style</i> to the action.
		<e>
      Batch Level:<br/>
      ExportOpenConnection("@APPVAR(values/dsn/exportdb:cs")<br/>
      SetTableName("Export_Results")<br/><br/>

      Current field:<br/>
      <b>ExportToColumn("db_Date,3")</b><br/><br/>

      Last Field:<br/>
      AddRecord()<br/><br/>

      This example exports the captured value of the Field object to which the rule applies, 
      from the Data file of the current page to the db_Date column of the Export_Results table, 
      within the Export database. 
      It also uses the second, optional parameter value to assign a <i>Style</i> to the action.
		</e>	
	</h>
  <lvl>Field level only.</lvl>
  <ret>
    <b>False</b> if:<br/>
    <b>1.</b> There is no connection to the database.<br/>
    <b>2.</b> The column identified by the parameters does not exist.<br/>
    <b>3.</b> A SetTableName action was not previously used.<br/><br/>

    Otherwise, <b>True.</b>
  </ret>
  <see>ExportFieldToColumn, ExportPropertyToColumn</see>
</ref>
	
<ref id="ExportOpenConnection" qi="Opens a connection to the database specified as the parameter.">
  <ap>
    The Connection String of the target Export database.
    Use smart parameters to avoid clear text passwords in your application.
  </ap>
  <h>
    Opens a connection to the database specified as the parameter.<br/><br/>

    A rule containing this action can apply to any object of the Document Hierarchy, but it is most often used at the batch level.<br/><br/>
    <e>
      <b>ExportOpenConnection("@APPVAR(values/dsn/exportdb:cs)")</b><br/><br/>

      <b>Note:</b> This action must come before any other ExportDB actions.  This example
      uses smart parameters to obtain the connection string from the application service
      where the custom connection string key "exportdb" has been created in the "Custom Values" tab.
      It provides a single location for the connection string and security for passwords.<br/><br/>

      <b>Note:</b> If the action is establishing a connection with an Oracle database,
      or a SQL Server database using SQL Server Authentication, be sure to expand the DSN parameter
      by adding the correct Provider, user ID and Password.  For example:<br/><br/>

      <b>Oracle</b><br/>
      ExportOpenConnection("PROVIDER=ODBCORACLE;DSN=1040Look;CATALOG=;DBNTA=;UID=Admin;PWD=Admin;")<br/><br/>

      <b>SQL Server Authentication</b><br/>
      ExportOpenConnection("PROVIDER=ODBCMSSQL;DSN=1040Look;CATALOG=;DBNTA=;UID=Admin;PWD=Admin;")<br/><br/>

      <b>Note:</b> Although the Oracle and SQL examples show the connection string, it is recommended that a smart 
      parameter is used to obtain the connection string from the application service, as shown in the first example,
      to provide password security and application portability.

    </e>
  </h>
  <lvl>All, but generally used at the Batch level.</lvl>
  <ret>
    <b>True</b> if the connection opens. Otherwise, <b>False.</b>
  </ret>
  <see>
    ExportCloseConnection
  </see>
</ref>


<ref id="SetTableName" qi="Sets the name of the table in your database to which the data is to be exported.">
  <ap>
    Two comma separated parameters:<br/><br/>

    <b>1.</b> The name of the database table where the exported data will be inserted.<br/><br/>

    <b>2.</b> Optional: If the numeric value of 1 is specified, the action will immediately check the database to
    confirm that the supplied table name is valid.  If the table name is not valid, SetTableName will return False.
    Note that this value causes an extra database call so it is typically specified only during development,
    not in a production system as it will increase the number of database calls and running time.<br/><br/>

    If the second parameter is not specified, this action will always return true.
    If the specified table name is in valid, an error will be returned when the current row is inserted to the database on the next AddRecord call.
  </ap>
  <h>Sets the name of the table in your database to which the data is to be exported.  This action needs to be used before the AddRecord action.
		<e><b>SetTableName(Export_Results,1)</b><br/>
		<scr>ExportFieldToColumn(MyDate, db_Date)</scr><br/>
		<scr>AddRecord()</scr> 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    Returns <b>False</b> only if the first parameter contains an invalid table name and a value of 1 is specified as a second parameter.  
    Otherwise this action always returns <b>True.</b>
  </ret>
  <see>AddRecord</see>
</ref>
	
<ref id="ExportBatchIDToColumn" qi="Exports the current Batch ID to the database column specified by the parameter.">
<ap>
  Three comma-separated values:<br/><br/>

  <b>1.</b> The name of the field whose value will be stored in the column.<br/><br/>

  <b>2.</b> The name of the database column that will hold the value.<br/><br/>

  <b>3.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.<br/><br/>
  
  If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>
  
  Setting the value to 1 causes this action to return False if the Table name is invalid;
  otherwise the error will not be discovered until the action that performs the DB insert call,
  such as an AddRecord action, is called.  This value would typically
  only be used in a development environment as it will increase processing time.<br/><br/>
  
  Setting this value to 2 allows NULL column values and inserts no quotes around values (for numeric) in the SQL query to update the database.<br/><br/>
  
  Setting the value to 3 allows NULL and if the column value is not NULL, 
  the column value will be surrounded in quotes in the SQL query to update the database.
  <br/><br/>
</ap>

  <h>
    Exports the current Batch ID to the database column specified by the parameter. The action also has an optional <i>Style</i> parameter with two values.
    <e>
      SetTableName("Export_Results")<br/>
      <b>ExportBatchIDToColumn("db_BatchID,1,2")</b><br/>
      ExportFieldToColumn("Date,db_Date")<br/>
      ExportFieldToColumn("Total,db_Total")<br/>
      AddRecord()
    </e>
  </h>
  <lvl>All, but generally at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if the second parameter is set to "1" and the parameter does not identify a
    valid database column. Otherwise, <b>True.</b>
  </ret>
  <see>AddRecord, ExportFieldToColumn, ExportPropertyToColumn</see>
</ref>

<ref id="ExportSmartParamToColumn" qi="Adds the evaluated value of a smart parameter to a column of the Export database">
  <ap>
    Three comma-separated values:<br/><br/>

    <b>1.</b> A smart parameter that specifies the value to be stored into the column.<br/><br/>

    <b>2.</b> The name of the database column that will hold the value.<br/><br/>

    <b>3.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.<br/><br/>
    
    If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>

    Setting the value to 1 causes this action to return False if the Table name is invalid; 
    otherwise the error will not be discovered until the action that performs the DB insert call, 
    such as an AddRecord action, is called.  This value would typically only be used 
    in a development environment as it will increase processing time.<br/><br/>
    
    Setting this value to 2 allows NULL column values and inserts no quotes 
    around values (for numeric) in the SQL query to update the database.<br/><br/>
    
    Setting the value to 3 allows NULL and if the column value is not NULL, 
    the column value will be surrounded in quotes in the SQL query to update the database.<br/><br/>
</ap>
  <h>
    Using the database opened by an earlier ExportDB action, this action will 
    store a value into the specified column for the current row.  
    The action allows the input value to be specified with a smart parameter.<br/><br/>
    <e>
      <b>ExportSmartParamToColumn("@P\MyField.TYPE,EXPDBCOLUM")</b>
    </e>
  </h>
  <lvl>All, but generally at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if:<br/><br/>
    <b>1.</b> There is no connection to the database.<br/>
    <b>2.</b> The column identified by the parameter does not exist.<br/>
    <b>3.</b> A <b>SetTableName</b> action was not previously used.<br/><br/>
    Otherwise, <b>True.</b>
  </ret>  
</ref>
  
<ref id="ExportNodeXMLToColumn" qi="Exports the value of the XML property of the bound object (node) of the Document Hierarchy to a column of the Export database.">
  <ap>
    Three comma-separated values:<br/><br/>

    1. The smart parameter path to the bound object of the Document Hierarchy. 
    This object's XML property will be added to a designated column of the Export database.<br/><br/>

    2. The String value of the name of the target column in the Export database. 
    The action will add the value of the calling object's XML property to this column.<br/><br/>

    3. Optional: Can be set to  the numerical value of 1, 2, or 3.  <br/><br/>
    
    If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>
    
    Setting the value to 1 causes this action to return False if the Table name is invalid; 
    otherwise the error will not be discovered until the action that performs the 
    DB insert call, such as an AddRecord action, is called.  This value would typically 
    only be used in a development environment as it will increase processing time.<br/><br/>
    
    Setting this value to 2 allows NULL column values and inserts no quotes around values (for numeric) in the SQL query to update the database.<br/><br/>
    
    Setting the value to 3 allows NULL and if the column value is not NULL, the column value
    will be surrounded in quotes in the SQL query to update the database.
  </ap>
  <h>
    This action exports the value of the <b>XML</b> property of the bound object (node)
    of the Document Hierarchy to a column of the Export database.<br/>
    <br/>
    <e>
      <b>ExportNodeXMLToColumn("@P\MyField,MYDBCOLUM")</b>
    </e>
  </h>
  <lvl>All, but generally at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if:<br/>
    <br/>
    <b>1.</b> There is no connection to the database.<br/>
    <b>2.</b> The column identified by the parameter does not exist.<br/>
    <b>3.</b> A <b>SetTableName</b> action was not previously used.<br/>
    <b>4.</b> The smart parameter path does not point to a valid object of the Document Hierarchy.<br/><br/>
    Otherwise, <b>True.</b>
  </ret>
</ref>
</help>
</rrx>
<rrx namespace="ExportXML" src="c:\datacap\RRS\ExportXML.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="xml_SaveFile" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call XMLExport.CommitNodes()]]>
<![CDATA[
]]>
<![CDATA[	xml_SaveFile = XMLExport.SaveXMLFile()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SaveFile")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_SetExportPath" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	xml_SetExportPath = XMLExport.SetExportPath(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SetExportPath")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_SetFileName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	xml_SetFileName = XMLExport.SetFileName(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SetFileName")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_NewNode" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim NewNodeID]]>
<![CDATA[
]]>
<![CDATA[	Dim ParentNodeID]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",",",")        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	NewNodeID = metaword(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	ParentNodeID = metaword(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	xml_NewNode = XMLExport.AddNode(NewNodeID,ParentNodeID)	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_NewNode")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_SetNodeValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sNodeID]]>
<![CDATA[
]]>
<![CDATA[	Dim sFindValue]]>
<![CDATA[
]]>
<![CDATA[	Dim sNodeValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = split(strparam & "," & CurrentObj.Type ,",")]]>
<![CDATA[
]]>
<![CDATA[	sNodeID = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sFindValue = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sNodeValue = MetaWord(sFindValue)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	xml_SetNodeValue=XMLExport.SetNodeValue(metaword(sNodeID), sNodeValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SetNodeValue")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_SetAttributeValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim NodeID]]>
<![CDATA[
]]>
<![CDATA[	Dim sAttID]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrparam]]>
<![CDATA[
]]>
<![CDATA[	Dim sFindValue]]>
<![CDATA[
]]>
<![CDATA[	Dim sNodeValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	xml_SetAttribute=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",," & CurrentObj.Type,",")        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	NodeID = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sAttID = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sFindValue = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sNodeValue = MetaWord(sFindValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	xml_SetAttributeValue=XMLExport.SetAttributeValue(NodeID,sAttID,sNodeValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SetAttributeValue")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_CommitNode" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	xml_CommitNode=XMLExport.CommitChildren(metaword(Trim(StrParam)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_CommitNode")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************
' help.xml for Export 

' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
' Version 8.1.0.30 RFerin 05/20/2011
'  * 32032 Converted to .Net DLL
'
'
'************************************************************
]]>

<ref id="xml_SaveFile">
  <ap>None.</ap>
  <h>
    This action commits all unsaved nodes and saves XML file to disk. You must use this action
    to complete the creation of the export XML file.
    <e>
      <b>xml_SaveFile()</b>
    </e>
  </h>
  <lvl>Batch, Document or Page level.</lvl>
  <ret>
    <b>True</b> if the file is created successfully. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="xml_SetExportPath" >
  <ap>
    String value of the file's full path.<br/>
    <b>Alert!</b> The action defaults to the <b>Batches</b>
    directory. Note that the action can use Smart Parameters.
  </ap>
  <h>
    This action will only set the path.  You will still need to use <b>xml_SetFileName</b> to set the
    name of the export file.
    <e>
      <b>xml_SetExportPath("C:\Invoice\ExportXML")</b><br/>
      xml_SetFileName("@BatchID")
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="xml_SetFileName">
  <ap>String value of the File Name. Note that the action can use Smart Parameters.</ap>
  <h>
    <e>
      xml_SetExportPath("C:\Invoice\ExportXML")<br/>
      <b>xml_SetFileName("@BatchID")</b>
    </e>
  </h>	
  <lvl>All.</lvl>
  <ret>Always <b>True.</b></ret>
  <see>xml_SaveFile</see>
</ref>
  
<ref id="xml_NewNode" >
  <ap>Comma-separated String values of:<br/><br/>  
    <b>1.</b> The NodeID (tag name) of a new child node.<br/>
    <b>2.</b> The NodeID (tag name) of the parent node, if there is a parent.<br/><br/>
    Smart parameters are supported.
  </ap>
  <h>
    The new NodeID followed by the parent NodeID creates a new Node in the Export XML file.  Note that the action can use Smart Parameters.
    <br/><br/>
    The first <b>xml_NewNode</b> action in a ruleset will create the root node of the XML file using the
    new child NodeID, the parent NodeID must be blank.
    <br/><br/>
    <e>
      xml_SetExportPath("C:\ParentDir\APT")<br/>
      xml_SetFileName("@BATCHID")<br/>
      <b>xml_NewNode("B")</b><br/>
      xml_SetAttributeValue("B,id,@BATCHID")<br/><br/>
      The example above starts an export XML file that is named the same as the current batch ID.
      It has a root node "B" whose "id" is assigned the batch ID.  It is expected that additional rules
      will continue to build the XML structure.  The last invoked action must call xml_SaveFile to save
      the export file to disk.
      <br/><br/>
      <b>xml_NewNode("ClaimsData,HCFA")</b><br/>
      Duplicated Node ID's will cause the prior node of the same ID to commit to its specific parent
      node and will no longer be available for modification.<br/><br/>
      Note: Adding a second child NodeID with the same Tag name of the root node will cause the action
      to return false.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if parent node exists. <br/><b>False</b> if duplicate root node
    is declared, or parent NodeID does not exist.
  </ret>
  <see>xml_SaveFile</see>
</ref>
  
<ref id="xml_SetNodeValue" >
  <ap>
    Two comma-separated values:<br/><br/>
    1. The NodeID.<br/>
    2. The value to assign to the node.<br/><br/>
    The action defaults the current object's value.<br/>
    Smart parameters are supported.
  </ap>
  <h>
    Assigns a value to a specific node.  Note that the action can use Smart Parameters.
    <e>
      The example below shows how creation of an XML for invoice line items might look.<br/>
      xml_NewNode("LineItem,Invoice")<br/>
      xml_SetAttributeValue("LineItem,id,@ID")<br/>
      xml_NewNode("ItemID,LineItem")<br/>
      <b>xml_SetNodeValue("IdemID,@F\ItemID")</b><br/>
      xml_NewNode("ItemDesc,LineItem")<br/>
      <b>xml_SetNodeValue("ItemDesc,@F\ItemDesc")</b><br/>
      xml_NewNode("Qty,LineItem")<br/>
      <b>xml_SetNodeValue("Qty,@F\Qty")</b><br/>
      xml_CommitNode("LineItem")<br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>Always <b>True.</b></ret>
  <see>xml_NewNode</see>
</ref>
  
<ref id="xml_SetAttributeValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns attributes to a specific node.">
  <ap>
    Three comma-separated values:<br/><br/>
    <b>1.</b>The NodeID.<br/>
    <b>2.</b>The attribute's name.<br/>  
    <b>3.</b>The value to be assigned to the attribute.  Smart parameters are supported.
  </ap>
  <h>
    Sets an attribute value within a specific node in the XML hierarchy.
    <e>
      The example below assigns the current Page's <b>Number</b> field value to the
      <b>Xpage</b> node's <b>Number</b> attribute.<br/>
      <b>xml_SetAttributeValue("Xpage,Number,@P\Number")</b><br/><br/>
  
      The example below shows how creation of an XML for invoice line items might look.<br/>
      xml_NewNode("LineItem,Invoice")<br/>
      <b>xml_SetAttributeValue("LineItem,id,@ID")</b><br/>
      xml_NewNode("ItemID,LineItem")<br/>
      xml_SetNodeValue("IdemID,@F\ItemID")<br/>
      xml_NewNode("ItemDesc,LineItem")<br/>
      xml_SetNodeValue("ItemDesc,@F\ItemDesc")<br/>
      xml_NewNode("Qty,LineItem")<br/>
      xml_SetNodeValue("Qty,@F\Qty")<br/>
      xml_CommitNode("LineItem")<br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the node does not exist.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="xml_CommitNode" >
  <ap>String value of the xml Tag.  Smart parameters are supported.</ap>
  <h>
    Commits (closes) current xml node with the xml tag value of the parameter. Allowing a new node with the same
    tag to be created at the same hierarchical level in the output xml.  Note that the action can use Smart Parameters.
    <e>xml_CommitNode("LineTotal")</e><br/>
    Example commits (closes) the current xml node with a Tag <i>LineTotal</i>.
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
</help>
</rrx>
<rrx namespace="FileNetIDM" src="c:\datacap\RRS\FileNetIDM.dll">

<i ref="rrunner">
</i>
<af name="Library_IS_Initialize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Initializes a previously defined, active Image Services Library.">
</af>
<af name="Library_DS_Initialize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Initializes a previously defined, active Document Services Library.">
</af>
<af name="Library_DMA_Initialize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Initializes a previously-defined, active DMA Library.">
</af>
<af name="Library_LogIn" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Logs into the initialized FileNet library using the User ID and Password parameter values.">
</af>
<f name="Library_LogOff" access="public">
</f>
<af name="SaveDocToFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Places the committed FileNet document in an existing folder of the open FileNet library.">
</af>
<f name="UseIndexes_ON" access="public">
</f>
<f name="UseIndexes_OFF" access="public">
</f>
<f name="NewDocument" access="public">
	<p name="StrParam">
	</p>
</f>
<af name="AddTIFImageToDocument" access="public" bInter="bInter" bDebug="bDebug" qi="Adds an Image file to the new FileNet document.">
</af>
<af name="AddPDFImageToDocument" access="public" bInter="bInter" bDebug="bDebug" qi="Adds a PDF Image file to the new FileNet document.">
</af>
<af name="AddFileToDocument" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Adds a file to the current FileNet document.">
</af>
<af name="AddAllImagesToDocument" access="public" bInter="bInter" bDebug="bDebug" qi="Adds All Document Page object Images to IS Document object.">
</af>
<af name="IndexProperty_ID_DateComponent" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Sets up a Date element of the FileNet task’s processing index.">
</af>
<f name="IndexProperty_SmartParameter" access="public">
	<p name="PropertyName">
	</p>
	<p name="Value">
	</p>
	<p name="Length">
	</p>
</f>
<af name="IndexProperty_LeftJUSTIFY" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Left-justifies a value that is being assigned to a target property of the FileNet document.">
</af>
<af name="IndexProperty_RightJUSTIFY" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Right-justifies a value that is being assigned to a target property of the FileNet document.">
</af>
<af name="Upload" access="public" bInter="bInter" bDebug="bDebug" qi="Commits the Active FileNet Document to the FileNet Library.">
</af>
<af name="FileNETDocID_SetValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Assigns the FileNet Document’s ID.">
</af>
<f name="FileNETDocID_SaveAsSmartParameter" access="public">
</f>
<af name="GetDocuments" access="public" bInter="bInter" bDebug="bDebug" qi="Logs the names of the documents in the FileNet collection.">
</af>
<af name="GetTopFolders" access="public" bInter="bInter" bDebug="bDebug" qi="Lists existing top-level FileNet folders in the current task’s Log file.">
</af>
<af name="CreateFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Creates a top-level FileNet folder.">
</af>
<af name="FileNetDB_ADOConnect" access="public" bInter="bInter" bDebug="bDebug" qi="Establishes an ActiveX Data Connection object (ADO connection) with FileNet.">
</af>
<af name="Upload_SetDelay" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Controls the delay between upload retries.">
</af>
<af name="Upload_SetNumAttempts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Control the number of retries for the FileNet upload.">
</af>
<help>
  <![CDATA[
  
'************************************************************************
' FileNetIDM.rrx - FileNet P8 Upload Actions

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'************************************************************************
' 
' FileNetIDM.rrx - Help.xml 
' 6/18/2012
'

]]>

  <ref id="Library_IS_Initialize">
    <ap>
      String value containing the Library name. The Library name will commonly consist of three, colon-separated elements of the Library Name. In some cases, the short
      name can be used.
      Smart Parameters are supported.
    </ap>
    <h>
      Initializes a previously defined, active Image Services Library.<br/><br/>
      In some cases, the formal three-part Library Name should be used to properly configure initialization. However, there may be some cases where
      configuring the library through the IDM Configuration tool first and then passing the short name could be used.
      Please check your FileNet documentation for guidelines on designating a formal Library Name.
      <e>
        <b>Library_IS_Initialize("LibraryName")</b><br/>
        This action initializes but does not open the library – see Library_Login.
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>False</b> if there is a problem connecting to the FileNet Image Services Library. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="Library_DS_Initialize">
    <ap>
      String value consisting of the three colon-separated elements of the Library Name.
      Smart Parameters are supported.
    </ap>
    <h>
      Initializes a previously defined, active Document Services Library.<br/><br/>
      Do not confuse the Library Name with the local FileNet Neighborhood label.
      In some cases, the formal three-part Library Name must be used to properly configure initialization.
      Please check your FileNet documentation for guidelines on designating a formal Library Name.
      <e>
        <b>Library_DS_Initialize("DSLibrary:Datacap:FileNet")</b><br/>
        Alert! This action initializes but does not open the library – see Library_Login.
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>False</b> if there is a problem connecting to the FileNet Document Services Library. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>
  <ref id="Library_DMA_Initialize">
    <ap>
      String value consisting of three colon-separated elements of the Library Name.
      Smart Parameters are supported.
    </ap>
    <h>
      Do not confuse the Library Name with the local FileNet Neighborhood label.
      In some cases, the formal three-part Library Name must be used to properly configure initialization.
      Please check your FileNet documentation on how to discern your formal library name.
      <e>
        <b>Library_DMA_Initialize("DMALibrary:Datacap:FileNet")</b><br/>
        This action initializes but does not open the library – see Library_Login.
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>False</b> if there is a problem connecting to the FileNet DMA Library. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="Library_LogIn">
    <ap>
      String values of the User ID and Password, with a comma separator. Smart Parameters are supported.
    </ap>
    <h>
      Logs into the initialized FileNet library using the User ID and Password parameter values.
      You must include this action to access a library. Be sure the Library_Login action follows
      one of the Library_Initialize actions.
      <e>
        Library_DS_Initialize("DefaultLib:Datacap:FileNet")<br/>
        <b>Library_Login("FileNet2,FN2")</b>
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>False</b> if an active library is not found, the parameter values are incorrect, or an error
      occurs while logging into the library. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="Library_LogOff">
    <ap>
      None.
    </ap>
    <h>
      Closes the FileNet connection.
      <e>
        <b>Library_LogOff()</b>
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>True,</b> if the logoff was successful.  Otherwise, <b>False.</b>
    </ret>
  </ref>
  <ref id="SaveDocToFolder">
    <ap>
      String value of the Folder ID, beginning with a forward slash (/) - see the example.  Smart Parameters are supported.
    </ap>
    <h>
      Places the committed FileNet document in an existing folder of the open FileNet library.
      Although the forward slash (/) character is a standard element of this action’s parameter,
      the setup of your FileNet library may mean that the forward slash is not used.
      Under exceptional circumstances, this action will have this syntax – note that a
      forward slash does not precede the Folder ID:
      SaveDocToFolder("1074a")
      <e>
        Library_DS_Initialize("1040Docs")<br/>
        Library_Login("FileNet2,FN2")<br/>
        NewDocument("1040EZtwo")<br/>
        AddAllImagesToDocument()<br/>
        Upload()<br/>
        <b>SaveDocToFolder("/1074a")</b><br/><br/>

        As the example shows, you can insert this action after adding images and successfully committing
        (uploading) the document to the FileNet library.
      </e>
    </h>
    <lvl>
      All Levels.
    </lvl>
    <ret>
      <b>False</b> if there is no active FileNet document, no active FileNet library,
      invalid parameter, or if the active FileNet document has not been committed. Otherwise, <b>True.</b>
      Note: If the action cannot access the specified folder, the action directs the Rulerunner
      task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="UseIndexes_ON">
    <ap>
      None.
    </ap>
    <h>
      This status allows the task to access the properties of the FileNet document,
      and to provide these properties with values of objects of the Document Hierarchy.
      True is the default value for using indexes
      <e>
        <b>UserIndexes_ON()</b><br/>
        IndexProperty_ID_Component("FNDoc,1040EZTwo,12")<br/><br/>

        A task cannot define or populate indices until a rule with this action activates the
        Indexing feature. However, the On status is a default status, and is in effect unless
        a UseIndexes_OFF action turns it Off.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="UseIndexes_OFF">
    <ap>
      None.
    </ap>
    <h>
      Turns Off a Rulerunner task’s Indexing feature.
      Because the feature is On by default, the task will continue to generate and assign
      index values until a rule with this action turns it Off.<br/><br/>
      A rule with action must be applied before a new FileNet document is created.
      <e>
        <b>UserIndexes_OFF()</b>
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>
  <ref id="NewDocument">
    <ap>
      String value of a previously defined FileNet Document Class.  Smart Parameters are supported.
    </ap>
    <h>
      Sets up a new FileNet document, and assigns the FileNet Document Class you specify as
      an argument to the new FileNet document.<br/><br/>

      After an Upload action commits the document to a FileNet library,
      FileNet immediately links a unique ID to the document.
      <e>
        Library_DS_Initialize("DefaultIMS:Datacap:FileNet")<br/>
        Library_Login("FileNet2,FN2")<br/>
        <b>NewDocument("1040EZtwo")</b><br/><br/>

        In this example, the NewDocument action instantiates a new FileNet document of Class:‘1040EZtwo’.
        (To populate the document, you’ll probably follow this action with one of the AddImage actions.)

      </e>
    </h>
    <lvl>
      All Levels.
    </lvl>
    <ret>
      <b>False</b> if a new document cannot be created. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="AddTIFImageToDocument">
    <ap>
      None.
    </ap>
    <h>
      Adds the Image file associated with a Page object of the Document Hierarchy to the new FileNet document.<br/><br/>
      If a rule containing this action is bound to a Field object, it adds the Image
      file associated with the field’s parent Page object.<br/>
      An Upload action should stay at any level lower than this action.
      <e>
        NewDocument("1040EZtwo")<br/>
        <b>AddTIFImageToDocument()</b><br/><br/>

        This sequence associates the calling component’s bound Image file with a new FileNet ‘1040EZtwo’ document.
      </e>
    </h>
    <lvl>
      Field or Page level.<br/>
    </lvl>
    <ret>
      <b>False</b> if no Page component of the calling object is found, batch images
      cannot be accessed, or if the active FileNet document has already been committed to the library. Otherwise, <br>True.</br>
      Note: If the action cannot access the batch’s image files, the action directs
      the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="AddPDFImageToDocument">
    <ap>
      None.
    </ap>
    <h>
      Adds a PDF Image file associated with a Page object of the Document Hierarchy to the new FileNet document.
      This action works only if the PDF file is in the appropriate folder of the application’s Batches directory –
      and has the same name as an associated page’s corresponding Tiff Image file.
      <e>
        NewDocument("1040EZtwo")<br/>
        AddPDFImageToDocument()<br/><br/>

        This sequence associates calling components bound to the PDF file with a new FileNet ‘1040EZtwo’ document.
      </e>
    </h>
    <lvl>
      Field or Page level.
    </lvl>
    <ret>
      <b>False</b> if no Page component of the calling object is found, batch images
      cannot be accessed, or if the active FileNet document has already been committed to the library. Otherwise, <b>True.</b>
      Note: If the action cannot access the batch’s image files, the action directs the
      Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>
  <ref id="AddFileToDocument">
    <ap>
      String value of the File name to add to the document – and its path.  Smart Parameters are supported.
    </ap>
    <h>
      Adds any file you designate as a parameter to the current FileNet document.<br/><br/>
      If the parameter does not include a path to a folder, the action will use the path to
      the current Batches directory as the default. You can also designate a variable of the
      bound object of the Document Hierarchy as the source of path’s value by using the
      # character followed by the variable’s name. For example: #FilePath
      <e>
        NewDocument("1040EZtwo")<br/>
        AddTIFImageToDocument()<br/>
        <b>AddFileToDocument("C:\Datacap\MQSW\Process\FNLog.log")</b><br/><br/>

        This sequence assumes that Taskmaster logs its FileNet activities – and that a resulting Log
        file is available for the document.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if the specified file is not found, or if the active FileNet document
      has already been committed to the library. Otherwise, <b>True.</b>
      Note: If the action cannot access the batch’s image files, the action directs the
      Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="AddAllImagesToDocument">
    <ap>
      None.
    </ap>
    <h>
      Assigns all images associated within a Document object (or parent Document object) of the Document Hierarchy to the new FileNet document.
      This action is valid for IS libraries only. DS libraries only permit a single associated file.<br/><br/>
      This action solicits information from the Rulerunner task’s Page file
      (upload.xml, for example) as it assigns Image files representing pages linked to a Document object
      (or child Page objects) of the Document Hierarchy to the FileNet document.<br/><br/>
      The images are not yet committed to the library.
      <e>
        NewDocument("1040EZtwo")<br/>
        AddAllImagesToDocument()
      </e>
    </h>
    <lvl>
      Document, Page or Field levels.
    </lvl>
    <ret>
      False if action is placed at the Batch level, if the current active FileNet
      document has already been committed to the Library, or if no documents exist in the batch. Otherwise, True.
      Note: If the action cannot access the batch’s image files, the action directs the
      Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>


  <ref id="IndexProperty_ID_Component">
    <ap>
      Comma-separated values of:<br/>
      1. the name of a FileNet document’s property;<br/>
      2. the name(s) of one or more Document Hierarchy objects with values for the variable that will be transferred to the FileNet document’s property;<br/>
      3. the value of the maximum length of the subscript value.<br/><br/>

      Smart Parameters are supported.
    </ap>
    <h>
      This action links the property of the FileNet document to an object of the Document Hierarchy.
      <e>
        IndexProperty_ID_Component("FNBatch,1040EZ,18")<br/>
        IndexProperty_ID_Component("FNDoc,1040EZTwo,22")<br/>
        IndexProperty_ID_Component("FNPageF,Front,12")<br/>
        IndexProperty_ID_Component("FNPageB,Back,12")<br/>
        IndexProperty_ID_Component("FNFldLast,Last,18")<br/>
        IndexProperty_ID_Component("NFldFirst,First,18")<br/>
        IndexProperty_ID_Component("NFldMI,MI,2")<br/><br/>

        This sequence defines seven elements of a processing index for a FileNet task. In each case,
        the first parameter is the name of a property of a FileNet document that has been previously assembled.
        The second parameter assigns the Name of a Document Hierarchy object to the FileNet document’s property.
        The third parameter is the property’s maximum length.
        During task operations, runtime values for each object will become the FileNet document’s Index values.
      </e>
    </h>
    <lvl>
      Page or Field level with child Fields.
    </lvl>
    <ret>
      <b>False</b> if the FileNet property specified is invalid, or the
      FileNet Property Collection does not exist. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>
  <ref id="IndexProperty_ID_DateComponent">
    <ap>
      String consisting of four comma-separated values:<br/>
      1. the name of the FileNet document’s Date property;<br/>
      2. the name of a Document Hierarchy object with a Date property;<br/>
      3. the format of the Date when supplied to the FileNet document; and<br/>
      4. the format of the Date value being added to the task’s processing index.<br/><br/>
      See the example for acceptable Date values.  Smart Parameters are supported.
    </ap>
    <h>
      This element can then supply Date information to a Date property of the FileNet document.<br/><br/>
      The parameters can use the Date formats on the left:<br/>
      cc Century 20 yy Year 03 yyyy Year 2003 dd Day 29 mm Month 06 Julian Year/Day 03-145
      <e>
        <b>IndexProperty_ID_Date_Component("FNStart,1040EZ,mm/dd/yy,yyyy/mm/dd")</b><br/><br/>

        This example re-formats the value of the Batch object’s Start Date and assigns it
        to the FNStart property of the FileNet document.
      </e>
    </h>
    <lvl>
      Page, or Field level with child Fields.
    </lvl>
    <ret>
      <b>False</b> if the FileNet property specified is invalid, or the FileNet Property Collection does not exist. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref> 
  
  <ref id="IndexProperty_LeftJUSTIFY">
    <ap>
      String with two comma-separated values:<br/>
      1. The name of the property of the FileNet document; and<br/>
      2. The maximum size of a value.<br/><br/>

      Smart Parameters are supported.
    </ap>
    <h>
      Left-justifies a value that is being assigned to a target property of the FileNet document.
      <e>
        IndexProperty_ID_Variable("FNFldData,Year+SSN+ Income+Deductions+Net,256")<br/>
        <b>IndexProperty_LeftJUSTIFY("FNFldData,256")</b><br/><br/>

        This sequence provides the FNFldData property with a value, then formats the value
        before it is actually assigned to the active FileNet document.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if the FileNet property cannot be set.
      Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="IndexProperty_RightJUSTIFY">
    <ap>
      String with two comma-separated values:<br/>
      1. The name of the property of the FileNet document; and<br/>
      2. The maximum size of a value.<br/><br/>

      Smart Parameters are supported.
    </ap>
    <h>
      Right-justifies a value that is being assigned to a target property of the FileNet document.
      <e>
        IndexProperty_ID_Variable("FNFldData,Year+SSN+ Income+Deductions+Net,256")<br/>
        <b>IndexProperty_RightJUSTIFY("FNFldData,256")</b><br/><br/>

        This sequence provides the FNFldData property with a value, then formats the value
        before it is actually assigned to the active FileNet document.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if the FileNet property cannot be set.
      Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="Upload">
    <ap>
      None.
    </ap>
    <h>
      Commits the active FileNet document to the open FileNet library.
      <e>
        <b>Upload()</b>
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if the Document object does not exist; if the library object is missing;
      if all pages were previously committed; if the active FileNet document has already been committed
      to the library; or the upload is unsuccessful. Otherwise, <b>True.</b>
      Note: If the active FileNet document has already been committed, or
      the action encounters an error, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>
    <ref id="FileNETDocID_SetValue">
      <ap>
        The name of the Field object.  Smart Parameters are supported.
      </ap>
      <h>
        Assigns the FileNet Document’s ID to a child Field object of the bound Document,
        Page or parent Field object of the Document Hierarchy.
        <e>
          NewDocument("1040EZtwo")<br/>
          AddAllImagesToDocument()<br/>
          Upload()<br/>
          FileNETDocID_SetValue("DocID")<br/><br/>

          This sequence will set up a new FileNet document, commit it to the FileNet library,
          and assign its ID as the Text value of the specified child field value of the bound object.
        </e>
      </h>
      <lvl>
        Document level, Page level or Field with child fields.
      </lvl>
      <ret>
        <b>False</b> if an active FileNet document is not found;
        if the active FileNet document has not been committed; or if the child Field object was not found.
        Otherwise, <b>True.</b>
      </ret>
    </ref>

    <ref id="FileNETDocID_SaveAsSmartParameter">
      <p name="SmartParam"/>
      <ap>
        Smart Parameter of the 'save to' location.
      </ap>
      <h>
        Assigns the FileNet document’s ID to a variable of the bound object of the Document Hierarchy.
        This action will create a new variable if the variable does not exist.
        <e>
          FileNETDocID_SaveAsSmartParameter("FNDocID")<br/><br/>

          This example retrieves the FileNet document’s ID and assigns it to the FNDocID
          property of the Document Hierarchy’s bound object.

          FileNETDocID_SaveAsSmartParameter("@P.FNDocID")<br/><br/>

          This example assigns the FileNet document’s ID it to a variable 'FNDocID' on the
          Document Hierarchy’s parent page object.

          FileNETDocID_SaveAsSmartParameter("@B.FNDocID")<br/><br/>

          This example assigns the FileNet document’s ID it to a variable 'FNDocID' on the
          Document Hierarchy’s parent Batch object.

        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        <b>False</b> if no active FileNet document is found; or if the active FileNet
        document has not been committed. Otherwise, <b>True.</b>
      </ret>
    </ref>

    <ref id="GetDocuments">
      <ap>
        None.
      </ap>
      <h>
        A utility action used to aid debugging, it logs the names of the documents in the collection.
        This action is used to help verify the FileNet connection and that documents have been created.
        It is recommended that this is used for debugging and not in a normal production environment.
        <e>
          <b>GetDocuments()</b>
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        Always <b>True.</b>
      </ret>
    </ref>
    <ref id="GetTopFolders">
      <ap>
        None.
      </ap>
      <h>
        Lists existing top-level FileNet folders in the current task’s Log file.
        <e>
          <b>GetTopFolders()</b>
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        <b>False</b> if the top-level folder collection cannot be located. Otherwise, <b>True.</b>
      </ret>
    </ref>
    <ref id="CreateFolder">
      <ap>
        The name of the folder to create.  Smart Parameters are supported.
      </ap>
      <h>
        Creates a top-level FileNet folder
        <e>
          <b>CreateFolder("MQSW_Q601")</b>
        </e>
      </h>
      <lvl>
        Document, Page or Field levels.
      </lvl>
      <ret>
        <b>False</b> if the folder cannot be created. Otherwise, <b>True.</b>
      </ret>
    </ref>
    <ref id="FileNetDB_ADOConnect">
      <ap>
        None.
      </ap>
      <h>
        Establishes an ActiveX Data Connection object (ADO connection) with the specified FileNet database.<br/><br/>
        <e>
          Library_IS_Initialize("DefaultIMS:Domain:FileNet")<br/>
          LibraryLogin("Admin,AdOK")<br/>
          <b>FileNetDB_ADOConnect()</b>
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        <b>False</b> if the FileNet library is not initialized. Otherwise, <b>True.</b>
        Note: If the action encounters an error connecting to the specified database, the action directs the Rulerunner task to finish with a status of “Aborted”.
      </ret>
    </ref>
    <ref id="Upload_SetDelay">
      <ap>
        The number of seconds to wait between each retry of the FileNet upload.  Smart Parameters are supported.
      </ap>
      <h>
        If an upload fails, it will be automatically retried.  Between each retry, the application will pause.  The
        length of the pause can be set with this action.
        If this action is not called, the default value of 5 seconds is used.
        <e>
          Upload_SetDelay("15")
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        Always <b>True.</b>
      </ret>
    </ref>

    <ref id="Upload_SetNumAttempts">
      <ap>
        The number of times to retry the FileNet upload upon failure.  Smart Parameters are supported.
      </ap>
      <h>
        If the upload action fails, it will be automatically retried.  The number of retries can be controlled with this action.
        If this action is not called, the default value of 3 will be used.
        <e>
          <b>Upload_SetNumAttempts("5")</b>
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        Always <b>True.</b>
      </ret>    
    </ref>  
  </help>
</rrx>
<rrx namespace="FileNetP8" src="c:\datacap\RRS\FileNetP8.dll">

<i ref="rrunner">
</i>
<af name="FNP8_SetURL" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the URL for the FileNet P8 Web Service.">
</af>
<af name="FNP8_Login" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the UserID and Password for login to the IBM FileNet P8 system.">
</af>
<af name="FNP8_SetLocale" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Identifies the locale on the target P8 system.">
</af>
<af name="FNP8_SetTargetClassID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the F8 Document Class for uploaded documents.">
</af>
<af name="FNP8_SetTargetObjectID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the name of the Object Store in which documents will be stored.">
</af>
<af name="FNP8_SetDestinationFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the destination folder for the documents being uploaded.">
</af>
<af name="FNP8_CreateFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Creates a subfolder on a specified target class and object.">
</af>
<af name="FNP8_SetDocClassId" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the P8 Document Class for the uploaded files.">
</af>
<af name="FNP8_SetDocTitle" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the Document Title for documents being uploaded.">
</af>
<af name="FNP8_SetProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the designated FileNet property to a specified value.">
</af>
<af name="FNP8_SetMultiValueProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the values in a multi-value property.">
</af>
<af name="FNP8_SetTimeout" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the timeout for the FileNet P8 Web Service in milliseconds.">
</af>
<af name="FNP8_Upload" access="public" bInter="bInter" bDebug="bDebug" qi="Uploads the Batch images to the FileNet P8 repository.">
</af>
<af name="FNP8_UploadDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Uploads all images from a specific source folder.">
</af>
<af name="FNP8_SetFileType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns the file type for the files that are uploaded.">
</af>
<af name="FNP8_SetUploadMode" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set the upload mode.">
</af>
<af name="FNP8_SetRetry" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the number of automatic upload retries.">
</af>
<af name="FNP8_SetKeyProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the update properties key to a FileNet document property and its corresponding property value.">
</af>
<af name="FNP8_UpdateProperties" access="public" bInter="bInter" bDebug="bDebug" qi="Updates an existing FileNet P8 document's properties values using the data passed into the SetProperty action.">
</af>
  <help>
  <![CDATA[

'************************************************************************
' FileNetP8.rrx - FileNet P8 Upload Actions

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'************************************************************************
' 
' FileNetP8.rrx - Help.xml 
' 6/18/2012
'
]]>
<ref id="FNP8_SetURL">
<ap>
A single parameter identifying the URL for the IBM FileNet P8 Server .
The IP port is typically :9080 (IBM WebSphere) and the URL typically ends in /WSDL.
</ap>
<h>
This action sets the URL for the FileNet P8 Content Manager Server.
This action should be called before any other P8 upload actions.
<e>
  <b>FNP8_SetURL("http://myp8server:9080/wsi/FNCEWS40MTOM/")</b><br /><br />
  IMPORTANT: The address may be case sensitive and the trailing forward-slash “/” must be present. To confirm that
  the address reaches a working IBM FileNet P8 Server, browse to the address after adding “wsdl” to
  the end, e.g. http://myp8server:9080/wsi/FNCEWS40MTOM/wsdl
</e>
</h>
<lvl>All, but generally at the Batch level.</lvl>
<ret>
<b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or if the parameter is not formatted as a valid URL. Otherwise, <b>True.</b><br /><br />
Note: This action returns True whether or not the URL is actually an operating IBM FileNet P8 Server
or not.  If not, an error will be reported when the Upload or UploadDir action runs.
You can check that the URL is correct and operating by displaying it in any web browser.
</ret>
</ref>
<ref id="FNP8_Login">
<ap>
Two comma-separated smart parameter supported string values:<br /><br />
1. Login Name.<br />
2. Password.<br /><br />    
</ap><h>
This action provides the User ID and Password to use when logging in to IBM FileNet P8.
<e><b>FNP8_Login("User1,Password1")</b></e></h><lvl>All, but generally at the Batch level.</lvl><ret><b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b></ret>
</ref>
<ref id="FNP8_SetLocale">
<ap>
Locale value accepted by the FileNet P8 Web Service. The default value is “en_US”.<br /><br />
Locales are represented by 2-letter ISO 639 Language Codes and 2-letter ISO 3166 Country Codes 
separated by a _ character. For example: en_US or de_DE<br /><br />
Please consult these ISO documents to determine your locale value.
</ap><h>
Sets the Locale (the language and language conventions such as date format) used on the P8 server.  
This action is only required if the P8 repository uses a locale other than US English.
<e><b>FNP8_SetLocale("en_US")</b></e></h><lvl>All, but generally at the Batch level.</lvl><ret><b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b></ret>
</ref>
<ref id="FNP8_SetTargetClassID">
<ap>
Specifies the repository type.  The valid values are "ObjectStore" and 
"FileStore".    
</ap><h>
Sets the top level repository type.
If this action is not called, the default value of "ObjectStore"will be used.
FileStore is an alternative repository type.
<e><b>FNP8_SetTargetClassID("ObjectStore")</b></e></h><lvl>All levels.</lvl><ret><b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b></ret>
</ref>
<ref id="FNP8_SetTargetObjectID">
<ap>String value of the Object ID.</ap><h>
Provides the name of the Object Store that you wish to store your documents in.
<e><b>FNP8_SetTargetObjectID("AP_ObjectStore")</b></e></h><lvl>All, but generally at the Batch level.</lvl><ret><b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b></ret>
</ref>
<ref id="FNP8_SetDestinationFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the destination folder for the documents being uploaded."><ap>
The path to the destination FileNet P8 folder in the selected Object Store where documents should be uploaded.  For example: \1040EZ\
The default value is the root folder of the specified target object.
</ap><h>
Sets the destination folder for the documents being uploaded.  See also FNP8_CreateFolder.<br /><br />
Note: This setting can be changed by a subsequent FNP8_CreateFolder action.
Note: If you call it with the foldername "Unfiled Documents" (case insensitive) it will upload to FileNet's special "Unfiled Documents" folder.
<e><b>FNP8_SetDestinationFolder("\1040EZ\")</b></e></h><lvl>All levels.</lvl><ret><b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b>
</ret>
</ref>
<ref id="FNP8_CreateFolder">
<ap>
A string value or a predefined Smart Parameter variable which specifies the name of the folder to 
create.<br /><br />
The allowed predefined variables are: @BATCHID, @ID, @STATUS, @TYPE, @VALUE, 
@JOBID, @JOBNAME, @OPERATOR, @STATION, @TASKID, @TASKNAME and @name.  Please refer to
the documentation for more information on these values.
</ap><h>
This action creates a subfolder on a specified target class and object.  Like the 
Upload actions, this action must be preceded by SetURL, Login and SetTargetClassID actions.
<e>
FNP8_SetDestinationFolder("\1040EZ\Export\")<br /><b>FNP8_CreateFolder("@BATCHID")</b><br /><br />
This example will create a subfolder under the \1040EZ\Export\ folder and change 
the destination folder to the newly created folder.
If the folder is created successfully, the action adds a variable “Folder_ID” 
to the current DCO with the folder ID returned from FileNet Web Service.
</e></h><lvl>All levels.</lvl><ret><b>False</b> if the parameter cannot be parsed, the set up information is invalid,
or the folder cannot be created.  Otherwise, <b>True.</b><br /><br />
Note: If the action returns False, the action directs the Rulerunner task to finish
with a status of “Aborted”.
</ret>
</ref>
<ref id="FNP8_SetDocClassId">
<ap>
String value of the Document Class ID.    
</ap><h>
Sets the Document Class to be used in FileNet P8 for the documents being uploaded.
If this action is not called, the default value of "Document" will be used.
<e><b>FNP8_SetDocClassId("Document")</b></e></h><lvl>All levels.</lvl><ret><b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
or if parameter is not a string.  Otherwise, <b>True.</b></ret>
</ref>
<ref id="FNP8_SetDocTitle">
<ap>
String value of a Document Title or a predefined Smart Parameter variable.  “Title”, without the quotation 
marks, is an acceptable default parameter.<br /><br />
The allowed predefined variables are: @BATCHID, @ID, @STATUS, @TYPE, @VALUE,
@JOBID, @JOBNAME, @OPERATOR, @STATION, @TASKID, @TASKNAME and @name.  Please refer to
the documentation for more information on these values.
</ap><h>
Sets the Document Title for documents being uploaded.
<e><b>FNP8_SetDocTitle("1040ez")</b><br />
or<br /><b>FNP8_SetDocTitle("@ID")</b></e></h><lvl>All levels.</lvl><ret><b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
or if parameter is not a string.  Otherwise, <b>True.</b></ret>
</ref>
<ref id="FNP8_SetMimeType">
<ap>A string indicating the MIME type of the uploaded documents.</ap><h>
FNP8_SetMimeType has been replaced by FNP8_SetFileType.<br />
This action sets the MIME (Multipurpose Internet Mail Extensions) type, or content type,
for the uploaded documents.
<e><b>FNP8_SetMimeType("jpg")</b></e></h><lvl>All levels.</lvl><ret><b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
or if parameter is not a string.  Otherwise, <b>True.</b></ret>
</ref>
<ref id="FNP8_SetProperty">
<ap>
The following comma-separated string values:<br /><b>1.</b> Property ID:  the name of an existing document property in the FileNet 
library (equivalent to a document index field).<br /><br /><b>2.</b> String value or a predefined Smart Parameter variable to assign to the property.<br /><br />
The allowed predefined variables are: @BATCHID, @ID, @STATUS, @TYPE, @VALUE,
@JOBID, @JOBNAME, @OPERATOR, @STATION, @TASKID, @TASKNAME and @name.  Please refer to
the documentation for more information on these values.<br /><br /><b>3.</b> Optional property type.  If this parameter is not specified, the
property type will default to a 'string'.  Supported types are: Binary, Boolean, DateTime, Float, ID, Integer, Object and String.
</ap><h>
Sets the designated FileNet property to a specified value.
This is equivalent to setting an index value for a document in other document management systems.
<e><b>FNP8_SetProperty("DocumentTitle, @ID")</b><br />
FNP8_Upload()
</e></h><lvl>All levels.</lvl><ret><b>False</b> if either parameter is blank or if the value parameter is invalid.  Otherwise <b>True.</b><br /><br />
Note: If the action returns False, the action directs the Rulerunner task to finish
with a status of “Abort”. The task will also abort if more than one value is assigned
to the Smart Parameter variable.  If a ruleset calls the FNP8_SetProperty action more than once,
using the same Property ID as the opening parameter, FileNet P8 assumes that the second
parameter is multi-value and assigns that value to the property.
</ret>
</ref>
<ref id="FNP8_SetMultiValueProperty">
<ap>
A comma separated string consisting of these three values:<br /><b>1.</b> Property ID<br /><b>2.</b> Property Value<br /><b>3.</b> An optional Property Type.  The default is a "String".  Refer to the FileNet documentation
for a list of Property Types.
</ap><h>
This action sets the property of a FileNet P8 multi-value property.  It can be called multiple times.
<e>
FNP8_SetDocClassId("MyFilenetClass")<br />
FNP8_SetDocTitle("MyFilenetClass Documents")<br />
FNP8_SetProperty("CustomerName,@D.CustomerName")<br /><b>FNP8_SetMultiValueProperty("InvoiceList,@D.InvoiceList")</b><br />
FNP8_SetProperty("ScanStation,@STATION")<br />
FNP8_SetProperty("ScanOperator,@OPERATOR")<br />
FNP8_SetFileType("pdf")<br />
FNP8_Upload()
</e></h><lvl>All levels.</lvl><ret><b>False</b> if the ID or Value parameters are missing or if the specified property
is not a multi-value property.  Otherwise <b>True.</b></ret>
</ref>
<ref id="FNP8_SetTimeout">
<ap>
A single parameter identifying the timeout in milliseconds for the FileNet P8 Web Service.  
The default timeout is 600000 milliseconds (600 seconds).
</ap><h>
This action sets the timeout in milliseconds for the FileNet P8 Web Service.  
This action should be called before the FNP8_Upload action.
<e><b>FNP8_SetTimeout(90000)</b><br /><br /></e></h><lvl>All, but generally at the Batch level.</lvl><ret><b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or if the parameter is not formatted as a valid integer value. Otherwise, <b>True.</b><br /><br /></ret>
</ref>
<ref id="FNP8_Upload">
<ap>None.
</ap>
<h>
Uploads image files from the Taskmaster batch to the specified destination folder in the 
FileNet library.  When called at the Batch or Document level, attempts to upload a 
multipage TIF image file named ObjID.tif, where ObjID is the DCO Object ID of the 
Batch or Document.  If such a file does not exist, tries to upload all page images in 
the Batch or Document.  When called at the Page level, uploads the image file for that page.
It is important that any required properties are set before calling FNP8_Upload such as FNP8_SetDocTitle otherwise an upload error could occur.
<e><b> FNP8_SetURL("http://server:port//wsi/FNCEWS40MTOM/")<br />
FNP8_Login("user,password")<br />
FNP8_SetLocale("en-us")<br />
FNP8_SetDocClassId("MyFilenetDocClass")<br />
FNP8_SetDocTitle("Document Title")<br />
FNP8_SetProperty("CustomerName,@D.CustomerName")<br /><b>FNP8_SetMultiValueProperty("InvoiceList,@D.InvoiceList")</b><br />
FNP8_SetProperty("ScanStation,@STATION")<br />
FNP8_SetProperty("ScanOperator,@OPERATOR")<br />
FNP8_SetFileType("pdf")<br />
FNP8_Upload()</b></e></h><lvl>Batch, Document or Page level.</lvl><ret><b>False</b> if the upload is not successful, or the action was applied to the
Field level.  Otherwise, <b>True.</b>  If successful, each page uploaded will have a
variable “Doc_ID” set to the FileNet document identifier.<br /><br />
Note: The action directs the Rulerunner task to finish with a status of “Aborted”.
</ret>
</ref>
<ref id="FNP8_UploadDir">
<ap>
Two comma-separated String values:<br /><b>1.</b>	The full path of the source folder that contains the images to be uploaded. 
For example: C:\images<br /><b>2.</b>	A Boolean value to indicate if images should be deleted from the source folder.<br />
False: images will not be deleted from the source folder after they are uploaded.<br />
True: images will be deleted from the source folder after they are uploaded.
</ap><h>
Uploads all images in the folder you enter as the first parameter to the specified 
destination folder.  This action is an alternative to FNP8_Upload if you wish to 
upload images that are not within a Taskmaster batch.
<e><b>FNP8_UploadDir("C:\images,False")</b><br />
This example leaves the images in the source folder after they are uploaded.<br /><br /><b>FNP8_UploadDir("C:\images,True")</b><br />
This example deletes the images in the source folder after they are uploaded.
</e></h><lvl>Batch or Document level.</lvl><ret><b>False</b> if the upload is not successful.  Otherwise, <b>True.</b><br /><br />
Note: If the action returns False, the action directs the Rulerunner task to finish
with a status of “Aborted”.
</ret>
</ref>
<ref id="FNP8_SetFileType">
<ap>
A string identifying the file type.  If not provided, the value defaults to TIF.<br />
Valid types are "tif", "jpeg", "jpg", "jpe", "gif", "pdf", "xls", "doc", "msg", "docx", "xlsx" and "zip".
</ap><h>
Use this action to identify the file type of the files that will be uploaded to FileNet P8.
<e><b>FNP8_SetFileType("jpg")</b><br />
FNP8_Upload()
</e></h><lvl>Batch or Document level.</lvl><ret>
Always returns <b>True.</b></ret>
</ref>
<ref id="FNP8_SetUploadMode">
<ap>
A string or Smart Parameter identifying the page level variable where file name stored.  If this action is not called the value defaults to blank and regular upload logic applied.<br />
For example FNP8_SetUploadMode("ParentImage") will cause uploading file with the name stored in  'ParentImage' variable on the page level.
</ap><h>
Use this action to identify the files that will be uploaded to FileNet P8.
<e><b>FNP8_SetUploadMode("ParentImage")</b><br />
FNP8_Upload()
</e></h><lvl>Batch, Document or Page level.</lvl><ret>
Always <b>True.</b></ret>
</ref>
<ref id="FNP8_SetRetry" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the number of automatic upload retries."><ap>
A integer value identifies the amount of retries performed if the upload failed.  Smart parameters are allowed.
</ap><lvl>Batch, Document or Page level.</lvl><ret><b>False</b> if non-numeric parameter specified. Otherwise <b>True.</b></ret><h>
Use this action to set the amount of retries for the FileNet P8 upload actions.  If the upload to FileNet fails, the
upload action will immediately be retried the number of times specified by the FNP8_SetRetry action.<br /><br />
If this action is not called prior to a FileNet upload action, the default amount of retries is 0.
<e><b>FNP8_SetRetry("3")</b><br />
FNP8_Upload()<br /><br />
FNP8_SetRetry("3") will cause the FNP8_Upload to initiate 3 upload attempts if the upload to FileNet fails.
</e></h><lvl>Batch, Document or Page level.</lvl><ret><b>False,</b> if a non-numeric parameter specified.  Otherwise <b>True.</b></ret>
</ref>
<ref id="FNP8_SetKeyProperty">
<ap>Strings values identify a FileNet document class property and its corresponding property value. The document class property name and its value should exist on the destination P8 Object Store. The property value should also be unique because the call to the FNP8_UpdateProperties action will return only one value.  Smart parameters are allowed.</ap><lvl>Batch, Document or Page level.</lvl><ret><b>False</b>if either parameter is blank or if the value parameter is invalid. Otherwise True. 
<b>True.</b></ret><h>
This action sets the a key that is used by the UpdateProperties action. The key is a FileNet document property id and its corresponding value. The UpdateProperties action will use the key to search for an existing FileNet document. If the document is found the properties on the document will be updated with the values specified in the SetProperty actions.<br /><br /><e><b></b><br></br>FNP8_SetKeyProperty("DCKey,@DCKey")<br />
FNP8_SetProperty("FNProperty,@SomeValue")<br></br>FNP8_SetKeyProperty("@FNProperty2,@SomeValue2")<br />
FNP8_UpdateProperties()<br /><br />
This example uses the parameters of FNP8_SetKeyProperty("DCKey,@DCKey") to search for a FileNet document on an object store, if the FileNet document is found it will be assigned the values specified in the SetProperty action when the UpdateProperties action is called. The UpdateProperties action will only perform actions on the first document that is returned. If more than one document matches the criteria specified in the SetKeyProperty action, only the first document will be updated.
<br /></e><br /></h>
</ref>
<ref id="FNP8_UpdateProperties">
<ap>
Uses the key specified in the FNP8_SetKeyProperty action to search for an existing document within a FileNet P8 Content Manager Object Store and updates the P8 document’s properties as specified by the FNP8_SetProperty action.
</ap><lvl>Batch, Document or Page level.</lvl><ret>Action returns <b>True </b>if the update is successfully; False if the action is unable to update the document.</ret><h>
Use this action to update an existing FileNet P8 document's properties. The UpdateProperties action should only be used to update properties for an existing document. If a new document is created use the Upload action. <br /><e><b>FNP8_SetKeyProperty ("DCKey,@DCKey)</b><br />
FNP8_SetProperty("AGIncome, @AGIncome")<br />
FNP8_SetProperty("TaxYear,@TaxYear)<br />
FNP8_UpdateProperties()<br /><br />
This example will first set the key document property name and value to search for a document, the next two actions indicate which properties and values that the Filenet P8 document should be updated with. The FNP8_UpdateProperties will invoke the actual update. If more than one document matches the criteria specified in the SetKeyProperty action, only the first document will be updated.
</e></h>       
</ref>
</help>

</rrx>
<rrx namespace="Flex" src="c:\datacap\RRS\Flex.dll">

<i ref="validations">
</i>
<i ref="barcode_p">
</i>
<i ref="zones">
</i>
<i ref="locate">
</i>
<i ref="redaction">
</i>
<af name="SetDynamicDetailZones" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="LoadCCOFromField" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="ScanLineItemDynamic" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="AllowOnlyChars" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="PopulateZNLineItemFieldDynamic" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="CalculateNotesZone" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="ParseImageName" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="IsFingerPrintClass" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="MovePDF" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  This action moves the PDF associated with the current document to the specified directory.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Dim oFS]]>
<![CDATA[
]]>
<![CDATA[   Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[   MovePDF = False]]>
<![CDATA[
]]>
<![CDATA[   if Right(StrParam,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      StrParam = StrParam & "\"]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[   While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Could not find document object.  Exiting without moving PDF")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if       ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if Not oFS.FileExists(StrParam & oDoc.ID & ".pdf") AND oFS.FileExists(Pilot.BatchDir & "\" & oDoc.ID & ".pdf") then]]>
<![CDATA[
]]>
<![CDATA[      Call  oFS.CopyFile(Pilot.BatchDir & "\" & oDoc.ID & ".pdf",StrParam & oDoc.ID & ".pdf")]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = StrParam & oDoc.ID & ".pdf"]]>
<![CDATA[
]]>
<![CDATA[      Writelog("CurrentObj.Text = " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[      MovePDF = TRUE]]>
<![CDATA[
]]>
<![CDATA[   End if   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="iloc_SetDetailSimple" access="public" bInter="bInteractive" bDebug="bDebug" strParam="sDetailName">
</af>
<af name="Is_InCharSet" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IsBatchVariable" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IsMultipageDocument" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="IsSinglePageDocument" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="DoMsgbox" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IsChildFieldValue" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="CreateFingerprint" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="SetPicChar" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ApplyPictureString" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="WriteErrorMessage" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IsInList" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IsInINI" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IsTaskName" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="DetailFix" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="CheckForSticky" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="IsCurrentObjVariable" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IsChildFieldBlank" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetStickyNo" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="ClearErrorMsg" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="AddToErrorMsg" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IsStationIDSuffix" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="OpenConnection" access="public" bInter="bInteractive" bDebug="bDebug" strParam="strParam">
</af>
<af name="ExecuteSQLBind" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="Is_JobName" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetSELECTonField" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SaveObjectVariable" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IntellocateHeaderFields" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ReadFPXMLZones" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="FPXMLUsed" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="SwitchMMDD" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ValidateVendor" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="FindExportImage" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ReadConfigurationDB" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="CreateFlexFields" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="SetFieldValidationVariables" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="ClearFlexFieldType" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="ValidateFlexField" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="WriteFlexXMLHeader" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="WriteFlexXMLFooter" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="WriteFlexXML" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="SetFieldLocateVariables" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="LocateFlexField" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="PerformAdditionalFlexActions" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="DeleteChildByType" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="FlexRegExFind" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="FlexKeywordListFind" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="FlexLastKeywordListFind" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="FindExportImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    One of the following values: ]]>
<![CDATA[
]]>
<![CDATA['    1. Document Level TIFF.]]>
<![CDATA[
]]>
<![CDATA['    2. Document Level PDF.]]>
<![CDATA[
]]>
<![CDATA['    3. Page Level TIO.]]>
<![CDATA[
]]>
<![CDATA['    4. Page Level TIF.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA['    This action searches the batch directory for a file that corresponds to the current page that contains the current]]>
<![CDATA[
]]>
<![CDATA['    field.  The file extension must match the extension specified with the input parameter.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[   FindExportImage = False]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oPage.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Unable to find page object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = oPage]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Unable to find document object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if InStr(",1,2,3,4,","," & StrParam & ",") < 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Invaid string parameter.  Expecting 1, 2, 3, or 4.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "1" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & oDoc.ID & ".tif") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & oDOc.ID & ".tif"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & oDoc.ID & ".tif was not found.") ]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "2" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & Pilot.BatchID & oDoc.ID & ".pdf") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & Pilot.BatchID & oDoc.ID & ".pdf"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & Pilot.BatchID & oDoc.ID & ".pdf was not found." )]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "3" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & oPage.ID & ".tio") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & oPage.ID & ".tio"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & oPage.ID & ".tio was not found." )]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "4" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & oPage.ID & ".tif") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & oPage.ID & ".tif"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & oPage.ID & ".tif was not found." )]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetToDocIDMPTIFF" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    The path to the exported tiff files.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA['    This action builds a full path to the a tiff file and sets the field text to this value. ]]>
<![CDATA[
]]>
<![CDATA['    The path consists of the export path + DOCID + .TIF.]]>
<![CDATA[
]]>
<![CDATA['    The value is put into the field]]>
<![CDATA[
]]>
<![CDATA['    so it can be access later in the application, if necessary.  It only builds the path.]]>
<![CDATA[
]]>
<![CDATA['    The action does not output the TIF file.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[   if Right(StrParam,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      StrParam = StrParam & "\"]]>
<![CDATA[
]]>
<![CDATA[   end if   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   While (oDoc.ObjectType > 1)]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[   Wend]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Text = StrParam &  oDoc.ID & ".tif" ]]>
<![CDATA[
]]>
<![CDATA[   SetToDocIDMPTIFF = true]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="CheckP8Config" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Your VBScript code goes here.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    CheckP8Config = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[    LogMessage = "You must go into file " & P8ConfigFile & " and fill out this entry to export to P8."]]>
<![CDATA[
]]>
<![CDATA[     Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[     Dim oPage]]>
<![CDATA[
]]>
<![CDATA[     Dim oField]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     For i = 0 to DCO.NumOfChildren-1   'loop through docs]]>
<![CDATA[
]]>
<![CDATA[          Set oDoc = DCO.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Checking document: " & oDoc.ID)]]>
<![CDATA[
]]>
<![CDATA[          Set oPage = oDoc.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Main_Page ID: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          for j = 0 to oPage.NumOfChildren - 1   'loop through fields]]>
<![CDATA[
]]>
<![CDATA[                Set oField = oPage.GetChild(j)]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Checking field: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                 If oField.Type = "DocType" then]]>
<![CDATA[
]]>
<![CDATA[                     CurrentDocType = oField.Text]]>
<![CDATA[
]]>
<![CDATA[                      Writelog("CurrentDocType: " & CurrentDocType)]]>
<![CDATA[
]]>
<![CDATA[                       retn = Pilot.GetProfileString(CurrentDocType,"P8DocClass","*",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[                       if retn = "*" then]]>
<![CDATA[
]]>
<![CDATA[                            Call Pilot.SetProfileString(CurrentDocType,"P8DocClass","",P8ConfigFIle)]]>
<![CDATA[
]]>
<![CDATA[                            Writelog("P8Config Error:  Missing P8DocClass entry for  [" & CurrentDocType & "]")]]>
<![CDATA[
]]>
<![CDATA[                            Writelog(LogMessage)]]>
<![CDATA[
]]>
<![CDATA[                       end if]]>
<![CDATA[
]]>
<![CDATA[                 end if]]>
<![CDATA[
]]>
<![CDATA[                 if oField.Type = "FlexField" then]]>
<![CDATA[
]]>
<![CDATA[                       retn = Pilot.GetProfileString(CurrentDocType,oField.ID,"*",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[                       if retn = "*" then]]>
<![CDATA[
]]>
<![CDATA[                            CheckP8Config = FALSE]]>
<![CDATA[
]]>
<![CDATA[                            Writelog("P8Config Error:  Missing entry for document [" & CurrentDocType & "] property: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                            Writelog(LogMessage)]]>
<![CDATA[
]]>
<![CDATA[                             Call Pilot.SetProfileString(CurrentDocType,oField.ID,"",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[                       end if]]>
<![CDATA[
]]>
<![CDATA[                       if TRIM(retn) = "" then]]>
<![CDATA[
]]>
<![CDATA[                             Writelog("P8Config Error: Blank entry for document [" & CurrentDocType & "] property: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                             Writelog(LogMessage)]]>
<![CDATA[
]]>
<![CDATA[                        end if]]>
<![CDATA[
]]>
<![CDATA[                 end if]]>
<![CDATA[
]]>
<![CDATA[         Next 'j]]>
<![CDATA[
]]>
<![CDATA[     Next 'i]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<f name="SetP8FlexProperties" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Your VBScript code goes here.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    SetP8FlexProperties = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[    Dim oField]]>
<![CDATA[
]]>
<![CDATA[    Dim PropAr]]>
<![CDATA[
]]>
<![CDATA[    for i = 0 to CurrentObj.NumOfChildren - 1   'loop through fields]]>
<![CDATA[
]]>
<![CDATA[           Set oField = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[           Writelog("Checking field: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[           If oField.Type = "DocType" then]]>
<![CDATA[
]]>
<![CDATA[              CurrentDocType = oField.Text]]>
<![CDATA[
]]>
<![CDATA[              Writelog("CurrentDocType: " & CurrentDocType)]]>
<![CDATA[
]]>
<![CDATA[              retn = Pilot.GetProfileString(CurrentDocType,"P8DocClass","*",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[               if retn = "*" then ]]>
<![CDATA[
]]>
<![CDATA[                     Writelog("P8Config Error:  Unable to find document class.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[                     Exit Function]]>
<![CDATA[
]]>
<![CDATA[                end if    ]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Setting P8 Document Class to: " & retn)]]>
<![CDATA[
]]>
<![CDATA[                 Call  FNP8_SetDocClassID(false,false,retn)          ]]>
<![CDATA[
]]>
<![CDATA[            end if]]>
<![CDATA[
]]>
<![CDATA[            if oField.Type = "FlexField" then]]>
<![CDATA[
]]>
<![CDATA[               retn = Pilot.GetProfileString(CurrentDocType,oField.ID,"*",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[                if ((retn = "*") OR (Trim(retn) ="")) then]]>
<![CDATA[
]]>
<![CDATA[                    Writelog("P8Config Error: Missing or blank entry for document [" & CurrentDocType & "] property: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                    Exit Function]]>
<![CDATA[
]]>
<![CDATA[                 end if]]>
<![CDATA[
]]>
<![CDATA[                 PropAr = SPLIT(retn,",")]]>
<![CDATA[
]]>
<![CDATA[                 PropName = PropAr(0)]]>
<![CDATA[
]]>
<![CDATA[                 Writelog("Setting P8 property type to: " & PropName)]]>
<![CDATA[
]]>
<![CDATA[                 if uBound(PropAr) > 0 then]]>
<![CDATA[
]]>
<![CDATA[                      DataType = PropAr(1)]]>
<![CDATA[
]]>
<![CDATA[                     Writelog("Setting P8 DataType to: " & DataType)]]>
<![CDATA[
]]>
<![CDATA[                 end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[                 Call FNP8_SetProperty(false,false,PropName,DataType)]]>
<![CDATA[
]]>
<![CDATA[           end if]]>
<![CDATA[
]]>
<![CDATA[   Next 'i  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<f name="GetPageBarcode" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Your VBScript code goes here.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    GetPageBarcode = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[    Call ZoneLeft_ImageLeft(false,false)]]>
<![CDATA[
]]>
<![CDATA[    Call ZoneRight_ImageRight(false,false)]]>
<![CDATA[
]]>
<![CDATA[    Call ZoneTop_ImageTop(false,false)]]>
<![CDATA[
]]>
<![CDATA[    Call ZoneBottom_ImageBottom(false,false)]]>
<![CDATA[
]]>
<![CDATA[    Call GetBarcodeBP(false,false)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<help>
  <![CDATA[
'*****************************************************************************
' help.xml for Flex
'-----------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'*****************************************************************************
'
]]>

<ref id="ActionName">
  <ap>None.</ap>
  <h>
    This action changes the <i>something</i> condition of a <b>Page</b> object - and
    its <b>Field</b> objects - from <i>Off</i> to <i> On</i>.<br/><br/>

    The <i>On</i> condition prevents a rule and its actions from assigning a "problem" status to a
    field - even if the field's value fails validation.<br/>
    <e>
      <b>ActionName()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    AnotherAction
  </see>
</ref>
   
  <ref id="SetDynamicDetailZones">
    <ap></ap>
    <h>StrParam is Zone Bottom field. If more than one field is listed, Zone Bottom must be first field, and additional fields are ignored.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="LoadCCOFromField">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ScanLineItemDynamic">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="AllowOnlyChars">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="PopulateZNLineItemFieldDynamic">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
</ref >
  
  <ref id="CalculateNotesZone">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ParseImageName">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsFingerPrintClass">
    <ap></ap>
    <h>
      Two comma separated parameters:
      1. The database connection string.  Smart parameters are supported.
      2. Fingerprint class.

      This action connects to the fingerprint database and verifies that the specified fingerprint
      class contains the fingerprint ID of the current page.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >

  <ref id="MovePDF">
    <ap></ap>
    <h>
      This action moves the PDF associated with the current document to the specified directory.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see> 
  </ref >
  
  <ref id="iloc_SetDetailSimple">
    <ap></ap>
    <h>
      Action fills Setup DCO from Runtime Data file Parameter is the DETAIL DCO TYPE
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="Is_InCharSet">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsBatchVariable">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsMultipageDocument">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsSinglePageDocument">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="DoMsgbox">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsChildFieldValue">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="CreateFingerprint">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetPicChar">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ApplyPictureString">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="WriteErrorMessage">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsInList">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsInINI">
    <ap></ap>
    <h>
      Parameter is Filename,Section,Keyword
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsTaskName">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="DetailFix">
    <ap></ap>
    <h>
      Action is meant to be placed on the LineItem field.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="CheckForSticky">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsCurrentObjVariable">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsChildFieldBlank">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetStickyNo">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ClearErrorMsg">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="AddToErrorMsg">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret>always return False</ret>
    <see></see>
  </ref >
  
  <ref id="IsStationIDSuffix">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="OpenConnection">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ExecuteSQLBind">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="Is_JobName">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetSELECTonField">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SaveObjectVariable">
      <ap></ap>
    <h>
      StrParam is VarName,VarValue
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IntellocateHeaderFields">
    <ap></ap>
    <h>
      Action write fingerprint.xml from runtime page file Parameter is FingerprintDir,HostName,HostID
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ReadFPXMLZones">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FPXMLUsed">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SwitchMMDD">
    <ap></ap>
    <h>
      StrParam is list of valid separators
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ValidateVendor">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FindExportImage">
    <ap></ap>
    <h>
      1 - Document Level TIFF
      2 - Document Level PDF
      3 - Page Level TIO
      4 - Page Level TIF
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ReadConfigurationDB">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="CreateFlexFields">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetFieldValidationVariables">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ClearFlexFieldType">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ValidateFlexField">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="WriteFlexXMLHeader">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="WriteFlexXMLFooter">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="WriteFlexXML">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetFieldLocateVariables">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="LocateFlexField">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="PerformAdditionalFlexActions">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="DeleteChildByType">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FlexRegExFind">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FlexKeywordListFind">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FlexLastKeywordListFind">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FindExportImage">   
    <ap></ap>
    <h>
        One of the following values:
        1. Document Level TIFF.
        2. Document Level PDF.
        3. Page Level TIO.
        4. Page Level TIF.
    
        This action searches the batch directory for a file that corresponds to the current page that contains the current
        field.  The file extension must match the extension specified with the input parameter.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >

  <ref id="SetToDocIDMPTIFF">
    <ap></ap>
    <h>
        The path to the exported tiff files.
    
        This action builds a full path to the a tiff file and sets the field text to this value.
        The path consists of the export path + DOCID + .TIF.
        The value is put into the field
        so it can be access later in the application, if necessary.  It only builds the path.
        The action does not output the TIF file.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see> 
  </ref >

  <ref id="CheckP8Config">
    <ap>
      None<br/>
    </ap>
    <h>
      Flex only.  Checks for completeness of the P8Config.ini file.  If an entry is blank, this action fails.  If an entry is missing in the file, it adds it (leaving it blank) and fails.<br/>
      <e>
        Function1:
        CheckP8Config()<br/>
        Function2:
        SkipChildren()<br/>
      </e>
    </h>
    <lvl>
      Designed to run at the batch level
    </lvl>
    <ret>
      If the P8Config.ini has missing or blank entries, it adds the entry (if missing) and returns <b>FALSE.</b>  Otherwise, <b>TRUE.</b>
    </ret>
    <see>
      Reference other related actions here <br/>
      <scr>RelatedFunctionName</scr>
    </see>
  </ref>

  <ref id="SetP8FlexProperties">
    <ap>
      None<br/>
    </ap>
    <h>
      For Flex only.  Sets the P8 Document Class and Properties defined in the P8Config.ini<br/>
      <e>
        SetP8FlexProperties()<br/>
      </e>
    </h>
    <lvl>
      Field level only
    </lvl>
    <ret>
      Always <b>TRUE.</b>
    </ret>
    <see>
      Reference other related actions here <br/>
      <scr>RelatedFunctionName</scr>
    </see>
  </ref>

  <ref id="GetPageBarcode">
    <ap>
      None<br/>
    </ap>
    <h>
      Sets the field dimensions to the entire page before recognizing the barcode to the field.  Note, if
      a combined CCO is used, then the entire document is searched.<br/>
      <e>
        GetPageBarcode<br/>
      </e>
    </h>
    <lvl>
      Field level only
    </lvl>
    <ret>
      Always <b>TRUE.</b>
    </ret>
  </ref>

</help>
</rrx>
<rrx namespace="Grayscale" src="c:\datacap\RRS\Grayscale.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="ConvertGraytoBW" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Converts Grayscale TIFF files to Black and White TIFF files."]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  <b>Note:</b>The action renames the original Grayscale image using the same base filename,]]>
<![CDATA[
]]>
<![CDATA[  '  but replaces the .tif filename extension with ".tis".]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ConvertGraytoBW = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType > 2) Then WriteLog("Error: This action must be placed at the Batch, Document, or Page Level.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	ConvertGraytoBW = Process(CurrentObj)]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' Grayscale Conversion Actions
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************

]]>

<ref id="ConvertGraytoBW" access="public" bInter="bInter" bDebug="bDebug" qi="Converts Grayscale TIFF files to Black and White TIFF files.">
  <ap>None.</ap>
  <h>
    This action converts Grayscale TIFF files into Black and White TIFF files.<br/><br/>
    <b>Note:</b>The action renames the original Grayscale image using the same base filename,
    but replaces the .tif filename extension with ".tis".
    <e>
      <b>ConvertGraytoBW()</b>
    </e>
  </h>
  <lvl>Batch, Document or Page level.</lvl>
  <ret>
    <b>False</b> if a ruleset with this action is bound to a <b>Field</b>object of the 
    Document Hierarchy. Otherwise, <b>True.</b>
  </ret>
</ref></help>
</rrx>
<rrx namespace="ImageConvert" src="c:\datacap\RRS\ImageConvert.dll">

<i ref="rrunner">
</i>
<af name="AppendImage_StartAsNew" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="AppendImage" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="AppendAllImages" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="AppendAllImages_ByType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetDeleteOriginal" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetTIFFCompression" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetLuminanceFactor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetGrayScale" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetChrominanceFactor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ConvertToJPEG" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="ConvertToTIFF" access="public" bInter="bInter" bDebug="bDebug">
</af>
<help>
  <![CDATA[
'******************************************************************************************
' Image Conversion Actions help
'******************************************************************************************
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'******************************************************************************************
]]>
    
<ref id="AppendImage_StartAsNew" access="public" bInter="bInter" bDebug="bDebug" qi="Sets the current page as the first page for a concatenated file.">
  <ap>None.</ap>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if the image file exists for the current page and if it is a TIFF file.  Otherwise, <b>False.</b>
  </ret>
  <h>
    Sets the current page as the start of a new concatenated document.  This action is used
    in conjunction with AppendImage to create a single image created by concatenating images to
    the bottom of the first image.      AppendImage_StartAsNew identifies the first page
    and AppendImage identifies all subsequent pages.
    The result of the action will modify the first image in the document to become a single continuous image like this:<br/>
    Page 1<br/>
    Page 2<br/>
    Page 3<br/><br/>

    If images are appended prior to recognition, the entire page area will be recognized and
    click-n-key enabled.<br/><br/>
    
    It is highly recommended that this action be used only documents that have a small number of pages, such as
    two or three pages per document.  The size of the
    final composite image can quickly become larger than can be handled by some image viewers and possibly subsequent
    actions.  To keep memory usage to a minimum, it is also recommended that 1-bit Black and White images are used.<br/><br/>

    <b>Note:</b> This action only operates on TIFF images.<br/>
    <e>
      <b>AppendImage_StartAsNew()</b>
    </e>
  </h>
  <see>AppendImage</see>
</ref>
  
<ref id="AppendImage" access="public" bInter="bInter" bDebug="bDebug" qi="Concatinates the current image to the bottom of an existing image.">
  <ap>None.</ap>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if the current page is successfully concatenated with the previous page.  Otherwise, <b>False.</b>
  </ret>
  <h>
    This action will concatenate the image for the current page to the bottom of the previous 
    image processed by a call to AppendImage_StartAsNew or AppendImage.  If AppendImage_StartAsNew
    has not been called, then the first image encountered will be treated as the starting image.<br/><br/>

    If images are appended prior to recognition, the entire page area will be recognized and
    click-n-key enabled.<br/><br/>
    
    The image must be a TIFF.
    See AppendImage_StartAsNew for details.<br/>
    <e>
      AppendImage()
    </e>
  </h>
  <see>AppendImage_StartAsNew</see>
</ref>
  
<ref id="AppendAllImages" access="public" bInter="bInter" bDebug="bDebug" qi="Appends all of the images in the document to the first page.">
  <ap>None.</ap>
  <lvl>Document level.</lvl>
  <ret>
    <b>True,</b> if all of the TIFF images within the document have been appended to the end of the first TIFF image.
    Otherwise, <b>False.</b>
  </ret>
  <h>
    This action will append (concatenate) all of the images within the document to the first image of the document, creating one long image.
    The result of the action will modify the first image in the document to become a single continuous image like this:<br/>
    Page 1<br/>
    Page 2<br/>
    Page 3<br/><br/>

    If images are appended prior to recognition, the entire page area will be recognized and
    click-n-key enabled.<br/><br/>      
    
    It is highly recommended that this action be used only documents that have a small number of pages, such as
    two or three pages per document.  The size of the
    final composite image can quickly become larger than can be handled by some image viewers and possibly subsequent
    actions.  To keep memory usage to a minimum, it is also recommended that 1-bit Black and White images are used.<br/><br/>
    
    <b>Note:</b> This action only operates on TIFF images.<br/>
    <e>
      <b>AppendAllImages()</b>
    </e>
  </h>
</ref>
  
<ref id="AppendAllImages_ByType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Appends all of the images of a specific type within a document.">
  <ap>
    A string that matches the pages' 'Type' variable.
  </ap>
  <lvl>
    Document level.
  </lvl>
  <ret>
    <b>True,</b> if all of the TIFF images that match the specified type within the document have 
    been appended to the end of the first matching TIFF image.
    Otherwise, <b>False.</b>
  </ret>
  <h>
    This action will append (concatenate) all of the images, that are of the type
    specified by the input parameter, that are all within the same document to the first image of that type, creating one long image.
    Images are not appended across documents.
    Assuming you have a document where the first three pages are all the same matching type, 
    the result of the action will modify the first image in the document to become a single continuous image like this:<br/>
    Page 1<br/>
    Page 2<br/>
    Page 3<br/><br/>

    If images are appended prior to recognition, the entire page area will be recognized and
    click-n-key enabled.<br/><br/>
    
    It is highly recommended that this action be used only documents that have a small number of pages, such as
    two or three pages per document.  The size of the
    final composite image can quickly become larger than can be handled by some image viewers and possibly by subsequent
    actions.  To keep memory usage to a minimum, it is also recommended that 1-bit Black and White images are used.<br/><br/>

    <b>Note:</b> This action only operates on TIFF images.
    <e>
      <b>AppendAllImages_ByType("PO")</b><br/><br/>
      This example will append all of the images within a document that have a page type of 'PO'.
    </e>
  </h>
</ref>



<ref id="SetDeleteOriginal" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Controls deletion of file after conversion.">
  <ap>
    <b>true:</b> After the new image is created, the original will be deleted.
    <b>false:</b> After the new image is created, the original will remain.<br/><br/>
    
    Smart Parameters are supported.
  </ap>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Use this action to control the deletion of the source image file when using the actions ConvertToJPEG and ConvertToTIFF.
    If this action is not called, the default value of <b>false</b> will be used, the source image
    will not be deleted after conversion.
    <e>
      <b>SetDeleteOriginal("True")</b><br/>
      ConvertToJPEG()
    </e>
  </h>
  <see>ConvertToJPEG ConvertToTIFF</see>
</ref>
  
<ref id="SetTIFFCompression" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Controls the compression format when saving a TIFF.">
  <ap>
    One of the following values:<br/>
    <b>0</b> : No compression.<br/>
    <b>1</b> : Run length encoding (RLE).<br/>
    <b>2</b> : CCITT Group 3 fax compression.<br/>
    <b>3</b> : CCITT Group 4 fax compression.<br/>
    <b>4</b> : LZW compression.<br/>
    <b>5</b> : Apple Macintosh PackBits compression.<br/>
    <b>6</b> : JPEG compression format.<br/>
    <b>7</b> : Lossless compression standard derived from LZ77.<br/>
    <b>8</b> : CCITT Group 3 two-dimensional standard fax compression.<br/><br/>
    
    Smart Parameters are supported.
  </ap>
  <lvl>
    All levels.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    This action sets the compression type of the TIFF that is output from the action ConvertToTIFF.
    Typically Group 4 compression is used for performing recognition on images.<br/><br/>
    <b>Note:</b> all of these possible output formats may not be supported by other image processing actions.
    If this action is not called, Group 4 compression will be used.
    <e>
      <b>SetTiffCompression("3")</b><br/>
      ConvertToTIFF()
    </e>
  </h>
  <see>ConvertToTIFF</see>
</ref>

  
<ref id="SetLuminanceFactor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the image luminance or grayscale quality.">
  <ap>
    A value of 0 to 255, with a value of 0 meaning minimum compression (best quality) and 255 meaning maximum image compression.
    Smart Parameters are supported.
  </ap>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>  
  </ret>
  <h>
    JPEG images are stored in a compressed format.  This action controls the amount of compression used when converting an image to
    a JPEG image using the ConvertToJPEG action.<br/><br/>

    Data loss is the result of JPEGs ability to achieve high compression ratios. Higher quality settings result in less compression,
    while lower quality settings result in higher compression. Quality versus compression is a tradeoff.
    Adjust image compression ratio by setting the SetLuminanceFactor and SetChrominanceFactor actions.
    The SetLuminanceFactor action adjusts the luminance or gray scale quality,
    while the SetChrominanceFactor action adjusts the chrominance or color quality.
    Lower settings for these properties result in higher quality images with less compression.
    Higher settings for these properties result in lower quality images with more compression.<br/><br/>

    If this action is not called, a default value of 24 will be used.
    <e>
      <b>SetLuminanceFactor("24")</b><br/>
      SetChrominanceFactor("10")<br/>
      SetGrayScale("True")<br/>
      ConvertToJPEG()
    </e>
  </h>
  <see>ConvertToJPEG</see>
</ref>

<ref id="SetGrayScale" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Controls the grayscale output for JPEG images.">
  <ap>
    <b>True:</b> Saves the image as a grayscale image.<br/>
    <b>False:</b> Saves the image as color.<br/>
    Smart Parameters are supported.
  </ap>
  <lvl>
    All Levels.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    This action will determine if a JPEG image will be output as grayscale or color.  
    If SetGrayScale is True, all images will be saved as 8 bit grayscale.  If SetGrayScale is False, color images will
    be saved as 24 bit color and if the original image is 1 bit black and white, the new image will be 8 bit grayscale.
    If this action is not called, the value will default to False (color).
    <e>
      SetLuminanceFactor("24")<br/>
      SetChrominanceFactor("10")<br/>
      <b>SetGrayScale("True")</b><br/>
      ConvertToJPEG()
    </e>
  </h>
  <see>ConvertToJPEG</see>
</ref>

<ref id="SetChrominanceFactor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set Compression for JPEG Output Files.">
  <ap>
    A value of 0 to 255, with a value of 0 meaning minimum compression (best quality) and 255 meaning maximum image compression.  
    Smart Parameters are supported.
  </ap>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    JPEG images are stored in a compressed format.  This action controls the amount of compression used when converting an image to
    a JPEG image using the ConvertToJPEG action.<br/><br/>
    
    Data loss is the result of JPEGs ability to achieve high compression ratios. Higher quality settings result in less compression,
    while lower quality settings result in higher compression. Quality versus compression is a tradeoff.
    Adjust image compression ratio by setting the SetLuminanceFactor and SetChrominanceFactor actions.
    The SetLuminanceFactor action adjusts the luminance or gray scale quality,
    while the SetChrominanceFactor action adjusts the chrominance or color quality.
    Lower settings for these properties result in higher quality images with less compression.
    Higher settings for these properties result in lower quality images with more compression.<br/><br/>
    
    If this action is not called, a default value of 10 will be used.
    <e>
      SetLuminanceFactor("24")<br/>
      <b>SetChrominanceFactor("10")</b><br/>
      SetGrayScale("True")<br/>
      ConvertToJPEG()
    </e>
  </h>
  <see>ConvertToJPEG</see>
</ref>


<ref id="ConvertToJPEG" access="public" bInter="bInter" bDebug="bDebug" qi="Converts the current image to a JPEG.">
  <ap>None.</ap>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if the image is converted to a JPEG.<br/>
    <b>False,</b> if the input image is a JPEG or if a failure occurs during the conversion.
  </ret>
  <h>
    Converts the current image to a JPEG.  The output file name will have a JPG extension.<br/><br/>
    
    Supported input file formats: BMP (1, 4, 8, or 24-bit), GIF (1, 4 or 8-bit), PNG (1, 4, 8 and 24-bit), and
    TIFF (1, 4, 8 and 24-bit) with compression (RLE, Group 3 fax, and Group 4 fax, Pack Bits, LZW, JPEG).<br/><br/>

    <b>Note:</b> Not all actions that manipulate images support the same input file formats as this action.    
    <e>
      SetLuminanceFactor("24")<br/>
      SetChrominanceFactor("10")<br/>
      SetGrayScale("True")<br/>
      <b>ConvertToJPEG()</b>
    </e>
  </h>
</ref>

<ref id="ConvertToTIFF" access="public" bInter="bInter" bDebug="bDebug" qi="Converts the current image to a TIFF.">
  <ap>
    None.
  </ap>
  <lvl>
    Page Level.
  </lvl>
  <ret>
    <b>True,</b> if the image is converted to a TIFF.<br/>
    <b>False,</b> if the input image is a TIFF or if a failure occurs during the conversion.
  </ret>
  <h>
    Converts the current image to a TIFF.  The output file name will have a TIF extension.<br/><br/>

    Supported input file formats: BMP (1, 4, 8, or 24-bit), GIF (1, 4 or 8-bit),
    JPG or JPEG (8 and 12-bit grayscale and 24-bit color), and PNG (1, 4, 8 and 24-bit).<br/><br/>

    <b>Note:</b> Not all actions that manipulate images support the same input file formats as this action.
    <e>
      SetTiffCompression("3")<br/>
      <b>ConvertToTIFF()</b>
    </e>
  </h>
</ref>

</help>
</rrx>
<rrx namespace="Imprint" src="c:\datacap\RRS\Imprint.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="SetFontName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Specifies the font style that will be used.]]>
<![CDATA[
]]>
<![CDATA[  'String value of the font's name.</ap>]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If(Not oImPrint is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[		call oImPrint.SetFontName(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		SetFontName = true]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SetFontName = false]]>
<![CDATA[
]]>
<![CDATA[		writelog("ImPrint object is not properly initialized")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFontSize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Specifies the font size that will be used. ]]>
<![CDATA[
]]>
<![CDATA[  'Numeric value of the font's size.</ap>  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if(Not oImPrint is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[		if(isNumeric(StrParam)) Then]]>
<![CDATA[
]]>
<![CDATA[			call oImPrint.SetFontSize(StrParam)]]>
<![CDATA[
]]>
<![CDATA[			SetFontSize = true]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			SetFontSize = false]]>
<![CDATA[
]]>
<![CDATA[			writelog("Parameter is not numeric")]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[	else]]>
<![CDATA[
]]>
<![CDATA[		SetFontSize = false]]>
<![CDATA[
]]>
<![CDATA[		writelog("ImPrint object is not properly initialized")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetAdjustedWidth" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Numeric value of the maximum character length of the string to be imprinted.]]>
<![CDATA[
]]>
<![CDATA[	' Adjust the width of the imprinted text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'This action is optional.  If the action is not used, the adjusted width will default to 30.  ]]>
<![CDATA[
]]>
<![CDATA[  ' If your text is being cut off, increase the parameter value.]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	If(Not oImPrint is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[		if(isNumeric(StrParam)) Then]]>
<![CDATA[
]]>
<![CDATA[			call oImPrint.SetAdjustWidth(StrParam)]]>
<![CDATA[
]]>
<![CDATA[			SetAdjustedWidth = true]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[			SetAdjustedWidth = false]]>
<![CDATA[
]]>
<![CDATA[			writelog("Parameter is not numeric")]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SetAdjustedWidth = false]]>
<![CDATA[
]]>
<![CDATA[		writelog("ImPrint object is not properly initialized")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetOpaque" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sets the opacity/transparency of rectangles that cover text, or images beneath the text, resulting from Imprint actions."]]>
<![CDATA[
]]>
<![CDATA[  '  Integer value: 1 or 0.]]>
<![CDATA[
]]>
<![CDATA[  '  SetOpaque(1) indicates full opacity and is typical.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[  '  SetOpaque(0) results in subsequent rectangles that are translucent (transparent.)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call oImPrint.SetOpaque(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  SetOpaque = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="AnnotateImage" access="public">
	<p name="displayText">
	</p>
	<p name="xCoordinate">
	</p>
	<p name="yCoordinate">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Imprints the text you specify onto the current page's image file"]]>
<![CDATA[
]]>
<![CDATA[   'Three parameters:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'displayText Comma-delimited string to be placed onto the image:<br/>]]>
<![CDATA[
]]>
<![CDATA[    'The 'text' parameter can combine plain text along with any number of tags]]>
<![CDATA[
]]>
<![CDATA[    'that will be evaluated at runtime.  Use commas to separate each part of the string.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    '<b>A)</b> Text to place on the image.  The text cannot contain commas.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>B)</b> Variables:<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>1.</b> @BATCHID - The current Batch ID.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>2.</b> @ID - The ID of the current object.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>3.</b> @STATUS - Status of the current object.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>4.</b> @TYPE - Type of the current object.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>5.</b> @DATE - Today's date.]]>
<![CDATA[
]]>
<![CDATA[    '<b>6.</b> @TIME - Current time.]]>
<![CDATA[
]]>
<![CDATA[    '<b>7.</b> @VARIABLE - ObjectType/VariableName<br/>]]>
<![CDATA[
]]>
<![CDATA[    'For ObjectType in Option #7 above:<br/> ]]>
<![CDATA[
]]>
<![CDATA[    '0 = Batch<br/>]]>
<![CDATA[
]]>
<![CDATA[    '1 = Document<br/>]]>
<![CDATA[
]]>
<![CDATA[    '2 = Page<br/>]]>
<![CDATA[
]]>
<![CDATA[    '3 = Field<br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    '<b>xCoordinate</b> The X coordinate for the starting position of the text on the image.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>yCoordinate</b> The Y coordinate for the starting position of the text on the image.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim nParam]]>
<![CDATA[
]]>
<![CDATA[	nParam = -1]]>
<![CDATA[
]]>
<![CDATA[  AnnotateImage = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  displayText = Trim(displayText)]]>
<![CDATA[
]]>
<![CDATA[  if (Len(displayText) = 0) Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("AnnotateImage: displayText value must not be blank.")]]>
<![CDATA[
]]>
<![CDATA[		exit function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	X = Trim(xCoordinate)]]>
<![CDATA[
]]>
<![CDATA[	if(Not IsNumeric(X)) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("AnnotateImage: X coordinate is not numeric: '" & X & "'.")]]>
<![CDATA[
]]>
<![CDATA[		exit function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Y = Trim(yCoordinate)]]>
<![CDATA[
]]>
<![CDATA[	if(Not IsNumeric(Y)) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("AnnotateImage: Y coordinate is not numeric: '" & Y & "'.")]]>
<![CDATA[
]]>
<![CDATA[		exit function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("Text string to annotate on image is: " & displayText)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oImPrint.InitPageVariables()]]>
<![CDATA[
]]>
<![CDATA[	call oImPrint.EndorseString(displayText,X,Y)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AnnotateImage = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<af name="Redact" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   'Redacts a field or a portion of an image."]]>
<![CDATA[
]]>
<![CDATA[   ' Six comma separated parameters:<br/>]]>
<![CDATA[
]]>
<![CDATA[   ' <b>1.</b> The fill color to use.  Must be either White, or Black.<br/>]]>
<![CDATA[
]]>
<![CDATA[   ' <b>2.</b> Optional - The text to include in the overlay.<br/>]]>
<![CDATA[
]]>
<![CDATA[   ' <b>3.</b> The top left X coordinate in pixels.<br/>]]>
<![CDATA[
]]>
<![CDATA[   ' <b>4.</b> The top left Y coordinate in pixels.<br/>]]>
<![CDATA[
]]>
<![CDATA[   ' <b>5.</b> The bottom right X coordinate in pixels.<br/>]]>
<![CDATA[
]]>
<![CDATA[   ' <b>6.</b> The bottom right Y coordinate in pixels.<br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Redact=false]]>
<![CDATA[
]]>
<![CDATA[writelog "Starting Redaction"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim aParam, l,t,r,b, cBack, cFore, redactImage, fileName, StrParamCount, sText, fName, nType]]>
<![CDATA[
]]>
<![CDATA[nType=1]]>
<![CDATA[
]]>
<![CDATA[aParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[StrParamCount = UBound(aParam)+1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[writelog "CurrentObj.ObjecType: " & CurrentObj.ObjectType]]>
<![CDATA[
]]>
<![CDATA[writelog "Number of parameters: " & StrParamCount]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[If aParam(1) <> "" Then nType=9]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[If (CurrentObj.ObjectType=2) And (strParamCount<>6) Then]]>
<![CDATA[
]]>
<![CDATA[	WriteLog "Incorrect number of parameters"]]>
<![CDATA[
]]>
<![CDATA[	babort=true]]>
<![CDATA[
]]>
<![CDATA[	Exit Function]]>
<![CDATA[
]]>
<![CDATA[ElseIf (CurrentObj.ObjectType=2) And (strParamCount=6) Then]]>
<![CDATA[
]]>
<![CDATA[	l=cint(aParam(2))]]>
<![CDATA[
]]>
<![CDATA[	t=cint(aParam(3))]]>
<![CDATA[
]]>
<![CDATA[	r=cint(aParam(4))]]>
<![CDATA[
]]>
<![CDATA[	b=cint(aParam(5))]]>
<![CDATA[
]]>
<![CDATA[	For i=2 To 5]]>
<![CDATA[
]]>
<![CDATA[ 	If Not IsNumeric(aParam(i)) Then]]>
<![CDATA[
]]>
<![CDATA[ 		Writelog "posiition parameter is not numeric"]]>
<![CDATA[
]]>
<![CDATA[ 		Exit Function]]>
<![CDATA[
]]>
<![CDATA[ 	End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	WriteLog "Setting position to specified position " & l & "," & t  & "," & r & "," & b]]>
<![CDATA[
]]>
<![CDATA[	fName = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[ElseIf (CurrentObj.ObjectType=3) And (strParamCount<2) Then]]>
<![CDATA[
]]>
<![CDATA[	WriteLog "Incorrect number of parameters"]]>
<![CDATA[
]]>
<![CDATA[	babort=true]]>
<![CDATA[
]]>
<![CDATA[	Exit Function]]>
<![CDATA[
]]>
<![CDATA[ElseIf (CurrentObj.ObjectType=3) Then	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.GetPosition l,t,r,b]]>
<![CDATA[
]]>
<![CDATA[	WriteLog "Setting position to field position " & l & "," & t  & "," & r & "," & b]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	Do While oPage.ObjectType>2]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[	Loop			]]>
<![CDATA[
]]>
<![CDATA[	fName = oPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[	writelog "oPage Type " & oPage.ObjectType]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = nothing]]>
<![CDATA[
]]>
<![CDATA[Else]]>
<![CDATA[
]]>
<![CDATA[	WriteLog "Incorrect number of parameters"]]>
<![CDATA[
]]>
<![CDATA[	babort=true]]>
<![CDATA[
]]>
<![CDATA[	Exit Function]]>
<![CDATA[
]]>
<![CDATA[End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim area]]>
<![CDATA[
]]>
<![CDATA[area = (r - l) * (b - t)]]>
<![CDATA[
]]>
<![CDATA[If (area <= 0) Then]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Invalid field bounds")]]>
<![CDATA[
]]>
<![CDATA[	babort=true]]>
<![CDATA[
]]>
<![CDATA[	Exit Function]]>
<![CDATA[
]]>
<![CDATA[End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[writelog "file name is: " & fname]]>
<![CDATA[
]]>
<![CDATA[If UCase(aParam(0)) = "WHITE" Then]]>
<![CDATA[
]]>
<![CDATA[  If nType=1 Then]]>
<![CDATA[
]]>
<![CDATA[		cBack=16777215]]>
<![CDATA[
]]>
<![CDATA[		cFore=0]]>
<![CDATA[
]]>
<![CDATA[	ElseIf nType=9 Then]]>
<![CDATA[
]]>
<![CDATA[		cBack=0]]>
<![CDATA[
]]>
<![CDATA[		cFore=16777215]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog "WHITE"]]>
<![CDATA[
]]>
<![CDATA[ElseIf UCase(aParam(0)) = "BLACK" Then]]>
<![CDATA[
]]>
<![CDATA[  If nType=1 Then]]>
<![CDATA[
]]>
<![CDATA[		cBack=0]]>
<![CDATA[
]]>
<![CDATA[		cFore=16777215]]>
<![CDATA[
]]>
<![CDATA[	ElseIf nType=9 Then]]>
<![CDATA[
]]>
<![CDATA[		cBack=16777215]]>
<![CDATA[
]]>
<![CDATA[		cFore=0]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog "BLACK"		]]>
<![CDATA[
]]>
<![CDATA[Else]]>
<![CDATA[
]]>
<![CDATA[	WriteLog "First paramter must be white or black"]]>
<![CDATA[
]]>
<![CDATA[	Exit Function]]>
<![CDATA[
]]>
<![CDATA[End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[If aParam(1) <> "" Then]]>
<![CDATA[
]]>
<![CDATA[	sText = aParam(1)]]>
<![CDATA[
]]>
<![CDATA[Else]]>
<![CDATA[
]]>
<![CDATA[ 	sText = ""]]>
<![CDATA[
]]>
<![CDATA[End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[WriteLog "Text: " & sText]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ImageCtrl.FileName=fName]]>
<![CDATA[
]]>
<![CDATA[writelog "loaded image"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ImageCtrl.GetImageInfo iW, iH, iR]]>
<![CDATA[
]]>
<![CDATA[dim xDPI]]>
<![CDATA[
]]>
<![CDATA[dim yDPI]]>
<![CDATA[
]]>
<![CDATA[ImageCtrl.GetRes xDPI, yDPI]]>
<![CDATA[
]]>
<![CDATA[writelog "image width, height, bitDepth " & iW & " " & iH & " " & iR]]>
<![CDATA[
]]>
<![CDATA[writelog "image xDPI, yDPI " & xDPI & " " & yDPI]]>
<![CDATA[
]]>
<![CDATA[If iW<r Then r=iW]]>
<![CDATA[
]]>
<![CDATA[If iH<b Then b=iH]]>
<![CDATA[
]]>
<![CDATA[if l<0 then l=0]]>
<![CDATA[
]]>
<![CDATA[if t<0 then t=0]]>
<![CDATA[
]]>
<![CDATA[writelog "checked boundaries"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ImageCtrl.EnableAnnot=true]]>
<![CDATA[
]]>
<![CDATA[WriteLog "Drawing rectangle " & l & " " & t & " " & r & " " & b & " " & nType & " " & cBack & " " & cFore & " " & sText]]>
<![CDATA[
]]>
<![CDATA[Call ImageCtrl.DrawRect(l,t,r,b,nType,cBack,cFore,sText)]]>
<![CDATA[
]]>
<![CDATA[WriteLog "Rectangle drawn"]]>
<![CDATA[
]]>
<![CDATA[ImageCtrl.MergeAnnotations()]]>
<![CDATA[
]]>
<![CDATA[Call ImageCtrl.SetRes(xDPI,yDPI)]]>
<![CDATA[
]]>
<![CDATA[WriteLog "Saving Image"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Set fso = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[if Not fso.FileExists(fName) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("ERROR - Source file does not exist: " & fName)]]>
<![CDATA[
]]>
<![CDATA[      babort=true]]>
<![CDATA[
]]>
<![CDATA[      set fso = nothing]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[end if]]>
<![CDATA[
]]>
<![CDATA[dim sDest]]>
<![CDATA[
]]>
<![CDATA[sDest = fName & ".redact"]]>
<![CDATA[
]]>
<![CDATA[Call fso.CopyFile(fName, sDest)]]>
<![CDATA[
]]>
<![CDATA[if err.number <>0 then]]>
<![CDATA[
]]>
<![CDATA[	writelog "Error backing up image"]]>
<![CDATA[
]]>
<![CDATA[	writelog "Error Number " & cstr(err.number)]]>
<![CDATA[
]]>
<![CDATA[	writelog "Error Description " & err.description]]>
<![CDATA[
]]>
<![CDATA[	err.clear]]>
<![CDATA[
]]>
<![CDATA[	Set fso = Nothing]]>
<![CDATA[
]]>
<![CDATA[	babort=true]]>
<![CDATA[
]]>
<![CDATA[	exit function]]>
<![CDATA[
]]>
<![CDATA[end if]]>
<![CDATA[
]]>
<![CDATA[Call fso.DeleteFile(fName, True)]]>
<![CDATA[
]]>
<![CDATA[ImageCtrl.Save(fName)]]>
<![CDATA[
]]>
<![CDATA[if err.number <>0 then]]>
<![CDATA[
]]>
<![CDATA[	writelog "Error saving redacted image"]]>
<![CDATA[
]]>
<![CDATA[	writelog "Error Number " & cstr(err.number)]]>
<![CDATA[
]]>
<![CDATA[	writelog "Error Description " & err.description]]>
<![CDATA[
]]>
<![CDATA[	err.clear]]>
<![CDATA[
]]>
<![CDATA[	Set fso = Nothing]]>
<![CDATA[
]]>
<![CDATA[	babort=true]]>
<![CDATA[
]]>
<![CDATA[	exit function]]>
<![CDATA[
]]>
<![CDATA[else]]>
<![CDATA[
]]>
<![CDATA[	Call fso.DeleteFile(sDest, True)	]]>
<![CDATA[
]]>
<![CDATA[end if	]]>
<![CDATA[
]]>
<![CDATA[Set fso = Nothing]]>
<![CDATA[
]]>
<![CDATA[WriteLog "Saved Image"]]>
<![CDATA[
]]>
<![CDATA[if err.number <>0 then]]>
<![CDATA[
]]>
<![CDATA[	writelog "Error Deleting temp file"]]>
<![CDATA[
]]>
<![CDATA[	writelog "Error Number " & cstr(err.number)]]>
<![CDATA[
]]>
<![CDATA[	writelog "Error Description " & err.description]]>
<![CDATA[
]]>
<![CDATA[	err.clear]]>
<![CDATA[
]]>
<![CDATA[end if]]>
<![CDATA[
]]>
<![CDATA[Redact=true		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' ImPrint Actions help
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
]]>
  
<ref id="SetFontName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>String value of the font's name.</ap>
  <h>
    Specifies the font style that will be used.<br/><br/>

    This action is optional. If not used, the font style will default to Times New Roman.
    <e>
      <b>SetFontName("Arial")</b>
      <br/>
      <scr>SetFontSize("10")</scr>
      <br/>
      <scr>SetAdjustedWidth("100")</scr>
      <br/>
      <scr>Imprint("@BatchID,Page:,@ID;0;0")</scr>
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the parameter is missing.  Otherwise <b>True.</b>
  </ret>
</ref>
	
<ref id="SetFontSize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>Numeric value of the font's size.</ap>  
  <h>
    Specifies the font size that will be used.<br/><br/>

    This action is optional. If you do not use the action, the font size will default to 12.
    <e>
      <scr>SetFontName("Arial")</scr>
      <br/>
      <scr>SetFontSize("10")</scr>
      <br/>
      <scr>SetAdjustedWidth("100")</scr>
      <br/>
      <scr>Imprint("@BatchID,Page:,@ID;0;0")</scr>
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the parameter is not Numeric.  Otherwise <b>True.</b>
  </ret>
</ref>

  
<ref name="SetAdjustedWidth" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<ap>Numeric value of the maximum character length of the string to be imprinted.</ap>	
	<h>Adjust the width of the imprinted text.<br/><br/>

	This action is optional.  If the action is not used, the adjusted width will default to 30.  
   If your text is being cut off, increase the parameter value.
		<e><scr>SetFontName("Arial")</scr><br/>
		<scr>SetFontSize("10")</scr><br/>
		<b>SetAdjustedWidth("100")</b><br/>
		<scr>Imprint("@BatchID,Page:,@ID;0;0")</scr>
		</e>
	</h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the parameter is not numeric.  Otherwise, <b>True.</b>
  </ret>
</ref>

  
<ref id=" SetOpaque" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    Integer value: 1 or 0.<br/><br/>
    SetOpaque(1) indicates full opacity and is typical.<br/><br/>
    SetOpaque(0) results in subsequent rectangles that are translucent (transparent.)
  </ap>
  <h>
    <e>
      <b>SetOpaque("1")</b>
    </e>
  </h>
  <lvl>All, but generally at the Page level.</lvl>
  <ret>
    <b>False</b> if the parameter is not an <i>Integer.</i> Otherwise, <b>True.</b>
  </ret>
</ref>


<ref id="AnnotateImage" access="public">
  <p name="displayText"/>
  <p name="xCoordinate"/>
  <p name="yCoordinate"/>
  <ap>
    Three parameters:<br/><br/>

    <b>displayText</b> smart parameter supported string to be placed onto the image.<br/>
    The 'displaytext' can combine plain text along with smart parameters.<br/><br/>

    <b>xCoordinate</b> The X coordinate for the starting position of the text on the image.<br/><br/>

    <b>yCoordinate</b> The Y coordinate for the starting position of the text on the image.
  </ap>
  <h>
    Imprints the text you specify onto the current page's image file.<br/><br/>

    By default, the text's font size is 12, and font's style "Times New Roman", with an adjusted width of 30.
    <e>
      SetFontName("Arial")<br/>
      SetFontSize("10")<br/>
      SetAdjustedWidth("100")<br/>
      <b>Imprint("@BATCHID+ Page:+@ID","0","0")</b><br/><br/>

      This example will place the Batch ID followed by ' Page:' and the calling object ID at the top of the image using the 'Arial' font
      with a point size of 10 and a width of 100.
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if parameter(s) are missing, or the X or Y parameters are not Numeric.  Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="ImPrint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    Three parts, separated by semicolons(;).  See AnnotateImage for descriptions of the parameters.<br/><br/>
  </ap>
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by AnnotateImage.    
  </h>
  <see>AnnotateImage</see>
</ref>

<ref id="Redact" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    Six comma separated parameters:<br/>
    <b>1.</b> The fill color to use.  Must be either White, or Black.<br/>
    <b>2.</b> Optional - The text to include in the overlay.<br/>
    <b>3.</b> The top left X coordinate in pixels.<br/>
    <b>4.</b> The top left Y coordinate in pixels.<br/>
    <b>5.</b> The bottom right X coordinate in pixels.<br/>
    <b>6.</b> The bottom right Y coordinate in pixels.<br/>
  </ap>
  <h>
    This action overlays a black, or white rectangle on the image.  A default text value may optionally be applied to the overlay.
    If run on the field level, the entire field will be redacted and the last four parameters will be ignored.  If run on the page level the last four parameters to specify the location must be included.
    <e>
      <b>Redact("white,")</b> - will apply a white overlay using the current field position<br/>
      <b>Redact("black,,0,0,100,100")</b> - will apply a black square overlay on the top left of the image
    </e>
  </h>
  <lvl>Page and Field</lvl>
  <ret>
    <b>True</b> if the area is redacted.  Otherwise, <b>False.</b>
  </ret>
  </ref>
</help>
</rrx>
<rrx namespace="Invoice" src="c:\datacap\RRS\Invoice.dll">

<i ref="rrunner">
</i>
<i ref="validations">
</i>
<i ref="lookup">
</i>
<g>
</g>
<af name="SetDynamicDetailZones" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    The parameter is the Zone Bottom field. If more than one field is listed, ]]>
<![CDATA[
]]>
<![CDATA['    Zone Bottom must be first field, and additional fields are ignored.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA['    This action takes the position of the line items and it builds the line coordinates from them]]>
<![CDATA[
]]>
<![CDATA['    and then it sets the details zones from that top line to the bottom of the CCO.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA['      LoadCCOFromField()      ]]>
<![CDATA[
]]>
<![CDATA['      SetDynamicDetailZones("Zone Bottom,Notes")]]>
<![CDATA[
]]>
<![CDATA['      ZoneBOTTOM_ImageBottom()]]>
<![CDATA[
]]>
<![CDATA['      ScanDetails()]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['     Page level.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    False if no children exist.  Otherwise, True.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[Dim oSubField]]>
<![CDATA[
]]>
<![CDATA[Dim PosAr]]>
<![CDATA[
]]>
<![CDATA[Dim LineULHx]]>
<![CDATA[
]]>
<![CDATA[Dim LineULHy]]>
<![CDATA[
]]>
<![CDATA[Dim LineLRHx]]>
<![CDATA[
]]>
<![CDATA[Dim LineLRHy]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[Dim FieldAr]]>
<![CDATA[
]]>
<![CDATA[Dim oZoneBottomField]]>
<![CDATA[
]]>
<![CDATA[Dim ZoneBottomY]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   LineULHx = 1000000]]>
<![CDATA[
]]>
<![CDATA[   LineULHy = 1000000]]>
<![CDATA[
]]>
<![CDATA[   LineLRHx = 0]]>
<![CDATA[
]]>
<![CDATA[   LineLRHy = 0]]>
<![CDATA[
]]>
<![CDATA[   Writelog("SetDynamicDetailZones active")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.NumOfChildren > 0 then]]>
<![CDATA[
]]>
<![CDATA[      Set oLineItem = CurrentObj.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No Children.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      SetDynamicDetailZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("LineItem: " & oLineItem.ID)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   for i = 0 to oLineItem.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[     Set oSubField = oLineItem.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Evaluating " & oSubField.Type)  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     if (oSubField.Variable("Position") <> "") AND (InStr("," & StrParam & ",","," & oSubField.Type & ",") = 0) then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Processing " & oSubField.Type) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("POS-" & oSubField.Type) = oSubField.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        PosAr = Split(oSubField.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[        if cLng(PosAr(0)) < cLng(LineULHx) AND cLng(PosAr(0)) > 0 then]]>
<![CDATA[
]]>
<![CDATA[           LineULHx = PosAr(0)]]>
<![CDATA[
]]>
<![CDATA[        End if   ]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[        if cLng(PosAr(1)) < cLng(LineULHy) AND cLng(PosAr(0)) > 0 then]]>
<![CDATA[
]]>
<![CDATA[           LineULHy = PosAr(1)]]>
<![CDATA[
]]>
<![CDATA[        End if            ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        if cLng(PosAr(2)) > cLng(LineLRHx) then]]>
<![CDATA[
]]>
<![CDATA[           LineLRHx = PosAr(2)]]>
<![CDATA[
]]>
<![CDATA[        End if   ]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[        if cLng(PosAr(3)) > cLng(LineLRHy) then]]>
<![CDATA[
]]>
<![CDATA[           LineLRHy = PosAr(3)]]>
<![CDATA[
]]>
<![CDATA[        End if            ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     oSubField.Variable("TestPos") = LineULHx & "," & LineULHy & "," & LineLRHx & "," & LineLRHy]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   next 'i  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'LineULHx = cLng(LineULHx) - 20]]>
<![CDATA[
]]>
<![CDATA[   'LineULHy = cLng(LineULHy) - 1]]>
<![CDATA[
]]>
<![CDATA[   'LineLRHx = cLng(LineLRHx) + 20]]>
<![CDATA[
]]>
<![CDATA[   'LineLRHy = cLng(LineLRHy) + 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("LineItemPos") = cStr(CCO.Left) & "," & LineULHy & "," & cStr(CCO.Right) & "," & LineLRHy]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   LineULHx = cLng(LineULHx) -10]]>
<![CDATA[
]]>
<![CDATA[   LineULHy = cLng(LineULHy) - 1]]>
<![CDATA[
]]>
<![CDATA[   LineLRHx = cLng(LineLRHx) + 10]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Handle ZoneBottom ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   FieldAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("FieldAr(0)=" & FieldAr(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oZoneBottomField = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oZoneBottomField = oLineItem.FindChild(FieldAr(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ZoneBottomY = cStr(CCO.Bottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("Position") =  cStr(CCO.Left) & "," & LineULHy & "," & cStr(CCO.Right) & "," & ZoneBottomY]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While CurrentObj.NumOfChildren > 0]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.DeleteChild(0)]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[   'DCO.Write(Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SetDynamicDetailZones = TRUE]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LoadCCOFromField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   None.]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '   This action loads the DCO from a field object.]]>
<![CDATA[
]]>
<![CDATA[ '   The verify panels do not load the CCO into the scripting engine so this action acomplishes that task.  ]]>
<![CDATA[
]]>
<![CDATA[ '   This action is required for any invoice action that uses the CCO.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '     LoadCCOFromField()]]>
<![CDATA[
]]>
<![CDATA[ '     SetDynamicDetailZones("Zone Bottom,Notes")]]>
<![CDATA[
]]>
<![CDATA[ '     ZoneBOTTOM_ImageBottom()]]>
<![CDATA[
]]>
<![CDATA[ '     ScanDetails()]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '     Field Level.]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '   False, if this action is not called on a field or if the CCO file does not exist.  Otherwise, True.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	LoadCCOFromField = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if CurrentObj.Parent.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Action must be on a field that is a child of a page.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileName ]]>
<![CDATA[
]]>
<![CDATA[	sFileName = Left(CurrentObj.Parent.ImageName,len(CurrentObj.Parent.ImageName) - 3) & "cco"]]>
<![CDATA[
]]>
<![CDATA[  writelog("Attempting to load: " & sFileName)]]>
<![CDATA[
]]>
<![CDATA[	Dim lbCCOCreator]]>
<![CDATA[
]]>
<![CDATA[	set lbCCOCreator = CreateObject("CCO._CCOCreator.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if FileMgr.FileExists(sFileName) then ]]>
<![CDATA[
]]>
<![CDATA[		set CCO = lbCCOCreator.load(sFileName)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Loading CCO '" & sFileName & "' ")]]>
<![CDATA[
]]>
<![CDATA[		LoadCCOFromField = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("CCO: " & sFileName & "' does not Exist.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 	Set lbCCOCreator = nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oField = CurrentObj]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanLineItemDynamic" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   A comma separated list of any fields that should be ignored.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '   This action scans the line items from the CCO that was loaded into the field.  It is like]]>
<![CDATA[
]]>
<![CDATA[ '   ScanLineItem but uses the CCO loaded for the field and reads position variables from the line item level.]]>
<![CDATA[
]]>
<![CDATA[ '   It is required for Find Details functionality.  It saves the positions of the line and of the feids at the detail]]>
<![CDATA[
]]>
<![CDATA[ '   level so all of the line items can be erased and recreated.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '     FPXMLUsed()]]>
<![CDATA[
]]>
<![CDATA[ '     ScanLineItemDynamic("ZoneBottom,Notes")]]>
<![CDATA[
]]>
<![CDATA[ '  ]]>
<![CDATA[
]]>
<![CDATA[ ' Field Level.]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '   Always True.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ScanLineItemDynamic=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog(sName)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		Set oField=CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(oField.ID)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		If Not oField Is Nothing  Then]]>
<![CDATA[
]]>
<![CDATA[      if InStr("," & StrParam & ",","," & oField.Type & ",") = 0 then ]]>
<![CDATA[
]]>
<![CDATA[			  oField.Variable("Position")= CurrentObj.Parent.variable("POS-" & oField.Type)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanLineItemDynamic=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AllowOnlyChars" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    A list of all characters allowed within the field.]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['    This action will match the field characters with the allowed set of characters.  If the field contains]]>
<![CDATA[
]]>
<![CDATA['    characters that are not in the allowed set, the characters will be deleted from the field.]]>
<![CDATA[
]]>
<![CDATA['    The comparison is case sensitive. ]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA['      CheckAnFixDecimal()]]>
<![CDATA[
]]>
<![CDATA['      Is_InCharSet("01234567890.,-$ ")]]>
<![CDATA[
]]>
<![CDATA['      AllowOnlyChars("0123456789.-")]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Field Level.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    False, if this action is called at the wrong level.  Otherwise, True.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[Dim StringOut]]>
<![CDATA[
]]>
<![CDATA[Dim ConfOut]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   AllowOnlyChars = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Object must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   For i = 1 to len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[      if InStr(StrParam,Mid(CurrentObj.Text,i,1)) > 0 then]]>
<![CDATA[
]]>
<![CDATA[          StringOut = StringOut & mid(CurrentObj.Text,i,1)]]>
<![CDATA[
]]>
<![CDATA[          ConfOut = ConfOut & mid(CurrentObj.ConfidenceString,i,1)]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Removed character: " & mid(CurrentObj.Text,i,1))]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   next 'i  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Text = StringOut]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.ConfidenceString = ConfOut]]>
<![CDATA[
]]>
<![CDATA[   Writelog(StringOut)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   AllowOnlyChars = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PopulateZNLineItemFieldDynamic" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    This action is like the PopulateZNLineItemField but it uses the CCO that was]]>
<![CDATA[
]]>
<![CDATA['    loaded into memory by LoadCCOFromField, instead of the global CCO.]]>
<![CDATA[
]]>
<![CDATA['    It populates the fingerprint’s Data file with the recognized value contained inside]]>
<![CDATA[
]]>
<![CDATA['    the zone of a child Field object of a LINEITEM parent field. This action should]]>
<![CDATA[
]]>
<![CDATA['    only be used with sub-fields of the LINEITEM field - ItemID, ItemDesc,]]>
<![CDATA[
]]>
<![CDATA['    Quantity, Price in the <i>Invoices</i> application.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  PopulateZNLineItemFieldDynamic=False]]>
<![CDATA[
]]>
<![CDATA[  sPos=CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If( sPos<>"" and sPos <> "0,0,0,0" ) Then]]>
<![CDATA[
]]>
<![CDATA[    If Not AdjustPosToParentDynamic(CurrentObj,1) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Ready for DCOFieldFromCCO")]]>
<![CDATA[
]]>
<![CDATA[    PopulateZNLineItemFieldDynamic=DCOFieldFromCCO(CurrentObj, CCO)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    PopulateZNLineItemFieldDynamic=true]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CalculateNotesZone" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   This action creates a zone between detail lines, so the text between lines can ]]>
<![CDATA[
]]>
<![CDATA['   be recognized.]]>
<![CDATA[
]]>
<![CDATA[Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[Dim oNextLineItem]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[Dim oNotesField]]>
<![CDATA[
]]>
<![CDATA[Dim NoteULHx]]>
<![CDATA[
]]>
<![CDATA[Dim NoteULHy]]>
<![CDATA[
]]>
<![CDATA[Dim NoteLRHx]]>
<![CDATA[
]]>
<![CDATA[Dim NoteLRHy]]>
<![CDATA[
]]>
<![CDATA[Dim PosAr1]]>
<![CDATA[
]]>
<![CDATA[Dim PosAr2]]>
<![CDATA[
]]>
<![CDATA[Dim PosAr3]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CalculateNotesZone = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.NumOfChildren = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No children found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   For i = 0 to CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[      Set oLineItem = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[      PosAr1 = Split(oLineItem.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[      NoteULHx = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[      NoteULHy = PosAr1(3)       ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Set NoteULHx to: " & cStr(NoteULHx))]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Set NoteULHy to: " & cStr(NoteULHy))]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[      if i = CurrentObj.NumOfChildren - 1 then]]>
<![CDATA[
]]>
<![CDATA[         PosAr2 = Split(CurrentObj.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[         NoteLRHx = CCO.Right ]]>
<![CDATA[
]]>
<![CDATA[         NoteLRHy = PosAr2(3)]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Last Child - Set NoteLRHx to: " & cStr(NoteLRHx))]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Last Child - Set NoteLRHy to: " & cStr(NoteLRHy))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Set oNextLineItem = CurrentObj.GetChild(i+1)]]>
<![CDATA[
]]>
<![CDATA[         PosAr3 = Split(oNextLineItem.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[         NoteLRHx = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[         NoteLRHy = PosAr3(1)]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Not Last Child - Set NoteLRHx to: " & cStr(NoteLRHx))]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Not Last Child - Set NoteLRHy to: " & cStr(NoteLRHy))]]>
<![CDATA[
]]>
<![CDATA[      End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.FindChild("Notes").Variable("Position") = NoteULHx & "," & NoteULHy & "," & NoteLRHx & "," & NoteLRHy]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Set Notes positon to: " & oLineItem.FindChild("Notes").Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[   Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ParseImageName" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   This action extracts only the file name from the variable 'ScanSrcPath' and]]>
<![CDATA[
]]>
<![CDATA['   places it into the 'Text' variable of the current object.  It is expected that the file]]>
<![CDATA[
]]>
<![CDATA['   name contains an underscore and only the value up to the underscore is kept.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim PathAr]]>
<![CDATA[
]]>
<![CDATA[Dim StrAr ]]>
<![CDATA[
]]>
<![CDATA[   ParseImageName = TRUE]]>
<![CDATA[
]]>
<![CDATA[   Writelog (CurrentObj.Parent.Variable("ScanSrcPath"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   PathAr = Split(CurrentObj.Parent.Variable("ScanSrcPath"),"\")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("PathAr ubound=" & cStr(uBound(PathAr)))]]>
<![CDATA[
]]>
<![CDATA[   Writelog(PathAr(uBound(PathAr)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   StrAr = Split(PathAr(ubound(PathAr)),"_")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Text = UCase(StrAr(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFingerPrintClass" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    Two comma separated parameters:]]>
<![CDATA[
]]>
<![CDATA['    1. The database connection string.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA['    2. Fingerprint class.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    This action connects to the fingerprint database and verifies that the specified fingerprint]]>
<![CDATA[
]]>
<![CDATA['    class contains the fingerprint ID of the current page.  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oConn]]>
<![CDATA[
]]>
<![CDATA[Dim oRS]]>
<![CDATA[
]]>
<![CDATA[Dim oRS1]]>
<![CDATA[
]]>
<![CDATA[Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[Dim RetnAr]]>
<![CDATA[
]]>
<![CDATA[Dim Retn]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim ConnectionString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   IsFingerprintClass = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a page level.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr= Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Wrong number of parameters.  Expecting (DSN,FingerPrintClass)")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oConn = CreateObject("ADODB.Connection")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ConnectionString = Trim(ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ' Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[   sSmartParam=MetaWord(ConnectionString)]]>
<![CDATA[
]]>
<![CDATA[   If sSmartParam<>"" and ConnectionString<>sSmartParam Then ]]>
<![CDATA[
]]>
<![CDATA[     'attempt to decrypt value]]>
<![CDATA[
]]>
<![CDATA[     bRes = [securecall]sSmartParam,ConnectionString[/securecall]   ]]>
<![CDATA[
]]>
<![CDATA[     If bRes=False Then Writelog("Value not Decrypted.")]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No result from Smart Parameter parsing. Using the original parameter string.") ]]>
<![CDATA[
]]>
<![CDATA[   End if ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   oConn.Open(FormatADOConn(ConnectionString))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If oConn.State <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Connection not open.  Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Connection Opened")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   sSQL = "Select tp_HostID from Template where tp_TemplateID = " & CurrentObj.variable("TemplateID") & ";"]]>
<![CDATA[
]]>
<![CDATA[   sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("sSQL=" & sSQL)]]>
<![CDATA[
]]>
<![CDATA[   Set oRS = oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If oRS.EOF Or oRS.BOF Then ]]>
<![CDATA[
]]>
<![CDATA[      IsFingerprintClass = False ]]>
<![CDATA[
]]>
<![CDATA[      writelog("RecordSet Returns EOF or BOF. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Retn = oRS.GetString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog  ("Returned: " & Retn)]]>
<![CDATA[
]]>
<![CDATA[   if Len(Retn) > 1 then]]>
<![CDATA[
]]>
<![CDATA[      RetnAr=Split(Retn,Chr(13))]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   Retn = RetnAr(uBound(RetnAr)-1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Retn: " & Retn) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if IsNumeric(Retn) then]]>
<![CDATA[
]]>
<![CDATA[      HostID = Retn]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Did not get a valid HostID. Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Writelog(sSQL)]]>
<![CDATA[
]]>
<![CDATA[      oConn.Close]]>
<![CDATA[
]]>
<![CDATA[      set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   sSQL = "Select hs_RefName from Host where hs_HostID = " & Trim(cStr(HostID)) & ";"  ]]>
<![CDATA[
]]>
<![CDATA[   sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("sSQL=" & sSQL)]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Set oRS1 = oConn.Execute(sSQL)  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oRS1.BOF or oRS1.EOF then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Nothing found.Exiting")]]>
<![CDATA[
]]>
<![CDATA[      oConn.Close]]>
<![CDATA[
]]>
<![CDATA[      set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[      set oRS1 = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if   ]]>
<![CDATA[
]]>
<![CDATA[   Retn = oRS1.GetString]]>
<![CDATA[
]]>
<![CDATA[   Retn = Left(Retn,len(Retn)-1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Retn='" & Retn & "' Second Parameter='" & ParamAr(1) & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if InStr("," & ParamAr(1) & ","  ,   "," & Retn & ",") > 0 then]]>
<![CDATA[
]]>
<![CDATA[      IsFingerPrintClass = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[       IsFingerPrintClass = FALSE]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   oConn.Close         ]]>
<![CDATA[
]]>
<![CDATA[   set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oRS1 = Nothing]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="iloc_SetDetailSimple" access="public" bInter="bInter" bDebug="bDebug" strParam="sDetailName">
	<g>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA['   The detail Datacap Object (DCO) Type.]]>
<![CDATA[
]]>
<![CDATA['   This action fills the Setup DCO from Runtime Data file. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[    Dim oPage]]>
<![CDATA[
]]>
<![CDATA[    Dim sFPID]]>
<![CDATA[
]]>
<![CDATA[    Dim oSetup]]>
<![CDATA[
]]>
<![CDATA[    Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[    Dim oDetail]]>
<![CDATA[
]]>
<![CDATA[    Dim xOffset]]>
<![CDATA[
]]>
<![CDATA[    Dim yOffset]]>
<![CDATA[
]]>
<![CDATA[    Dim nLeft, nTop, nRight, nBottom]]>
<![CDATA[
]]>
<![CDATA[    Dim nLineLeft, nLineTop, nLineRight, nLineBottom]]>
<![CDATA[
]]>
<![CDATA[    Dim LinePosAr]]>
<![CDATA[
]]>
<![CDATA[    Dim DetailPosAr]]>
<![CDATA[
]]>
<![CDATA[    Dim oSetupNode_Detail]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iloc_SetDetailSimple = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    xOffset = clng(0)]]>
<![CDATA[
]]>
<![CDATA[    yOffset = clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   	Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	If oPage Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Current DCO node found.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if oPage.ObjectType<>2 Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Current DCO must be Type Page.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Template ID for oPage]]>
<![CDATA[
]]>
<![CDATA[	sFPID = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	If Len(sFPID)=0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Template ID found.")]]>
<![CDATA[
]]>
<![CDATA[        Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        writelog("Template ID:'" & sFPID & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Find the offset for oPage]]>
<![CDATA[
]]>
<![CDATA[    sOffset = oPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[    If len(sOffset)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        writelog("Image Offset is '" & sOffset & "'")]]>
<![CDATA[
]]>
<![CDATA[        aOffset = Split(sOffset,",")]]>
<![CDATA[
]]>
<![CDATA[        If IsNumeric(aOffset(0)) then xOffset=clng(aOffset(0))]]>
<![CDATA[
]]>
<![CDATA[        If IsNumeric(aOffset(1)) then yOffset=clng(aOffset(1))]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oSetup = CurrentObj.SetupObject]]>
<![CDATA[
]]>
<![CDATA[	If(oSetup Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("SetupObject Not Found.")]]>
<![CDATA[
]]>
<![CDATA[        Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("Setup path:'" & oSetup.Path & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	If oSetup.readlock(oSetup.path) Then]]>
<![CDATA[
]]>
<![CDATA[		'Process The Detail]]>
<![CDATA[
]]>
<![CDATA[		Set oDetail = oPage.FindChild(Trim(sDetailName))]]>
<![CDATA[
]]>
<![CDATA[		If Not(oDetail is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[			Set oLineItem=oDetail.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[			If oLineItem is Nothing then]]>
<![CDATA[
]]>
<![CDATA[				Writelog("No First Child field found - Exiting.")]]>
<![CDATA[
]]>
<![CDATA[				Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[				Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Writelog("First Field Found:'" & oLineItem & "'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			nLineLeft   = "" 'clng(0)]]>
<![CDATA[
]]>
<![CDATA[			nLineTop    = "" 'clng(0)]]>
<![CDATA[
]]>
<![CDATA[			nLineRight  = "" 'clng(0)]]>
<![CDATA[
]]>
<![CDATA[			nLineBottom = "" 'clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Loop through LineItem Subfields]]>
<![CDATA[
]]>
<![CDATA[			For i = 1 to (oLineItem.NumOfChildren-Len(oLineItem.Text))]]>
<![CDATA[
]]>
<![CDATA[				Set oSubField = oLineItem.GetChild(i-1)]]>
<![CDATA[
]]>
<![CDATA[				If Not(oSubField is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[					sPosition = Trim(oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[					Writelog(oSubField.Type & " has a DCO position of " & sPosition) ]]>
<![CDATA[
]]>
<![CDATA[					if Len(oDetail.Variable("POS-" & oSubField.ID)) > 7 then]]>
<![CDATA[
]]>
<![CDATA[						sPosition = oDetail.Variable("POS-" & oSubField.ID) ]]>
<![CDATA[
]]>
<![CDATA[						Writelog(oSubField.Type & " has a captured position of " & sPosition) ]]>
<![CDATA[
]]>
<![CDATA[					end if]]>
<![CDATA[
]]>
<![CDATA[					aPosition = Split(sPosition & "," ,",")]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[					'check runtime field for position info]]>
<![CDATA[
]]>
<![CDATA[					If sPosition<>"0,0,0,0" and len(sPosition)>0 and ubound(aPosition)=4 then]]>
<![CDATA[
]]>
<![CDATA[						Set oSetupNode_SubField = oSetup.GetNodeByName(3,oSubField.Type)]]>
<![CDATA[
]]>
<![CDATA[						If Not(oSetupNode_SubField is Nothing) then  ]]>
<![CDATA[
]]>
<![CDATA[	                                   ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[							'Adjust for Image_Offset & save to SetupNode    ]]>
<![CDATA[
]]>
<![CDATA[							 nLeft   = clng(aPosition(0)) + xOffset]]>
<![CDATA[
]]>
<![CDATA[							 nTop    = clng(aPosition(1)) + yOffset           ]]>
<![CDATA[
]]>
<![CDATA[							 nRight  = clng(aPosition(2)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[							 nBottom = clng(aPosition(3)) + yOffset]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[							 Writelog("Setting SubField Zone to:'" & CStr(nLeft) & "," & CStr(nTop) & "," & CStr(nRight) & "," & CStr(nBottom) & "'")]]>
<![CDATA[
]]>
<![CDATA[							 oSetupNode_SubField.Variable("Pos" & sFPID) = CStr(nLeft) & "," & CStr(nTop) & "," & CStr(nRight) & "," & CStr(nBottom)]]>
<![CDATA[
]]>
<![CDATA[	                        ]]>
<![CDATA[
]]>
<![CDATA[							 'Adjust LineItem field]]>
<![CDATA[
]]>
<![CDATA[							 If nLineLeft = ""   then nLineLeft = nLeft   ]]>
<![CDATA[
]]>
<![CDATA[							 If nLineTop = ""    then nLineTop = nTop ]]>
<![CDATA[
]]>
<![CDATA[							 If nLineRight = ""  then nLineRight = nRight ]]>
<![CDATA[
]]>
<![CDATA[							 If nLineBottom = "" then nLineBottom = nBottom ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							 If nLineLeft>nLeft     Then nLineLeft = nLeft ]]>
<![CDATA[
]]>
<![CDATA[							 If nLineTop>nTop       Then nLineTop = nTop]]>
<![CDATA[
]]>
<![CDATA[							 If nLineRight<nRight   Then nLineRight = nRight]]>
<![CDATA[
]]>
<![CDATA[							 If nLineBottom<nBottom Then nLineBottom = nBottom]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							Writelog("Setupnode is Nothing!")]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						Set oSetupNode_SubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   'if oLineItem.Variable("Position") <> "" then]]>
<![CDATA[
]]>
<![CDATA[		   '    LinePosAr = Split(oLineItem.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[		   '    Writelog("Line item unadjusted positions" & oLineItem.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		   'end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   if oLineItem.Parent.Variable("LineItemPos") <> "" then]]>
<![CDATA[
]]>
<![CDATA[			   LinePosAr = Split(oLineItem.Parent.Variable("LineItemPos"),",")]]>
<![CDATA[
]]>
<![CDATA[			   Writelog("Line item unadjusted positions" & oLineItem.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   if uBound(LinePosAr) = 3 then]]>
<![CDATA[
]]>
<![CDATA[			  nLineLEft = cLng(LinePosAr(0)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineTop = cLng(LinePosAr(1)) + yOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineRight = cLng(LinePosAr(2)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineBottom = cLng(LinePosAr(3)) + yOffset ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			   Set oSetupNode_LineItem = oSetup.GetNodeByName(3,oLineItem.Type)]]>
<![CDATA[
]]>
<![CDATA[			   If Not(oSetupNode_LineItem is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[				   Writelog("Setting LineItem Zone to:'" & CStr(nLineLeft) & "," & CStr(nLineTop) & "," & CStr(nLineRight) & "," & CStr(nLineBottom) & "'")]]>
<![CDATA[
]]>
<![CDATA[				   oSetupNode_LineItem.Variable("Pos" & sFPID) = CStr(nLineLeft) & "," & CStr(nLineTop) & "," & CStr(nLineRight) & "," & CStr(nLineBottom)]]>
<![CDATA[
]]>
<![CDATA[			   End if]]>
<![CDATA[
]]>
<![CDATA[			   Set oSetupNode_LineItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   else]]>
<![CDATA[
]]>
<![CDATA[			   Writelog("Line Postition was invalid")]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[		   if oDetail.Variable("Position") <> "" then]]>
<![CDATA[
]]>
<![CDATA[			   DetailPosAr = Split(oDetail.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[			   Writelog("Detail unadjusted positions" & oDetail.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   if uBound(DetailPosAr) = 3 then]]>
<![CDATA[
]]>
<![CDATA[			  nLineLEft = cLng(DetailPosAr(0)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineTop = cLng(DetailPosAr(1)) + yOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineRight = cLng(DetailPosAr(2)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineBottom = cLng(DetailPosAr(3)) + yOffset ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			   Set oSetupNode_Detail = oSetup.GetNodeByName(3,oDetail.Type)]]>
<![CDATA[
]]>
<![CDATA[			   If Not(oSetupNode_Detail is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[				   Writelog("Setting Detail Zone to:'" & CStr(nLineLeft) & "," & CStr(nLineTop) & "," & CStr(nLineRight) & "," & CStr(nLineBottom) & "'")]]>
<![CDATA[
]]>
<![CDATA[				   oSetupNode_Detail.Variable("Pos" & sFPID) = CStr(nLineLeft) & "," & CStr(nLineTop) & "," & CStr(nLineRight) & "," & CStr(nLineBottom)]]>
<![CDATA[
]]>
<![CDATA[			   End if]]>
<![CDATA[
]]>
<![CDATA[			   Set oSetupNode_Detail = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   else]]>
<![CDATA[
]]>
<![CDATA[			   Writelog("Detail Postition was invalid")]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Detail Field not found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[	   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If oSetup.WriteSetup(oSetup.path)=False Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Unable to save Setup DCO:'" & oSetup.path & "'")  ]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Saved DCO Setup:'" & oSetup.path & "'")]]>
<![CDATA[
]]>
<![CDATA[					iloc_SetDetailSimple = True]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		oSetup.UnlockIt()]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[	  writelog("unable to save DCO because it was locked")]]>
<![CDATA[
]]>
<![CDATA[	  writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	End If 'readlock]]>
<![CDATA[
]]>
<![CDATA[    Set oLineItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Is_InCharSet" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    A list of valid characters.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    This action checks the 'Text' value of the current field to confirm that each of the characters are]]>
<![CDATA[
]]>
<![CDATA['    contained within the specified set of expected characters.  If one or more characters are not in the specified]]>
<![CDATA[
]]>
<![CDATA['    set, the action returns false.]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Is_InCharSet = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.Text = "" then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Null field value.  Returning False")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   For i = 1 to len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[      if InStr(StrParam,Mid(CurrentObj.Text,i,1)) = 0 then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Found character: " & Mid(CurrentObj.Text,i,1))]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[   next 'i]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Is_InCharSet = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsMultipageDocument" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' This action is used to determine if the current object is a document with multiple pages attached.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   IsMultipageDocument = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action cannot be on a batch object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.ObjectType = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Document object not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Document has " & oDoc.NumOfChildren & " page(s).")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.NumOfChildren > 1 then]]>
<![CDATA[
]]>
<![CDATA[      IsMultipageDocument = True]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsSinglePageDocument" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['  This action is used to determine if the current object is a document with only 1 page attached.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   IsSinglePageDocument = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action cannot be on a batch object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.ObjectType = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Document object not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Document has " & oDoc.NumOfChildren & " page(s).")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.NumOfChildren = 1 then]]>
<![CDATA[
]]>
<![CDATA[      IsSinglePageDocument = True]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsChildFieldValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    Two comma separated parameters:]]>
<![CDATA[
]]>
<![CDATA['    1. The name of the variable to check.]]>
<![CDATA[
]]>
<![CDATA['    2. The value to compare.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   This action locates a child field and compares its value to the one passed in.  This action]]>
<![CDATA[
]]>
<![CDATA[ '   can be used to perform actions if a field contains a specific value.]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim oField]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   IsChildFieldValue = False]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Wrong number of parameters.  Expecting (FieldName,Value).  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oField = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oField = CurrentObj.FindChild(ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Unable to find field.  Fieldname is case-sensitive.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oField.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Child object was not a field.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oField.Text = ParamAr(1) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Match found")]]>
<![CDATA[
]]>
<![CDATA[      IsChildFieldValue = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Child field has a value of " & oField.Text & " which does not match.")]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CreateFingerprint" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[ '   This action will create a fingerprint for the current page.  ]]>
<![CDATA[
]]>
<![CDATA[ '   Forces the creation of a new fingerprint using the current image, even if there is an existing]]>
<![CDATA[
]]>
<![CDATA[ '   fingerprint.  A typical scenario is when there is a very similar fingerprint that]]>
<![CDATA[
]]>
<![CDATA[ '   incorrectly matches the current image, such as two invoices]]>
<![CDATA[
]]>
<![CDATA[ '   that are very similar.  When the new invoice is received in the future, it should]]>
<![CDATA[
]]>
<![CDATA[ '   now match on this new fingerprint.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	CreateFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("CreateFingerprint skipping. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- CreateFingerprint for: "& CurrentObj.ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	retn = oFingerprint.AddNewFingerprint(CurrentObj,CurrentObj.Type)]]>
<![CDATA[
]]>
<![CDATA[	If bFailRule = True Then]]>
<![CDATA[
]]>
<![CDATA[		CreateFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CreateFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("CreateFingerprint returns " & CreateFingerprint)]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetPicChar" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    This action should not be used, as it is scheduled to be removed in future versions.]]>
<![CDATA[
]]>
<![CDATA['    It has been replaced by PIC_SetPictureCharacter in Picture.rrx.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim PicCharNum]]>
<![CDATA[
]]>
<![CDATA[   SetPicChar = FALSE]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   PicCharNum = Left(StrParam,1)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Len(StrParam) < 3 then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Not IsNumeric(PicCharNum) then    'first character must be a digit]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if mid(StrParam,2,1) <> "," then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   PicCharAr(PicCharNum) = Right(StrParam,Len(StrParam) - 2)  ]]>
<![CDATA[
]]>
<![CDATA[   WriteLog("Picture Character " & cStr(PicCharNum) & " is set to: " &  PicCharAr(PicCharNum))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SetPicChar = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="WriteErrorMessage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[ '   Writes the message to field level variable message that appears in the status bar.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  DCOMessage(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  WriteErrorMessage = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsInList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['   A string that is a superset of the expected 'Text' value.]]>
<![CDATA[
]]>
<![CDATA['   This action validates that the value of a field is contained within a given string.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   IsInList = FALSE]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Action must be on a field object. Exiting")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if InStr("," & StrParam & ","   ,    "," & CurrentObj.Text & ",") > 0  then]]>
<![CDATA[
]]>
<![CDATA[      IsInList = TRUE]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsInINI" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    A comma separated string of:]]>
<![CDATA[
]]>
<![CDATA['    1. The INI Filename.]]>
<![CDATA[
]]>
<![CDATA['    2. The section within the INI file.]]>
<![CDATA[
]]>
<![CDATA['    3. The keword to find in the section.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Reads the value of the specified key in the INI file.  It compares the value of the current]]>
<![CDATA[
]]>
<![CDATA['    field with the with the string in the INI file.  The field must be a substring of the string in the]]>
<![CDATA[
]]>
<![CDATA['    INI file.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA['     IsInINI("C:\MyDir\settings.ini", "mysection", "mykey")      ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next       ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[  Dim oFS]]>
<![CDATA[
]]>
<![CDATA[  Dim SearchList]]>
<![CDATA[
]]>
<![CDATA[  Dim DCOValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsInINI = FALSE]]>
<![CDATA[
]]>
<![CDATA[  ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If uBound(ParamAr) <> 2 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Improper number of parameters.  Parameters are a CSV value of the 1) INI Filename 2) Section & 3) Keyword.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Not oFS.FileExists(ParamAr(0)) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Could not find the INI file specified: "  & ParamAr(0) & ".   Parameters are Filename,Section,Keyword ")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Looking for section [" & ParamAr(1) & "] key '" & ParamAr(2) & "' in INI file:'" & ParamAr(0) & "'." ) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SearchList = Pilot.GetProfileString(ParamAr(1), ParamAr(2),"",ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 3 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Calling DCO is not a field, using variable 'Text' as value source.")]]>
<![CDATA[
]]>
<![CDATA[    DCOValue = CurrentObj.Variable("Text")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    DCOValue = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If SearchList = "" then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Unable to find section [" & ParamAr(1) & "] with key '" & ParamAr(2) & "'.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Returned key value:'" & SearchList & "'. Checking if returned value is in calling DCO value of '" & DCOValue & "'.")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InStr("," & SearchList & ","  , "," & DCOValue & ",") > 0 then]]>
<![CDATA[
]]>
<![CDATA[    IsInINI = TRUE]]>
<![CDATA[
]]>
<![CDATA[    Writelog("DCO value was found in the INI returned value.")]]>
<![CDATA[
]]>
<![CDATA[    'Next call sets value to high confidence (Text=Text)]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Text = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("DCO value was NOT found in the INI returned value.")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsTaskName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    The expected task name.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    This action will check the name of the currently running task to see if it matches the specified task name.  ]]>
<![CDATA[
]]>
<![CDATA['    If it matches, it will return True.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if Pilot.TaskName = StrParam or Pilot.Taskname = "" then]]>
<![CDATA[
]]>
<![CDATA[      IsTaskName = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else ]]>
<![CDATA[
]]>
<![CDATA[      IsTaskName = FALSE]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DetailFix" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    Calculates the quantity, price and line total for when one of them is blank within a detail field.]]>
<![CDATA[
]]>
<![CDATA['    This calculation is performed for all detail lines on the page.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim oQtyField]]>
<![CDATA[
]]>
<![CDATA[Dim oPriceField]]>
<![CDATA[
]]>
<![CDATA[Dim oLineTotalField]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   DetailFix = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.NumOfChildren = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("There were no children fields.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[       WriteLog("There are " &  CurrentObj.NumOfChildren & "  children")]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Set oQtyField = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Set oPriceField = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Set oLineTotalField = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Set oQtyField = CurrentObj.FindChild("Qty")]]>
<![CDATA[
]]>
<![CDATA[      Set oPriceField = CurrentObj.FindChild("Price")]]>
<![CDATA[
]]>
<![CDATA[      Set oLineTotalField = CurrentObj.FindChild("LineTotal")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("The Qty is :" & oQtyField.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[	  'WriteLog("The Price is :" & CurrentObj.FindChild("Price") & "'")]]>
<![CDATA[
]]>
<![CDATA[	  'WriteLog("The LineTotal is :" & CurrentObj.FindChild("LineTotal") & "'")]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[      if oQtyField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Unable to find Qty field.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if oPriceField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Unable to find Price field.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if oLineTotalField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Unable to find LineTotal field.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oQtyField.Text) <> "" And Not IsNumeric(oQtyField.Text) then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Non-numeric Qty found.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oPriceField.Text) <> "" And Not IsNumeric(oPriceField.Text) then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Non-numeric Price found.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oLineTotalField.Text) <> "" And Not IsNumeric(oLineTotalField.Text) then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Non-numeric Line total found.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if (Trim(oQtyField.Text) = "" AND Trim(oPriceField.Text) = "") OR (Trim(oLineTotalField.Text) = "" AND Trim(oPriceField.Text) = "") OR (Trim(oQtyField.Text) = "" AND Trim(oLineTotalField.Text) = "") Then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Missing too many values for calculation")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oQtyField.Text) = "" then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Qty was blank")]]>
<![CDATA[
]]>
<![CDATA[          oQtyField.Text = cStr( cDbl(oLineTotalField.text) / cDbl(oPriceField.text))]]>
<![CDATA[
]]>
<![CDATA[           'oQtyField.Text = cStr( oLineTotalField.text / oPriceField.text)]]>
<![CDATA[
]]>
<![CDATA[          'Round to nearest whole number]]>
<![CDATA[
]]>
<![CDATA[          'oQtyField.Text =  cStr(cLng(cDbl(oQtyField.Text) + 0.5))]]>
<![CDATA[
]]>
<![CDATA[          oQtyField.Variable("Calculated") = "YES"]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Variable("Calculated Field") = "Qty"]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Calculated QTY (" & oQtyField.Text & ") from Price (" &  oPriceField.Text & ") and LineTotal(" & oLineTotalField.Text & ")")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If Trim(oPriceField.Text) = "" then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Price was blank")]]>
<![CDATA[
]]>
<![CDATA[         oPriceField.Text = cStr( cDbl(oLineTotalField.Text) / cDbl(oQtyField.Text))]]>
<![CDATA[
]]>
<![CDATA[         oPriceField.Variable("Calculated") = "YES"]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Variable("Calculated Field") = "Price"]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Calculated Price (" & oPriceField.Text & ") from Qty (" &  oQtyField.Text & ") and LineTotal(" & oLineTotalField.Text & ")")]]>
<![CDATA[
]]>
<![CDATA[         oPriceField.Text = FormatCurrency(oPriceField.Text,2,-1) ]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oLineTotalField.Text) = "" then]]>
<![CDATA[
]]>
<![CDATA[       WriteLog("LineTotal blank")]]>
<![CDATA[
]]>
<![CDATA[         oLineTotalField.Text = cStr( cDbl(oPriceField.Text) * cDbl(oQtyField.Text))]]>
<![CDATA[
]]>
<![CDATA[         oLineTotalField.Variable("Calculated") = "YES"]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Variable("Calculated Field") = "LineTotal"]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Calculated LineTotal (" & oLineTotalField.text & ") from Qty (" &  oQtyField.Text & ") and Price(" & oPriceField.Text & ")")]]>
<![CDATA[
]]>
<![CDATA[         oLineTotalField.Text = FormatCurrency(oLineTotalField.Text,2,-1)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckForSticky" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[      '    For new fingerprints this action checks to see if there another matching fingerprint ]]>
<![CDATA[
]]>
<![CDATA['    within the same batch that has already been verified, where it can ]]>
<![CDATA[
]]>
<![CDATA['    use it to obtain zone information.  An example is when a batch contains two similar]]>
<![CDATA[
]]>
<![CDATA['    invoices, which have never been processed by the system before.  Once the first]]>
<![CDATA[
]]>
<![CDATA['    invoice is zoned during verify, the same new fingerprint can be used]]>
<![CDATA[
]]>
<![CDATA['    on the second invoice.  This is only needed on new matching fingerprints within the same batch]]>
<![CDATA[
]]>
<![CDATA['    because a fingerprints zones are saved at export time and are available for subsequent batches.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[    Dim j]]>
<![CDATA[
]]>
<![CDATA[    Dim k]]>
<![CDATA[
]]>
<![CDATA[    Dim ThisFingerprintID]]>
<![CDATA[
]]>
<![CDATA[    Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[    Dim oPage]]>
<![CDATA[
]]>
<![CDATA[    Dim oSourceField]]>
<![CDATA[
]]>
<![CDATA[    Dim oDestField]]>
<![CDATA[
]]>
<![CDATA[    Dim PosAr]]>
<![CDATA[
]]>
<![CDATA[    Dim OffSetAr]]>
<![CDATA[
]]>
<![CDATA[    Dim oSourceLineItemField]]>
<![CDATA[
]]>
<![CDATA[    Dim oDestLineItemField]]>
<![CDATA[
]]>
<![CDATA[    Dim oDetails]]>
<![CDATA[
]]>
<![CDATA[    Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CheckForSticky = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ThisFingerprintID = CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[    For i = 0 To DCO.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[       Set oDoc = DCO.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[       Set oPage = oDoc.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[       If oPage.Type = "Main_Page" And oPage.Variable("TemplateID") = ThisFingerprintID And (oPage.Status = 0 OR oPage.Status = 73) Then]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.FindChild("Vendor").Text  = oPage.FindChild("Vendor").Text]]>
<![CDATA[
]]>
<![CDATA[          OffSetAr = Split(CurrentObj.Variable("Image_Offset"),",")   ]]>
<![CDATA[
]]>
<![CDATA[          For j = 0 To CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[             Set oSourceField = oPage.GetChild(j) ]]>
<![CDATA[
]]>
<![CDATA[             Writelog("oSourceField: " & oSourceField.ID)         ]]>
<![CDATA[
]]>
<![CDATA[             Set oDestField = CurrentObj.GetChild(j)]]>
<![CDATA[
]]>
<![CDATA[             oDestField.Text = ""]]>
<![CDATA[
]]>
<![CDATA[             writelog ("Writing positions for " & oSourceField.Type) ]]>
<![CDATA[
]]>
<![CDATA[             If oSourceField.Variable("Position") <> "0,0,0,0" Then]]>
<![CDATA[
]]>
<![CDATA[                PosAr = Split(oSourceField.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[                oDestField.Variable("Position") = cStr(clng(PosAr(0))- cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(1))-cLng(OffsetAr(1))) & "," & cStr(cLng(PosAr(2))-cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(3))-cLng(OffsetAr(1))) ]]>
<![CDATA[
]]>
<![CDATA[            'oDestField.Variable("Position") = cStr(clng(PosAr(0))) & "," & cStr(cLng(PosAr(1))) & "," & cStr(cLng(PosAr(2))) & "," & cStr(cLng(PosAr(3))) ]]>
<![CDATA[
]]>
<![CDATA[             End If]]>
<![CDATA[
]]>
<![CDATA[             if (oSourceField.ID = "Vendor") Or (oSourceField.ID = "Vendor_Number") then]]>
<![CDATA[
]]>
<![CDATA[                  oDestField.Text = oSourceField.Text]]>
<![CDATA[
]]>
<![CDATA[             end if ]]>
<![CDATA[
]]>
<![CDATA[          Next 'j ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Set oSourceLineItemField = Nothing]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Set oSourceLineItemField = oPage.FindChild("Details").GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If Not oSourceLineItemField Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[             set oDetails = CurrentObj.FindChild("Details")]]>
<![CDATA[
]]>
<![CDATA[             Writelog("Found Details Field")]]>
<![CDATA[
]]>
<![CDATA[             oDetails.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[             Set oLineItem = oDetails.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[             oLineItem.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[             Set oDestLineItemField = CurrentObj.FindChild("Details").GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[             PosAr = Split(oSourceLineItemField.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[             'msgbox(oSourceLineItemField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[             oDestLineItemField.Variable("Position") = cStr(clng(PosAr(0))- cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(1))-cLng(OffsetAr(1))) & "," & cStr(cLng(PosAr(2))-cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(3))-cLng(OffsetAr(1))) ]]>
<![CDATA[
]]>
<![CDATA[             'msgbox(oDestLineItemField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[             For k = 0 To oDestLineItemField.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[                Set oSourceField = oSourceLineItemField.GetChild(k)]]>
<![CDATA[
]]>
<![CDATA[                Set oDestField = oDestLineItemField.GetChild(k)]]>
<![CDATA[
]]>
<![CDATA[               ' msgbox ("Writing positions for " & oDestField.Type & "  " &oDestField.Variable("Position") ) ]]>
<![CDATA[
]]>
<![CDATA[                If oSourceField.Variable("Position") <> "0,0,0,0" Then]]>
<![CDATA[
]]>
<![CDATA[                   PosAr = Split(oSourceField.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[                   oDestField.Variable("Position") = cStr(clng(PosAr(0))- cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(1))-cLng(OffsetAr(1))) & "," & cStr(cLng(PosAr(2))-cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(3))-cLng(OffsetAr(1))) ]]>
<![CDATA[
]]>
<![CDATA[                   'msgbox("Dest-" & oDestField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[                oDestField.Variable("Position") = cStr(clng(PosAr(0))) & "," & cStr(cLng(PosAr(1))) & "," & cStr(cLng(PosAr(2))) & "," & cStr(cLng(PosAr(3))) ]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[               ]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[             Next 'k]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          End If ]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Ready to write variable")]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Variable("Sticky") = "Yes"]]>
<![CDATA[
]]>
<![CDATA[          Exit Function   ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[       End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Next 'i ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable("Sticky") = "No"]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsChildFieldBlank" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ '   Searches for a child field that matches the provided parameter.  If it matches and if the text value]]>
<![CDATA[
]]>
<![CDATA[ '   is empty, then this action returns true, causing the next action in the ruleset to run.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim oField]]>
<![CDATA[
]]>
<![CDATA[   IsChildFieldBlank = FALSE]]>
<![CDATA[
]]>
<![CDATA[   Set oField = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oField = CurrentObj.FindChild(StrParam)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if oField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Field was not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if TRIM(oField.Text) = "" then]]>
<![CDATA[
]]>
<![CDATA[      IsChildFieldBlank = TRUE]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetStickyNo" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['    This action sets the 'Sticky' indicator to 'No', indicating that there are no sticky fingerprints.]]>
<![CDATA[
]]>
<![CDATA['    Sticky fingerprints are a way of identifying a page within a single verify session, when another]]>
<![CDATA[
]]>
<![CDATA['    form of the same type appears after a previous form had just been zoned.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("Sticky") = "No"]]>
<![CDATA[
]]>
<![CDATA[   SetStickyNo = TRUE]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ClearErrorMsg" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['  This action clears the current error message.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   ClearErrorMsg = TRUE]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("ErrorMessage") = ""]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Error Message: " & CurrentObj.Variable("ErrorMessage"))]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddToErrorMsg" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['  The error message text.]]>
<![CDATA[
]]>
<![CDATA['  Appends the suplied text to any existing error message string.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   AddToErrorMsg = FALSE   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("This action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Page is: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   oPage.Variable("ErrorMessage") = oPage.Variable("ErrorMessage") & StrParam & Chr(13)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Error message currently set to: " & oPage.Variable("ErrorMessage"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddToDetailErrorMsg" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['   The error message text.]]>
<![CDATA[
]]>
<![CDATA['    Appends additional text to the existing error message.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   AddToDetailErrorMsg = FALSE   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("This action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Page is: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   oPage.Variable("ErrorMessage") = oPage.Variable("ErrorMessage") & "Lineitem " & cStr(CurrentObj.Parent.Parent.FindChildIndex(CurrentObj.Parent.ID) + 1) & "-" & StrParam & Chr(13)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Error message currently set to: " & oPage.Variable("ErrorMessage"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsStationIDSuffix" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ '   The expected Station ID suffix.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '   This action will test the current station ID.  It checks that the specified parameter matches the right most portion of]]>
<![CDATA[
]]>
<![CDATA[ '   the station ID.  This can be useful if you have stations with different sufixes and you want to control]]>
<![CDATA[
]]>
<![CDATA[ '   actions based on the station name.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '     IsStationIDSuffix("-Test")]]>
<![CDATA[
]]>
<![CDATA[ '     CloseConnection()]]>
<![CDATA[
]]>
<![CDATA[ '     OpenConnection("@APPVAR(*/lookupdb:cs)")]]>
<![CDATA[
]]>
<![CDATA[ '     ]]>
<![CDATA[
]]>
<![CDATA[ '     In this example, If the station name is "Validate-Test", the action will]]>
<![CDATA[
]]>
<![CDATA[ '     return true and continue executing the following actions.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   IsStationIDSuffix = False]]>
<![CDATA[
]]>
<![CDATA[   if Len(StrParam) > len(Pilot.Station) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Specified suffix was longer than then current StationID. Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   if Right(Pilot.Station,len(StrParam)) = StrParam then]]>
<![CDATA[
]]>
<![CDATA[      IsStationIDSuffix = TRUE]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExecuteSQLBind" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ' This action should not be used, as it is scheduled to be removed in future versions.    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim oCmd]]>
<![CDATA[
]]>
<![CDATA[Dim oParam]]>
<![CDATA[
]]>
<![CDATA[Dim oRS]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ExecuteSQLBind = FALSE]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   If Not isobject(oConn) Or oConn is Nothing then]]>
<![CDATA[
]]>
<![CDATA[      writelog("No DB Connection Object. Aborting Task.")]]>
<![CDATA[
]]>
<![CDATA[      nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If oConn.State =0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("DB Connection is Closed.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oCmd = CreateObject("ADODB.Command")]]>
<![CDATA[
]]>
<![CDATA[   Set oParam = oCmd.CreateParameter("HostID",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Setting oCmd.CommandText to: " & ParamAr(0) )]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandText = ParamAr(0)]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandType = 1]]>
<![CDATA[
]]>
<![CDATA[   oCmd.ActiveConnection = oConn]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   for i = 1 to uBound(ParamAr)]]>
<![CDATA[
]]>
<![CDATA[    'oCmd.Parameters.Append oParam]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Setting parameter " & cStr(i-1) & " to " & ReturnNamedValue(ParamAr(i)) )]]>
<![CDATA[
]]>
<![CDATA[    'oCmd(i-1).Value = ReturnNamedValue(ParamAr(i))]]>
<![CDATA[
]]>
<![CDATA[   ' oCmd(i-1).Value = "1083"]]>
<![CDATA[
]]>
<![CDATA[   next 'i   ]]>
<![CDATA[
]]>
<![CDATA[   'msgbox oCmd.CommandText]]>
<![CDATA[
]]>
<![CDATA[   'msgbox oCmd(0).Value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oRS = oCmd.Execute]]>
<![CDATA[
]]>
<![CDATA[   'msgbox "Here"]]>
<![CDATA[
]]>
<![CDATA[   str = ""]]>
<![CDATA[
]]>
<![CDATA[   oRS.movefirst]]>
<![CDATA[
]]>
<![CDATA[   Do While NOT oRS.EOF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      for i = 0 to oRS.fields.count - 1]]>
<![CDATA[
]]>
<![CDATA[         str = str & " " & oRS.fields(i).value]]>
<![CDATA[
]]>
<![CDATA[      next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      writelog(str)]]>
<![CDATA[
]]>
<![CDATA[      str = ""]]>
<![CDATA[
]]>
<![CDATA[      oRS.movenext]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Loop]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ExecuteSQLBind = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Is_JobName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ '   This action will compare the provided job name with the name of the currently running job.  This can]]>
<![CDATA[
]]>
<![CDATA[ '   be useful, if you wish to perform actions based on different job names.  The comparison is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Pilot.JobName = StrParam then]]>
<![CDATA[
]]>
<![CDATA[      Is_JobName = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Is_JobName = FALSE]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Is_JobNamePrefix" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   Tests the left most portion of the job name to see if it matches the provided prefix.  The comparison]]>
<![CDATA[
]]>
<![CDATA[ '   is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if uCase(Left(Pilot.JobName,Len(StrParam))) = uCase(StrParam) then]]>
<![CDATA[
]]>
<![CDATA[      Is_JobNamePrefix = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Is_JobNamePrefix = FALSE]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReadFPXMLZones" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    Comma separated parameters:]]>
<![CDATA[
]]>
<![CDATA['    1. The fingerprint directory.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA['    2. A comma separated list of the detail lines.]]>
<![CDATA[
]]>
<![CDATA['     ]]>
<![CDATA[
]]>
<![CDATA['    This action reads the zones from the FPXML into the objects for the page and stores the specified ]]>
<![CDATA[
]]>
<![CDATA['    fileds so that when it creates detail lines it knows the positions of the detail line's fields.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[Dim oField]]>
<![CDATA[
]]>
<![CDATA[Dim FingerprintDir]]>
<![CDATA[
]]>
<![CDATA[Dim sFPXML]]>
<![CDATA[
]]>
<![CDATA[Dim xFPXML]]>
<![CDATA[
]]>
<![CDATA[Dim xDoc]]>
<![CDATA[
]]>
<![CDATA[Dim oLineItemField]]>
<![CDATA[
]]>
<![CDATA[Dim oSubField]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ReadFPXMLZones = FALSE]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   FingerprintDir = MetaWord(Trim(ParamAr(0)))]]>
<![CDATA[
]]>
<![CDATA[   if Right(FingerprintDir,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      FingerprintDir = FingerprintDir & "\"]]>
<![CDATA[
]]>
<![CDATA[   End if ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType = 2 then]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a page object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   if oPage.Variable("TemplateID") = "" then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Setting to test")]]>
<![CDATA[
]]>
<![CDATA[      oPage.Variable("TemplateID") = "1068"]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   sFPXML = FingerprintDir & oPage.Variable("TemplateID") & ".xml" ]]>
<![CDATA[
]]>
<![CDATA[   writelog("Attempting to read: " & sFPXML) ]]>
<![CDATA[
]]>
<![CDATA[   if Not oFS.FileExists(sFPXML) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("FPXML does not exist: " & sFPXML)]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set xDoc=CreateObject("MSXML2.DOMDocument")]]>
<![CDATA[
]]>
<![CDATA[   xDoc.async=False]]>
<![CDATA[
]]>
<![CDATA[   xDoc.Load(sFPXML)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   For i=0 To oPage.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[     Set oField=oPage.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Processing: " & oField.Type)]]>
<![CDATA[
]]>
<![CDATA[     sType = oField.Type  ]]>
<![CDATA[
]]>
<![CDATA[     sPos=xDoc.selectSingleNode(".//F[@type='" & sType & "']/V[@n='Position']").text]]>
<![CDATA[
]]>
<![CDATA[     oField.Variable("Position")=sPos]]>
<![CDATA[
]]>
<![CDATA[     Writelog(oField.Type & ".Variable(Position) was set to: " & sPos)]]>
<![CDATA[
]]>
<![CDATA[     if oField.Type = ParamAr(1) then]]>
<![CDATA[
]]>
<![CDATA[     sPos=xDoc.selectSingleNode(".//F[@type='" & ParamAr(2) & "']/V[@n='Position']").text]]>
<![CDATA[
]]>
<![CDATA[        oField.Variable("LineItemPos") = sPos ]]>
<![CDATA[
]]>
<![CDATA[        Writelog(oField.Type & ".Variable(LineItemPos) was set to: " & sPos)]]>
<![CDATA[
]]>
<![CDATA[        for j = 3 to uBound(ParamAr)]]>
<![CDATA[
]]>
<![CDATA[           sPos=xDoc.selectSingleNode(".//F[@type='" & ParamAr(j) & "']/V[@n='Position']").text]]>
<![CDATA[
]]>
<![CDATA[           oField.Variable("POS-" & ParamAr(j)) = sPos]]>
<![CDATA[
]]>
<![CDATA[           Writelog(oField.Type & ".Variable(POS-" & ParamAr(j) & ") was set to " & sPos)]]>
<![CDATA[
]]>
<![CDATA[           Writelog("Looping j")]]>
<![CDATA[
]]>
<![CDATA[        next 'j  ]]>
<![CDATA[
]]>
<![CDATA[     end if  ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Looping i")]]>
<![CDATA[
]]>
<![CDATA[   Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ReadFPXMLZones = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FPXMLUsed" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['    This action indicates if FPXML format fingerprint files are being used.  Call this action if you are]]>
<![CDATA[
]]>
<![CDATA[ '   using fingerprints from FPXML with Invoice.rrx.    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oPage.Variable("ZoneRead") = "FPXML" then]]>
<![CDATA[
]]>
<![CDATA[      FPXMLUsed = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else ]]>
<![CDATA[
]]>
<![CDATA[      FPXMLUsed = FALSE]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SwitchMMDD" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="">
	<g>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    This action is intended to switch US Month and Day date values.  It will swap the first two characters]]>
<![CDATA[
]]>
<![CDATA['    of the field value with the two characters following the separator.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA[Dim DateAr]]>
<![CDATA[
]]>
<![CDATA[Dim SepUsed]]>
<![CDATA[
]]>
<![CDATA[Dim SepCount]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[Dim OldVal]]>
<![CDATA[
]]>
<![CDATA[Dim OldConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   OldVal = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[   oldConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Starting value: " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[   SwitchMMDD = False]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   SepCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Call AllowOnlyChars(False,False,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   'Remove Extra Spaces]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   While InStr(CurrentObj.Text,"  ") > 0 ]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = Replace(CurrentObj.Text,"  "," ")]]>
<![CDATA[
]]>
<![CDATA[   wend  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   For i = 1 to Len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[         if InStr(StrParam,mid(CurrentObj.Text,i,1)) > 0 then]]>
<![CDATA[
]]>
<![CDATA[            SepCount = SepCount + 1]]>
<![CDATA[
]]>
<![CDATA[            if SepUsed = "" then]]>
<![CDATA[
]]>
<![CDATA[            SepUsed = mid(CurrentObj.Text,i,1)]]>
<![CDATA[
]]>
<![CDATA[         end if]]>
<![CDATA[
]]>
<![CDATA[      end if   ]]>
<![CDATA[
]]>
<![CDATA[   next 'i]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("SepCount: " & cStr(SepCount))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if SepCount = 2 then]]>
<![CDATA[
]]>
<![CDATA[      DateAr = Split(CurrentObj.Text,SepUsed)]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = DateAr(1) & SepUsed & DateAr(0) & SepUsed & DateAr(uBound(DateAr))]]>
<![CDATA[
]]>
<![CDATA[      SwitchMMDD = TRUE]]>
<![CDATA[
]]>
<![CDATA[    end if  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    writelog(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ValidateVendor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   The connection string to the lookup database.  Smart Parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '   Checks to see if the current vendor, vendor number and zip code exist on the same record in the lookup database.]]>
<![CDATA[
]]>
<![CDATA[ '   The fields that are validated are: Vendor, Vendor_Number and Remittance_Zip.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[Dim oConn]]>
<![CDATA[
]]>
<![CDATA[Dim oCmd]]>
<![CDATA[
]]>
<![CDATA[Dim oRS]]>
<![CDATA[
]]>
<![CDATA[Dim Retn]]>
<![CDATA[
]]>
<![CDATA[Dim oTestField]]>
<![CDATA[
]]>
<![CDATA[Dim oParam1]]>
<![CDATA[
]]>
<![CDATA[Dim oParam2]]>
<![CDATA[
]]>
<![CDATA[Dim oParam3]]>
<![CDATA[
]]>
<![CDATA[Dim PathAr]]>
<![CDATA[
]]>
<![CDATA[Dim ConnectionString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ValidateVendor = FALSE]]>
<![CDATA[
]]>
<![CDATA[   PathAr = Split(Pilot.ProjectPath,"\") ]]>
<![CDATA[
]]>
<![CDATA[   For i = 0 to uBound(PathAr) - 1]]>
<![CDATA[
]]>
<![CDATA[      SettingsFile = SettingsFile & PathAr(i) & "\"]]>
<![CDATA[
]]>
<![CDATA[   Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SettingsFile = SettingsFile & "Settings.ini"]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   writelog("SettingsFile: " & SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[   If Right(SettingsFile,12) <> "Settings.ini" Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Missing settings file " & Pilot.ProjectPath & ".  Please contact Administrator or Datacap Support.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oConn = CreateObject("ADODB.Connection")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ConnectionString = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[   sSmartParam=MetaWord(ConnectionString)]]>
<![CDATA[
]]>
<![CDATA[   If sSmartParam<>"" and ConnectionString<>sSmartParam Then ]]>
<![CDATA[
]]>
<![CDATA[     'attempt to decrypt value]]>
<![CDATA[
]]>
<![CDATA[     ConnectionString = Replace(ConnectionString,"[secured]", "")]]>
<![CDATA[
]]>
<![CDATA[     ConnectionString = Replace(ConnectionString,"[/secured]", "")]]>
<![CDATA[
]]>
<![CDATA[     bRes = [securecall]sSmartParam,ConnectionString[/securecall]   ]]>
<![CDATA[
]]>
<![CDATA[     If bRes=False Then Writelog("Index 4 Value not Decrypted.")]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("No result from Smart Parameter parsing. Using the original parameter string.") ]]>
<![CDATA[
]]>
<![CDATA[   End if ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[   oConn.Open(FormatADOConn(ConnectionString))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Connection Opened 2")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oConn.State <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Connection not open.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oTestField = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oTestField = CurrentObj.Parent.FindChild("Vendor")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If oTestField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Vendor field was not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oTestField = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oTestField = CurrentObj.Parent.FindChild("Vendor_Number")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If oTestField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Vendor_Number field was not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oTestField = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oTestField = CurrentObj.Parent.FindChild("Remittance_Zip")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   If oTestField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Remittance_Zip field was not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Fields found")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   VendorName = CurrentObj.Parent.FindChild("Vendor").Text]]>
<![CDATA[
]]>
<![CDATA[   VendorCode = CurrentObj.Parent.FindChild("Vendor_Number").Text]]>
<![CDATA[
]]>
<![CDATA[   Zip = CurrentObj.Parent.FindChild("Remittance_Zip").Text]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   'sSQL = "Select Count (VendorName) from VendorTable where VendorName = ? AND VendorID = ? and VendorZip = ?"]]>
<![CDATA[
]]>
<![CDATA[    sSQL = Pilot.GetProfileString("Database","ValidateVendor","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If sSQL = "*" Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Missing ValidateVendor entry in settings file.  Please contact Administrator or Datacap Support.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("sSQL=" & sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oCmd = CreateObject("ADODB.Command")]]>
<![CDATA[
]]>
<![CDATA[   Set oParam1 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[   Set oParam2 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[   Set oParam3 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Parameters created")]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandText = sSQL]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandType = 1]]>
<![CDATA[
]]>
<![CDATA[   oCmd.ActiveConnection = oConn]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Connection set")]]>
<![CDATA[
]]>
<![CDATA[   oCmd.Parameters.Append oParam1]]>
<![CDATA[
]]>
<![CDATA[   oCmd.Parameters.Append oParam2]]>
<![CDATA[
]]>
<![CDATA[   oCmd.Parameters.Append oParam3]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Parameters set")]]>
<![CDATA[
]]>
<![CDATA[   Writelog(VendorName)]]>
<![CDATA[
]]>
<![CDATA[   Writelog(Zip)]]>
<![CDATA[
]]>
<![CDATA[   Writelog(VendorCode)]]>
<![CDATA[
]]>
<![CDATA[   oCmd(0).Value = VendorName]]>
<![CDATA[
]]>
<![CDATA[   oCmd(1).Value = VendorCode]]>
<![CDATA[
]]>
<![CDATA[   oCmd(2).Value = Zip]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Ready to do oCmd.Execute")]]>
<![CDATA[
]]>
<![CDATA[   Set oRS = oCmd.Execute]]>
<![CDATA[
]]>
<![CDATA[   Writelog("SQL Executed")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Retn = oRS.GetString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog(Retn)]]>
<![CDATA[
]]>
<![CDATA[   if len(Retn) > 1 then]]>
<![CDATA[
]]>
<![CDATA[      Retn = Left(Retn,1)]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if Not IsNumeric(Retn) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("SQL returned a non-numeric result.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CLng(Retn) > 0 then]]>
<![CDATA[
]]>
<![CDATA[      'msgbox Retn]]>
<![CDATA[
]]>
<![CDATA[      ValidateVendor = TRUE]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindExportImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    One of the following values: ]]>
<![CDATA[
]]>
<![CDATA['    1. Document Level TIFF.]]>
<![CDATA[
]]>
<![CDATA['    2. Document Level PDF.]]>
<![CDATA[
]]>
<![CDATA['    3. Page Level TIO.]]>
<![CDATA[
]]>
<![CDATA['    4. Page Level TIF.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA['    This action searches the batch directory for a file that corresponds to the current page that contains the current]]>
<![CDATA[
]]>
<![CDATA['    field.  The file extension must match the extension specified with the input parameter.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[   FindExportImage = False]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oPage.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Unable to find page object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = oPage]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Unable to find document object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if InStr(",1,2,3,4,","," & StrParam & ",") < 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Invaid string parameter.  Expecting 1, 2, 3, or 4.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "1" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & oDoc.ID & ".tif") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & oDOc.ID & ".tif"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & oDoc.ID & ".tif was not found.") ]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "2" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & Pilot.BatchID & oDoc.ID & ".pdf") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & Pilot.BatchID & oDoc.ID & ".pdf"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & Pilot.BatchID & oDoc.ID & ".pdf was not found." )]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "3" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & oPage.ID & ".tio") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & oPage.ID & ".tio"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & oPage.ID & ".tio was not found." )]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "4" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & oPage.ID & ".tif") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & oPage.ID & ".tif"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & oPage.ID & ".tif was not found." )]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SwapImages" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    Two extensions:]]>
<![CDATA[
]]>
<![CDATA['    1. The extension to be saved as TIF.]]>
<![CDATA[
]]>
<![CDATA['    2. The extension that current tif is saved as.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    This action interchanges the TIF for the current page with another TIF that has the same file name but]]>
<![CDATA[
]]>
<![CDATA['    a different extension.  One possible use is if you had a backup of the TIF and need to restore it.]]>
<![CDATA[
]]>
<![CDATA['    The current TIF will be named with the new extension while the other named TIF, is renamed to have a TIF extension.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[Dim CurrentTIFF]]>
<![CDATA[
]]>
<![CDATA[Dim ProcessedTIFF]]>
<![CDATA[
]]>
<![CDATA[Dim OriginalTIFF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SwapImages = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType < 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action will not work from a document or batch level.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType = 3 ]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oPage.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Field was not on a page.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Invalid number of parameters.  Expecting (ext1,ext2).  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Left(ParamAr(0),1) <> "." then]]>
<![CDATA[
]]>
<![CDATA[      ParamAr(0) = "." & ParamAr(0)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("First extension changed to: " & ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Left(ParamAr(1),1) <> "." then]]>
<![CDATA[
]]>
<![CDATA[      ParamAr(1) = "." & ParamAr(1)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Second extension changed to: " & ParamAr(1))]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentTIFF = oPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ProcessedTIFF = Left(CurrentTIFF,InStrRev(CurrentTIFF,".") - 1)  & ParamAr(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Moving " & CurrentTIFF & " to " & ProcessedTiFF)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oFS.FileExists(CurrentTIFF) then]]>
<![CDATA[
]]>
<![CDATA[      Call oFS.MoveFile(CurrentTIFF,ProcessedTIFF)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Moved Processed")]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      writelog("File not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   OriginalTIFF = Left(CurrentTIFF,InStrRev(CurrentTIFF,".") - 1)  & ParamAr(0)        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oFS.FileExists(OriginalTIFF) then]]>
<![CDATA[
]]>
<![CDATA[      Call oFS.CopyFile(OriginalTIFF,CurrentTIFF)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Moved Original")]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Original File not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SwapImages = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AlterDatebyDay" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    The number of days to add.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    This action will add the specified number of days to the date contained in the current field.  The original character]]>
<![CDATA[
]]>
<![CDATA['    confidence is not changed.  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim OldConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   AlterDatebyDay = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Not IsNumeric(StrParam) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Expecting numeric parameter.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   OldConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Text = DateAdd("d",cLng(StrParam),CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.ConfidenceString = OldConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
	</g>
</af>
<af name="SetToDocIDMPTIFF" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    The path to the exported tiff files.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA['    This action builds a full path to the a tiff file and sets the field text to this value. ]]>
<![CDATA[
]]>
<![CDATA['    The path consists of the export path + DOCID + .TIF.]]>
<![CDATA[
]]>
<![CDATA['    The value is put into the field]]>
<![CDATA[
]]>
<![CDATA['    so it can be access later in the application, if necessary.  It only builds the path.]]>
<![CDATA[
]]>
<![CDATA['    The action does not output the TIF file.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[   if Right(StrParam,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      StrParam = StrParam & "\"]]>
<![CDATA[
]]>
<![CDATA[   end if   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   While (oDoc.ObjectType > 1)]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[   Wend]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Text = StrParam &  oDoc.ID & ".tif" ]]>
<![CDATA[
]]>
<![CDATA[   SetToDocIDMPTIFF = true]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckFreeDiskSpace" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    Two comma separated parameters:]]>
<![CDATA[
]]>
<![CDATA['    1. The path to Settings.ini that contains the 'LowDiskSpaceThreshold' setting.]]>
<![CDATA[
]]>
<![CDATA['    2. The letter drive of the drive to check.    ]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Reads the 'LowDiskSpaceThreshold' setting from the [Notifications] section of the Settings.ini file.  If the]]>
<![CDATA[
]]>
<![CDATA['    available disk space is lower than the value specified in the INI file, then a notification will be created.]]>
<![CDATA[
]]>
<![CDATA['    If the 'LowDiskSpaceThreashold' is missing from the INI file, the default value of 3000 bytes will be used.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim Threshold]]>
<![CDATA[
]]>
<![CDATA[Dim oDrive]]>
<![CDATA[
]]>
<![CDATA[Dim DriveFreeSpace]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CheckFreeDiskSpace = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 0 then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Action was designed to run from batch level only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = SPlit(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Invalid number of parameters.  Expecting SettingsFile,DriveLetter).  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Not oFS.FileExists(ParamAr(0)) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("SettingsFile was not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   set oDrive = oFS.GetDrive(oFS.GetDriveName(ParamAr(1)))   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   DriveFreeSpace =  FormatNumber(oDrive.FreeSpace/(1024 * 1024),0) ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Free Space: " &  DriveFreeSpace)  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Threshold = Pilot.GetProfileString("Notifications","LowDiskSpaceThreshold","3000",ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Threshold Setting: " & Threshold)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if cLng(DriveFreeSpace) >= cLng(Threshold) then]]>
<![CDATA[
]]>
<![CDATA[      if Pilot.GetProfileString("Notifications","LowDiskNotificationSent","",ParamAr(0)) = "Yes" then ]]>
<![CDATA[
]]>
<![CDATA[         Call Pilot.SetProfileString("Notifications","LowDiskNotificationSent","No",ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[         writelog("Cleared Notification")]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      if Pilot.GetProfileString("Notifications","LowDiskNotificationSent","",ParamAr(0)) = "No" then ]]>
<![CDATA[
]]>
<![CDATA[         Call Pilot.SetProfileString("Notifications","LowDiskNotificationSent","Yes",ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[         writelog("Marked Notification to Send")]]>
<![CDATA[
]]>
<![CDATA[         CheckFreeDiskSpace = TRUE]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   end if  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="CheckAndFixDecimal" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    Replaces the space or , with .]]>
<![CDATA[
]]>
<![CDATA['    This can be used to fix errors where the decimal is not recognized and leaves a blank in that area, ]]>
<![CDATA[
]]>
<![CDATA['    also this can be used for conversion for European numbers that use a comma to separate dollars from cents]]>
<![CDATA[
]]>
<![CDATA['    so $100,00 becomes $100.00 or $100 00 becomes $100.00.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA[   Dim oldCOnf]]>
<![CDATA[
]]>
<![CDATA[   Dim NewText]]>
<![CDATA[
]]>
<![CDATA[   CheckandFixDecimal = False ]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   if Len(CurrentObj.Text) < 3  then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Length is too short for currency.  Exiting FALSE")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   Writelog("The Starting value is :" & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[   oldConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Mid(CurrentObj.Text,len(CurrentObj.Text) - 2,1) = " " OR  Mid(CurrentObj.Text,len(CurrentObj.Text) - 2,1) = ","  then]]>
<![CDATA[
]]>
<![CDATA[       NewText = Left(CurrentObj.Text,Len(CurrentObj.Text) - 3) & "." & Right(CurrentObj.Text,2)]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Converting " & CurrentObj.Text & " to " & NewText) ]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Text = NewText]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.ConfidenceString = oldCOnf]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("The value of :" & CurrentObj.Text & " doesn't fall in the criteria of a space or comma followed by two digits")]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CheckAndFixDecimal = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="MovePDF" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  This action moves the PDF associated with the current document to the specified directory.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Dim oFS]]>
<![CDATA[
]]>
<![CDATA[   Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[   MovePDF = False]]>
<![CDATA[
]]>
<![CDATA[   if Right(StrParam,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      StrParam = StrParam & "\"]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[   While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Could not find document object.  Exiting without moving PDF")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if       ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if Not oFS.FileExists(StrParam & oDoc.ID & ".pdf") AND oFS.FileExists(Pilot.BatchDir & "\" & oDoc.ID & ".pdf") then]]>
<![CDATA[
]]>
<![CDATA[      Call  oFS.CopyFile(Pilot.BatchDir & "\" & oDoc.ID & ".pdf",StrParam & oDoc.ID & ".pdf")]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = StrParam & oDoc.ID & ".pdf"]]>
<![CDATA[
]]>
<![CDATA[      Writelog("CurrentObj.Text = " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[      MovePDF = TRUE]]>
<![CDATA[
]]>
<![CDATA[   End if   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AllMixedCase" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['    This action will change the value of the current field to be Title case.  The first letter of]]>
<![CDATA[
]]>
<![CDATA['    each word will be capitalized.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[Dim oldConf]]>
<![CDATA[
]]>
<![CDATA[Dim MixedString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   AllMixedCase = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action is designed for field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function   ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   writelog("Getting confidence")]]>
<![CDATA[
]]>
<![CDATA[   oldConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   for i = 1 to len(CurrentObj.Text) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if i = 1 then]]>
<![CDATA[
]]>
<![CDATA[         MixedString = uCase(Left(CurrentObj.Text,1))]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[         if mid(CurrentObj.Text,i-1,1) = " " then]]>
<![CDATA[
]]>
<![CDATA[            MixedString = MixedString & uCase(mid(CurrentObj.Text,i,1))]]>
<![CDATA[
]]>
<![CDATA[         else]]>
<![CDATA[
]]>
<![CDATA[            MixedString = MixedString & lCase(mid(CurrentObj.Text,i,1)) ]]>
<![CDATA[
]]>
<![CDATA[         end if]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[      Writelog(MixedString)]]>
<![CDATA[
]]>
<![CDATA[   next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Text = MixedString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.ConfidenceString = oldConf]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CaptureOpInfo" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    An optional prefix to the variable name.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA['    This action will capture the Operator, Station ID and current time and place them into variables.  The variables will be]]>
<![CDATA[
]]>
<![CDATA['    named based on the provided variable prefix, like this: "prefix Operator", "prefix Station" and "prefix Time".]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CapatureOpInfo = TRUE]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Trim(StrParam) = "" Then StrParam = Pilot.TaskID]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable(StrParam & " " & "Operator") = Pilot.Operator]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable(StrParam & " " & "Station") = Pilot.Station]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable(StrParam & " " & "Time") = Now()]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GenerateDetails" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    This action sets up a field in APT and puts a detail subfield on every page.  This extra detail subfield]]>
<![CDATA[
]]>
<![CDATA['    appears on all pages of a multi-page invoice, allowing every page to be viewed.    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[Dim NumPages]]>
<![CDATA[
]]>
<![CDATA[Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[Dim oField]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   GenerateDetails = False]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.Parent.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field that is a child of a page object.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj.Parent]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if oPage.Parent.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field in a document structure.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Proper structure found")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   NumPages = oDoc.NumOfChildren   ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Detected " & NumPages & " pages.")   ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   For i = 0 to NumPages - 1      'children indexes are 0 based]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Creating line for page " & cStr(i+1) ) ]]>
<![CDATA[
]]>
<![CDATA[      Set oLineItem = CurrentObj.AddChild(3,"Page_No" & cStr(i+1) ,i)      ]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.Type = "Page_No"      ]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.Status = 0]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.Variable("Position") = "90,90,210,210"]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.Variable("IMAGEFILE") = oDoc.GetChild(i).Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[      Set oField = oLineItem.AddChild(3,"TIFF",0)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      oField.Variable("IMAGEFILE") = oDoc.GetChild(i).Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[      oField.Variable("Position") = "100,100,200,200"]]>
<![CDATA[
]]>
<![CDATA[      oField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[      oField.Text = Right(oField.Variable("IMAGEFILE"),12)]]>
<![CDATA[
]]>
<![CDATA[      oField.Type = "TIFF"]]>
<![CDATA[
]]>
<![CDATA[   next 'i]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   GenerateDetails = TRUE]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IncrementBatchVar" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the variable to increment.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '   This action increments a batch level variable by 1.  If the variable does not already exist, it will be created.]]>
<![CDATA[
]]>
<![CDATA[ '   If the variable exists but the value is not numeric, the variable will be set to 1.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   Dim CurrentValue]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   IncrementBatchVar = TRUE]]>
<![CDATA[
]]>
<![CDATA[   CurrentValue = DCO.Variable(strParam)]]>
<![CDATA[
]]>
<![CDATA[   if Not IsNumeric(CurrentValue) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Creating batch variable: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[      DCO.Variable(strParam) = "1"]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   DCO.Variable(StrParam) = cStr(cLng(DCO.Variable(StrParam)) + 1)      ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SendOutlookNotification" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   The extension of the attachment.  The attachment is expected to be named the same as the current document ID.]]>
<![CDATA[
]]>
<![CDATA[ '  ]]>
<![CDATA[
]]>
<![CDATA[ '   This action uses outlook to send a notification to specified e-mail addresses.  The message within the email]]>
<![CDATA[
]]>
<![CDATA[ '   is determined by previous calls to actions that have set notification, such as CheckFreeDiskSpace.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '   Note that this action has some requirements such as Outlook installed on the machine and logged]]>
<![CDATA[
]]>
<![CDATA[ '   in with an ID that has appropriate permissions to send emails.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oOutlook]]>
<![CDATA[
]]>
<![CDATA[Dim oMail]]>
<![CDATA[
]]>
<![CDATA[Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[Dim MailTo]]>
<![CDATA[
]]>
<![CDATA[Dim StrMessage]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      SendOutlookNotification = TRUE]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[      While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[         Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[      Wend]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      if oDoc.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Document object not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Set oOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Set oOutlook = CreateObject("Outlook.Application")]]>
<![CDATA[
]]>
<![CDATA[      if oOutlook Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Could not create Outlook object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Set oMail = oOutlook.CreateItem(0)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   SettingsFile = Pilot.GetProfileString("Files","Settings","*",Pilot.ProjectPath)]]>
<![CDATA[
]]>
<![CDATA[   If SettingsFile = "*" Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Missing settings file " & Pilot.ProjectPath & ".  Please contact Administrator or Datacap Support.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Settings file: " & SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   MailTo = Pilot.GetProfileString("Notifications",CurrentObj.Text,"*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[   if MailTo = "*" then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Could not find email address in settings.ini.  Exiting - " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if Left(StrParam,1) <> "." then]]>
<![CDATA[
]]>
<![CDATA[      StrParam = "." & StrParam]]>
<![CDATA[
]]>
<![CDATA[   End if   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   oMail.To = MailTo]]>
<![CDATA[
]]>
<![CDATA[   oMail.Subject = "Taskmaster Notification - " & oDoc.ID]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   if oFS.FileExists(Pilot.BatchDir & "\" & oDoc.ID & StrParam) then]]>
<![CDATA[
]]>
<![CDATA[      oMail.Attachments.Add(Pilot.BatchDir & "\" & oDoc.ID & StrParam)]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Could not find attachment: " & Pilot.BatchDir & "\" & oDoc.ID & StrParam) ]]>
<![CDATA[
]]>
<![CDATA[   end if     ]]>
<![CDATA[
]]>
<![CDATA[   strMessage = "Reason for notification: " & CurrentObj.Text & vbcrlf & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   strMessage = strMessage & "Operator: " & CurrentObj.Parent.Variable("Verify Operator") & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   strMessage = strMessage & "Station: " & CurrentObj.Parent.Variable("Verify Station") & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   strMessage = strMessage & "Time: " & CurrentObj.Parent.Variable("Verify Time") & vbcrlf ]]>
<![CDATA[
]]>
<![CDATA[   strMessage = strMessage & "Comments: " & CurrentObj.Parent.Variable("comments") & vbcrlf ]]>
<![CDATA[
]]>
<![CDATA[   oMail.Body = strMessage]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[   oMail.Send]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oMail = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oOutlook = Nothing  ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="UpdateFPStats" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[ '   This action updates the fingerprint statistics in the fingerprint database.    ]]>
<![CDATA[
]]>
<![CDATA[ '   It keeps track of the last accessed fingerprint and the number of times a fingerprint is accessed.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim oCmd]]>
<![CDATA[
]]>
<![CDATA[Dim oParam1]]>
<![CDATA[
]]>
<![CDATA[Dim oParam2]]>
<![CDATA[
]]>
<![CDATA[Dim DateHit]]>
<![CDATA[
]]>
<![CDATA[Dim oRS]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ON ERROR RESUME NEXT]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   UpdateFPStats = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oConn.State = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Connection to the rules/fingerprint database was not found.Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("This action was designed to operate on a page level object only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oCmd = CreateObject("ADODB.Command")]]>
<![CDATA[
]]>
<![CDATA[   Set oParam1 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[   Set oParam2 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   sSQL = "UPDATE Template SET tp_HitCount = tp_HitCOunt + 1, tp_LastHit = ? WHERE tp_TemplateID = ?"]]>
<![CDATA[
]]>
<![CDATA[   sSQL = ModifySQLByDBType(oCmd,sSQL)]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandText = sSQL]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandType = 1]]>
<![CDATA[
]]>
<![CDATA[   oCmd.ActiveConnection = oConn]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Connection set")]]>
<![CDATA[
]]>
<![CDATA[   oCmd.Parameters.Append oParam1]]>
<![CDATA[
]]>
<![CDATA[   oCmd.Parameters.Append oParam2]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Parameters set")]]>
<![CDATA[
]]>
<![CDATA[   Writelog("TemplateID = " & CurrentObj.Variable("TemplateID"))]]>
<![CDATA[
]]>
<![CDATA[   oCmd(0).Value = Date()]]>
<![CDATA[
]]>
<![CDATA[   oCmd(1).Value = CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oCmd(1).Value = "" then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No TemplateID found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Ready to do oCmd.Execute")]]>
<![CDATA[
]]>
<![CDATA[   oRS = oCmd.Execute]]>
<![CDATA[
]]>
<![CDATA[   Writelog("SQL Executed")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oCmd = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oParam1 = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oParam2 = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[   ERR.CLEAR]]>
<![CDATA[
]]>
<![CDATA[   UpdateFPStats = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<help>
<![CDATA[
'*****************************************************************
'Invoice rrx Action Help 
'IBM Confidential
'
'OCO Source Materials
'
'5725-C15 5725-C69
'© Copyright IBM Corp. 1994, 2012
'The source code for this program is not published or otherwise
'divested of its trade secrets, irrespective of what has been 
'deposited with the U.S. Copyright Office.
'-----------------------------------------------------------------
'
' Version 8.0.1.11 Updated 12/21/2010 PHofle
'   * Converted to .Net Dll
'
'*************************************************
'
']]>
<ref id="SetDynamicDetailZones"  >
  <ap>
    The parameter is the Zone Bottom field. If more than one field is listed, 
    Zone Bottom must be first field, and additional fields are ignored.
  </ap>
  <h>  
    This action takes the position of the line items and it builds the line coordinates from them
    and then it sets the details zones from that top line to the bottom of the CCO.
    <e>
      LoadCCOFromField()<br/>      
      <b>SetDynamicDetailZones("Zone Bottom,Notes")</b><br/>
      ZoneBOTTOM_ImageBottom()<br/>
      ScanDetails()
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if no children exist.  Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="LoadCCOFromField"  >
  <ap>None.</ap>
  <h>
    This action loads the DCO from a field object.
    The verify panels do not load the CCO into the scripting engine so this action acomplishes that task.  
    This action is required for any invoice action that uses the CCO.
    <e>
      <b>LoadCCOFromField()</b><br/>
      SetDynamicDetailZones("Zone Bottom,Notes")<br/>
      ZoneBOTTOM_ImageBottom()<br/>
      ScanDetails()
    </e>
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    <b>False,</b> if this action is not called on a field or if the CCO file does not exist.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
  
<ref id="ScanLineItemDynamic"  >
  <ap>
    A comma separated list of any fields that should be ignored.
  </ap>
  <h>
    This action scans the line items from the CCO that was loaded into the field.  It is like
    ScanLineItem but uses the CCO loaded for the field and reads position variables from the line item level.
    It is required for Find Details functionality.  It saves the positions of the line and of the feids at the detail
    level so all of the line items can be erased and recreated.
    <e>
      FPXMLUsed()<br/>
      <b>ScanLineItemDynamic("ZoneBottom,Notes")</b>
    </e>
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
  
<ref id="AllowOnlyChars"  >
  <ap>
    A list of all characters allowed within the field.
  </ap>
  <h>
    This action will match the field characters with the allowed set of characters.  If the field contains
    characters that are not in the allowed set, the characters will be deleted from the field.
    The comparison is case sensitive. 
    <e>
      CheckAnFixDecimal()<br/>
      Is_InCharSet("01234567890.,-$ ")<br/>
      <b>AllowOnlyChars("0123456789.-")</b>
    </e>
  </h>
  <lvl>
    Field Level.
  </lvl>
  <ret>
    <b>False,</b> if this action is called at the wrong level.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="PopulateZNLineItemFieldDynamic"  >
  <ap>
    None.
  </ap>
  <h>
    This action is like the PopulateZNLineItemField but it uses the CCO that was
    loaded into memory by LoadCCOFromField, instead of the global CCO.
    It populates the fingerprint’s Data file with the recognized value contained inside
    the zone of a child Field object of a LINEITEM parent field. This action should
    only be used with sub-fields of the LINEITEM field - ItemID, ItemDesc,
    Quantity, Price in the <i>Invoices</i> application.
    <e>
      FPXMLUsed()<br/>
      <b>PopulateZNLineItemFieldDynamic()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if there is no field position or if the data was found in a zone.
    <b>False,</b> if there is a zone defined but it is blank.    
  </ret>
</ref>
<ref id="CalculateNotesZone"  >
  <ap>
    None.
  </ap>
  <h>
    This action creates a zone between detail lines, so the text between lines can 
    be recognized.
    <e>
      <b>CalculateNotesZone()</b>
    </e>
  </h>
  <lvl>Field level, on the detail field.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="ParseImageName"  >
  <ap>
    None.
  </ap>
  <h>
    This action extracts only the file name from the variable 'ScanSrcPath' and
    places it into the 'Text' variable of the current object.  It is expected that the file
    name contains an underscore and only the value up to the underscore is kept.
    <e>
      <b>ParseImageName()</b>
    </e>
  </h>
  <lvl>Document or Page level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="IsFingerPrintClass"  >  
  <ap>
    Two comma separated parameters:<br/>
    1. The database connection string.  Smart parameters are supported.<br/>
    2. Fingerprint class.
  </ap>
  <h>
    This action connects to the fingerprint database and verifies that the specified fingerprint
    class contains the fingerprint ID of the current page.  
    <e>
      ChkDCOStatus("75")<br/>      
      <b>IsFingerPrintClass("@APPVAR(*/fingerprintconn:cs)+,[New]")</b><br/>
      DeleteFingerprint()<br/>
      IncrementBatchVar("Deleted New Fingerprint")<br/><br/>

      A parameter of [New] checks to see if the fingerprint exists in the new class,
      and if it does, follow on actions can perform further processing.
    </e>
  </h>
  <lvl>
    Page Level.
  </lvl>
  <ret>
    <b>False,</b> if called with the wrong number of parameters, on the wrong level, if the 
    fingerprint ID does not exist in the specified class.
  </ret>
</ref>
  
<ref id="iloc_SetDetailSimple"  strParam="sDetailName" >
  <ap>
    The detail Datacap Object (DCO) Type.
  </ap>
  <h>
    This action fills the Setup DCO from Runtime Data file.    
    <e>
      SetFingerprint("@P\Vendor")<br/>
      iloc_SetZones()<br/>
      <b>iloc_SetDetailSimple("Details")</b><br/>
      IncrementBatchVar("Intellocate Fingerprint")
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if the DCO node cannot be found, if the fingerprint ID is not
    found, or if the setup DCO cannot be saved.  Otherwise, <b>True.</b>
  </ret>
</ref>
		
  
<ref id="Is_InCharSet"  >
  <ap>
    A list of valid characters.
  </ap>
  <h>
    This action checks the 'Text' value of the current field to confirm that each of the characters are
    contained within the specified set of expected characters.  If one or more characters are not in the specified
    set, the action returns false.<br/><br/>
    
    <b>Note:</b> The comparison is case sensitive.
    <e>
      CheckAndFixDecimal()<br/>      
      <b>Is_InCharSet("0123456789.,-$ ")</b>
    </e>
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if the 'Text' value of the current object is empty or if
    a character in the 'Text' variable of the current object does not exist in the specified character set.
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="IsMultipageDocument"  >
  <ap>
    None.
  </ap>
  <h>
    This action is used to determine if the current object is a document with multiple pages attached.
    <e>
      <b>IsMultipageDocument()</b>
    </e>
  </h>
  <lvl>
    Document level.
  </lvl>
  <ret>
    <b>False,</b> if called at the Batch level, the document object cannot be found, 
    or if the document does not have more than 1 child.
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="IsSinglePageDocument"  >
  <ap>
    None.
  </ap>
  <h>
    This action is used to determine if the current object is a document with only 1 page attached.
    <e>
      <b>IsSinglePageDocument()</b><br/>
      PopulateZNField()
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False,</b> if not called on a document object or if the document does not contain exactly one page.
    <b>True,</b> if the document contains one page.
  </ret>
</ref>
  
<ref id="DoMsgbox"  >
  <ap>
    The message to display.  
  </ap>
  <h>
    This Action is Deprecated, its functionality is no longer supported.
    
    The message is displayed to the user and they must press "OK" to continue.<br/><br/>
    
    <b>Note:</b> This action must not be used within a ruleset that is run
    unattended or processing will stop.
    <e>
      CheckDCOStatus("75")<br/>
      <b>DoMsgbox("The page was deleted.")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="IsChildFieldValue"  >
  <ap>
    Two comma separated parameters:<br/>
    1. The name of the variable to check.<br/>
    2. The value to compare.
  </ap>
  <h>
    This action locates a child field and compares its value to the one passed in.  This action
    can be used to perform actions if a field contains a specific value.
    <e>
      <b>IsChildFieldValue("Add_New_Fingerprint,YES")</b>      
    </e>
  </h>
  <lvl>Document Level</lvl>
  <ret>
    <b>False,</b> if the field is not found, the number of parameters is incorrect
    or if it is called at the wrong level.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="CreateFingerprint"  >
  <ap>
    None.
  </ap>
  <h>
    This action will create a fingerprint for the current page.  
    Forces the creation of a new fingerprint using the current image, even if there is an existing
    fingerprint.  A typical scenario is when there is a very similar fingerprint that
    incorrectly matches the current image, such as two invoices
    that are very similar.  When the new invoice is received in the future, it should
    now match on this new fingerprint.
    <e>
      IsChildFieldValue("Add_New_Fingerprint,YES")<br/>
      SetFingerprintDir("@APPPATH(fingerprint)")<br/>
      SetFingerprintRecogPriority("True")<br/>
      RecognizePageOCR_S()<br/>
      <b>CreateFingerprint()</b><br/>
      SetFingerprint("@P\Vendor")<br/>
      iloc_SetDetailSimple("Details")<br/>
      IncrementBatchVar("Verify requested Add Fingerprint")
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if a new fingerprint has been created.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="SetPicChar"  >
  <ap>
  </ap>
  <h>
    This action should not be used, as it is scheduled to be removed in future versions.
    It has been replaced by PIC_SetPictureCharacter in Picture.rrx.
  </h>
</ref>

<ref id="WriteErrorMessage"  >
  <ap>
    The error message.
  </ap>
  <h>    
    Writes the message to field level variable message that appears in the status bar. The message is stored in the MESSAGE variable.
    <e>
      GetDCOStatus("75")<br/>
      <b>WriteErrorMessage("The page is set to a deleted status.")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>
  
<ref id="IsInList"  >
  <ap>
    A string that is a substring of the expected 'Text' value.
  </ap>
  <h>
    This action validates that the value of a field is contained within a given string.
    <e>
      <b>IsInList("Hello Larry")</b>
      <br/><br/>
      In this example, if the field 'Text' value is 'Larry', the action will return true.
    </e>
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    <b>True,</b> if the value of the Text variable of the current field is contained within the specified list.
  </ret>
</ref>
  
<ref id="IsInINI"  >
  <ap>
    A comma separated string of:<br/>
    1. The INI Filename.<br/>
    2. The section within the INI file.<br/>
    3. The keyword to find in the section.
  </ap>
  <h>
    Reads and returns to the action the value of the specified key in the INI file.  It compares the value of the current
    field with the with the string in the INI file.  The field must be a substring of the string in the
    INI file.
    <e>
      <b>IsInINI("C:\MyDir\settings.ini", "mysection", "mykey")</b><br/><br/>      
    </e>    
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    <b>True,</b> if the value of the current field is a substring within the string specified in the INI file.
    Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="IsTaskName"  >
  <ap>
    The expected task name.
  </ap>
  <h>
    This action will check the name of the currently running task to see if it matches the specified task name.  
    If it matches, it will return True.
    <e>
      IsTaskName("Verify")<br/>
      <b>LoadCCOFromField()</b><br/>
      PopulateZNField()
    </e>
  </h>
  <lvl>Any levels.</lvl>
  <ret>
    <b>True,</b> if the specified name matches the currently running task.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="DetailFix"  >  
  <ap>None.</ap>
  <h>
    Calculates the quantity, price and line total for when one of them is blank within a detail field.
    This calculation is performed for all detail lines on the page.
    <e>
      <b>DetailFix()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level.<br/>
    <b>False,</b> The any of following fields do not exist or are not numeric: Qty, Price and LineTotal.<br/>
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="CheckForSticky"  >
  <ap>None.</ap>
  <h>
    For new fingerprints this action checks to see if there another matching fingerprint 
    within the same batch that has already been verified, where it can 
    use it to obtain zone information.  An example is when a batch contains two similar
    invoices, which have never been processed by the system before.  Once the first
    invoice is zoned during verify, the same new fingerprint can be used
    on the second invoice.  This is only needed on new matching fingerprints within the same batch
    because a fingerprints zones are saved at export time and are available for subsequent batches.
    <e>
      <b>CheckForSticky()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
      
  
<ref id="IsCurrentObjVariable"  >  
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCompare in rrunner.
    <e>
      <b>rrCompare("@F.Sticky","No")</b><br/>
      SkipChildren()
    </e>
  </h>
</ref>
  
<ref id="IsChildFieldBlank"  >
  <ap>
    The name of a child field of the current object.
  </ap>
  <h>
    Searches for a child field that matches the provided parameter.  If it matches and if the text value
    is empty, then this action returns true, causing the next action in the ruleset to run.
    <e>
      <b>IsChildFieldBlank("Qty")</b>
    </e>
  </h>
  <lvl>
    Field Level.
  </lvl>
  <ret>
    <b>True,</b> if the child field is located and if it has an empty text field.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="SetStickyNo"  >
  <ap>None.</ap>
  <h>
    This action sets the 'Sticky' indicator to 'No', indicating that there are no sticky fingerprints.
    Sticky fingerprints are a way of identifying a page within a single verify session, when another
    form of the same type appears after a previous form had just been zoned.
    <e>
      IsCurrentObjVariable("Sticky,Yes")<br/>
      <b>SetStickyNo()</b>
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="ClearErrorMsg"  >
  <ap>None.</ap>
  <h>
    This action clears the current error message.
    <e>
      Status_Preserve_OFF()<br/>
      <b>ClearErrorMsg()</b><br/>
      CaptureOpInfo()<br/>
      rrCompare("@P\Routing_Instructions","None")
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
 
<ref id="AddToErrorMsg"  >
  <ap>
    The error message text.
  </ap>
  <h>
    Appends the suplied text to any existing error message string.
    <e>
      <b>AddToErrorMsg("Vendor Number cannot be blank.")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>
  
<ref id="AddToDetailErrorMsg"  >  
  <ap>
    The error message text.
  </ap>
  <h>
    Appends additional text to the existing error message.
    <e>
      <b>AddToDetailErrorMsg("Description cannot be blank.")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>
  
<ref id="IsStationIDSuffix"  >
  <ap>
    The expected Station ID suffix.
  </ap>
  <h>
    This action will test the current station ID.  It checks that the specified parameter matches the right most portion of
    the station ID.  This can be useful if you have stations with different sufixes and you want to control
    actions based on the station name.
    <e>
      <b>IsStationIDSuffix("-Test")</b><br/>
      CloseConnection()<br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/><br/>
      
      In this example, If the station name is "Validate-Test", the action will
      return true and continue executing the following actions.
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>False,</b> if the suffix is longer than the current Station ID or if the
    specified suffix does not match the Station ID.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="OpenConnection"  >
  <h>
    This action should not be used, as it is scheduled to be removed in future versions.
    It has been replaced by OpenConnection in Lookup.rrx.
  </h>
</ref>
  
<ref id="ExecuteSQLBind"  >
  <h>
    This action should not be used, as it is scheduled to be removed in future versions.    
  </h>
</ref>
  
<ref id="Is_JobName"  >
  <ap>
    The name of the job name you expect for the current job.
  </ap>
  <h>
    This action will compare the provided job name with the name of the currently running job.  This can
    be useful, if you wish to perform actions based on different job names.  The comparison is case sensitive.
    <e>
      <b>Is_JobName("Demo-Multipage TIFF")</b><br/>
      PageIDByVariableChange("ScanSrcPath,Main_Page,Trailing_Page")
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>True,</b> if the current job matches the provided name.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="Is_JobNamePrefix"  >
  <ap>
    The prefix you are expecting for the current job.
  </ap>
  <h>
    Tests the left most portion of the job name to see if it matches the provided prefix.  The comparison
    is case sensitive.
    <e>     
      <b>Is_JobNamePrefix("Test")</b><br/><br/>
      
      If the current job name is "TestRecognition", the action will return True.
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>True,</b> if the left most portion matches.  Otherwise, False.
  </ret>
</ref>
  
<ref id="SaveObjectVariable"  >  
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrSet in rrunner.
    <e>
      rrSet("Normal","@P.RecogType")<br/>
      Is_JobName("Demo-Dot Matrix") <br/>     
      rrSet("s_fg","7")<br/>
      rrSet("s_ml","3")<br/>
      rrSet("Dot_Matrix","@P.RecogType")<br/>
      rrCompare("Normal","@P.RecogType")
    </e>
  </h>
</ref>
  
<ref id="ReadFPXMLZones"  >
  <ap>
    Comma separated parameters:<br/>
    1. The fingerprint directory.  Smart parameters are supported.<br/>
    2. A comma separated list of the detail lines.
  </ap>  
  <h>
    This action reads the zones from the FPXML into the objects for the page and stores the specified 
    fileds so that when it creates detail lines it knows the positions of the detail line's fields.
    <e>
      <b>ReadFPXMLZones("@APPPATH(fingerprint),details,lineid,itemdesc,qty,price,linetotal")</b><br/>
      rrSet("FPXML","@P.ZoneRead")<br/>
      IsMultipageDocument()<br/>
      SetEOL("|")
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level or if the FPXML does not exist.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="FPXMLUsed"  >
  <ap>None.</ap>
  <h>
    This action indicates if FPXML format fingerprint files are being used.  Call this action if you are
    using fingerprints from FPXML with Invoice.rrx.    
    <e>
      <b>FPXMLUsed()</b><br/>
      ZoneBOTTOM_ImageBottom()<br/>
      ScanDetails()
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if a FPXML fingerprint file exist for the current page object.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="SwitchMMDD"  qi="">
  <ap>
    A list of separators.
  </ap>
  <h>
    This action is intended to switch US Month and Day date values.  It will swap the first two characters
    of the field value with the two characters following the separator.
    <e>
      <b>SwitchMMDD("/")</b><br/><br/>
      
      In this example, the value "03/09/10" becomes "09/03/10".
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True,</b> if two separators are found and the separators are swapped.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="ValidateVendor"  >
  <ap>
    The connection string to the lookup database.  Smart Parameters are supported.
  </ap>
  <h>
    Checks to see if the current vendor, vendor number and zip code exist on the same record in the lookup database.
    The fields that are validated are: Vendor, Vendor_Number and Remittance_Zip.
    <e>
      SetIsOverrideable("False")<br/>
      <b>ValidateVendor("@APPVAR(*/lookupdb:cs)")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if the connection cannot be opened or if the settings file cannot be found.<br/>
    <b>False,</b> if these fields cannot be found: Vendor, Vendor_Number or Remittance_Zip.<br/>
    <b>False,</b> if the vendor cannot be found in the database.<br/>
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="FindExportImage"  >
  <ap>
    One of the following values:<br/> 
    1. Document Level TIFF.<br/>
    2. Document Level PDF.<br/>
    3. Page Level TIO.<br/>
    4. Page Level TIF.
  </ap>
  <h>
    This action searches the batch directory for a file that corresponds to the current page that contains the current
    field.  The file extension must match the extension specified with the input parameter.
    <e>
      <b>FindExportImage("1")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level or if the input parameter is invalid.
    <b>True,</b> if the correctly named file of with the specified extension exists in the batch directory.
  </ret>
</ref>
  
<ref id="SwapImages"  >
  <ap>
    Two extensions:<br/>
    1. The extension to be saved as TIF.<br/>
    2. The extension that current tif is saved as.
  </ap>
  <h>
    This action interchanges the TIF for the current page with another TIF that has the same file name but
    a different extension.  One possible use is if you had a backup of the TIF and need to restore it.
    The current TIF will be named with the new extension while the other named TIF, is renamed to have a TIF extension.
    <e>
      <b>SwapImages("TIO,TIB")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if the wrong number of parameters are specified,
    or if the original file cannot be found.
    <b>True,</b> if the file extensions are interchanged.
  </ret>
</ref>
  
<ref id="AlterDatebyDay"  >
  <ap>
    The number of days to add.
  </ap>
  <h>
    This action will add the specified number of days to the date contained in the current field.  The original character
    confidence is not changed.  
    <e>
      <b>AlterDatebyDay("7")</b><br/><br/>

      This example adds one week to the date contained in the field.  If the date crosses
      over a month or year boundary, they will be adjusted appropriately.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level or if the input is not numeric.  Otherwise, <b>True.</b>
  </ret>
</ref>
    
<ref id="SetToDocIDMPTIFF"  >
  <ap>
    The path to the exported tiff files.
  </ap>
  <h>
    This action builds a full path to the a tiff file and sets the field text to this value. 
    The path consists of the export path + DOCID + .TIF.
    The value is put into the field
    so it can be access later in the application, if necessary.  It only builds the path.
    The action does not output the TIF file.
    <e>
      <b>SetToDocIDMPTIFF("@APPPATH(export)")</b>
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="CheckFreeDiskSpace"  >
  <ap>
    Two comma separated parameters:<br/>
    1. The path to ini file that contains the 'LowDiskSpaceThreshold' setting.<br/>
    2. The letter drive of the drive to check (letter drive must be accompanied by a colon, i.e C:).    
  </ap>
  <h>
    Reads the 'LowDiskSpaceThreshold' setting from the [Notifications] section of the ini file specified in the first parameter.  If the
    available disk space is lower than the value specified in the INI file, then a notification will be created in the INI file. The notification is created under the [Notifications] section of the ini file, under the "LowDiskNotificationSent" setting. This setting will be set to "Yes".
    If the 'LowDiskSpaceThreashold' is missing from the INI file, the default value of 3000 bytes will be used.
    If a notification has been previously created, and the disk space has been increased since the last time the action ran, then the notification will be removed from the ini file (LowDiskNotificationSent will be set to "No")
    <e>
      <b>CheckFreeDiskSpace("C:\Datacap\APT\dco_APT\settings.ini,C:")</b><br/><br/>
      Scan()<br/>
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if parameters are missing or if the settings.ini file cannot be found.
    Otherwise, <b>True.</b>
  </ret>
</ref>
     
  
<ref id="CheckAndFixDecimal"  >
  <ap>None.</ap>
  <h>
    Replaces the space or , with .
    This can be used to fix errors where the decimal is not recognized and leaves a blank in that area, 
    also this can be used for conversion for European numbers that use a comma to separate dollars from cents
    so $100,00 becomes $100.00 or $100 00 becomes $100.00.
    <e>
      CheckAndFixDecimal()<br/>
      Is_InCharSet("0123456789.,-$")<br/>
      AllowOnlyChars("0123456789.-")<br/>
      IsFieldCurrency()
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="MovePDF"  >
  <ap>
    The target directory for the PDF.  Smart Parameters are supported.
  </ap>
  <h>
    This action copies the PDF associated with the current DCO document to the specified directory. The PDF document name must match the name/ID of the current DCO document for the copy to take place.
    <e>
      <b>MovePDF("@APPPATH(export)")</b>
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False,</b> if the document cannot be found, if the source file does not exist or if the target file does exist.
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="AllMixedCase"  >
  <ap>None.</ap>
  <h>
    This action will change the value of the current field to be Title case.  The first letter of
    each word will be capitalized.
    <e>
      <b>AllMixedCase()</b><br/><br/>
      
      If the field in this example is "hello, i MUST be going.", the text will be changed to "Hello, I Must Be Going."
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="CaptureOpInfo"  >
  <ap>
    An optional prefix to the variable name.
  </ap>
  <h>
    This action will capture the Operator, Station ID and current time and place them into variables.  The variables will be
    named based on the provided variable prefix, like this: "prefix Operator", "prefix Station" and "prefix Time". If a prefix is not provided, the task name is used as the prefix by default.
    <e>
      Status_Preserve_OFF()<br/>
      ClearErrorMsg()<br/>
      <b>CaptureOpInfo("Production")</b><br/>
      rrCompare("@P\Routing_Instructions","None")<br/><br/>
      
      In this example, the variables created will be "Production Operator", "Production Station" and "Production Time".
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="GenerateDetails"  >
  <ap>None.</ap>
  <h>
    This action sets up a field in APT and puts a detail subfield on every page.  This extra detail subfield
    appears on all pages of a multi-page invoice, allowing every page to be viewed.    
    <e>
      <b>GenerateDetails()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False,</b> if called on the wrong level.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="IsCurrentObjValue"  >
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCompare in rrunner.<br/>
    Use the @VALUE parameter to access the 'Text' variable of the current object and provide the comparison text string.
    <e>
      <b>rrCompare("@VALUE","Yes")</b><br/>  
      SetPageStatus("75")<br/>
      SetDocStatus("128")
    </e>
  </h>
</ref>
  
<ref id="IncrementBatchVar"  >
  <ap>
    The name of the variable to increment.
  </ap>
  <h>
    This action increments a batch level variable by 1.  If the variable does not already exist, it will be created.
    If the variable exists but the value is not numeric, the variable will be set to 1.
    <e>
      <b>rrCompareNot("@P.RecogStatus","1")</b><br/>
      SetDocStatus("128")<br/>
      IncrementBatchVar("Recog - Deleted Document")
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="SendOutlookNotification"  >
  <ap>
    The extension of the attachment.  The attachment is expected to be named the same as the current document ID.
  </ap>
  <h>
    This action uses outlook to send a notification to specified e-mail addresses.  The message within the email
    is determined by previous calls to actions that have set notification, such as CheckFreeDiskSpace.<br/><br/>
    
    Note that this action has some requirements such as Outlook installed on the machine and logged
    in with an ID that has appropriate permissions to send emails.
    <e>
      <b>SendOutlookNotification(".pdf")</b>
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if the connection to Outlook could not be established,
    or if email addresses could not be found in Settings.ini.
  </ret>
  <see>
    CheckFreeDiskSpace
  </see>
</ref>
  
<ref id="UpdateFPStats"  >
  <ap>None.</ap>
  <h>
    This action updates the fingerprint statistics in the fingerprint database.    
    It keeps track of the last accessed fingerprint and the number of times a fingerprint is accessed.
    <e>
      <b>UpdateFPStats()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level or if the fingerprint does not exist.
    Otherwise, <b>True.</b>
  </ret>
</ref></help>


</rrx>
<rrx namespace="IOverlay" src="c:\datacap\RRS\IOverlay.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="Overlay" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Combines the current image with the image file specified by the SetBackgroundImage action into ]]>
<![CDATA[
]]>
<![CDATA[  'a new image replacing the current image.  This action is used to reinstate a form background ]]>
<![CDATA[
]]>
<![CDATA[  'that was 'dropped out' during scanning.]]>
<![CDATA[
]]>
<![CDATA[  ' Note: The parameter of the preceding <b>SetBackgroundImage</b>action can be a smart parameter that]]>
<![CDATA[
]]>
<![CDATA[  '  locates a <b>paths.ini</b>file in the same folder that contains the application's Document Hierarchy file.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim sOverlay]]>
<![CDATA[
]]>
<![CDATA[  Dim X, Y, rtn]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Overlay = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then ]]>
<![CDATA[
]]>
<![CDATA[     'CurrentObj must be a dco page]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Overlay: object is not a page.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Look for field 'Image_Offset']]>
<![CDATA[
]]>
<![CDATA[  writelog("Looking for Image_Offset field.")]]>
<![CDATA[
]]>
<![CDATA[	Set fldImgOvr = CurrentObj.FindChild( "Image_Offset" )]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'If Image_Offset field is not found look for field 'IMAGEOVERLAYOFFSET']]>
<![CDATA[
]]>
<![CDATA[  If (fldImgOvr Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[     writelog("Looking for IMAGEOVERLAYOFFSET field.") ]]>
<![CDATA[
]]>
<![CDATA[     Set fldImgOvr = CurrentObj.FindChild("IMAGEOVERLAYOFFSET")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Check that one of the fields was returned]]>
<![CDATA[
]]>
<![CDATA[	If (fldImgOvr Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Couldn't find the image offset field...")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Image to Overlay:'" & CurrentObj.ImageName & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rtn = -1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Get the value and filter for spaces and semi-colon (autofld.dll puts a semi-colon at the end of the field value)]]>
<![CDATA[
]]>
<![CDATA[  sOverlay = Trim(fldImgOvr.Text)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If (sOverlay = "") or (sOverlay = ";") Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Looking for Image_Offset page variable")]]>
<![CDATA[
]]>
<![CDATA[    sOverlay = CurrentObj.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sOverlay = Trim(Replace(sOverlay,";",""))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If (sOverlay <> "") Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Overlay field value:" & sOverlay)]]>
<![CDATA[
]]>
<![CDATA[			aXY = Split(sOverlay, ",")]]>
<![CDATA[
]]>
<![CDATA[			X = CLng(aXY(0))]]>
<![CDATA[
]]>
<![CDATA[			Y = CLng(aXY(1)) ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("X: " & X & "; Y: " & Y)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[			rtn = g_oImageOverlay.Overlay(CurrentObj.ImageName, X, Y) ]]>
<![CDATA[
]]>
<![CDATA[			CatchOverlayError("")]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("no overlay offset info found.")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If(rtn = 0) Then ]]>
<![CDATA[
]]>
<![CDATA[			If X < 0 Then X = 0]]>
<![CDATA[
]]>
<![CDATA[			If Y < 0 Then Y = 0]]>
<![CDATA[
]]>
<![CDATA[			Call ov_ZoneChildren(CurrentObj, 0, X, Y)]]>
<![CDATA[
]]>
<![CDATA[			Overlay = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetBackgroundImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Designates the Image file that will overlay the current page's image."]]>
<![CDATA[
]]>
<![CDATA[  'Full path to the overlay Image file.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetBackgroundImage = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    strParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Check for valid path from parameter]]>
<![CDATA[
]]>
<![CDATA[  If IsAlive(FileMgr) Then]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    If Not FileMgr.FileExists(strParam) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("File not found:'" & strParam & "'")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("File '" & strParam & "' exists.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  g_oImageOverlay.BackgroundImage = StrParam]]>
<![CDATA[
]]>
<![CDATA[	CatchOverlayError("")]]>
<![CDATA[
]]>
<![CDATA[	SetBackgroundImage = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="SetHaloBackground" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Enables or disables a halo of white pixels around any black pixels from the current ]]>
<![CDATA[
]]>
<![CDATA[  'image where they would otherwise touch pixels from the background. This makes the foreground information easier to read."]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value to enable a halo ("<b>True</b>") or prevent a halo ("<b>False</b>").</ap>	]]>
<![CDATA[
]]>
<![CDATA[	'<h>Enables or disables a halo of white pixels around any black pixels from the current image ]]>
<![CDATA[
]]>
<![CDATA[  ' where they would otherwise touch pixels from the background.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetHaloBackgroung = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If (StrParam = "true") Then]]>
<![CDATA[
]]>
<![CDATA[		g_oImageOverlay.HaloBackground = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		g_oImageOverlay.HaloBackground = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	SetHaloBackground = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="SetDitheringBackground" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value to enable dithering ("<b>True</b>") or disable dithering ("<b>False</b>").</ap>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetDitheringBackground= False]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If (StrParam = "true") Then]]>
<![CDATA[
]]>
<![CDATA[		g_oImageOverlay.DitheringBackground = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		g_oImageOverlay.DitheringBackground = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	SetDitheringBackground= True]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' IOverlay.rrx - Image Overlay Actions
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'************************************************************************
]]>

<ref id="Overlay" access="public" bInter="bInter" bDebug="bDebug" qi="Combines the current image with the image file specified by the SetBackgroundImage action into a new image replacing the current image.  This action is used to reinstate a form background that was 'dropped out' during scanning.">
	<ap>None.<br/>
    <br/>
    <b>Note:</b>The parameter of the preceding <b>SetBackgroundImage</b>action can be a smart parameter that
    locates a <b>paths.ini</b>file in the same folder that contains the application's Document Hierarchy file.
    <br/><br/>
    In such a case, the <b>SetBackgroundImage</b>action will locate the Background Image file (.tif) with 
    a setting similar to this:<br/><br/>   
    [Paths]<br/>   BlankForm=..\Images\blank.tif
  </ap>
	<h>
    <e>
      SetBackgroundImage(c:\ParentDir\mclaims\process\hcfa\hcfa.tif)<br/>
      <b>Overlay()</b><br/><br/>
      
      In this example, the <b>Overlay</b>action uses the file name and path in the parameter of 
      the <b>SetBackgroundImage</b>action to locate the Background Image file.
      
      SetBackgroundImage((@PATH(BlankForm))<br/>
      <b>Overlay(</b>)<br/><br/>
      
      Here, the <b>SetBackgroundImage</b>action's smart parameter solicits information from 
      a <b>paths.ini</b>file in the application's <b>process</b>directory. A setting in this 
      file locates the Background Image file.

	    <b><i>Alert!</i></b><b>SetBackgroundImage</b>must be called before <b>Overlay</b>. Other actions 
      such as <b>SetHaloBackground</b>and <b>SetDithering</b>are optional and, if used, should precede 
      the call to the <b>Overlay</b>action.
		</e>
	</h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the action is not applied to a <b>Page</b>object; if it cannot locate
    the Background Image file; or if the action encounters an error of a different kind.
    Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="SetBackgroundImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Designates the Image file that will overlay the current page's image.">
	<ap>Full path to the overlay Image file.</ap>
	<h>Designates the Image file that will overlay the current page's image.
		<e><b>SetBackgroundImage(c:\ParentDir\mclaims\process\hcfa\hcfat.tif)</b><br/>
		<scr>SetDitheringBackground(True)</scr><br/>
		<scr>SetHaloBackground(True)</scr><br/>
		<scr>Overlay()</scr> 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if image does not exist, otherwise <b>True.</b>
  </ret>

</ref>
	
<ref id="SetHaloBackground" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Enables or disables a halo of white pixels around any black pixels from the current image where they would otherwise touch pixels from the background. This makes the foreground information easier to read.">
	<ap>String value to enable a halo ("<b>True</b>") or prevent a halo ("<b>False</b>").</ap>	
	<h>Enables or disables a halo of white pixels around any black pixels from the current image 
   where they would otherwise touch pixels from the background.<br/><br/>

	This makes the foreground information easier to read.
		<e><scr>SetBackgroundImage(c:\ParentDir\mclaims\process\hcfa\hcfat.tif)</scr><br/>
      <scr>SetDitheringBackground(True)</scr><br/>
      <b>SetHaloBackground(True)</b><br/>
      <scr>Overlay()</scr> 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
	
<ref id="SetDitheringBackground" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<ap>String value to enable dithering ("<b>True</b>") or disable dithering ("<b>False</b>").</ap>
	<lvl>All.</lvl>
	<ret>Always <b>True.</b></ret>
	<h>Enables or disables dithering of the background image.<br/><br/>

     Dithering will make the background image appear lighter than the current image's information so that 
     visually it appears less prominent. 
     <e><scr>SetBackgroundImage(c:\ParentDir\mclaims\process\hcfa\hcfat.tif)</scr><br/>
       <b>SetDitheringBackground(True)</b><br/>
       <scr>SetHaloBackground(True)</scr><br/>
       <scr>Overlay()</scr> 
     </e>
	</h>
</ref>
</help>
</rrx>
<rrx namespace="Locate" src="c:\datacap\RRS\Locate.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<g>
</g>
<f name="AddKeyList" access="public">
	<p name="KeyName">
	</p>
	<p name="KeyWord_01">
	</p>
	<p name="KeyWord_02">
	</p>
	<p name="KeyWord_03">
	</p>
	<p name="KeyWord_04">
	</p>
	<p name="KeyWord_05">
	</p>
	<p name="KeyWord_06">
	</p>
	<p name="KeyWord_07">
	</p>
	<p name="KeyWord_08">
	</p>
	<p name="KeyWord_09">
	</p>
	<p name="KeyWord_10">
	</p>
	<p name="KeyWord_11">
	</p>
	<p name="KeyWord_12">
	</p>
	<p name="KeyWord_13">
	</p>
	<p name="KeyWord_14">
	</p>
	<p name="KeyWord_15">
	</p>
	<p name="KeyWord_16">
	</p>
	<p name="KeyWord_17">
	</p>
	<p name="KeyWord_18">
	</p>
	<p name="KeyWord_19">
	</p>
	<p name="KeyWord_20">
	</p>
	<p name="KeyWord_21">
	</p>
	<p name="KeyWord_22">
	</p>
	<p name="KeyWord_23">
	</p>
	<p name="KeyWord_24">
	</p>
	<p name="KeyWord_25">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ' Adds list to dictionary ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    Dim sExtn]]>
<![CDATA[
]]>
<![CDATA[    Dim nExtnPos]]>
<![CDATA[
]]>
<![CDATA[    Dim sKeyNameExtn]]>
<![CDATA[
]]>
<![CDATA[    Dim sListTest]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    AddKeyList=TRUE    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    sExtn = ".key"]]>
<![CDATA[
]]>
<![CDATA[    nExtnPos = InStrRev(KeyName,sExtn,vbTextCompare)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Add the '.key' extension for file i/o compatibility]]>
<![CDATA[
]]>
<![CDATA[    If nExtnPos>5 or nExtnPos<=0 then sKeyNameExtn = KeyName & sExtn]]>
<![CDATA[
]]>
<![CDATA[ 		    ]]>
<![CDATA[
]]>
<![CDATA[    If dictKEYFILES.Exists(KeyName) or dictKEYFILES.Exists(KeyNameExtn) then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Key '" & KeyName & "' already exists in Dictionary. Returning True.")   ]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    sList = KeyWord_01 & vbcrlf & KeyWord_02 & vbcrlf & KeyWord_03 & vbcrlf & KeyWord_04 & vbcrlf & KeyWord_05 & vbcrlf & _ ]]>
<![CDATA[
]]>
<![CDATA[            KeyWord_06 & vbcrlf & KeyWord_07 & vbcrlf & KeyWord_08 & vbcrlf & KeyWord_09 & vbcrlf & KeyWord_10 & vbcrlf & _]]>
<![CDATA[
]]>
<![CDATA[            KeyWord_11 & vbcrlf & KeyWord_12 & vbcrlf & KeyWord_13 & vbcrlf & KeyWord_14 & vbcrlf & KeyWord_15 & vbcrlf & _]]>
<![CDATA[
]]>
<![CDATA[            KeyWord_16 & vbcrlf & KeyWord_17 & vbcrlf & KeyWord_18 & vbcrlf & KeyWord_19 & vbcrlf & KeyWord_20 & vbcrlf & _]]>
<![CDATA[
]]>
<![CDATA[            KeyWord_21 & vbcrlf & KeyWord_22 & vbcrlf & KeyWord_23 & vbcrlf & KeyWord_24 & vbcrlf & KeyWord_25 & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    sListTest = sList]]>
<![CDATA[
]]>
<![CDATA[    sListTest = replace(sListTest,vbcrlf,"")]]>
<![CDATA[
]]>
<![CDATA[    sListTest = replace(sListTest,Space(1),"")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If len(sListTest)=0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Empty List '" & KeyName & "' not added to Key List dictionary. Returning False.")]]>
<![CDATA[
]]>
<![CDATA[      AddKeyList=False]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Call dictKEYFILES.Add(sKeyNameExtn, sList)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Added " & KeyName & " file to Key List dictionary.")]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<af name="WordFind" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   A word or phrase to find on the page.]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '   The current page be searched to find the word or phrase.  The location of the first]]>
<![CDATA[
]]>
<![CDATA[ '   word or phrase that matches the parameter will be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA[ '   utilized by subsequent actions.  Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[ '   To improve matching,]]>
<![CDATA[
]]>
<![CDATA[ '   this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA[ '   common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA[ '   "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA[ '   Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  WordFind=False]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[  WordFind = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function WordFind")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="WordFind_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'A word or phrase to find in the current zoned field.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  The current field will be searched to find the word or phrase.  The location of the first]]>
<![CDATA[
]]>
<![CDATA[  '  word or phrase that matches the parameter will be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA[  '  utilized by subsequent actions.  Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[ '   To improve matching,]]>
<![CDATA[
]]>
<![CDATA[ '   this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA[ '   common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA[ '   "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA[ '   Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WordFind_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	WordFind_InZone = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function WordFind_InZone")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="WordFindNext" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'A word or phrase to find on the page, following a previously found word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  The current page will be searched to find the word or phrase, starting from the location]]>
<![CDATA[
]]>
<![CDATA[  '  remembered from the last search, such as from WordFind.  The location of the first]]>
<![CDATA[
]]>
<![CDATA[  '  word or phrase that matches the parameter will now be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA[  '  utilized by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[  '  Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' To improve matching,]]>
<![CDATA[
]]>
<![CDATA[   ' this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA[   ' common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA[   ' "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA[   ' Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		WordFindNext=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    	If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[	    	Exit Function]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[		L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[		T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[		B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[		WordFindNext = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function WordFindNext")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="WordFindNext_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'A word or phrase to find in the current field, following a previously found word.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  The current field will be searched to find the word or phrase, starting from the]]>
<![CDATA[
]]>
<![CDATA[  '  remembered location of a previous find.  The new location of the first]]>
<![CDATA[
]]>
<![CDATA[  '  word or phrase in the field that matches the parameter will now be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA[  '  utilized by subsequent actions.    ]]>
<![CDATA[
]]>
<![CDATA[  '  Word matching is case sensitive.']]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    To improve matching,]]>
<![CDATA[
]]>
<![CDATA['    this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA['    common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA['    "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA['    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	WordFindNext_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	WordFindNext_InZone = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function WordFindNext_InZone")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="RegExFind" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  A word or phrase to find on the current page.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[  '  a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Locates the first occurrence of a word or phrase on the current page where the input search term]]>
<![CDATA[
]]>
<![CDATA[  '  is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is started from the first word the current page.  The location of the ]]>
<![CDATA[
]]>
<![CDATA[  '  found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim strKey]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  RegExFind=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'StrParam is a built Regular expression]]>
<![CDATA[
]]>
<![CDATA[  strKey = StrParam]]>
<![CDATA[
]]>
<![CDATA[  RegExFind = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function RegExFind")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="RegExFind_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ '   A word or phrase to find in the current field.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[ '   a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '  Locates the first occurrence of a word or phrase in the current field where the input search term]]>
<![CDATA[
]]>
<![CDATA[ '   is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is started from the first word of the current field.  The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	RegExFind_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = StrParam]]>
<![CDATA[
]]>
<![CDATA[	RegExFind_InZone = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function RegExFind_InZone")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="RegExFindNext" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  A word or phrase to find on the current page.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[  '  a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Starting from the location of a previously found word, this action locates the first]]>
<![CDATA[
]]>
<![CDATA[  '  occurrence of a word or phrase on the current page where the input search term]]>
<![CDATA[
]]>
<![CDATA[  '  is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is started from the location of a previously found word.  The location of the]]>
<![CDATA[
]]>
<![CDATA[  '  found word or phrase will now be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		RegExFindNext=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[        If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    		Exit Function]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[		L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[		T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[		B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'StrParam is a built Regular expression]]>
<![CDATA[
]]>
<![CDATA[		strKey = StrParam]]>
<![CDATA[
]]>
<![CDATA[		RegExFindNext = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function RegExFindNext")]]>
<![CDATA[
]]>
<![CDATA[			 ]]>
	</g>
</af>
<af name="RegExFindNext_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ '   A word or phrase to find in the current field.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[ '   a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   Starting from the location of a previously found word, this action locates the first]]>
<![CDATA[
]]>
<![CDATA[ '   occurrence of a word or phrase in the current field where the input search term]]>
<![CDATA[
]]>
<![CDATA[ '   is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is started from the location of a previously found word in the current field.  The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	RegExFindNext_InZone=False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = StrParam]]>
<![CDATA[
]]>
<![CDATA[	RegExFindNext_InZone = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function RegExFindNext_InZone")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="FindKeyList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA[ '   separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in ]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[ '   Opens the Keyword file you specify as a parameter, then checks the]]>
<![CDATA[
]]>
<![CDATA[ '   words on the current page against the keywords in the list to find a match.  The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase that matches an entry in the keyword file ]]>
<![CDATA[
]]>
<![CDATA[ '   will be remembered so the result can be used by subsequent actions.    ]]>
<![CDATA[
]]>
<![CDATA[ '   Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   To improve matching, ]]>
<![CDATA[
]]>
<![CDATA[ '   this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA[ '   common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA[ '   "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA[ '   Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindKeyList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="FindKeyList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Keyword text file.  The file will contain a list of words or phrases, ]]>
<![CDATA[
]]>
<![CDATA[ '   separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   Opens the Keyword file you specify as a parameter, then checks the]]>
<![CDATA[
]]>
<![CDATA[ '   words in the current field of the source page's .cco file against the keywords]]>
<![CDATA[
]]>
<![CDATA[ '   in the key file list to find a match.  The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase that matches an entry in the keyword file]]>
<![CDATA[
]]>
<![CDATA[ '   will be remembered so the result can be used by subsequent actions.    ]]>
<![CDATA[
]]>
<![CDATA[ '   Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindKeyList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindKeyList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextKeyList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  '  The name of the Keyword text file.  The file will contain a list of words, separated by new lines,]]>
<![CDATA[
]]>
<![CDATA[  '  that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextKeyList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextKeyList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="FindNextKeyList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Keyword text file.  The file will contain a list of words, separated by new lines,]]>
<![CDATA[
]]>
<![CDATA[ '   that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextKeyList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextKeyList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindDBList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[' An SQL statement whose result returns a word or phrase, or a list of word or phrases.    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindDBList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = GetDBKeyList(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindDBList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindDBList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['    An SQL statment whose result returns a word or phrase, or a list of word or phrases.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA['    This action issues an SQL query against the lookup database, returning a list]]>
<![CDATA[
]]>
<![CDATA['    of words or phrases that will be located in the current field.  The search is performed]]>
<![CDATA[
]]>
<![CDATA['    from the first word of the current field.  Initially, the first listed word or phrase]]>
<![CDATA[
]]>
<![CDATA['    is searched for in the field.  If there is no match, it will search for the next word or]]>
<![CDATA[
]]>
<![CDATA['    phrase returned from the database.  This continues until a match is found or none of the returned words]]>
<![CDATA[
]]>
<![CDATA['    are contained on the page.  The location of the]]>
<![CDATA[
]]>
<![CDATA['    found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA['    The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindDBList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = GetDBKeyList(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[      strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindDBList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextDBList" accessed="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['    An SQL statement whose result returns a word or phrase, or a list of word or phrases.]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['    This action issues an SQL query against the lookup database, returning a list]]>
<![CDATA[
]]>
<![CDATA['    of words or phrases that will be located on the current page.  Starting from the]]>
<![CDATA[
]]>
<![CDATA['    location of a previously found word, the search is performed.]]>
<![CDATA[
]]>
<![CDATA['    Initially, the first listed word or phrase from the SQL query]]>
<![CDATA[
]]>
<![CDATA['    is searched for on the page.  If there is no match, it will search for the next word or]]>
<![CDATA[
]]>
<![CDATA['    phrase returned from the database. This continues until a match is found or none of the returned words]]>
<![CDATA[
]]>
<![CDATA['    are contained on the page.  The location of the]]>
<![CDATA[
]]>
<![CDATA['    found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA['    The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextDBList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = GetDBKeyList(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextDBList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextDBList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   An SQL statement whose result returns a word or phrase, or a list of word or phrases.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextDBList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = GetDBKeyList(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextDBList_InZone = bReturn  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindRegExList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA[ '   separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindRegExList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[    strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then	]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindRegExList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindRegExList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindRegExList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindRegExList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextRegExList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA[ '   separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextRegExList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then	]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextRegExList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextRegExList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['    the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextRegExList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextRegExList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastWord" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   A word or phrase to find on the page.]]>
<![CDATA[
]]>
<![CDATA['   The current page will be searched to find the last occurrence of a word or phrase. ]]>
<![CDATA[
]]>
<![CDATA['   The location of the last]]>
<![CDATA[
]]>
<![CDATA['   word or phrase that matches the parameter will be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA['   utilized by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim strKey]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  FindLastWord=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[    Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[		L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[		T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[		B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Setup CCO position to Last Line & Word]]>
<![CDATA[
]]>
<![CDATA[		Call CCO.SetCurrentPosition(CCO.Count,CCO.Item(CCO.Count).Count, CCO.Count,CCO.Item(CCO.Count).Count)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[		FindLastWord = KeySearch(strKey, sPosition, -1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function FindLastWord")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastWord_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['The target word to locate within the current zone.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    The current field will be searched to find the word or phrase.  The location of the last]]>
<![CDATA[
]]>
<![CDATA['    occurrence of the word or phrase that matches the parameter will be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA['    utilized by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA['    Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	FindLastWord_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   	'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	FindLastWord_InZone = KeySearch(strKey, sPosition, -1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function FindLastWord_InZone")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastKeyList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases, ]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['    the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastKeyList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,-1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, -1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastKeyList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastKeyList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  '  The name of the Keyword text file.  The file will contain a list of words or phrases, ]]>
<![CDATA[
]]>
<![CDATA[  '  separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[  '  1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[  '  2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[  '  the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastKeyList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,-1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, -1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastKeyList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastRegEx" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    A word or phrase to find on the current page.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA['    a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA['    Locates the last occurrence of a word or phrase on the current page where the input search term]]>
<![CDATA[
]]>
<![CDATA['    is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA['    The search is started from the first word of the current page.]]>
<![CDATA[
]]>
<![CDATA['    The location of the]]>
<![CDATA[
]]>
<![CDATA['    found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA['   The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		FindLastRegEx=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[        If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		    Exit Function]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[       	'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[    	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[		L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[		T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[		B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		FindLastRegEx = KeySearch(strParam, sPosition, -1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function RegExFindLast")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastRegEx_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   A word or phrase to find in the current field.  The parameter are expected to be]]>
<![CDATA[
]]>
<![CDATA[ '   a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   Locates the last occurrence of a word or phrase in the current field where the input search term]]>
<![CDATA[
]]>
<![CDATA[ '   is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is started from the first word of the current field.]]>
<![CDATA[
]]>
<![CDATA[ '   The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	FindLastRegEx_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    	Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	FindLastRegEx_InZone = KeySearch(strParam, sPosition, -1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function FindLastRegEx_InZone")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastRegExList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.  The entries in the]]>
<![CDATA[
]]>
<![CDATA['    keyword file are expected to be regular expressions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['    the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastRegExList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,-1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then	]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, -1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastRegExList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastRegExList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.  The entries in the]]>
<![CDATA[
]]>
<![CDATA['    keyword file are expected to be regular expressions.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['    the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastRegExList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,-1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, -1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastRegExList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<g>
</g>
<af name="GoLeftWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of words to move leftwards from the current position.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Moves <var>n</var> words to the left of the current word, in the same line.']]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoLeftWord = False]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToWordH(bInteractive, bDebug, -nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoLeftWord = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoLeftWord") ]]>
	</g>
</af>
<af name="GoRightWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ ' An Integer indicating the number of words to move to the right.  ]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '   Moves <var>n</var> words to the right of the current word, in the same line. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoRightWord = False]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToWordH(bInteractive, bDebug, nSteps) Then		]]>
<![CDATA[
]]>
<![CDATA[		GoRightWord = True]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoRightWord") ]]>
	</g>
</af>
<af name="GoAboveWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' An Integer indicating the number of lines above the current word.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' Moves to a word which is above the current word by <var>n</var> lines.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoAboveWord = False	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToWordV(bInteractive, bDebug, -nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoAboveWord = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoAboveWord") ]]>
	</g>
</af>
<af name="GoBelowWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of lines below the current word.  ]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Moves to a word which is below the current word by <var>n</var> lines.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoBelowWord = False	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToWordV(bInteractive, bDebug, nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoBelowWord = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoBelowWord") ]]>
	</g>
</af>
<af name="GoFirstWord" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['   This action navigates to the first word on the current line. If the page's ]]>
<![CDATA[
]]>
<![CDATA['   Fingerprint file (.cco)  does not have a Line position, the action defaults ]]>
<![CDATA[
]]>
<![CDATA['   to the first line of the current zone - or page, if a zone is not present.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    Dim L1,L2,W1,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[    Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[    Dim arData]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoFirstWord = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Get Current Zone boundry]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("New Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Final Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[    If sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	arData=Split(sPosition, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(arData)]]>
<![CDATA[
]]>
<![CDATA[		If trim(arData(i))="" then]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=CLng(arData(i))]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Start CCO Position lines:" & L1 & "-" & L2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        'If no CCO position then default to 1st line in zone or page if no zone]]>
<![CDATA[
]]>
<![CDATA[    	If L1=0 then]]>
<![CDATA[
]]>
<![CDATA[            Call CCO.LocateLines(arData(1),arData(3),L1,L2)]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Locate Lines " & L1 & "-" & L2)]]>
<![CDATA[
]]>
<![CDATA[            If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	    W1=1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.SetCurrentPosition(L1,W1,L1,W1)]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Position set to Line " & L1 & " Word " & W1)]]>
<![CDATA[
]]>
<![CDATA[        GoFirstWord=True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoFirstWord") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GoLastWord" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' If the source page's Fingerprint file (.cco) does not have a Line position, ]]>
<![CDATA[
]]>
<![CDATA[  '  the action defaults to the first line in the current zone or page, if no zone is present.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim L1,L2,W1,W2]]>
<![CDATA[
]]>
<![CDATA[	  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[    Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[    Dim arData]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoLastWord = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Get Current Zone boundry]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		'Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    arData=Split(sPosition, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(arData)]]>
<![CDATA[
]]>
<![CDATA[		If trim(arData(i))="" then]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=CLng(arData(i))]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        'If no CCO position then default to 1st line in zone or page if no zone]]>
<![CDATA[
]]>
<![CDATA[        If L2=0 then ]]>
<![CDATA[
]]>
<![CDATA[            Call CCO.LocateLines(arData(1),arData(3),L1,L2)]]>
<![CDATA[
]]>
<![CDATA[            If L2=0 then L2=1             ]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	    W2=CCO.Item(L2).Count]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.SetCurrentPosition(L2,W2,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Position set to Line " & L2 & " Word " & W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        GoLastWord =True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoLastWord") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GoFirstLine" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  This action moves to the first line of the current zone, or to the first line ]]>
<![CDATA[
]]>
<![CDATA[  '  of the source page if there is no zone.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim L1,L2,W1,W2]]>
<![CDATA[
]]>
<![CDATA[	  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[    Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[    Dim arData]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoFirstLine = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Get Current Zone boundry]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		'Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	arData=Split(sPosition, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(arData)]]>
<![CDATA[
]]>
<![CDATA[		If trim(arData(i))="" then]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=CLng(arData(i))]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        'If no CCO position then default to 1st line in zone or page if no zone]]>
<![CDATA[
]]>
<![CDATA[    	Call CCO.LocateLines(arData(1),arData(3),L1,L2)]]>
<![CDATA[
]]>
<![CDATA[        If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[        W1=1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.SetCurrentPosition(L1,W1,L1,W1)]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Position set to Line " & L1 & " Word " & W1)]]>
<![CDATA[
]]>
<![CDATA[        GoFirstLine=True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoFirstLine") ]]>
	</g>
</af>
<af name="GoLastLine" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   This action navigates to the last line in the current zone, or to the last ]]>
<![CDATA[
]]>
<![CDATA[ '   line in the current page if a zone is not present.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim L1,L2,W1,W2]]>
<![CDATA[
]]>
<![CDATA[    Dim oParent]]>
<![CDATA[
]]>
<![CDATA[    Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[    Dim arData]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    GoLastLine = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[	  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Get Current Zone boundry]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[      Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[      sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[      'Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[    Wend]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If sPosition="" then ]]>
<![CDATA[
]]>
<![CDATA[      sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    arData=Split(sPosition, ",")]]>
<![CDATA[
]]>
<![CDATA[    For i=0 To UBound(arData)]]>
<![CDATA[
]]>
<![CDATA[      If trim(arData(i))="" then]]>
<![CDATA[
]]>
<![CDATA[        arData(i)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[        arData(i)=CLng(arData(i))]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        'If no CCO position then default to 1st line in zone; page if no zone]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.LocateLines(arData(1),arData(3),L1,L2)]]>
<![CDATA[
]]>
<![CDATA[        If L2=0 then L2=1             ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        'If no position info for bottom position use last line]]>
<![CDATA[
]]>
<![CDATA[        If arData(3)=0 then L2=CCO.Count]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[	      W2=CCO.Item(L2).Count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.SetCurrentPosition(L2,W2,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Position set to Line " & L2 & " Word " & W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        GoLastLine =True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoLastLine") ]]>
	</g>
</af>
<af name="GoDownLine" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' An Integer indicating the number of lines below the current line.  ]]>
<![CDATA[
]]>
<![CDATA[   ' Moves to the first word of a line that is <var>n</var> lines below the current line. ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	GoDownLine = False	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToLine(bInteractive, bDebug, nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoDownLine = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoDownLine") ]]>
	</g>
</af>
<af name="GoUpLine" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'An Integer indicating the number of lines above the current line.  ]]>
<![CDATA[
]]>
<![CDATA[  '   Moves to the first word of a line that is <var>n</var> lines above the current line.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoUpLine = False	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToLine(bInteractive, bDebug, -nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoUpLine = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoUpLine") ]]>
	</g>
</af>
<af name="UpdateField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['    Updates the appropriate field in the current page's Data file with the recognized ]]>
<![CDATA[
]]>
<![CDATA['    (and possibly formatted!) value of the located word.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim v_left,v_top,v_right,v_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v1_left,v1_top,v1_right,v1_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v2_left,v2_top,v2_right,v2_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue, sConfidence]]>
<![CDATA[
]]>
<![CDATA[	Dim Wx,Lx,Cx]]>
<![CDATA[
]]>
<![CDATA[	Dim Cleft ,Ctop ,Cright ,Cbottom]]>
<![CDATA[
]]>
<![CDATA[	Dim sEOL,n]]>
<![CDATA[
]]>
<![CDATA[	Dim Wxstart,Wxend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	UpdateField=False]]>
<![CDATA[
]]>
<![CDATA[	sEOL=Space(1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("CCO Position:" & L1 & "," & W1 & "," & L2 & "," & W2)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If L1=0 and W1=0 then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Position information found. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'First Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v1_left = CCO.Item(L1).Item(W1).Left]]>
<![CDATA[
]]>
<![CDATA[	v1_top = CCO.Item(L1).Item(W1).Top]]>
<![CDATA[
]]>
<![CDATA[	v1_right = CCO.Item(L1).Item(W1).Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = CCO.Item(L1).Item(W1).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Last Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v2_left = CCO.Item(L2).Item(W2).Left]]>
<![CDATA[
]]>
<![CDATA[	v2_top = CCO.Item(L2).Item(W2).Top]]>
<![CDATA[
]]>
<![CDATA[	v2_right = CCO.Item(L2).Item(W2).Right]]>
<![CDATA[
]]>
<![CDATA[	v2_bottom = CCO.Item(L2).Item(W2).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Merge Positions]]>
<![CDATA[
]]>
<![CDATA[	If v2_left < v1_left then v1_left = v2_left]]>
<![CDATA[
]]>
<![CDATA[	If v2_top < v1_top then v1_top = v2_top]]>
<![CDATA[
]]>
<![CDATA[	If v2_right > v1_right then v1_right = v2_right]]>
<![CDATA[
]]>
<![CDATA[	If v2_bottom > v1_bottom then v1_bottom = v2_bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CheckMCCOImageReference(CurrentObj,L1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Expand Zone for viewability - check image border boundries]]>
<![CDATA[
]]>
<![CDATA[	v1_left = v1_left-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_left<0 then v1_left=0]]>
<![CDATA[
]]>
<![CDATA[	v1_top = v1_top-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_top<0 then v1_top=0]]>
<![CDATA[
]]>
<![CDATA[	v1_right = v1_right+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_right>CCO.Right then v1_right=CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = v1_bottom+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_bottom>CCO.bottom then v1_right=CCO.bottom ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(v1_left-2, v1_top-2, v1_right+2, v1_bottom+2)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(L2))=0 then L2=L1]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(W2))=0 then W2=W1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Lx = L1 to L2]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Wxstart=1]]>
<![CDATA[
]]>
<![CDATA[		Wxend=CCO.Item(Lx).Count]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Lx=L1 Then Wxstart=W1]]>
<![CDATA[
]]>
<![CDATA[		If Lx=L2 Then Wxend=W2]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		For Wx = Wxstart to Wxend]]>
<![CDATA[
]]>
<![CDATA[			For Cx = 1 to CCO.Item(Lx).Item(Wx).Count]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				sValue = ASCW(CCO.Item(Lx).Item(Wx).Item(Cx).Value)]]>
<![CDATA[
]]>
<![CDATA[				sConfidence = CCO.Item(Lx).Item(Wx).Item(Cx).confidence]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = CurrentObj.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(sValue), CLng(sConfidence))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				  Cleft = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Left)]]>
<![CDATA[
]]>
<![CDATA[				   Ctop = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Top)]]>
<![CDATA[
]]>
<![CDATA[				 Cright = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Right)]]>
<![CDATA[
]]>
<![CDATA[				Cbottom = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Bottom)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		        bRes = cObj.SetPosition(Cleft ,Ctop ,Cright ,Cbottom)		]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Add Space to DCO Value Between Words]]>
<![CDATA[
]]>
<![CDATA[			If Wx<Wxend then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = CurrentObj.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(32), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		        bRes = cObj.SetPosition(Clng(0) ,Clng(0) ,Clng(0) ,Clng(0))]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Next 'Wx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Add EOL character(s) to DCO Value between Lines]]>
<![CDATA[
]]>
<![CDATA[		If Lx<L2 then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If IsAlive(g_SetEOL) Then sEOL = g_SetEOL]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			For n = 1 to len(sEOL)]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = CurrentObj.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(ASCW(Mid(sEOL,n,1))), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			   bRes = cObj.SetPosition(Clng(0) ,Clng(0) ,Clng(0) ,Clng(0))]]>
<![CDATA[
]]>
<![CDATA[		   ]]>
<![CDATA[
]]>
<![CDATA[		   Next 'n]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Next 'Lx]]>
<![CDATA[
]]>
<![CDATA[     	 ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "UpdateField    Value Found: '" & CurrentObj.Text & "'    Confidence: '" & CurrentObj.ConfidenceString & "' ")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(logwindow) Then]]>
<![CDATA[
]]>
<![CDATA[		Call ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	 	ValueUP.Text = CurrentObj.Text				]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	UpdateField = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function UpdateField")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="UpdateDCOField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   String value of the target field's name, as a <b>Field</b> object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[ '   This action updates the size and position coordinates of the <b>Field</b>object ]]>
<![CDATA[
]]>
<![CDATA[ '   representing the field identified by the parameter. Typically, the action follows ]]>
<![CDATA[
]]>
<![CDATA[ '   earlier actions and events which modify the field's width and height, or its ]]>
<![CDATA[
]]>
<![CDATA[ '   precise placement on the current source page. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[  Dim v_left,v_top,v_right,v_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v1_left,v1_top,v1_right,v1_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v2_left,v2_top,v2_right,v2_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue, sConfidence]]>
<![CDATA[
]]>
<![CDATA[  Dim Wx,Lx,Cx]]>
<![CDATA[
]]>
<![CDATA[  Dim Cleft ,Ctop ,Cright ,Cbottom]]>
<![CDATA[
]]>
<![CDATA[  Dim oField]]>
<![CDATA[
]]>
<![CDATA[  Dim sEOL,n]]>
<![CDATA[
]]>
<![CDATA[  Dim Wxstart,Wxend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	UpdateDCOField=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[  Writelog("CCO Position:" & L1 & "," & W1 & "," & L2 & "," & W2)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If L1=0 and W1=0 then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Position information found. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'First Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v1_left = CCO.Item(L1).Item(W1).Left]]>
<![CDATA[
]]>
<![CDATA[	v1_top = CCO.Item(L1).Item(W1).Top]]>
<![CDATA[
]]>
<![CDATA[	v1_right = CCO.Item(L1).Item(W1).Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = CCO.Item(L1).Item(W1).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Last Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v2_left = CCO.Item(L2).Item(W2).Left]]>
<![CDATA[
]]>
<![CDATA[	v2_top = CCO.Item(L2).Item(W2).Top]]>
<![CDATA[
]]>
<![CDATA[	v2_right = CCO.Item(L2).Item(W2).Right]]>
<![CDATA[
]]>
<![CDATA[	v2_bottom = CCO.Item(L2).Item(W2).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Merge Positions]]>
<![CDATA[
]]>
<![CDATA[	If v2_left < v1_left then v1_left = v2_left]]>
<![CDATA[
]]>
<![CDATA[	If v2_top < v1_top then v1_top = v2_top]]>
<![CDATA[
]]>
<![CDATA[	If v2_right > v1_right then v1_right = v2_right]]>
<![CDATA[
]]>
<![CDATA[	If v2_bottom > v1_bottom then v1_bottom = v2_bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oField = DCONav(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Target DCO not found.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CheckMCCOImageReference(oField,L1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oField.Text=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Expand Zone for viewability - check image border boundries]]>
<![CDATA[
]]>
<![CDATA[	v1_left = v1_left-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_left<0 then v1_left=0]]>
<![CDATA[
]]>
<![CDATA[	v1_top = v1_top-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_top<0 then v1_top=0]]>
<![CDATA[
]]>
<![CDATA[	v1_right = v1_right+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_right>CCO.Right then v1_right=CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = v1_bottom+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_bottom>CCO.bottom then v1_right=CCO.bottom ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call oField.SetPosition(v1_left-2, v1_top-2, v1_right+2, v1_bottom+2)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(L2))=0 then L2=L1]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(W2))=0 then W2=W1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For Lx = L1 to L2]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Wxstart=1]]>
<![CDATA[
]]>
<![CDATA[		Wxend=CCO.Item(Lx).Count]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Lx=L1 Then Wxstart=W1]]>
<![CDATA[
]]>
<![CDATA[		If Lx=L2 Then Wxend=W2]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		For Wx = Wxstart to Wxend]]>
<![CDATA[
]]>
<![CDATA[			For Cx = 1 to CCO.Item(Lx).Item(Wx).Count]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				sValue = ASCw(CCO.Item(Lx).Item(Wx).Item(Cx).Value)]]>
<![CDATA[
]]>
<![CDATA[				sConfidence = CCO.Item(Lx).Item(Wx).Item(Cx).confidence]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = oField.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(sValue), CLng(sConfidence))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				  Cleft = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Left)]]>
<![CDATA[
]]>
<![CDATA[				   Ctop = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Top)]]>
<![CDATA[
]]>
<![CDATA[				 Cright = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Right)]]>
<![CDATA[
]]>
<![CDATA[				Cbottom = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Bottom)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		        bRes = cObj.SetPosition(Cleft ,Ctop ,Cright ,Cbottom)		]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[			Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Add Space to DCO Value Between Words]]>
<![CDATA[
]]>
<![CDATA[			If Wx<Wxend then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = oField.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(32), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		        bRes = cObj.SetPosition(Clng(0) ,Clng(0) ,Clng(0) ,Clng(0))]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Next 'Wx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Add EOL character(s) to DCO Value between Lines]]>
<![CDATA[
]]>
<![CDATA[		If Lx<L2 then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If IsAlive(g_SetEOL) Then sEOL = g_SetEOL]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			For n = 1 to len(sEOL)]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = oField.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(ASCW(Mid(sEOL,n,1))), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			   bRes = cObj.SetPosition(Clng(0) ,Clng(0) ,Clng(0) ,Clng(0))]]>
<![CDATA[
]]>
<![CDATA[		   ]]>
<![CDATA[
]]>
<![CDATA[		   Next 'n]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Next 'Lx]]>
<![CDATA[
]]>
<![CDATA[     	 ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "UpdateDCOField    Value Found: '" & oField.Text & "'    Confidence: '" & oField.ConfidenceString & "' Image:'" & oField.Variable("IMAGEFILE") &"'")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(logwindow) Then]]>
<![CDATA[
]]>
<![CDATA[		Call ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	 	ValueUP.Text = oField.Text				]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	UpdateDCOField = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function UpdateDCOField")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="SetRect" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ 'Four coordinates designating the rectangle's size and location: X,Y,W,H.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim vals]]>
<![CDATA[
]]>
<![CDATA[	Dim nX,nY,nW,nH]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	vals = Split(strParam,",",4)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nX = CLng(Trim(vals(0))) ]]>
<![CDATA[
]]>
<![CDATA[	nY = CLng(Trim(vals(1))) ]]>
<![CDATA[
]]>
<![CDATA[	nW = CLng(Trim(vals(2))) ]]>
<![CDATA[
]]>
<![CDATA[	nH = CLng(Trim(vals(3))) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(nX,nY,nX+nW,nY+nH)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetRect = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetRect")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="MergeWordRT" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of words to the right, starting from the previously ]]>
<![CDATA[
]]>
<![CDATA['    found word, to be placed into a field.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    Places the located word with one or more words to the right, on the same line, ]]>
<![CDATA[
]]>
<![CDATA['    into the current object field.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim Wx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Or IsNull(StrParam) Then StrParam = 1 ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Abs(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MergeWordRT=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[	If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[	If L2=0 then L2=1]]>
<![CDATA[
]]>
<![CDATA[	If W1=0 then W1=1]]>
<![CDATA[
]]>
<![CDATA[	If W2=0 then W2=1]]>
<![CDATA[
]]>
<![CDATA[	     ]]>
<![CDATA[
]]>
<![CDATA[	For Wx = 1 To StrParam]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Check if there is a word to the right to merge with]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Item(L2).count < (W2 + Wx) Then ]]>
<![CDATA[
]]>
<![CDATA[			MergeWordRT = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Call CCO.SetCurrentPosition(L1,W1,L2,W2 + Wx)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Next 'Wx]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("MergeWordRT New Value: " & GetCurrValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MergeWordRT = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function MergeWordRT")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="IsNumber" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   An Integer (0-100) indicating the minimum percentage of characters that must be numeric.]]>
<![CDATA[
]]>
<![CDATA[ '   If no parameter is specified, the value defaults to 100 percent; all characters must be numeric.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim Value, TrueCount, FalseCount, TFRatio]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is not Numeric. Setting to 100")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If StrParam < 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 0]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is negative value. Setting to Zero")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If StrParam > 100 Then ]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is Greater than 100. Setting to 100")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsNumber = False]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetCurrValue)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking Value of '" & Value & "'.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For Cx = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[		If IsNumeric(Mid(value,Cx,1)) Then]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*Len(value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio and Len(Value)>0 Then IsNumber = True]]>
<![CDATA[
]]>
<![CDATA[	If Len(Value) <= 0 Then Lval = 1 Else Lval = Len(value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "Value is " & (TrueCount/Lval)*100 & "% Numeric") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNumber=False Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("value contains less than " & StrParam & "% numeric characters.") ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="IsAlpha" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    An Integer (0-100) indicating the minimum percentage of characters that need to be alphabetic. ]]>
<![CDATA[
]]>
<![CDATA['    If no value is provided, the percentage defaults to 100; all characters must be alphabetic.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim Value, TrueCount, FalseCount, TFRatio, Ck]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsAlpha = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' StrParam is a value between 0 and 100]]>
<![CDATA[
]]>
<![CDATA[	' This action determines the percentage of numbers required to return True]]>
<![CDATA[
]]>
<![CDATA[	' Defaults to 100% ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is not Numeric. Setting to 100")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	If StrParam < 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 0]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is negative value. Setting to Zero")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	If StrParam > 100 Then ]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is Greater than 100. Setting to 100")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetCurrValue)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Ck = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[    If Not DCGlobalStrings.RegExIsMatch(Mid(value,Ck,1),"\p{L}") Then]]>
<![CDATA[
]]>
<![CDATA[			FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Ck]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*Len(value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio Then IsAlpha = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsAlpha Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Value is at least " & StrParam & "% Alphabetic") ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Value is not at least " & StrParam & "% Alphabetic") ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="MergeWordLF" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of words to the left of the previously found field,]]>
<![CDATA[
]]>
<![CDATA['    to be placed into the current object field.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    Merges the located word with one or more words to the left, on the same line.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim Wx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Or IsNull(StrParam) Then StrParam = 1 ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Abs(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MergeWordLF=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[  If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[	If L2=0 then L2=1]]>
<![CDATA[
]]>
<![CDATA[	If W1=0 then W1=1]]>
<![CDATA[
]]>
<![CDATA[	If W2=0 then W2=1]]>
<![CDATA[
]]>
<![CDATA[	     ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Starting from leading and trailing words:" & L1 & "," & W1 & ":" & L2 & "," & W2)     ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Merging up to '" & strparam & "' words Left.")     ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[	For Wx = 1 To StrParam]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Check if there is a word to the left to merge with]]>
<![CDATA[
]]>
<![CDATA[    If (W1 - Wx)<=0 Then     ]]>
<![CDATA[
]]>
<![CDATA[			MergeWordLF = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    Call CCO.SetCurrentPosition(L1,W1-Wx,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Next 'Wx]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("MergeWordLF New Value: " & GetCurrValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MergeWordLF = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function MergeWordLF")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsDateValue" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Determines if the recognized value of the located word has an acceptable Date format.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[  Dim slocale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  IsDateValue=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  IsDateValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Value = GetCurrValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  writelog("Checking Value:'" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[  slocale = currentobj.variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  IsDateValue = DCGlobalDates.IsDate(Value,slocale) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  writelog(DCGlobalDates.GetLog())]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="FilterIt" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   A String containing the character(s) to be removed. ]]>
<![CDATA[
]]>
<![CDATA[ '   <b>Alert!</b> This action removes every instance of the character or characters.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("FilterIt: Calling RemoveType...")]]>
<![CDATA[
]]>
<![CDATA[	FilterIt = RemoveType(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="SelectSnippet" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '  1.</b> The character that is to appear in the Snippet field if a value is not ]]>
<![CDATA[
]]>
<![CDATA[ '   available. "~" is the default.]]>
<![CDATA[
]]>
<![CDATA[ '  2.</b> The magnification of the value's image. "1" = 100% and is the default.]]>
<![CDATA[
]]>
<![CDATA[ '  ]]>
<![CDATA[
]]>
<![CDATA[ '   Used in conjunction with directional actions, this action will populate a Snippet ]]>
<![CDATA[
]]>
<![CDATA[ '   field with the recognized value of the located word.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim Lx, Wx]]>
<![CDATA[
]]>
<![CDATA[	Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim v_left,v_top,v_right,v_bottom]]>
<![CDATA[
]]>
<![CDATA[    Dim v1_left,v1_top,v1_right,v1_bottom]]>
<![CDATA[
]]>
<![CDATA[    Dim v2_left,v2_top,v2_right,v2_bottom]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = StrParam & ", "]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " ,1"]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(aStrParam(1)) Then aStrParam(1) = "1"]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SelectSnippet: setting default area...")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SelectSnippet=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[	If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[	If L2=0 then L2=1]]>
<![CDATA[
]]>
<![CDATA[	If W1=0 then W1=1]]>
<![CDATA[
]]>
<![CDATA[	If W2=0 then W2=1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("Showing CCO " & L1 & "," & W1 & " to " & L2 & "," & W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'First Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v1_left = CCO.Item(L1).Item(W1).Left]]>
<![CDATA[
]]>
<![CDATA[	v1_top = CCO.Item(L1).Item(W1).Top]]>
<![CDATA[
]]>
<![CDATA[	v1_right = CCO.Item(L1).Item(W1).Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = CCO.Item(L1).Item(W1).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Last Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v2_left = CCO.Item(L2).Item(W2).Left]]>
<![CDATA[
]]>
<![CDATA[	v2_top = CCO.Item(L2).Item(W2).Top]]>
<![CDATA[
]]>
<![CDATA[	v2_right = CCO.Item(L2).Item(W2).Right]]>
<![CDATA[
]]>
<![CDATA[	v2_bottom = CCO.Item(L2).Item(W2).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Merge Positions]]>
<![CDATA[
]]>
<![CDATA[	If v2_left < v1_left then v1_left = v2_left]]>
<![CDATA[
]]>
<![CDATA[	If v2_top < v1_top then v1_top = v2_top]]>
<![CDATA[
]]>
<![CDATA[	If v2_right > v1_right then v1_right = v2_right]]>
<![CDATA[
]]>
<![CDATA[	If v2_bottom > v1_bottom then v1_bottom = v2_bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = v1_bottom + ((v1_bottom - v1_top) * (2 * aStrParam(1)))  ]]>
<![CDATA[
]]>
<![CDATA[	 v1_right = v1_right + ((v1_right - v1_left) * (.75 * aStrparam(1)))]]>
<![CDATA[
]]>
<![CDATA[	  v1_left = v1_left - (15 * aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	   v1_top = v1_top - (15 * aStrParam(1)) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(v1_left, v1_top, v1_right, v1_bottom)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.text = aStrParam(0)		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CheckMCCOImageReference(CurrentObj,L1)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		ValueUp.text = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[		Call ShowRect (v1_left, v1_top, v1_right, v1_bottom)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SelectSnippet = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SelectSnippet")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="DefaultValue" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA['    The String value assigned to the bound <b>Field</b> object of the Document Hierarchy ]]>
<![CDATA[
]]>
<![CDATA['    that represents the current field.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then Valuetxt.text = strParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text = StrParam]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then ValueUp.text = StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	DefaultValue = True]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="MaxLength" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'An Integer specifying the maximum number of characters the word can contain.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim wCount, msg]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " "]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MaxLength = False ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	wCount = Len(GetCurrValue())]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		If wCount <= CLng(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[			MaxLength = True]]>
<![CDATA[
]]>
<![CDATA[			msg = vbCr & "MaxLength returns TRUE."]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			If wCount >= CLng(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[				bOverride=False]]>
<![CDATA[
]]>
<![CDATA[				msg = vbCr & "MaxLength returns FALSE."]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		msg = "Parameter is not Numeric, MaxLength returns False."]]>
<![CDATA[
]]>
<![CDATA[		writelog(msg)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("MaxLength: Set to " & StrParam & " Characters. Count is " & wCount & ". " & msg)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="MinLength" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'An Integer specifying the minimum number of characters the word can contain.  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim wCount, msg]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " "]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MinLength = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	wCount = Len(GetCurrValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		If wCount >= CInt(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[			MinLength = True]]>
<![CDATA[
]]>
<![CDATA[			msg = vbCr & "MinLength returns TRUE."]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			msg = vbCr & "MinLength returns FALSE."]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		msg = "Parameter is not Numeric, MinLength returns False."]]>
<![CDATA[
]]>
<![CDATA[		Writelog(msg)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("MinLength: Set to " & StrParam & " Characters. Count is " & wCount & ". " &  msg)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="IsCurrency" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  This CCO action determines if the value of the located word is 100% numeric and ]]>
<![CDATA[
]]>
<![CDATA[  '  includes a two-digit decimal amount.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  The field must contain a two digit currency value.  The decimal separator can be a period or]]>
<![CDATA[
]]>
<![CDATA[  '  comma.  The action will ignore leading and trailing spaces.  The field cannot contain]]>
<![CDATA[
]]>
<![CDATA[  '  a currency symbol.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsCurrency = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentValue = GetCurrValue()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalStrings.RegExIsMatch(CurrentValue,"[^\p{N}\p{Sc}\.\,\'\s]") Then]]>
<![CDATA[
]]>
<![CDATA[		If Len(Trim(CurrentValue))>=3 Then]]>
<![CDATA[
]]>
<![CDATA[			If Left(Right(CurrentValue,3),1) = "." Or Left(Right(CurrentValue,3),1) = "," Then]]>
<![CDATA[
]]>
<![CDATA[				IsCurrency = True]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("IsCurrency returns " & IsCurrency)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsCurrency")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="ScanRT" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' Numeric value of the number of words to be evaluated to the right of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' ScanRT (scan right) looks for a word or words in positions that are slightly above or below the ]]>
<![CDATA[
]]>
<![CDATA[   ' line on which the current word rests.]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim Up_xL,Up_yB,Dn_xL,Dn_yT,CM,CR,DistUp,DistDN,l,w]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ScanRT=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Check the parameter is numeric (default to 1 if not)]]>
<![CDATA[
]]>
<![CDATA[  If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  '///Word Code Relationship Diagram -]]>
<![CDATA[
]]>
<![CDATA[	'///WordCode:     Ln   LL	Hn   RR    Rn       Ln     LS      RS     Rn      HL    RH        HH]]>
<![CDATA[
]]>
<![CDATA[	'///TargetWord-> ---- ----  --  ----  ----  :  ----  ------  ------  ---- :  ----  ----  :  ------  	]]>
<![CDATA[
]]>
<![CDATA[	'///CurrentCCO->          ------                        ---------            ----------     ------]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[  ScanRT = True]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If JumpToWordH(bInteractive, bDebug,  CLng(strParam)) Then	]]>
<![CDATA[
]]>
<![CDATA[    'go right n words on same line]]>
<![CDATA[
]]>
<![CDATA[  elseif CodeUP("R1",1) And NoCodeUP("L,S,H",1) And CodeDN("R1",1) And NoCodeDN("L,S,H",1) Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("find closest R1 word coordinates")	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[			If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[			If L2=0 then L2=1]]>
<![CDATA[
]]>
<![CDATA[			If W1=0 then W1=1]]>
<![CDATA[
]]>
<![CDATA[			If W2=0 then W2=1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Up_xL = CCO.Item(L2-1).Item( (InStr(LineMapUp(1),"R1")+2) /3).Left]]>
<![CDATA[
]]>
<![CDATA[			Up_yB = CCO.Item(L2-1).Item( (InStr(LineMapUp(1),"R1")+2) /3).bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Dn_xL = CCO.Item(L2+1).Item( (InStr(LineMapDN(1),"R1")+2) /3).Left]]>
<![CDATA[
]]>
<![CDATA[			Dn_yT = CCO.Item(L2+1).Item( (InStr(LineMapDN(1),"R1")+2) /3).Top]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			CM = CCO.Item(L2).Item(W2).Bottom - CCO.Item(L2).Item(W2).Top]]>
<![CDATA[
]]>
<![CDATA[			CR = CCO.Item(L2).Item(W2).Right]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			DistUp = ( (Up_xL-CR)^2 + (Up_yB-CM)^2 )]]>
<![CDATA[
]]>
<![CDATA[			DistDN = ( (Dn_xL-CR)^2 + (Dn_yT-CM)^2 )]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "DistUP: " & DistUp & "   DistDN: " & DistDN)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CLng(DistUP) > CLng(DistDN) Then ]]>
<![CDATA[
]]>
<![CDATA[				writelog(Space(6) & "UPto")]]>
<![CDATA[
]]>
<![CDATA[				Call GoUpTo(bInteractive, bDebug,"R1,1") ]]>
<![CDATA[
]]>
<![CDATA[			Else ]]>
<![CDATA[
]]>
<![CDATA[				writelog(Space(6) & "DNto")]]>
<![CDATA[
]]>
<![CDATA[				Call GoDnTo(bInteractive, bDebug,"R1,1")]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		elseif CodeUP("R1",1) And NoCodeUP("L,S,H",1) And countUP(1)=1 Then]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "CodeUP('R1',1) And NoCodeUP('L,S,H',1)")]]>
<![CDATA[
]]>
<![CDATA[			If countUP(1) = 1 Then Call GoUpTo(bInteractive, bDebug,"R1,1") 	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		elseif CodeDN("R1",1) And NoCodeDN("L,S,H",1) And countDN(1) = 1  Then]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "CodeDN('R1',1) And NoCodeDN('L,S,H',1)")]]>
<![CDATA[
]]>
<![CDATA[			If countDN(1) = 1 Then Call GoDnTo(bInteractive, bDebug,"R1,1")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		elseif CodeUP("R1",1) And NoCodeUP("S,LL,H",1) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "CodeUP('R1',1) And NoCodeUP('S,LL,H',1)") 	]]>
<![CDATA[
]]>
<![CDATA[			Call GoUpto(bInteractive, bDebug,"R1,1")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		elseif CodeDN("R1",1) And NoCodeDN("S,LL,H",1) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "CodeUP('R1',1) And NoCodeUP('S,LL,H',1)") 	]]>
<![CDATA[
]]>
<![CDATA[			Call GoDNto(bInteractive, bDebug,"R1,1")]]>
<![CDATA[
]]>
<![CDATA[ 						]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			ScanRT = False]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "ScanRT = False")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ScanRT returns "  & ScanRT)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ScanRT")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="GroupWords" access="public" bInter="bInter" bDebug="bDebug" strParam="nSpaces">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Long value of the maximum character width separating words to the right and left of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Groups any words to the left and right of a located word if the target words are]]>
<![CDATA[
]]>
<![CDATA[    'themselves separated by a character width equal to or less than the character]]>
<![CDATA[
]]>
<![CDATA[    'width you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GroupWords = GroupCCOWords(nSpaces, "ALL") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GroupWordsRIGHT" access="public" bInter="bInter" bDebug="bDebug" strParam="nSpaces">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' Long value of the maximum character width separating words to the right of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' Groups words to the right of the located word if the target words are separated]]>
<![CDATA[
]]>
<![CDATA[   ' by a character width equal to or less than the character width you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	GroupWordsRIGHT = GroupCCOWords(nSpaces, "RIGHT") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GroupWordsLEFT" access="public" bInter="bInter" bDebug="bDebug" strParam="nSpaces">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Long value of the maximum character width separating words to the left of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Groups only words to the left of the located word if the target words are]]>
<![CDATA[
]]>
<![CDATA[  '  separated by a character width equal to or less than the character width you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GroupWordsLEFT = GroupCCOWords(nSpaces, "LEFT") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsValue" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  '  The value to be compared to the object's recognized value.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Determines if the recognized value of a word of the current page is identical ]]>
<![CDATA[
]]>
<![CDATA[  '  to the value you enter as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  '  If you want to check only a subset of the field, use ValueInField.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim lenV, ValueUP, cntV]]>
<![CDATA[
]]>
<![CDATA[	IsValue = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	value = GetCurrValue() ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	value = Trim(value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(2) & "Looking for " & Strparam & ". Current CCO value is " & value)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Ucase(strParam) = Ucase(value) Then IsValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		Call ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsValue_RegEx" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    A Regular Expression that will be used for comparison with the recognized value of the word.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA['    Determines if the recognized value of a word of the current page is identical]]>
<![CDATA[
]]>
<![CDATA['    to the value you enter as a parameter.  The parameter will be evaluated as]]>
<![CDATA[
]]>
<![CDATA['    as regular expression when compared to the recognized text.]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  Dim Match]]>
<![CDATA[
]]>
<![CDATA[  Dim Matches]]>
<![CDATA[
]]>
<![CDATA[  Dim bFound]]>
<![CDATA[
]]>
<![CDATA[  Dim oValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsValue_RegEx = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Search Value:" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue= Space(1) & Replace(GetCurrValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  WriteLog(Space(2) & "Looking for " & Strparam & ". Current CCO value is " & svalue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	regEx.Pattern = StrParam]]>
<![CDATA[
]]>
<![CDATA[	regEx.IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set Matches = regEx.Execute(sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[  If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[     Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[     Err.Clear]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	For Each Match In Matches]]>
<![CDATA[
]]>
<![CDATA[		If len(Trim(Cstr(Match.Value)))>0 then]]>
<![CDATA[
]]>
<![CDATA[			      ]]>
<![CDATA[
]]>
<![CDATA[      For Mv = 1 To Len(Match.Value)]]>
<![CDATA[
]]>
<![CDATA[			    ThisChar = Mid(Match.Value,Mv,1)]]>
<![CDATA[
]]>
<![CDATA[			    CCode = ThisChar 		]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If DCGlobalStrings.RegExIsMatch(CCode,"\p{Zs}") = True then]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[WHITE SPACE SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{Zl}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[LINE SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{Zp}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[PARAGRAPH SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{P}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & ThisChar '"[PUNCTUATION-->" & ThisChar & "<--]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{C}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[CONTROL CHARACTER]"]]>
<![CDATA[
]]>
<![CDATA[			    else ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & ThisChar]]>
<![CDATA[
]]>
<![CDATA[			    End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[		  Next 'Mv]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Matched Value >>" & CStr(sOUTPUT) & "<<")]]>
<![CDATA[
]]>
<![CDATA[			sOUTPUT = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		IsValue_RegEx = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		Call ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="ValueInField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ 'The value that is to be matched with a portion of the value in the current field.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   Checks if the parameter you enter is within the value of the current field represented ]]>
<![CDATA[
]]>
<![CDATA[ '   by the bound <b>Field</b> object of the Document Hierarchy.  Only a portion of the field's]]>
<![CDATA[
]]>
<![CDATA[ '   value needs to match the parameter.  If the entire field must match, use IsValue.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ValueInField = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue= Space(1) & Replace(GetFieldValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Look in string: " & sValue)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Check for and protect against RegEx reserved characters]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"*","\*")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"\","\\")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"^","\^")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"$","\$")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"+","\+")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"?","\?")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,".","\.")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"[","\[")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"]","\]")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"(","\(")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,")","\)")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"|","\|")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"{","\{")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"}","\}")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,",","\,")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"-","\-")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	regEx.Pattern = StrParam]]>
<![CDATA[
]]>
<![CDATA[	regEx.IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set Matches = regEx.Execute(sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[  If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	For Each Match In Matches]]>
<![CDATA[
]]>
<![CDATA[		If len(Trim(Cstr(Match.Value)))>0 then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        For Mv = 1 To Len(Match.Value)]]>
<![CDATA[
]]>
<![CDATA[			    ThisChar = Mid(Match.Value,Mv,1)]]>
<![CDATA[
]]>
<![CDATA[			          ]]>
<![CDATA[
]]>
<![CDATA[          If DCGlobalStrings.RegExIsMatch(CCode,"\p{Zs}") = True then]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[WHITE SPACE SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{Zl}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[LINE SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{Zp}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[PARAGRAPH SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{P}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & ThisChar '"[PUNCTUATION-->" & ThisChar & "<--]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{C}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[CONTROL CHARACTER]"]]>
<![CDATA[
]]>
<![CDATA[			    else ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & ThisChar]]>
<![CDATA[
]]>
<![CDATA[			    End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[		    Next 'Mv]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Matched Value >>" & CStr(sOUTPUT) & "<<")]]>
<![CDATA[
]]>
<![CDATA[			sOUTPUT = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		ValueInField = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="ValueInField_RegEx" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    The portion of the value to find in the field.  The parameter is expected]]>
<![CDATA[
]]>
<![CDATA['    to be expressed as a regular expression.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    This action checks if the Regular Expression you specify as the parameter ]]>
<![CDATA[
]]>
<![CDATA['    is equivalent to the value of the current field.  Only a part of the field must match]]>
<![CDATA[
]]>
<![CDATA['    the parameter.  To match the entire value of the field, use IsValueRegEx.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim oValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ValueInField_RegEx = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Search Value:" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue= Space(1) & Replace(GetFieldValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Look in string: " & sValue)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	regEx.Pattern = StrParam]]>
<![CDATA[
]]>
<![CDATA[	regEx.IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set Matches = regEx.Execute(sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[  If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	For Each Match In Matches]]>
<![CDATA[
]]>
<![CDATA[		If len(Trim(Cstr(Match.Value)))>0 then]]>
<![CDATA[
]]>
<![CDATA[		    For Mv = 1 To Len(Match.Value)]]>
<![CDATA[
]]>
<![CDATA[			    ThisChar = Mid(Match.Value,Mv,1)]]>
<![CDATA[
]]>
<![CDATA[			          ]]>
<![CDATA[
]]>
<![CDATA[          If DCGlobalStrings.RegExIsMatch(CCode,"\p{Zs}") = True then]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[WHITE SPACE SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{Zl}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[LINE SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{Zp}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[PARAGRAPH SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{P}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & ThisChar '"[PUNCTUATION-->" & ThisChar & "<--]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{C}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[CONTROL CHARACTER]"]]>
<![CDATA[
]]>
<![CDATA[			    else ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & ThisChar]]>
<![CDATA[
]]>
<![CDATA[			    End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[		    Next 'Mv]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Matched Value >>" & CStr(sOUTPUT) & "<<")]]>
<![CDATA[
]]>
<![CDATA[			sOUTPUT = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		ValueInField_RegEx = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ValueInField_Fuzzy" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    'String value to be matched to the current field's value, using fuzzy matching procedures.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Checks if there is a "fuzzy" match of the parameter's value with the value in the current field.]]>
<![CDATA[
]]>
<![CDATA[    'Only a portion of the field's value needs to match.]]>
<![CDATA[
]]>
<![CDATA[    'The match is performed by allowing for common substitutions that can occur during]]>
<![CDATA[
]]>
<![CDATA[    'recognition.  These substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[    	]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim oValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ValueInField_Fuzzy = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Original Value:" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	modStrParam = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue= Space(1) & Replace(GetFieldValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Look in string: " & sValue)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	regEx.Pattern = modStrParam]]>
<![CDATA[
]]>
<![CDATA[	regEx.IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set Matches = regEx.Execute(sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[  If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	For Each Match In Matches]]>
<![CDATA[
]]>
<![CDATA[		If len(Trim(Cstr(Match.Value)))>0 then]]>
<![CDATA[
]]>
<![CDATA[			  For Mv = 1 To Len(Match.Value)]]>
<![CDATA[
]]>
<![CDATA[			    ThisChar = Mid(Match.Value,Mv,1)]]>
<![CDATA[
]]>
<![CDATA[			          ]]>
<![CDATA[
]]>
<![CDATA[          If DCGlobalStrings.RegExIsMatch(CCode,"\p{Zs}") = True then]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[WHITE SPACE SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{Zl}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[LINE SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{Zp}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[PARAGRAPH SEPARATOR]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{P}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & ThisChar '"[PUNCTUATION-->" & ThisChar & "<--]"]]>
<![CDATA[
]]>
<![CDATA[			    elseif DCGlobalStrings.RegExIsMatch(CCode,"\p{C}") = True then ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & "[CONTROL CHARACTER]"]]>
<![CDATA[
]]>
<![CDATA[			    else ]]>
<![CDATA[
]]>
<![CDATA[				    sOUTPUT = sOUTPUT & ThisChar]]>
<![CDATA[
]]>
<![CDATA[			    End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[		    Next 'Mv]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Matched Value >>" & CStr(sOUTPUT) & "<<")]]>
<![CDATA[
]]>
<![CDATA[			sOUTPUT = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		ValueInField_Fuzzy = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="WordFind_Offset" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    1. String value of a keyword that the action is to find on both the fingerprint and recognized image.]]>
<![CDATA[
]]>
<![CDATA['    2. An optional parameter that specifies the offset threshold.  If not specified, the default value is 100 pixels.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    This action locates a word or phrase on both the recognized page and on the fingerprint.]]>
<![CDATA[
]]>
<![CDATA['    The positioning of both locations are compared to determine an offset value.  The calculated]]>
<![CDATA[
]]>
<![CDATA['    difference is stored in the DCO of the current page in the variable Image_Offset.  This value]]>
<![CDATA[
]]>
<![CDATA['    will be used by subsequent actions, such as ReadZones, to compensate for ]]>
<![CDATA[
]]>
<![CDATA['    the difference so the field data is properly located.]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim nThreshold]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim Temp_CCO]]>
<![CDATA[
]]>
<![CDATA[	Dim L,W]]>
<![CDATA[
]]>
<![CDATA[	Dim nLiveTop, nLiveLeft]]>
<![CDATA[
]]>
<![CDATA[	Dim nFPIDTop, nFPIDLeft]]>
<![CDATA[
]]>
<![CDATA[	Dim nFPID]]>
<![CDATA[
]]>
<![CDATA[	Dim sFPIDFile]]>
<![CDATA[
]]>
<![CDATA[	Dim sSQL, aResult]]>
<![CDATA[
]]>
<![CDATA[	Dim nOffSetX, nOffSetY]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WordFind_Offset = TRUE]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While not(oPage.ObjectType<=2)	]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()	]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check for page object]]>
<![CDATA[
]]>
<![CDATA[	If oPage.ObjectType <>2 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Calling DCO must be of Type PAGE")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check if page has a fingerprint ID]]>
<![CDATA[
]]>
<![CDATA[	nFPID = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(nFPID)=0 or Not(Isnumeric(nFPID)) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("FingerPrint ID not found on Run Time CCO. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Split & Check Parameters]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & "," , ",")]]>
<![CDATA[
]]>
<![CDATA[	sKeyWord = aStrparam(0)]]>
<![CDATA[
]]>
<![CDATA[	nThreshold = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(nThreshold)=0 or Not(Isnumeric(nThreshold)) Then]]>
<![CDATA[
]]>
<![CDATA[		nThreshold = cint(100)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Distance Threshold is set to '" & nThreshold & "' pixels.") ]]>
<![CDATA[
]]>
<![CDATA[		nThreshold = cint(nThreshold)		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Word & Positions on Live CCO]]>
<![CDATA[
]]>
<![CDATA[	If Not(WordFind(bInter, bDebug,sKeyWord)) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Keyword not found on Run Time CCO. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[	  Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[	  Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L,W)]]>
<![CDATA[
]]>
<![CDATA[	If L=0 then L=1]]>
<![CDATA[
]]>
<![CDATA[	If W=0 then W=1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nLiveTop = CCO.Item(L).Item(W).Top]]>
<![CDATA[
]]>
<![CDATA[	nLiveLeft = CCO.Item(L).Item(W).Left]]>
<![CDATA[
]]>
<![CDATA[	Writelog("LiveX=" & nLiveLeft & ", LiveY=" & nLiveTop)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find & Load Fingerprint CCO file]]>
<![CDATA[
]]>
<![CDATA[	sSQL = "SELECT tp_CCOPath FROM Template WHERE tp_TemplateID=" & nFPID & ";"]]>
<![CDATA[
]]>
<![CDATA[	aResult = GetDataArray(sSQL)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(aResult(0,0)) or aResult(0,0)="" then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Null or Empty Value returned from DB FPID file lookup. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sFPIDFile = aResult(0,0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not FileMgr.FileExists(sFPIDFile) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("File:" & sFPIDFile & " not found. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set Temp_CCO = CCO]]>
<![CDATA[
]]>
<![CDATA[	Set CCO = CCOCreator.Load(sFPIDFile)]]>
<![CDATA[
]]>
<![CDATA[	If CCO is Nothing Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("FPID CCO could not be loaded. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set CCO = Temp_CCO]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Word & Positions on FPID CCO]]>
<![CDATA[
]]>
<![CDATA[	If Not(WordFind(bInter, bDebug,sKeyWord)) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Keyword not found on FPID CCO. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set CCO = Temp_CCO]]>
<![CDATA[
]]>
<![CDATA[		Set Temp_CCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L,W)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If L=0 then L=1]]>
<![CDATA[
]]>
<![CDATA[	If W=0 then W=1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nFPIDTop = CCO.Item(L).Item(W).Top]]>
<![CDATA[
]]>
<![CDATA[	nFPIDLeft = CCO.Item(L).Item(W).Left]]>
<![CDATA[
]]>
<![CDATA[	Writelog("FPIDX=" & nLiveLeft & ", FPIDY=" & nLiveTop)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Switch Page CCO back]]>
<![CDATA[
]]>
<![CDATA[	Set CCO = Temp_CCO]]>
<![CDATA[
]]>
<![CDATA[	Set Temp_CCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Compare Live vs. FPID and calculate Offset]]>
<![CDATA[
]]>
<![CDATA[	nOffSetX = nFPIDLeft - nLiveLeft]]>
<![CDATA[
]]>
<![CDATA[	nOffSetY = nFPIDTop - nLiveTop]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (abs(nOffSetX)<= nThreshold) and (abs(nOffSetX)<= nThreshold) then]]>
<![CDATA[
]]>
<![CDATA[		oPage.Variable("Image_Offset") = cstr(nOffsetX) & "," & cstr(nOffSetY)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("New OffSet Calculated: (" & cstr(nOffsetX) & "," &  cstr(nOffSetY) & ").")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("OffSet (" & cstr(nOffsetX) & "," &  cstr(nOffSetY) & ") was beyond the Set threshold. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WordFind_Offset = True]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<f name="AggregateKeyList" access="public">
	<p name="SearchAll" type="bool">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ' Toggles Key list searches to merge all words in the list into a single query.]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	g_bAggregateListSearch=SearchAll]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  AggregateKeyList=True		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
<![CDATA[
'************************************************************
' help.xml for Locate 

' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'------------------------------------------------------------
'
' Version 8.0.1.41 
' Updated 12/23/2010 PHofle
' * Converted into a .NET DLL for using resources that allow translation of the Datacap Studio help
'
' Updated 05.17.2011 PHofle
' * fixed help tags
'
' Version 8.1.0.53 
' Updated 4/11/2011 PHofle
' * Fixed help for action SetRect SPR 34347
'
' Version 8.1.0.57 
' Updated 4/19/2011 PHofle
' * Changed help for action UpdateDCOfield to include smartparameter enabled and works
'   at page and field level.
'
' Version 8.1.0.61
' Updated 5/24/2012 PHofle
' * Added Help for action AddKeyList SPR 33044
'
' Version 8.1.0.62
' Updated 7/31/2012 CMcGhee
' * Updated Help for GoActions and IsActions per SPR 34364
'
' Version 8.1.0.63
' Updated 8/1/2012 CMcGhee
' * Updated Help - references to "word" changed to "word or phrase"
'  fixed typos, changed "Word matching is case sensitive" to "Matching
'  is case sensitive" per SPR 34364/email from Paul H.
'
' Version 8.1.0.64
' Updated 8/1/2012 PHofle
' * Updated Help - cross checked and modified as required new 
'   "word or phrase" wording against expected action logic.
'
' Version 8.1.0.65
' Updated 8/6/2012 PHofle
' * Updated Help - Added missing TRUE/FALSE to examples for actions:
'   IsAlpha, IsCurrency, IsDateValue, IsNumber, MaxLength.
' * Updated Help - Clarified the results for examples for actions:
'   GroupWords, GroupWordsLEFT & GroupWordsRIGHT. 
' * Updated Help - Added phrase 'Regardless of being called at the page
'   or field level, this action operates on the recognized text for the
'   current page.' to actions: MaxLength, MinLength, MergeWordsLF, 
'   MergeWordsRT, GroupWords, GroupWordsLEFT & GroupWordsRIGHT.
'   SPR 34364  
'
'************************************************************
]]>
<ref id="WordFind">
  <ap>
    A word or phrase to find on the page.
  </ap>
  <h>
    The current page is searched to find the word or phrase.  The location of the first
    word or phrase that matches the parameter will be remembered so it can be
    utilized by subsequent actions.  Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      <b>WordFind("Sales Tax")</b><br/>
      <scr>GoRightWord("1")</scr><br/>
      <scr>IsCurrency()</scr><br/>
      <scr>UpdateField</scr><br/><br/>

      In this example, the WordFind action looks for the first occurrence of
      "Sales Tax" within the current page, always starting at the first word of the page.
      If the phrase "Sales Tax" is found, the subsequent actions will operate based
      on the location of the found phrase.
    </e>
  </h>
  <lvl>Field level only.</lvl>
  <ret>
    <b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b>
  </ret>
  <see>
    <scr>WordFindNext</scr>, <scr>FindKeyList</scr>,<scr>AddKeyList</scr>
  </see>
     </ref>
 <ref id="WordFind_InZone">
  <ap>A word or phrase to find in the current zoned field.</ap>
  <h>
    The current field will be searched to find the word or phrase.  The location of the first
    word or phrase that matches the parameter will be remembered so it can be
    utilized by subsequent actions.  Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>WordFind_InZone("Sub Total")</b><br/>
      GoRightWord("1")<br/>
      IsCurrency()
      In this example, the WordFind action looks for the first occurrence of
      "Sub Total" within the current field, always starting at the first word of the zone.
      If the phrase "Sub Total" is found, the subsequent actions will operate based
      on the location of the found phrase.
    </e>
    </h>
    <lvl>Page or Field</lvl>
    <ret><b>True</b> if the word or phrase is located in the field. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind, WordFindNext, WordFindNext_InZone</scr>
    </see>
     </ref>
 <ref id="WordFindNext">
  <ap>A word or phrase to find on the page, following a previously found word or phrase.</ap>
  <h>
    The current page will be searched to find the word or phrase, starting from the location
    remembered from the last search, such as from WordFind.  The location of the first
    word or phrase that matches the parameter will now be remembered so it can be
    utilized by subsequent actions.
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><scr>WordFind("Total")</scr>
    <br/><b>WordFindNext("Total")</b><br/><b>WordFindNext("Total")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>IsCurrency()</scr>
    <br/><scr>UpdateField</scr>
    <br/><br/>

      In this sequence, the Locate rule locates the third instance of 
      the word "Total" in the current page.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if the parameter is located. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind</scr>
    , <scr>FindLastWord</scr>
    </see>
     </ref>
 <ref id="WordFindNext_InZone">
  <ap>A word or phrase to find in the current field, following a previously found word or phrase.</ap>
  <h>
    The current field will be searched to find the word or phrase, starting from the
    remembered location of a previous find.  The new location of the first
    word or phrase in the field that matches the parameter will now be remembered so it can be
    utilized by subsequent actions.    
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      WordFind_InZone(ItemID)<br/>
      WordFindNext_InZone(Desc)<br/><br/>
      
      In this example, the WordFind_InZone action looks for the first occurrence of
      "ItemID" within the current field, always starting at the first word of the zone.
      If the phrase "ItemID" is found, the word "Desc" will be looked for in the
      current field, starting after the location of "ItemID".  If "Desc" is found,
      any subsequent actions will operate based
      on the location of that found phrase.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the parameter is located. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind_InZone</scr>
    , <scr>FindLastWord_InZone</scr>
    </see>
     </ref>
 <ref id="RegExFind">
  <ap>
    A word or phrase to find on the current page.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Locates the first occurrence of a word or phrase on the current page where the input search term
    is specified as a regular expression.
    The search is started from the first word on the current page.  The location of the 
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.
    <e><b>RegExFind("Da?e")</b><br/>
      GoRightWord("1")<br/>
      IsDateValue()<br/>
      UpdateField()<br/><br/>
      RegExFind will look for the first occurrence of a word or phrase that matches the regular expression.
      If a match is found, it continues processing by moving one word to the right of the result
      of RegExFind and acts on that word.  If it is a date format, UpdateField will place the
      value into the current field.      
    </e>
    </h>
    <lvl>Page level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="RegExFind_InZone">
  <ap>
    A word or phrase to find in the current field.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Locates the first occurrence of a word or phrase in the current field where the input 
    search term is specified as a regular expression.
    The search is started from the first word of the current field.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.
    <e><b>RegExFind_InZone("Da?e")</b><br/>
      GoRightWord("1")<br/>
      IsDateValue()<br/>
      UpdateField()<br/><br/>
      RegExFind_InZone will look for the first occurrence of a word or phrase that matches 
      the regular expression. If a match is found, it will continue processing by moving 
      one word right of the result of RegExFind and act on that word.  If it is a date 
      format, UpdateField will place the value into the current field.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the word or phrase is located in the current field. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFindNext_InZone.
  </see>
     </ref>
 <ref id="RegExFindNext">
  <ap>
    A word or phrase to find on the current page.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Starting from the location of a previously found word or phrase, this action locates the first
    occurrence of a word or phrase on the current page where the input search term
    is specified as a regular expression.
    The search is started from the location of a previously found word or phrase.  The 
    location of the found word or phrase will now be remembered so the result can be used 
    by subsequent actions. The search is case sensitive.
    <e>
      RegExFind("ItemID")<br/><b>RegExFindNext("Desc")</b><br/><br/>
      In this sequence, the first action looks for "ItemID". If the search
      succeeded, RegExFindNext looks for the first occurrence of "Desc" that comes after "ItemID".
    </e>
    </h>
    <lvl>Page level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="RegExFindNext_InZone">
  <ap>
    A word or phrase to find in the current field.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Starting from the location of a previously found word or phrase, this action locates the first
    occurrence of a word or phrase in the current field where the input search term
    is specified as a regular expression.
    The search is started from the location of a previously found word or phrase in the current 
    field.  The location of the found word or phrase will be remembered so the result can be 
    used by subsequent actions. The search is case sensitive.
    <e>
      RegExFind_InZone("ItemID")<br/><b>RegExFindNext_InZone("Desc")</b><br/><br/>
      In this sequence, the first action looks for "ItemID". If the search
      succeeded, RegExFindNext looks for the first occurrence of "Desc" that comes after "ItemID".
    </e>
    </h>
    <lvl>Page level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="FindKeyList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>
    
    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in 
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.
    The location of the found word or phrase that matches an entry in the keyword file 
    will be remembered so the result can be used by subsequent actions.    
    Matching is case sensitive.<br/><br/>

    To improve matching, 
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindKeyList("InvNum")</b><br/><br/>

      This action searches the current page, from first word to the last word of the current page, 
      for the first keyword in the Invoices Number Keyword file (InvNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvNum.key, starting from first word
      of the current page, repeating this search pattern until a match is found, 
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindNextKeyList, FindLastKeyList, AddKeyList
  </see>
     </ref>
 <ref id="FindKeyList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases, 
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases in the current field of the source page's .cco file against the keywords
    in the key file list to find a match.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.    
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindKeyList_InZone("Line_Items")</b><br/><br/>

      This action searches the current bound zone for the
      first keyword in the Keyword file (Line_Items.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in Line_Items.key, from the beginning 
      of the current bound zone, repeating this search pattern until 
      a match is found, or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if at least one word in the current bound zone matches any 
    word or pattern in the Keyword file.  Otherwise, <b>False.</b></ret>
   <see>
     FindNextKeyList, FindLastKeyList, AddKeyList
   </see>
     </ref>
 <ref id="FindNextKeyList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the words or 
    phrases on the current page against the keywords in the list to find a match.
    The search starts from the last word that had been found using an action such as
    FindKeyList or FindNextKeyList.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      FindKeyList("Tax")<br/><b>FindNextKeyList("IRS")</b><br/><br/>

      Starting from the word or phrase that was located in the FindKeyList action, 
      this action searches the current page, starting from that previously found word, for the
      first word or phrase in the first line of the Keyword file (IRS.key).
      If successful, the search stops and remembers the location of that new 
      word for subsequent actions;
      if not, the action continues searching using the next word or phrase in IRS.key, 
      starting again from the location word previously found by FindKeyList(Tax), 
      repeating this search pattern until a match is found,
      or until there are no more keywords in the file.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if at least one word or phrase on the page, starting from the previously located
    word, matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
   <see>
     FindLastKeyList, AddKeyList, FindKeyListInZone, FindNextKeyList_InZone
   </see>
     </ref>
 <ref id="FindNextKeyList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases in the current field against the keywords in the list to find a match.
    The search starts from the last word that had been found using an action such as
    FindKeyList_InZone or FindNextKeyList_InZone.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      FindKeyList_InZone("Inventory")<br/><b>FindNextKeyList_InZone("Parts")</b><br/><br/>

      This action searches the current field, starting from the first word of the zone, for the
      first occurrence of a word or phrase in the Keyword file "Inventory.key".  If a match is found,
      the application will then look for a word from within the Keyword file "Parts.key",
      starting from the previously found word from the FindKeyList_InZone action and using the
      first word or phrase in the "Parts.key" file.
      If successful, the search stops and remembers the location of the new word for subsequent actions;
      if not, the action continues searching using the next word in "Parts.key", starting again from the
      location of previously found word in the zone, repeating this search pattern until a match is found,
      or until there are no more keywords in the file.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>False</b> if the Fingerprint file(.cco) of the current source 
    page has not been loaded, or is empty. Otherwise, <b>True.</b></ret>
     </ref>
  <see>
    FindLastKeyList, AddKeyList, FindKeyListInZone
  </see>
 <ref id="FindDBList">
  <ap>
    An SQL statement whose result returns a word or phrase, or a list of words or phrases.    
  </ap>
  <h>
    This action issues an SQL query against the lookup database, returning a list
    of words or phrases that will be located on the current page.  The search is performed
    from the first word of the current page.  Initially, the first listed word or phrase
    is searched for on the page.  If there is no match, it will search for the next word or
    phrase returned from the database. This continues until a match is found or none of the returned words
    are contained on the page.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindDBList("Select LastName from Providers")</b><br/><br/>
      This example will obtain a list of last names from a provider table and find the first
      matching occurrence on the page.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindDBList_InZone, FindNextDBList.
  </see>
     </ref>
 <ref id="FindDBList_InZone">
  <ap>
    An SQL statment whose result returns a word or phrase, or a list of word or phrases.
  </ap>
  <h>
    This action issues an SQL query against the lookup database, returning a list
    of words or phrases that will be located in the current field.  The search is performed
    from the first word of the current field.  Initially, the first listed word or phrase
    is searched for in the field.  If there is no match, it will search for the next word or
    phrase returned from the database.  This continues until a match is found or none of the returned words
    are contained on the page.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindDBList("Select LastName from Providers")</b><br/><br/>
      This example will obtain a list of last names from a provider table and find the first
      matching occurrence on the page.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindNextDBList_InZone, FindNextDBList.
  </see>
     </ref>
 <ref id="FindNextDBList">
  <ap>
    An SQL statement whose result returns a word or phrase, or a list of word or phrases.
  </ap>
  <h>
    This action issues an SQL query against the lookup database, returning a list
    of words or phrases that will be located on the current page.  Starting from the
    location of a previously found word, the search is performed.
    Initially, the first listed word or phrase from the SQL query
    is searched for on the page.  If there is no match, it will search for the next word or
    phrase returned from the database. This continues until a match is found or none of the returned words
    are contained on the page.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      WordFind("Hello")<br/><b>FindNextDBList("Select LastName from Providers")</b><br/><br/>
      This example will first locate the word, "Hello".  Once found, it will then 
      obtain a list of last names from a provider table and find the first
      matching occurrence on the page that occurs after the word "Hello".
    </e>
    </h>
    <lvl>Page level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindDBList_InZone, FindDBList.
  </see>
     </ref>
 <ref id="FindNextDBList_InZone">
  <ap>
    An SQL statement whose result returns a word or phrase, or a list of word or phrases.
  </ap>
  <h>
    This action issues an SQL query against the lookup database, returning a list
    of words or phrases that will be located on the current field.  Starting from the
    location of a previously found word, the search is performed.
    Initially, the first listed word or phrase from the SQL query
    is searched for on the page.  If there is no match, it will search for the next word or
    phrase returned from the database. This continues until a match is found or none of the returned words
    are contained on the page.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      WordFind_InZone("Hello")<br/><b>FindNextDBList("Select LastName from Providers")</b><br/><br/>
      This example will first locate the word, "Hello" in the current field.  Once found, it will then
      obtain a list of last names from a provider table and find the first
      matching occurrence in the field that occurs after the word "Hello".
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the word or phrase is located in the field. Otherwise, <b>False.</b></ret>
    <see>
    WordFind_InZone, FindDBList.
  </see>
     </ref>
 <ref id="FindRegExList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the first word or phrase in the keyword
    file.  If the word is found on the page, the search stops.  If no match is found,
    the next line from the keyword file is read and again the entire page is searched.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e><b>FindRegExList("InvoiceNum")</b>

      This action searches the current page, from the first word of the current page, for the
      first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvoiceNum.key, starting from first word
      of the current page, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList
  </see>
     </ref>
 <ref id="FindRegExList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the first word or phrase in the keyword
    file.  If the word or phrase is found in the current field zone, the search stops.  If no match is found,
    the next line from the keyword file is read and again the current field zone is searched.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e><b>FindRegExList_InZone("InvoiceNum")</b>

      This action searches the current page, from the first word of the current field, for the
      first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvoiceNum.key, starting from first word
      of the current field, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, FindLastKeyList, FindNextRegExList, AddKeyList
  </see>
     </ref>
 <ref id="FindNextRegExList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, starting from the location of
    a previous find, this action checks the words or phrases
    on the current page against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the first word or phrase in the keyword
    file.  Starting from the location of the last find, if the word is found, the search stops.  If no match is found,
    the next line from the keyword file is read and again the search starts from the result of
    a previous find.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e>
      FindRegExList("InvoiceNum")<br/><b>FindNextRegExList("InvoiceNum")</b><br/><br/>

      This action searches the current page, starting from the result of the FindRegExList action, for the
      first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvoiceNum.key, 
      repeating this search pattern until a match is found,
      or until there are no more keywords.  Although this example shows FindNextRegExList 
      using the same keyword file, it is allowed to use a different keyword file.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if at least one word on the page, that follows the result of a previous find,
    matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList_InZone, AddKeyList
  </see>
     </ref>
 <ref id="FindNextRegExList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, starting from the location of
    a previous find, this action checks the words or phrases 
    in the current field against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the first word or phrase in the keyword
    file.  Starting from the location of the last find, if the word is found, the search stops.  If no match is found,
    the next line from the keyword file is read and again the search starts from the result of
    a previous find.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e>
      FindRegExList_InZone("InvoiceNum")<br/><b>FindNextRegExList_InZone("InvoiceNum")</b><br/><br/>

      This action searches the current page, starting from the result of the FindRegExList_InZone action, 
      for the first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvoiceNum.key,
      repeating this search pattern until a match is found,
      or until there are no more keywords.  Although this example shows FindNextRegExList_InZone
      using the same keyword file, it is allowed to use a different keyword file.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if at least one word in the field, that follows the result of a previous find,
    matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList_InZone, AddKeyList
  </see>
     </ref>
 <ref id="FindLastWord">
  <ap>A word or phrase to find on the page.</ap>
  <h>
    The current page will be searched to find the last occurrence of a word or phrase. 
    The location of the last
    word or phrase that matches the parameter will be remembered so it can be
    utilized by subsequent actions.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindLastWord("Total")</b><br/>
      GoRightWord("1")<br/>
      IsCurrency()<br/><br/>
      
      This sequence finds the last instance of "Total" on the current page; 
      moves right one word; and checks to be sure that the word has a Currency value.
    </e>
    </h>
    <lvl>Page level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind,</scr>
    <scr>WordFindNext</scr>
    </see>
     </ref>
 <ref id="FindLastWord_InZone">
  <ap>The word or phrase to locate within the current zone.</ap>
  <h>
    The current field will be searched to find the word or phrase.  The location of the last
    occurrence of the word or phrase that matches the parameter will be remembered so it can be
    utilized by subsequent actions.
    Word matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindLastWord_InZone("Total")</b><br/>
      GoRightWord("1")<br/>
      IsCurrency()<br/><br/>
      
      This sequence attempts to find the last occurrence of "Total" in the current zone. 
      It then locates and validates a Currency amount for the Total field, assuming
      the currency amount is to the right of the word "Total".
    </e>
    </h>
    <lvl>Page level.</lvl>
    <ret><b>True</b> if the word or phrase is located in the field. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind_InZone,</scr>
    <scr>WordFindNext_InZone</scr>
    </see>
     </ref>
 <ref id="FindLastKeyList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases, 
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.
    The current page will be searched to find the last occurrence of word or phrase.  
    The location of the last occurrence
    word or phrase that matches an entry in the keyword file will be remembered so it can be
    utilized by subsequent actions.
    Word matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindLastKeyList("InvNum")</b><br/><br/>

      This action searches the current page for the
      last instance of a match with the first keyword in the Keyword file (InvNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching using the next word in InvNum.key, matching the last occurrence
      of the word, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Page level.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindKeyList, FindNextKeyList, AddKeyList
  </see>
     </ref>
 <ref id="FindLastKeyList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases, 
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases in the current bound zone against the keywords in the list to find a match.
    The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>

    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindLastKeyList_InZone("ClaimsData")</b><br/><br/>

      This action searches the current bound zone for the
      last instance of a match with the first keyword in the Keyword file (ClaimsData.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching using the next word in ClaimsData.key, matching the last occurrence
      of the word, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindKeyList_InZone, FindNextKeyList_InZone, AddKeyList
  </see>
     </ref>
 <ref id="FindLastRegEx">
  <ap>
    A word or phrase to find on the current page.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Locates the last occurrence of a word or phrase on the current page where the input search term
    is specified as a regular expression.
    The search is started from the first word of the current page.
    The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.
    <e><b>FindLastRegEx("Da?e")</b><br/>
      GoRightWord("1")<br/>
      IsDateValue()<br/>
      UpdateField()<br/><br/>
      FindLastRegEx will look for the last occurrence of a word that matches the regular expression.
      If it match is found, it will continue processing by moving one word right to the result
      of RegExFind and act on that word.  In this example, if it is a date format, 
      UpdateField will place the value into the current field.
    </e>
    </h>
    <lvl>Page level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="FindLastRegEx_InZone">
  <ap>
    A word or phrase to find in the current field.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Locates the last occurrence of a word or phrase in the current field where the input search term
    is specified as a regular expression.
    The search is started from the first word of the current field.
    The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.
    <e><b>FindLastRegEx_InZone("Da?e")</b><br/>
      GoRightWord("1")<br/>
      IsDateValue()<br/>
      UpdateField()<br/><br/>
      FindLastRegEx will look for the last occurrence of a word that matches the regular expression.
      If it match is found, it will continue processing by moving one word right to the result
      of RegExFind and act on that word.  In this example, if it is a date format,
      UpdateField will place the value into the current field.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the word or phrase is located in the field. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="FindLastRegExList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.  The entries in the
    keyword file are expected to be regular expressions.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the last occurrence of the first word
    or phrase in the keyword file.  If the word is found on the page,
    the search stops at the last occurrence of the word.  If no match is found,
    the next line from the keyword file is read and again the entire page is searched.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the last occurrence of a
    found word or phrase will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e><b>FindLastRegExList("InvoiceNum")</b>

      This action searches the current page, from the first word of the current page, for the
      last occurrence of the first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the last occurrence of the next word in InvoiceNum.key, 
      starting from top of the current page, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Page level.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList, AddKeyList
  </see>
     </ref>
 <ref id="FindLastRegExList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.  The entries in the
    keyword file are expected to be regular expressions.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases in the current field against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the last occurrence of the first word
    or phrase in the keyword file.  If the word is found on the page,
    the search stops at the last occurrence of the word.  If no match is found,
    the next line from the keyword file is read and again the entire field is searched.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.
    The location of the last occurrence of a
    found word or phrase will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e><b>FindLastRegExList_InZone("InvoiceNum")</b>

      This action searches the current page, from the first word of the current page, for the
      last occurrence of the first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the last occurrence of the next word in InvoiceNum.key,
      starting from top of the current page, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if at least one word in the field matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList, AddKeyList
  </see>
     </ref>
 <ref id="GoLeftWord">
  <ap>An integer indicating the number of words to move to the left.</ap>
  <h>
    Starting from a word or phrase found by a previous Locate action, the location position is moved to the left on the
    current line by the number of words indicated by the input parameter. Subsequent Locate actions can then
    perform additional operations on this located word.  Regardless of being called at the page or field level,
    this action operates on the recognized text for the current page.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e><scr>WordFind("Total")</scr>
    <br/><b>GoLeftWord("1")</b><br/><scr>GoBelowWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      If the fingerprint has a table with columns such as Total and Tax, 
      the actions above will locate the Tax amount below ("344.76"):<br/><br/><b>Tax</b><b>Total</b><br/>
      344.76 13,774.00
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a word is found. Otherwise, <b>False.</b></ret>
    <see><scr>GoRightWord</scr>
    , <scr>FindWord</scr>
    , <scr>FindKeyList</scr>
    </see>
     </ref>
 <ref id="GoRightWord">
  <ap>An integer indicating the number of words to move to the right.</ap>
  <h>
    Starting from a word or phrase found by a previous Locate action, the location position is moved to the right on the
    current line by the number of words indicated by the input parameter. Subsequent Locate actions can then
    perform additional operations on this located word.  Regardless of being called at the page or field level,
    this action operates on the recognized text for the current page.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e><scr>WordFind("Tax")</scr>
    <br/><b>GoRightWord("1")</b><br/><scr>GoBelowWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      If the fingerprint has a table with columns such as Total and Tax, the 
      actions above will locate the Total amount below ("13,774.00"):<br/><br/><b>Tax</b><b>Total</b>
      344.76 13,774.00
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a word is found. Otherwise, <b>False.</b></ret>
     </ref>
 <ref id="GoAboveWord">
  <ap>An integer indicating the number of lines to move up.</ap>
  <h>
    Starting from a word or phrase found by a previous Locate action, the location position is moved to a 
    word directly above it by the number of lines indicated by the input parameter. 
    Subsequent Locate actions can then perform additional operations on this located word. 
    Regardless of being called at the page or field level, this action operates on the recognized 
    text for the current page.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>
    <e><scr>WordFind("Total")</scr>
    <br/><b>GoAboveWord("1")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      This sequence finds the word which is the 
      Tax field's entered value ("29.78") when a fingerprint has these fields and values:<br/><b>Tax</b> 29.78<br/><b>Total</b> 234.70
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a word is found. Otherwise, <b>False.</b></ret>
    <see><scr>GoBelowWord</scr>
    </see>
     </ref>
 <ref id="GoBelowWord">
  <ap>An integer indicating the number of lines to move down.</ap>
  <h>
    Starting from a word or phrase found by a previous Locate action, the location position is moved 
    to a word directly below it by the number of lines indicated by the input parameter. 
    Subsequent Locate actions can then perform additional operations on this located word.
    Regardless of being called at the page or field level,
    this action operates on the recognized text for the current page.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e><scr>WordFind("Tax")</scr>
    <br/><b>GoBelowWord("1")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      This sequence finds the word which is the Total field's 
      entered value ("234.70") when a fingerprint has these fields:<br/><b>Tax</b> 29.78<br/><b>Total</b> 234.70
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is found. Otherwise, <b>False.</b></ret>
    <see>
    GoAboveWord, FindWord, FindKeyList, RegExFind
  </see>
     </ref>
 <ref id="GoFirstWord">
  <ap>None.</ap>
   <h>
     Starting from a word or phrase found by a previous Locate action, the location position is moved to the first word
     on the current line. If the page's Fingerprint file (.cco) does not have a line position, the action
     defaults to the first word on the first line of the current zone, or on the first line of
     the current page if a zone is not present. Subsequent Locate actions can then perform additional operations
     on this located word. Regardless of being called at the page or field level, this action operates on the
     recognized text for the current page.<br/><br/>

     <e>
       <b>GoFirstWord()</b>
     </e>
   </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the page's Fingerprint file (.cco) is not available or if 
    it is empty. Otherwise, <b>True.</b></ret>
    <see>WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="GoLastWord">
  <ap>None.</ap>
  <h>
    Starting from a word or phrase found by a previous Locate action, the location position is moved to the last word
    on the current line. If the page's Fingerprint file (.cco) does not have a line position, the action
    defaults to the last word on the first line of the current zone, or on the first line of
    the current page if a zone is not present. Subsequent Locate actions can then perform additional operations
    on this located word.  Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.<br/><br/>
    
    <e><b>GoLastWord()</b></e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the Fingerprint file (.cco) is not available, or if it is empty. Otherwise, <b>True.</b></ret>
    <see>WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="GoFirstLine">
  <ap>None.</ap>
  <h>
    Starting from the current position, the location position is moved to the first line of the current zone,
    or to the first line on the page if a zone is not present. Subsequent Locate actions can then perform
    additional operations from this position. Regardless of being called at the page or field level, this action
    operates on the recognized text for the current page.<br/><br/>

    <e><b>GoFirstLine()</b></e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the page's Fingerprint file(.cco) is unavailable or empty. Otherwise, <b>True.</b></ret>
    <see>WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="GoLastLine">
  <ap>None.</ap>
  <h>
    Starting from the current position, the location position is moved to the last line of the current zone,
    or to the last line on the page if a zone is not present. Subsequent Locate actions can then perform
    additional operations from this position. Regardless of being called at the page or field level, this action
    operates on the recognized text for the current page.<br/><br/>
    
    <e><b>GoLastLine()</b></e>
    </h>
    <lvl>Page or field.</lvl>
    <ret><b>False</b> if the source page's Fingerprint file (.cco) is not available, or
    if it is empty. Otherwise, <b>True.</b></ret>
    <see>WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="GoDownLine">
  <ap>An integer indicating the number of lines to move down below the current line.</ap>
  <h>
    Starting from the current position, the location position is moved down by the number of lines indicated
    in the input parameter and is moved to the first word of that line.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e><scr>FindKeyList("Invoice")</scr>
    <br/><b>GoDownLine("1")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      This sequence finds the word which is the Number field's entered value ("10034") 
      when a fingerprint has these fields:<br/>
      INVOICE<br/>
      Number: 10034
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a line is found. Otherwise, <b>False.</b></ret>
    <see>
    GoUpLine, FindWord, FindKeyList
  </see>
     </ref>
 <ref id="GoUpLine">
  <ap>An integer indicating the number of lines to move up above the current line.</ap>
  <h>
    Starting from the current position, the location position is moved up by the number of lines indicated
    in the input parameter and is moved to the first word of that line.

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e><scr>FindKeyList("Invoice")</scr>
    <br/><b>GoUpLine("1")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      This sequence finds and extracts the entered value of the Date field ("2/13/03"), 
      in a fingerprint with these words:<br/><br/>

      Date: 2/13/03<br/>
      INVOICE
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a line is found. Otherwise, <b>False.</b></ret>
    <see>
    GoDownLine, FindWord, FindKeyList, RegExFind
  </see>
     </ref>
 <ref id="UpdateField">
  <ap>None.</ap>
  <h>
    Updates the appropriate field in the current page's Data file with the recognized 
    (and possibly formatted) value of the located word or phrase.<br/><br/>
    <b>Important</b> An entered value that the UpdateField action places in a Data file 
    becomes a captured value, and can be processed by Validation and Export RuleSets.
    <e><scr>FindKeyList("Date")</scr>
    <br/><scr>GoRightWord("1")</scr>
    <br/><scr>IsDateValue()</scr>
    <br/><b>UpdateField()</b><br/><br/>

      The first action in the sequence finds a word or phrase that identifies the Date Field 
      object of the current page. This is the field's static value - probably its title.<br/><br/>

      The next action moves right one word or phrase to locate the field's entered value - 
      a recognized date such as 12/31/2002. The third action checks to be sure the 
      value has an acceptable Date format.<br/><br/>

      The concluding UpdateField action takes place only if the others are successful. 
      It adds the field's entered value to the current page's Data file, where it is a 
      captured value awaiting the attention of upcoming rules with Validate and Export actions.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
     </ref>
 <ref id="UpdateDCOField">
  <ap>
    String value of the target field's name (Smart Parameter enabled), as a <b>Field</b> object of the Document Hierarchy.
  </ap>
  <h>
    This action updates the size and position coordinates of the <b>Field</b> object 
    representing the field identified by the parameter. Typically, the action follows 
    earlier actions and events which modify the field's width and height, or its 
    precise placement on the current source page. <br/><br/>
    Do not confuse this action with the <b>UpDateField</b>action, 
    which updates Text values.  This action does not update a field's Text value. 
    Instead, it modifies the size and location parameters of a field or zone.
    <e>
      To find a sibling field 'Preparer_Name':<br/>
      <b>UpdateDCOField("..\Preparer_Name")</b><br/><br/>

      To find a child field 'Preparer_Name':<br/>
      <b>UpdateDCOField("Preparer_Name")</b></e>
    </h>
    <lvl>Page or Field level.</lvl>
    <ret><b>False</b> if: the source page's Fingerprint file (.cco) is not available or is empty; 
    if the target field cannot be found; or if there is no information about the target 
    field's starting and ending sizes and locations. Otherwise, <b>True.</b></ret>
     </ref>
 <ref id="SetRect">
  <ap>Four comma separated coordinates designating the rectangle's size and location: X, Y, Width and Height.</ap>
  <h>
    Updates the zone of the current field.
    <e><b>SetRect("0,0,100,200")</b><br/><br/>

      This action changes the field's zone postion to a rectangle at coordinates 0, 0, which is 100 wide and 200 high. <br/><br/>

      This action is useful if you wish to change the zone to a specific area of the image 
      where you know your value resides.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
     </ref>
 <ref id="MergeWordRT">
  <ap>
    An integer indicating the number of words to the right, starting from the previously 
    found word or phrase, to be placed into a field.</ap>
  <h>
    Places the located word or phrase with one or more words to the right, on the same line,
    into the current object field.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("Jan")</scr>
    <br/><b>MergeWordRT("1")</b><br/><scr>UpdateField()</scr>
    <br/><br/>

      Given the following cco string:<br/>
      Invoice Date: Jan 2000<br/><br/>

      The result of <scr>WordFind("Jan")</scr>
     is to locate the highlighted word:<br/>
      Invoice Date: <b>Jan</b> 2000<br/><br/><scr>MergeWordRt("1")</scr>
     will consolidate that value with the year value to its right:<br/>
      Invoice Date: <b>Jan 2000</b><br/><br/><scr>UpdateField</scr>
     saves the entire value, "Jan 2000" is saved to the calling object field.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>MergeWordLF</scr>
    </see>
     </ref>
 <ref id="IsNumber">
  <ap>
    An integer (0-100) indicating the minimum percentage of characters that must be numeric.
    If no parameter is specified, the value defaults to 100 percent; all characters must be numeric.
  </ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the
    characters are numeric. By testing the type of characters recognized in the current word or phrase,
    it is possible for an application to determine it has located the type of data that is
    required, and then take subsequent actions based on the result of the test. This action
    does not consider the decimal symbol, digit grouping symbol or a currency symbol to be
    numeric. Regardless of being called at the page or field level, this action operates on
    the recognized text for the current page. <br/><br/>
    
    <e><scr>WordFind("Total")</scr>
    <br/><scr>GoRightWord("1")</scr>
    <br/><scr>IsNumber("100")</scr>
    <br/><br/>
      
      If the located word's recognized value is: #755<br/><br/>
      <b>IsNumber("75")</b>  returns TRUE<br/>
      <b>IsNumber("80")</b>  returns FALSE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value meets the parameter's requirement for an integer.  Otherwise, <b>False.</b></ret>
    <see>
    IsAlpha, IsCurrency, IsDateValue, FindWord, FindWordList, RegExFind
  </see>
     </ref>
 <ref id="IsAlpha">
  <ap>
    An integer (0-100) indicating the minimum percentage of characters that must be alphabetic. 
    If no value is provided, the percentage defaults to 100; all characters must be alphabetic.
  </ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the characters
    are alphabetic. By testing the type of characters recognized in the current word or phrase, it is possible
    for an application to determine it has located the type of data that is required, and then take
    subsequent actions based on the result of the test. Regardless of being called at the page or
    field level, this action operates on the recognized text for the current page.<br/><br/>
    
    <e><scr>FindKey(Name)</scr>
    <br/><scr>GoRightWord("1")</scr>
    <br/><scr>IsAlpha("100")</scr>
    <br/>
            
      If the located word's recognized value is:  ABC1<br/>
      <b>IsAlpha("75")</b> returns TRUE<br/>
      <b>IsAlpha("80")</b> returns FALSE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the minimum percentage of characters specified by the parameter is alphabetic. Otherwise, <b>False.</b></ret>
    <see><scr>IsCurrency</scr>
    , <scr>IsDateValue</scr>
    , <scr>IsNumber</scr>
    </see>
     </ref>
 <ref id="MergeWordLF">
  <ap>
    An integer indicating the number of words or phrases to the left of the previously found field,
    to be placed into the current object field.
  </ap>
  <h>
    Merges the located word or phrase with one or more words to the left, on the same line.<br/><br/>

    A "word" in this context is a string of characters, which may include spaces.
    This action is used when the value searched for may have spaces in it.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("2000")</scr>
    <br/><b>MergeWordLF("1")</b><br/><scr>UpdateField()</scr>
    <br/><br/>

      Given the following cco string:<br/>
      Invoice Date: Jan 2000<br/><br/><scr>FindWord("2000")</scr>
     will locate the highlighted value:<br/>
      Invoice Date: Jan <b>2000</b><br/><br/><b>MergeWordLF("1")</b> will consolidate it with the text "Jan":<br/>
      Invoice Date: <b>Jan 2000</b><br/><br/>

      ...so that the <scr>UpdateField</scr>
     action will save the entire value, "Jan 2000" into the current
      object's field.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>MergeWordRT</scr>
    </see>
     </ref>
 <ref id="IsDateValue">
  <ap>None.</ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the characters
    are in a valid date format and are a valid date.  By testing the type of characters recognized in
    the current word or phrase, it is possible for an application to determine it has located the type of data
    that is required, and then take subsequent actions based on the result of the test. Regardless of
    being called at the page or field level, this action operates on the recognized text for the current
    page.<br/>
    Note: This action is dynamic locale aware.<br/><br/>
    
    <e>
      If the located word's recognized value is:    01/01/2003<br/><b>IsDateValue()</b> returns TRUE<br/><br/>

      If the located word's recognized value is:    January 01,2003<br/><b>IsDateValue()</b> returns TRUE<br/><br/>

      If the located word's recognized value is:    13/13/2003<br/><b>IsDateValue()</b> returns FALSE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value is an acceptable Date. Otherwise, <b>False.</b></ret>
    <see>
    IsAlpha, IsCurrency, IsNumber, WordFind, FindKeyList, RegExFind
  </see>
     </ref>
 <ref id="FilterIt">
  <ap>
    A string containing the character(s) to be removed. <br/><br/>
    <b>Alert</b> This action removes every instance of the character or characters.
  </ap>
  <h>
    Removes all instances of the character(s) you enter as a parameter from the located word or phrase.
    <e><b>FilterIt("-")</b><br/>
      31-Dec-01 becomes 31Dec01<br/><br/><b>FilterIt("1")</b><br/>
      31-Dec-01 becomes 3-Dec-0
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>DeleteString</scr>
    </see>
     </ref>
 <ref id="SelectSnippet">
  <ap><b>1.</b> The character that is to appear in the Snippet field if a value is not 
    available. "~" is the default.<br/><b>2.</b> The magnification of the value's image. "1" = 100% and is the default.
  </ap>
  <h>
    Used in conjunction with directional actions, this action will populate a Snippet
    field with the recognized value of the located word or phrase.<br/><br/>

    This action is usually the last rule of a Locate RuleSet, and is included as a 
    last resort when the probably location of the field has been found by finding 
    the label, but no likely values have been found.
    <e><scr>FindKeyInList("InvNum")</scr>
    <br/><scr>GoRightWord("1")</scr>
    <br/><b>SelectSnippet("~,1")</b><br/><br/>

      This sequence first tries to locate an Invoices Number keyword in the current page.
      If successful, the next action attempts to lock onto a word or phrase to the right of the located word or phrase.<br/><br/>

      If that word is present, the <scr>SelectSnippet</scr>
     action will place the 
      image of the word's recognized value into the Snippet of the applicable Field object. 
      The Data Entry operator can then determine if the Snippet contains the correct 
      value and can enter the data into the accompanying Data Edit field in the Data Entry Panel.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
     </ref>
 <ref id="DefaultValue">
  <ap>
    The String value assigned to the bound <b>Field</b> object of the Document Hierarchy 
    that represents the current field.
  </ap>
  <h>
    Sets the captured value of the current field to the String value you enter as a parameter.<br/><br/><e><b>DefaultValue("Bill Paid")</b><br/><br/><b>DefaultValue("Past Due")</b></e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
     </ref>
 <ref id="MaxLength">
  <ap>An integer specifying the maximum number of characters the word or phrase can contain.</ap>
  <h>
    Compares the number of characters in the located word or phrase to a maximum number you supply as the parameter.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e>
      If the recognized value of the located word or phrase is: ANYTHING<br/>
      <b>MaxLength("14")</b> returns TRUE<br/>
      <b>MaxLength("8")</b> returns TRUE<br/>
      <b>MaxLength("3")</b> returns FALSE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the parameter is not Numeric, or if the actual number of
    characters exceeds the parameter. Otherwise, <b>True.</b></ret>
    <see><scr>MinLength</scr>
    </see>
     </ref>
 <ref id="MinLength">
  <ap>An integer specifying the minimum number of characters the word or phrase can contain.</ap>
  <h>
    Compares the number of characters in the located word or phrase to a minimum number you supply as the parameter.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e>
      If the recognized value of the word or phrase is: ABC1<br/>
      <b>MinLength("4")</b> returns <br/><b>MinLength("3")</b> returns <br/><b>MinLength("6")</b> returns </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the parameter is not Numeric, or if the actual number of characters 
    is less than the parameter. Otherwise, <b>True.</b></ret>
    <see><scr>MaxLength</scr>
    </see>
     </ref>
 <ref id="IsCurrency">
  <ap>None.</ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the characters are in a valid
    currency format and are a valid currency value.  By testing the type of characters recognized in the current word or phrase,
    it is possible for an application to determine it has located the type of data that is required, and then take
    subsequent actions based on the result of the test. Regardless of being called at the page or field level, this
    action operates on the recognized text for the current page.<br/>

    Note: This action is NOT dynamic locale aware and uses a simple regex and separator character test.<br/><br/>

    <e>
      If the recognized value of the word or phrase is: 12.00<br/><b>IsCurrency()</b> returns TRUE<br/><br/>

      If the recognized value of the word or phrase is: 12,00<br/><b>IsCurrency()</b> returns TRUE<br/><br/>

      If the recognized value of the word or phrase is: 1200<br/><b>IsCurrency()</b> returns FALSE<br/><br/>

      If the recognized value of the word or phrase is: 1,200.00<br/><b>IsCurrency()</b> returns TRUE<br/><br/>

      If the recognized value of the word or phrase is: $12.00<br/><b>IsCurrency()</b> returns TRUE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value is currency. Otherwise, <b>False.</b></ret>
    <see><scr>IsAlpha</scr>
    , <scr>IsDateValue</scr>
    , <scr>IsNumber</scr>
    </see>
     </ref>
 <ref id="ScanRT">
  <ap>Numeric value of the number of words to be evaluated to the right of the current word or phrase.</ap>
  <h>
    ScanRT (scan right) looks for a word in positions that are slightly <b>above or below</b> the 
    line on which the current word or phrase is located.<br/><br/>
    <e><scr>WordFind("Number")</scr>
    <br/><b>ScanRT("1")</b><br/><br/>

      This sequence first finds "Number" on the current page, then moves one
      word to the right as it searches for a value.<br/><br/>

      To compensate for the possibility that this value may be printed slightly 
      above or below the line on which "Number" was printed, the <scr>ScanRT</scr>
      action expands the area in which the target value can reside.  When a page is recognized, 
      skewing or data layout may cause alignment problems.  
      Words that are thought of as being on the same line, may not have been 
      recognized as being on the same line, but slightly above or below the current line.  
      This action compensates for that anomaly when looking for words right of the current 
      word location.  It uses a calculation adjustment to determine which of the words to 
      the right of the current word, should be considered to be on the same line.  
      It will then remember the location of the word that best fits this criteria.  This new
      remembered location can then be utilized by subsequent actions.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if a word is found. Otherwise, <b>False.</b></ret>
    <see>GoRightWord</see>
     </ref>
 <ref id="GroupWords">
  <ap>Long value of the maximum character width separating words to the right and left of the current word.</ap>
  <h>
    Groups any words to the left and right of a located word if the target words are
    themselves separated by a character width equal to or less than the character
    width you specify as a parameter. 
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("Treasury")</scr>
    <br/><b>GroupWords("1.5")</b><br/><br/>

      If a line contains these words:<br/>
      20 000 U S Treasury 7 33<br/><br/>

      the <scr>GroupWords</scr>
    action will merge "20" with "000"; "U" with "S" and "7" with "33" to produce:<br/>
      20 000 U S Treasury 7 33
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>GroupWordsLeft</scr>
    , <scr>GroupWordsRight</scr>
    </see>
     </ref>
 <ref id="GroupWordsRIGHT">
  <ap>Long value of the maximum character width separating words to the right of the current word.</ap>
  <h>
    Groups words to the right of the located word if the target words are separated
    by a character width equal to or less than the character width you specify as a parameter.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("US")</scr>
    <br/><b>GroupWordsRight("2")</b><br/><br/>

      If a line contains these words:<br/>
      20 000 US Treasury<br/><br/>

      the <scr>GroupWordsRight</scr>
     action will merge "US" with "Treasury" to produce:<br/>
      US Treasury
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>GroupWords</scr>
    , <scr>GroupWordsLeft</scr>
    </see>
     </ref>
 <ref id="GroupWordsLEFT">
  <ap>Long value of the maximum character width separating words to the left of the current word.</ap>
  <h>
    Groups only words to the left of the located word if the target words are
    separated by a character width equal to or less than the character width you specify as a parameter.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("000")</scr>
    <br/><b>GroupWordsLeft("2")</b><br/><br/>

      If a line contains these words:<br/>
      20 000 US Treasury<br/><br/>

      the <scr>GroupWordsLeft</scr>
     action will merge "20" with "000" to produce:<br/>

      20 000 
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>GroupWords</scr>
    , <scr>GroupWordsRight</scr>
    </see>
     </ref>
 <ref id="IsValue">
  <ap>The value to be compared to the object's recognized value.</ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the
    value matches the value of the input parameter. By testing the value recognized in the
    current word or phrase, it is possible for an application to determine it has located the data
    that is required, and then take subsequent actions based on the result of the test.
    If you want to check the value of a subset of the word or phrase, use the ValueInWord action.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.<br/>

    Note: Match test is not case sensitive and does not include leading and trailing spaces.<br/><br/>

    <e><scr>WordFind("Houston")</scr>
    <br/><scr>GoRightWord("2")</scr>
    <br/><b>IsValue("77770")</b><br/><br/>

      This sequence confirms that the current page's recognized value for Houston's ZIP code is "77770". <br/><br/>

      The action returns a Boolean value: <b>True</b> if the values are the same, 
      <b>False</b> if they are not.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value matches the parameter's value. Otherwise, <b>False.</b></ret>
    <see>ValueInField, WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="IsValue_RegEx">
  <ap>
    A Regular Expression that will be used for comparison with the recognized value of the word or phrase.
  </ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the regular
    expression provided in the input parameter finds a match in the value. By testing the value recognized
    in the current word or phrase, it is possible for an application to determine it has located the data that is
    required, and then take subsequent actions based on the result of the test. Regardless of being called
    at the page or field level, this action operates on the recognized text for the current page.

    <e><scr>WordFind("Houston")</scr>
    <br/><scr>GoRightWord("2")</scr>
    <br/><b>IsValue_RegEx("Total")</b></e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value matches the parameter's value. Otherwise, <b>False.</b></ret>
     </ref>
 <ref id="ValueInField">
  <ap>The value that is to be matched with a portion of the value in the current field.</ap>
  <h>
    Checks if the parameter you enter is within the value of the current field represented 
    by the bound <b>Field</b> object of the Document Hierarchy.  Only a portion of the field's
    value needs to match the parameter.  If the entire field must match, use IsValue.
    <e><b>ValueInField("Invoice")</b></e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>False</b> if no match occurs. Otherwise, <b>True.</b></ret>
    <see>IsValue, ValueInFieldRegEx</see>
     </ref>
 <ref id="ValueInField_RegEx">
  <ap>
    The portion of the value to find in the field.  The parameter is expected
    to be expressed as a regular expression.</ap>
  <h>
    This action checks if the Regular Expression you specify as the parameter 
    is equivalent to the value of the current field.  Only a part of the field must match
    the parameter.  To match the entire value of the field, use IsValueRegEx.
    <e><b>ValueInField_RegEx("[\^\b\s\n\r]Inv[oO0][iItl1]ce[\b\s]*")</b></e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>False</b> if no match occurs.  Otherwise <b>True.</b></ret>
    <see>IsValue, IsValueRegEx, ValueInField</see>
     </ref>
 <ref id="ValueInField_Fuzzy">
  <ap>String value to be matched to the current field's value, using fuzzy matching procedures.</ap>
  <h>
    Checks if there is a "fuzzy" match of the parameter's value with the value in the current field.
    Only a portion of the field's value needs to match.
    The match is performed by allowing for common substitutions that can occur during
    recognition.  These substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>ValueInField_Fuzzy("Invoice")</b></e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>False</b> if no match occurs. Otherwise, <b>True.</b></ret>
     </ref>
 <ref id="WordFind_Offset">
  <ap>
    1. String value of a keyword that the action is to find on both the fingerprint and recognized image.<br/>
    2. An optional parameter that specifies the offset threshold.  If not specified, the default value is 100 pixels.
  </ap>
  <h>
    This action locates a word or phrase on both the recognized page and on the fingerprint.
    The positioning of both locations are compared to determine an offset value.  The calculated
    difference is stored in the DCO of the current page in the variable Image_Offset.  This value
    will be used by subsequent actions, such as ReadZones, to compensate for 
    the difference so the field data is properly located.<br/><br/>

    For best results, the word or phrase should appear only once or the first instance of the word or phrase should
    always appear in the same location.<br/><br/>

    The threshold is the maximum distance between keywords found on the Live image and the fingerprint.
    The Default value is 100 pixels. If the keywords are more than 100 pixels apart no Offset is generated;
    preventing matches of keywords where there is more then one instance of the word to be found on an image.
    A successful matched pair will update the Image_Offset variable at the page level.<br/><br/>

    This action requires the FingerPrint CCO to have full page recognition results. Otherwise, there will be nothing to match against.<br/><br/>
    
    This action should not be located in the same ruleset where full page recognition is done. It needs to exist in a ruleset that
    is performed afterwards.    
    <e><b>WordFind_Offset("Invoice")</b></e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
    Always <b>True.</b></ret>
     </ref>
  <ref id="AggregateKeyList">
    <ap>Toggles Key list searches to merge all words or phrases in the list into a single query.</ap>
    <h>
      Use of this action changes the search behavior for all 'List' type key word search actions.
      Default behavior is to search each keyword in the list sequentially. This action with the 
      parameter set to TRUE changes the search behavior to check for all the keywords in a single
      aggregate keyword search. To change back to the default behavior use this action with the
      FALSE parameter.
      <e>
        <b>AggregateKeyList(True)</b><br/>
        <b>FindKeyList("InvNum")</b><br/><br/>

          This action searches the current page, from first word to the last word of the current page, for the
          first occurance of all keywords in the Invoices Number Keyword file (InvNum.key).
          If successful, the search stops and remembers the location of that word for subsequent actions;
          if not, the action continues searching for the next word in InvNum.key, starting from first word
          of the current page, repeating this search pattern until a match is found,
          or until there are no more keywords.
          
        </e>
    </h>
    <lvl>Any.</lvl>
    <ret>
      Always <b>True</b>.
    </ret>
    <see>
      FindKeyList, FindNextKeyList, FindLastKeyList, AddKeyList
    </see>
  </ref>
  <ref id="AddKeyList">
    <ap>
         1. String value used as a reference name for other actions to call this list of keywords or phrases.<br/>
      2-25. An optional number of up to twentyfive keywords or phrases to be used for matching.
    </ap>
    <h>
      Adds a list of keywords or phrases that can be used for matching.<br/><br/>

      This action complements the List search actions that can load a Keyword text file which 
      contains a list of words or phrases, separated by new lines, that will be used for matching.<br/>
      AddKeyList adds a list of up to 25 words or phrases without having to read or edit a file.<br/><br/>
    
      <e>
        <b>AddKeyList("InvNum","Invoice Number","Inv. Num.","Invoice #:")</b><br/>
        <b>FindKeyList("InvNum")</b><br/><br/>

        This action searches the current page, from first word to the last word of the current page, for the
        first occurance of all keywords in the Invoices Number Keyword list "InvNum".<br/>
        If successful, the search stops and remembers the location of that word for subsequent actions.<br/>
        If not successful, the action continues searching for the next keyword in the InvNum list, starting from first word
        of the current page, repeating this search pattern until a match is found, or until there are no more keywords.

      </e>
    </h>
    <lvl>Any.</lvl>
    <ret>
      <b>False</b> if no keywords or phrases are entered, otherwise <b>True</b>.
    </ret>
    <see>
      FindKeyList, FindKeyList_InZone, FindNextKeyList, FindNextKeyList_InZone, FindRegExList,
      FindRegExList_InZone, FindNextRegExList, FindNextRegExList_InZone, FindLastKeyList,
      FindLastKeyList_InZone, FindLastRegExList, FindLastRegExList_InZone, AggregateKeyList
    </see>
  </ref>
  	
 </help>
 </rrx>
<rrx namespace="Lookup" src="c:\datacap\RRS\Lookup.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="OpenConnection" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The Data Source Name or Connection String.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   If the action is establishing a connection with an Oracle database,]]>
<![CDATA[
]]>
<![CDATA['   or a SQL Server database using SQL Authentication, be sure to expand the DSN parameter]]>
<![CDATA[
]]>
<![CDATA['   by adding the correct Provider, user ID and Password.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['   A smart parameters are supported to prevent plain text credentials in the application rules.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On error resume next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[  Dim sError]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	oConn.Errors.Clear]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	OpenConnection = True	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" and strParam<>sSmartParam Then ]]>
<![CDATA[
]]>
<![CDATA[    'attempt to decrypt value]]>
<![CDATA[
]]>
<![CDATA[    bRes = [securecall]sSmartParam,strParam[/securecall]   ]]>
<![CDATA[
]]>
<![CDATA[    If bRes=False Then Writelog("Value not decrypted.")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using the original parameter string.") ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	strParam = FormatADOConn(strParam)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 1 Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Connection is already Open, Function returns TRUE")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	oConn.CursorLocation=3]]>
<![CDATA[
]]>
<![CDATA[	oConn.Open(strParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("oConn.State = " & oConn.State)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 1 Then OpenConnection = True Else OpenConnection = False : WriteLog(sError)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("OpenConnection returns " & OpenConnection )]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("Function OpenConnection")]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function OpenConnection") ]]>
	</g>
</af>
<af name="CloseConnection" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['Closes an open connection to your Lookup database.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Dim i, sError]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ CloseConnection = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Writelog("Close Connection...")]]>
<![CDATA[
]]>
<![CDATA[ Writelog("oConn.State = " & oConn.State)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Call CloseDB()]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[ If oConn.State = 1 Then CloseConnection = True Else Writelog(sError)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ Writelog("CloseConnection returns " & CloseConnection )]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[ Call ConnErrHandler("Function CloseConnection")]]>
<![CDATA[
]]>
<![CDATA[ Call ErrorHandler("Function CloseConnection") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PopulateWithResult" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    1. A number <var>n</var> indicating which value in a record retrieved by an]]>
<![CDATA[
]]>
<![CDATA['    earlier <scr>ExecuteSQL</scr> action is to be assigned to the current]]>
<![CDATA[
]]>
<![CDATA['    Field object (and added to the Data file of the current page.)]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    "1" refers to the first column in a recordset, "2" refers to the second column, etc.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    2. True or False. True causes the action to fail if the action]]>
<![CDATA[
]]>
<![CDATA['    returns a recordset with multiple lines. False permits the action to accept a recordset with multiple]]>
<![CDATA[
]]>
<![CDATA['    lines but to use values in the first record of the recordset.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",," , ",")]]>
<![CDATA[
]]>
<![CDATA[	bMultiReturnFail = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  aStrParam(0)=Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[  aStrParam(1)=Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Ucase(aStrParam(1)) = "FALSE" Then]]>
<![CDATA[
]]>
<![CDATA[		bMultiReturnFail = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	PopulateWithResult = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Beginning Populate With Results")	]]>
<![CDATA[
]]>
<![CDATA[	If Not(IsNumeric(aStrParam(0))) Then aStrParam(0)=1 ]]>
<![CDATA[
]]>
<![CDATA[	aStrParam(0) = CLng(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Note: g_aResults is a two dimensional array of results from a prior lookup]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If IsArray(g_aResults) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Array Found")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		writelog((UBound(g_aResults,2)+1) & " Columns in DB Array.")]]>
<![CDATA[
]]>
<![CDATA[		If (aStrParam(0) > UBound(g_aResults,2)+1) Or (aStrParam(0)<1) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Queried Column Value '" & aStrParam(0) & "' is an invalid number. Setting to '1'.") ]]>
<![CDATA[
]]>
<![CDATA[			aStrParam(0) = 1]]>
<![CDATA[
]]>
<![CDATA[		End If	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If bMultiReturnFail = True And UBound(g_aResults,1) > 1 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Multiple Rows returned")]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Populating Current Field with Result #" & aStrParam(0) & " : '" & g_aResults(0,aStrParam(0)-1) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.Text = CStr(g_aResults(0,aStrParam(0)-1))]]>
<![CDATA[
]]>
<![CDATA[			PopulateWithResult = True]]>
<![CDATA[
]]>
<![CDATA[		End If	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("PopulateWithResult returns " & PopulateWithResult)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("Function PopulateWithResult")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function PopulateWithResult") ]]>
	</g>
</af>
<af name="ExecuteSQL" access="public" bInter="bInter" bDebug="bDebug" strParam="sStringIn">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	']]>
<![CDATA[
]]>
<![CDATA[	' section 1 : SELECT * FROM [Names] WHERE Zip=%s AND State='%s';]]>
<![CDATA[
]]>
<![CDATA[	' section 2 : ZipCode, State  (Sibling DCO field names, Values are 10951 and NY)]]>
<![CDATA[
]]>
<![CDATA[	'	]]>
<![CDATA[
]]>
<![CDATA[	' Constructs SQL of: SELECT * FROM [Names] WHERE Zip=10951 AND State='NY';]]>
<![CDATA[
]]>
<![CDATA[	']]>
<![CDATA[
]]>
<![CDATA[	' Result is saved as the calling field value. ]]>
<![CDATA[
]]>
<![CDATA[	' Suppress Result saved to field by having a field name of '-1' in fields list]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim oRS ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[  Dim Index]]>
<![CDATA[
]]>
<![CDATA[	Dim nSubst]]>
<![CDATA[
]]>
<![CDATA[	Dim Tmpstr]]>
<![CDATA[
]]>
<![CDATA[  Dim Counter]]>
<![CDATA[
]]>
<![CDATA[  Dim FieldVal]]>
<![CDATA[
]]>
<![CDATA[	Dim FieldList ]]>
<![CDATA[
]]>
<![CDATA[	Dim FieldArray]]>
<![CDATA[
]]>
<![CDATA[	Dim RowCount	]]>
<![CDATA[
]]>
<![CDATA[	Dim bSuppressResult]]>
<![CDATA[
]]>
<![CDATA[	Dim nStart]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	bSuppressResult = False      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ExecuteSQL = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Check for Connection Errors]]>
<![CDATA[
]]>
<![CDATA[	writelog("Checking connection...")]]>
<![CDATA[
]]>
<![CDATA[	If Not isobject(oConn) Or oConn is Nothing then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No DB Connection Object. Aborting Task.")]]>
<![CDATA[
]]>
<![CDATA[		nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State =0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DB Connection is Closed.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sStringIn = Trim(sStringIn)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_aResults = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Index = InStrRev(sStringIn, Chr(34))	]]>
<![CDATA[
]]>
<![CDATA[	If Index > 1 Then ]]>
<![CDATA[
]]>
<![CDATA[	    sSQL = Left(sStringIn,index-1)]]>
<![CDATA[
]]>
<![CDATA[		FieldList = Mid(sStringIn,(index+2),Len(sStringIn))]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sSQL = sStringIn]]>
<![CDATA[
]]>
<![CDATA[		FieldList = ""]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Parameter : " & sStringIn)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("    Index : " & index)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("  Raw SQL : " & sSql)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("FieldList : " & FieldList)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Pre-Substitute")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      FieldArray = Split(FieldList & ",",",")]]>
<![CDATA[
]]>
<![CDATA[      nSubst = InStr(sSQL,"%s")]]>
<![CDATA[
]]>
<![CDATA[      Counter = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If InStr(FieldList,"-1")>0 Then ]]>
<![CDATA[
]]>
<![CDATA[		bSuppressResult = True ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Suppressing Result to DCO.Text is ON")]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  While nSubst > 0]]>
<![CDATA[
]]>
<![CDATA[	   writelog("FieldName:" & FieldArray(Counter))]]>
<![CDATA[
]]>
<![CDATA[	   FormatLen = 0]]>
<![CDATA[
]]>
<![CDATA[	   If nSubst+2<len(sSQL) Then]]>
<![CDATA[
]]>
<![CDATA[	      ch = Mid(sSQL,nSubst+2,1)]]>
<![CDATA[
]]>
<![CDATA[	      C = ASC(ch)]]>
<![CDATA[
]]>
<![CDATA[	      If(C >= 48 And C <= 57) then]]>
<![CDATA[
]]>
<![CDATA[	         FormatLen = cInt(ch)]]>
<![CDATA[
]]>
<![CDATA[	      End If]]>
<![CDATA[
]]>
<![CDATA[	   End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If FieldArray(Counter)<>"-1" Then ]]>
<![CDATA[
]]>
<![CDATA[		  FieldVal=ReturnNamedValue(FieldArray(Counter)) ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("FieldVal: '" & FieldVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[			FieldVal = replace(FieldVal,"'","''")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If FormatLen = 0 Then]]>
<![CDATA[
]]>
<![CDATA[	       sSQL = Mid(sSQL,1,nSubst-1) & FieldVal & Mid(sSQL,nSubst+2,Len(sSQL))]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[         sSQL = Mid(sSQL,1,nSubst-1) & Mid(FieldVal,1,FormatLen) & Mid(sSQL,nSubst+3,Len(sSQL))]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      nSubst = InStr(sSQL,"%s")  ]]>
<![CDATA[
]]>
<![CDATA[		End If	]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Counter = Counter+1		]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    'Remove leading spaces and quote char]]>
<![CDATA[
]]>
<![CDATA[    If len(sSQL)>1 Then]]>
<![CDATA[
]]>
<![CDATA[        While left(sSQL,1)=CHR(34)]]>
<![CDATA[
]]>
<![CDATA[            sSQL = Right(sSQL,len(sSQL)-1) ]]>
<![CDATA[
]]>
<![CDATA[            sSQL = Trim(sSQL) ]]>
<![CDATA[
]]>
<![CDATA[            If len(sSQL)<=1 then]]>
<![CDATA[
]]>
<![CDATA[                Writelog("SQL Expression '" & sSQL & "' is less than 1 character long. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[                Exit Function]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[    	wend]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Post Substitute")]]>
<![CDATA[
]]>
<![CDATA[	  sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Constructed SQL :" & sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ExecuteSQL = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If InStr(Ucase(sSQL), "SELECT")=1 or InStr(Ucase(sSQL), "EXEC")=1 Then]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Set oRS = oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[      			]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oRS) then]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[        If oRS.State=0 Then       ]]>
<![CDATA[
]]>
<![CDATA[          writelog("RecordSet returned Closed.")]]>
<![CDATA[
]]>
<![CDATA[        Elseif oRS.EOF Or oRS.BOF Then ]]>
<![CDATA[
]]>
<![CDATA[			    ExecuteSQL = False ]]>
<![CDATA[
]]>
<![CDATA[			    writelog("RecordSet Returns EOF or BOF. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[			    Call ConnErrHandler("EOF or BOF")]]>
<![CDATA[
]]>
<![CDATA[			    Exit Function]]>
<![CDATA[
]]>
<![CDATA[		    Else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		        Tmpstr = oRS.GetString]]>
<![CDATA[
]]>
<![CDATA[        	]]>
<![CDATA[
]]>
<![CDATA[		        Writelog("Query Return String: " & Tmpstr)]]>
<![CDATA[
]]>
<![CDATA[        			]]>
<![CDATA[
]]>
<![CDATA[		        If Len(Tmpstr)<> 0 Then]]>
<![CDATA[
]]>
<![CDATA[			        If bSuppressResult = False Then CurrentObj.Text = Left(tmpstr ,Len(tmpstr)-1)	]]>
<![CDATA[
]]>
<![CDATA[		        End If			]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		        RowCount = 0]]>
<![CDATA[
]]>
<![CDATA[		        oRS.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[		        While Not oRS.EOF	]]>
<![CDATA[
]]>
<![CDATA[			        RowCount = RowCount + 1]]>
<![CDATA[
]]>
<![CDATA[			        oRS.MoveNext()]]>
<![CDATA[
]]>
<![CDATA[		        Wend]]>
<![CDATA[
]]>
<![CDATA[        	]]>
<![CDATA[
]]>
<![CDATA[		        Writelog(Space(3) & (RowCount) & " Row(s) containing " & oRS.Fields.Count & " fields found.")]]>
<![CDATA[
]]>
<![CDATA[		        ReDim g_aResults(RowCount-1,oRS.Fields.Count-1)]]>
<![CDATA[
]]>
<![CDATA[        	]]>
<![CDATA[
]]>
<![CDATA[		        oRS.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[		        For Row = 0 To RowCount-1]]>
<![CDATA[
]]>
<![CDATA[			        fldStr = ""]]>
<![CDATA[
]]>
<![CDATA[			        For Fld = 0 To oRS.Fields.Count-1]]>
<![CDATA[
]]>
<![CDATA[				        if IsNull(oRS.Fields(Fld).Value) Then]]>
<![CDATA[
]]>
<![CDATA[					        g_aResults(Row,Fld) = ""]]>
<![CDATA[
]]>
<![CDATA[					        fldStr = fldStr & "["& "" & "] "]]>
<![CDATA[
]]>
<![CDATA[				        else]]>
<![CDATA[
]]>
<![CDATA[					        g_aResults(Row,Fld) = CStr(oRS.Fields(Fld).Value)]]>
<![CDATA[
]]>
<![CDATA[					        fldStr = fldStr & "["& oRS.Fields(Fld).Value & "] "]]>
<![CDATA[
]]>
<![CDATA[				        end if]]>
<![CDATA[
]]>
<![CDATA[			        Next 'Fld]]>
<![CDATA[
]]>
<![CDATA[			        Writelog("RowSet: " & fldStr)	]]>
<![CDATA[
]]>
<![CDATA[			        oRS.MoveNext]]>
<![CDATA[
]]>
<![CDATA[		        Next 'Row]]>
<![CDATA[
]]>
<![CDATA[        		]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[		    ]]>
<![CDATA[
]]>
<![CDATA[        Set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[		End if 'IsAlive(oRS)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oConn.Errors.Count=0 Then]]>
<![CDATA[
]]>
<![CDATA[		ExecuteSQL = True]]>
<![CDATA[
]]>
<![CDATA[		Writelog("SUCCESS: SQL Statement executed properly") ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		ExecuteSQL = False]]>
<![CDATA[
]]>
<![CDATA[		Writelog("ERROR:The SQL statement DID NOT execute properly")]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("ExecuteSQL")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("ExecuteSQL")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="SmartSQL" access="public">
	<p name="sStringIn">
	</p>
	<p name="sPopulate">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    <b>1.</b>The SQL expression you want to execute.  Smart parameters are supported within the expression.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>2.</b>True/False value to enable or suppress populating value of any record returned from the SQL expression.<br/>]]>
<![CDATA[
]]>
<![CDATA[  Dim oRS ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[	Dim bSuppressResult]]>
<![CDATA[
]]>
<![CDATA[	Dim nStart]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  Dim Row]]>
<![CDATA[
]]>
<![CDATA[  Dim RowCount]]>
<![CDATA[
]]>
<![CDATA[  Dim Tmpstr]]>
<![CDATA[
]]>
<![CDATA[  Dim fldstr]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	bSuppressResult = False      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SmartSQL = False]]>
<![CDATA[
]]>
<![CDATA[	'oConn.Errors]]>
<![CDATA[
]]>
<![CDATA[	writelog("Checking connection...")]]>
<![CDATA[
]]>
<![CDATA[	If Not isobject(oConn) Or oConn is Nothing then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No DB Connection Object. Aborting Task.")]]>
<![CDATA[
]]>
<![CDATA[		nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State =0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DB Connection is Closed.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sStringIn = Trim(sStringIn)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_aResults = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Pre Smart Parameter Parsing")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If InStr(sPopulate,"0")>0 or ucase(sPopulate)="NO" or ucase(sPopulate)="FALSE" Then ]]>
<![CDATA[
]]>
<![CDATA[		bSuppressResult = True ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Suppressing Result to DCO Text property is ON")]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Convert Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sValue = MetaWord(sStringIn)]]>
<![CDATA[
]]>
<![CDATA[	If Len(sValue)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No smart parameter return value.")]]>
<![CDATA[
]]>
<![CDATA[		sSQL=sStringIn]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sSQL=sValue]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Post Smart Parameter Parsing")]]>
<![CDATA[
]]>
<![CDATA[	sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Constructed SQL :" & sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SmartSQL = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If InStr(Ucase(sSQL), "SELECT")=1 or InStr(Ucase(sSQL), "EXEC")=1 Then]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Set oRS = oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[      			]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oRS) then]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[        If oRS.State=0 Then       ]]>
<![CDATA[
]]>
<![CDATA[          writelog("RecordSet returned Closed.")                   ]]>
<![CDATA[
]]>
<![CDATA[		    ElseIf oRS.EOF Or oRS.BOF Then ]]>
<![CDATA[
]]>
<![CDATA[			    SmartSQL = False ]]>
<![CDATA[
]]>
<![CDATA[			    writelog("RecordSet Returns EOF or BOF. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[			    Call ConnErrHandler("EOF or BOF")]]>
<![CDATA[
]]>
<![CDATA[			    Exit Function]]>
<![CDATA[
]]>
<![CDATA[		    Else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		      Tmpstr = oRS.GetString]]>
<![CDATA[
]]>
<![CDATA[      	]]>
<![CDATA[
]]>
<![CDATA[		      Writelog("Query Return String: " & Tmpstr)]]>
<![CDATA[
]]>
<![CDATA[      			]]>
<![CDATA[
]]>
<![CDATA[		      If Len(Tmpstr)<> 0 Then]]>
<![CDATA[
]]>
<![CDATA[			      If bSuppressResult = False Then CurrentObj.Text = Left(tmpstr ,Len(tmpstr)-1)	]]>
<![CDATA[
]]>
<![CDATA[		      End If			]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		      RowCount = 0]]>
<![CDATA[
]]>
<![CDATA[		      oRS.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[		      While Not oRS.EOF	]]>
<![CDATA[
]]>
<![CDATA[			      RowCount = RowCount + 1]]>
<![CDATA[
]]>
<![CDATA[			      oRS.MoveNext()]]>
<![CDATA[
]]>
<![CDATA[		      Wend]]>
<![CDATA[
]]>
<![CDATA[      	]]>
<![CDATA[
]]>
<![CDATA[		      Writelog(Space(3) & (RowCount) & " Row(s) containing " & oRS.Fields.Count & " fields found.")]]>
<![CDATA[
]]>
<![CDATA[		      ReDim g_aResults(RowCount-1,oRS.Fields.Count-1)]]>
<![CDATA[
]]>
<![CDATA[      	]]>
<![CDATA[
]]>
<![CDATA[		      oRS.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[		      For Row = 0 To RowCount-1]]>
<![CDATA[
]]>
<![CDATA[			      fldStr = ""]]>
<![CDATA[
]]>
<![CDATA[			      For Fld = 0 To oRS.Fields.Count-1]]>
<![CDATA[
]]>
<![CDATA[				      if IsNull(oRS.Fields(Fld).Value) Then]]>
<![CDATA[
]]>
<![CDATA[					      g_aResults(Row,Fld) = ""]]>
<![CDATA[
]]>
<![CDATA[					      fldStr = fldStr & "["& "" & "] "]]>
<![CDATA[
]]>
<![CDATA[				      else]]>
<![CDATA[
]]>
<![CDATA[					      g_aResults(Row,Fld) = CStr(oRS.Fields(Fld).Value)]]>
<![CDATA[
]]>
<![CDATA[					      fldStr = fldStr & "["& oRS.Fields(Fld).Value & "] "]]>
<![CDATA[
]]>
<![CDATA[				      end if]]>
<![CDATA[
]]>
<![CDATA[			      Next 'Fld]]>
<![CDATA[
]]>
<![CDATA[			      Writelog("RowSet: " & fldStr)	]]>
<![CDATA[
]]>
<![CDATA[			      oRS.MoveNext]]>
<![CDATA[
]]>
<![CDATA[		      Next 'Row]]>
<![CDATA[
]]>
<![CDATA[      		]]>
<![CDATA[
]]>
<![CDATA[		      If IsObject(LogWindow) Then ValueUp.Text = GetFieldValue]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[       End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[       Set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[		End if 'IsAlive(oRS)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oConn.Errors.Count=0 Then]]>
<![CDATA[
]]>
<![CDATA[		SmartSQL = True]]>
<![CDATA[
]]>
<![CDATA[		Writelog("SUCCESS: SQL Statement executed properly") ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SmartSQL = False]]>
<![CDATA[
]]>
<![CDATA[		Writelog("ERROR:The SQL statement DID NOT execute properly")]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("SmartSQL")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("SmartSQL")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</f>
<af name="ClearLookupResults" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ' This action clears the stored results returned from a previous Lookup action such as PopulateWithResult.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ClearLookupResults=True]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Clearing Lookup Results.")]]>
<![CDATA[
]]>
<![CDATA[  g_aResults = ""]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************
' help.xml for Lookup 
'------------------------------------------------------------
'
' Version 8.0.1.15 PHofle 12/23/2010
'  * Converted to .Net Dll
'
' Version 8.0.1.20 PHofle 04/27/2011
'  * Updated help for actions LookupCurrentValue and LookupReturnValue
'    Help includes ODBC connection requirement and replacement
'    actions ExecuteSQL, SmartSQL to use as well as deprecation in 
'    future release. SPR 31668
'
' Version 8.1.0.21 PHofle 05/27/2011
'  * 32032 Removed support for SIT.
'
' Version 8.1.0.25 PHofle 06/03/2011
'  * Commented out help for DEPRECATED ACTIONS: 
'    LookupCurrentValue, LookupReturnValue
'
' Version 8.1.0.26 PHofle 06/03/2011
'  * Updated help for action PopulateWithResult to no longer reference
'    deprecated actions.
'  * Updated all help references to SelectSQL (Deprecated Action) to use
'    ExecuteSQL and/or SmartSQL instead.
'
' Version 8.1.0.27 RFerin 07/13/2011
'  * 29425 Updated help to emphesize the use of the applicaiton service and removed examples of DSN usage.
'
' Version 8.1.0.30 PHofle 04/19/2012
' * Updated help examples for actions PopulateWithResult, ClearLookupResults, ExecuteSQL, SmartSQL to 
'   reference opening the lookup database instead of the fingerprint database. SPR 34153
'
'************************************************************
]]>
  
<ref id="OpenConnection">
  <ap>
    The Data Source Name or Connection String.<br/><br/>

    If the action is establishing a connection with an Oracle database,
    or a SQL Server database using SQL Authentication, be sure to expand the DSN parameter
    by adding the correct Provider, user ID and Password.<br/><br/>
    
    Smart parameters are supported to prevent plain text credentials in the application rules.
  </ap>
  <h>
    This action uses the Connection String you provide as the parameter
    to open a connection to your LookUp database.
    <e> 
      <b>OpenConnection("@APPVAR(*/fingerprintconn:cs)")</b><br/>
      This example opens the fingerprint database and obtains the connection information from the Application Service.
      It is recomended to use the applicaiton service so passwords are kept hidden.<br/><br/>

      <b>Access:</b><br/>
      <b>OpenConnection("Provider=MSACCESS;DSN=C:\Datacap\1040EZ\1040ezLook.mdb;UID=;PWD=;")</b><br/><br/>
      
      <b>Oracle:</b><br/>
      <b>OpenConnection("Provider=OraOLEDB.Oracle.1;Password=mypassword;Persist Security Info=True;User ID=myuserid;Data Source=TM2")</b><br/><br/>
      
      <b>SQL Server Authentication:</b><br/>
      <b>OpenConnection("Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=mycatalog;Data Source=mysource")</b><br/>
    </e>
    </h>
    <lvl>All.</lvl>
    <ret><b>True</b> if the action results in a connection to the database. Otherwise, <b>False.</b></ret>
    <see><scr>CloseConnection</scr>
    </see>
     </ref>
  
 <ref id="CloseConnection">
  <ap>None.</ap>
  <h>
     Closes an open connection to your Lookup database.<br/><br/>

	   Usually, this action is placed in a RuleSet that is separate from the RuleSet that opens 
     the connection and stores the data.<br/><br/>

     LookupDBClose RuleSet, for example, is run at the Batch level after all data has been 
     exported from the batch to the specified database.<br/><br/><e><b>CloseConnection()</b><br/><br/>

       This action closes the previously opened connection to the Lookup database.<br/><br/>

       This action is usually part of a separate RuleSet that prevents the 
       need to repeatedly open the connection to the database. (You can 
       open the connection once in the first RuleSet, use the database from all 
       documents and pages in the batch, then close the connection once in the second RuleSet.) 
     </e>
    </h>
    <lvl>All, but generally used as part of a separate RuleSet at the Batch level.</lvl>
    <ret><b>True,</b> even if the connection is already closed.
  </ret>
    <see><scr>OpenConnection</scr>
    </see>
     </ref>
 <!-- NOTE: LookupCurrentValue is DEPRECATED 06/03/2011 -->
 <!--
 <ref id="LookupCurrentValue">
  <ap>
     Four clauses of a SQL SELECT statement (see the example):<br/>
	- SELECT clause: designates the column or columns to be checked.<br/>
	- FROM clause:  identifies the source table within the previously opened database.<br/>
	- WHERE clause: specifies the matching criteria.<br/>
	- AND clause (optional): limits the statement's scope.<br/><br/><b>Note:</b>If the action is looking for values in an ORACLE database, 
    the parameters must be in UPPER CASE.
  </ap>
  <h>
    Queries an open LookUp database to see if a Field object's captured value is also a 
    value in the database. Requires ODBC Type database connection.<br/><br/><e>
      OpenConnection("InvoiceLook")<br/><b>LookupCurrentValue("PONumber,Vendor,PONumber")</b><br/>
		  CloseConnection()<br/><br/>

		  This sequence looks in the Vendor table of the InvoiceLook database to see if the captured 
      value of the current Field object is also a value in the database.<br/><br/>

	  	The LookupCurrentValue action uses its parameters to assemble a SQL SELECT statement 
      with these clauses:<br/><br/>

		  SELECT PONumber(column)<br/>
  		FROM Vendor(table)<br/>
		  WHERE PONumber(captured value)<br/><br/>

		  The action returns <b>True</b> if the PONumber column in the Vendor table
      contains a value equal to the captured value of the current Field object.

      NOTE: This action will be deprecated in a future release. It's functionality has been replaced by actions "ExecuteSQL" and "SmartSQL".
      
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>False</b> if the action is not applied at the Field level;
    if the database connection was not opened; or the captured value is not in the database.
    Otherwise, <b>True.</b></ret>
    <see><scr>LookUpReturnValue</scr>
    </see>
     </ref>
 -->
 <!-- NOTE: LookupReturnValue is DEPRECATED 6/3/2011  -->
 <!--
 <ref id="LookupReturnValue">
  <ap> 
    Four clauses of a SQL SELECT statement (see the example):<br/>
    - SELECT clause: designates the column or columns to be checked.<br/>
    - FROM clause:  identifies the source table within the previously opened database.<br/>
    - WHERE clause: specifies the matching criteria.<br/>
    - AND clause (optional): limits the statement's scope.<br/><br/><b>Note:</b>If the action is looking for values in an ORACLE database, 
    the parameters must be in UPPER CASE.
	</ap>
  <h>
    Uses the captured value associated with the current Field object to determine if a
    table in an open LookUp database contains a corresponding value. Requires ODBC Type database connection.<br/><br/>

    If there is a match (True), the <scr>PopulateWithResult</scr>
     action updates 
    the Data file of the current page with the value.<br/><br/><e>
      OpenConnection("@APPVAR(*/fingerprintconn:cs)")<br/>
      <b>LookupReturnValue("VendorName,Vendor,VendorID")</b><br/>
		  PopulateWithResult("1,FALSE")<br/>
		  CloseConnection()<br/><br/>

      This sequence looks in the Vendor table of the InvoiceLook database, for a VendorID 
      value that matches the captured value of the current VendorID  Field object.<br/><br/>

      If the search is successful (True), the follow-up PopulateWithResult
      action assigns the Vendor Name value to the Data file of the current page, as the
      VendorName field's captured value.

      NOTE: This action will be deprecated in a future release. It's functionality has been replaced by actions "ExecuteSQL" and "SmartSQL".
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>False</b> if the action is not applied at the Field level;
    the database connection was not opened; or the captured value is not in the database.
    Otherwise, <b>True.</b></ret>
    <see><scr>LookupCurrentValue, PopulateWithResult</scr>
    </see>
     </ref>
  -->
  
 <ref id="PopulateWithResult">
  <ap><b>1.</b> A number  indicating which value in a record retrieved by an
    earlier <scr>ExecuteSQL</scr>
     or <scr>SmartSQL</scr>
     action is to be assigned to the current
    Field object (and added to the Data file of the current page.)<br/><br/>

    "1" refers to the first column in a recordset, "2" refers to the second column, etc.<br/><br/><b>2.</b> True or False. True causes the action to fail if the action
    returns a recordset with multiple lines. False permits the action to accept a recordset with multiple
    lines but to use values in the first record of the recordset.
  </ap>
  <h>
    Populates a Field object with a database value retrieved by
    a <scr>ExecuteSQL</scr> or <scr>SmartSQL</scr> action.<br/><br/>

    This action allows multiple rules to populate multiple Field objects with data from a
    single database record (see the example below.)<br/><br/><e>
      (Field #1)<br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      ExecuteSQL(""Select * From Vendor Where VendorID = %s;",VendorID")<br/>
      <b>PopulateWithResult("1,FALSE")</b><br/><br/>

      (Field #2)<br/><b>PopulateWithResult("2,FALSE")</b><br/><br/>

      In the example, the <scr>ExecuteSQL</scr>
     action of the RuleSet applied to Field #1
      retrieves the recordset (if it exists). The <scr>PopulateWithResult</scr>
     action places
      the value of the first record's first column into the field where the rule has been applied.<br/><br/>

      The <scr>PopulateWithResult</scr>
     action of a rule applied to Field #2 populates the field with
      the value of the first record's second column.<br/><br/><b>False</b> means that the action can accept a recordset with multiple records but will
      extract value(s) from the first record only.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if the second parameter is "True" and a previous <scr>ExecuteSQL</scr> or <scr>SmartSQL</scr> action finds 
    a recordset with only one record.<br/><br/><b>True</b> if the second parameter is "False" and a previous ExecuteSQL (or SmartSQL) 
    action finds a recordset with one or more records.<br/><br/>

    Otherwise, <b>False.</b></ret>
    <see><scr>ExecuteSQL</scr>,<scr>SmartSQL</scr>
    </see>
     </ref>
  
 <ref id="ExecuteSQL">
  <ap><b>1.</b>The SQL expression you want to execute surrounded by quotation marks (" ")<br/>
    '%s' or %s can be substituted in the SQL expression to represent a field value. <br/>
    If %s represents a text field, it must be surrounded by ' '. <br/>
    If %s represents a numeric field, it appears without surrounding apostrophe characters.<br/><br/><b>2,3+</b>Field names whose captured values you want to use in the SQL expression (see the example).<br/></ap>
  <h>
    Executes the SQL statement you enter in the first parameter. Field values can be substituted
    for "%s" in the statement.<br/><br/><e>
      This sequence opens a connection to the InvoiceLook database.  Next, it inserts values
      into the CompanyCode and Type columns of the Vendor table:<br/><br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      <b>ExecuteSQL("INSERT INTO Vendor (CompanyCode,Type) VALUES ('MQSW','New')")</b><br/><br/>
      
      Here, dbVendorID is a numeric field while dbVendorname is a text field:<br/><br/>
      OpenConnection("@APPVAR(*/fingerprintconn:cs)")<br/>
      ExecuteSQL(""SELECT CompanyCode  FROM Vendor WHERE dbVendorID = %s AND dbVendorName = '%s';",VendorID,VendorName")
      <br/><br/></e>
    </h>
    <lvl>All.</lvl>
    <ret><b>True</b> if the SQL statement executes successfully, select statements must also
    return a value.<br/><b>False,</b> if it does not.
  </ret>
     </ref>
  
 <ref id="SmartSQL">
  <ap><b>1.</b>The SQL expression you want to execute.  Smart parameters are supported within the expression.<br/><b>2.</b>True/False value to enable or suppress populating value of any record returned from the SQL expression.<br/></ap>
  <h>
    Executes the SQL statement you enter in the first parameter.<br/><br/><e>
      This sequence opens a connection to the InvoiceLook database.  Next, it inserts values
      into the CompanyCode and Type columns of the Vendor table:<br/><br/>

      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      SmartSQL("INSERT INTO Vendor (CompanyCode,Type) VALUES ('MQSW','New')")
      <br/><br/>
      
      Here, dbVendorID is a numeric field while dbVendorname is the calling text field:<br/><br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      <b>SmartSQL("SELECT CompanyCode FROM Vendor WHERE dbVendorID =+@P\VendorID+ AND dbVendorName = '+@F+';",YES)</b><br/><br/></e>
    </h>
    <lvl>All.</lvl>
    <ret><b>True</b> if the SQL statement executes successfully, select statements must also
    return a value.<br/><b>False</b> if the SQL statement does not execute successfully.
  </ret>
     </ref>
  
 <ref id="ClearLookupResults">
  <ap>None.</ap>
  <h>
    This action clears the stored results returned from a previous Lookup action such as
    <b>PopulateWithResult.</b><br/><br/><e>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      ExecuteSQL("SELECT NAME, ADDRESS FROM Vendor;")<br/>
      PopulateWithResult("1")<br/><b>ClearLookupResults()</b><br/><br/>

      Here, ClearLookupResults() clears the stored results of the Vendor Name and Address.
    </e>
    </h>
    <lvl>All.</lvl>
    <ret>Always <b>True.</b></ret>
     </ref>
 </help>
 </rrx>
<rrx namespace="Picture" src="c:\datacap\RRS\Picture.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="PIC_FormatFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	PIC_FormatFields = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.m_bFilter = False]]>
<![CDATA[
]]>
<![CDATA[	PIC_FormatFields = oPictureStringFormater.Process(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="PIC_FilterFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	PIC_FilterFields = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.m_bFilter = True           ' Replace low confidence with a space.]]>
<![CDATA[
]]>
<![CDATA[	PIC_FilterFields = oPictureStringFormater.Process(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PIC_ValidateField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  Dim oSetupNode]]>
<![CDATA[
]]>
<![CDATA[  Dim nSetupStatus]]>
<![CDATA[
]]>
<![CDATA[  Dim bHiddenField]]>
<![CDATA[
]]>
<![CDATA[  Dim sMsg]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  PIC_ValidateField = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Object must be of Type Field. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    PIC_ValidateField = False]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  bHiddenField=False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.m_bFilter = False]]>
<![CDATA[
]]>
<![CDATA[  bReturn = oPictureStringFormater.Validate(CurrentObj)    ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  If bReturn = False Then ]]>
<![CDATA[
]]>
<![CDATA[		sMsg = RRState.LoadString("picture","CharOutOfScope","Field '{0}' value of '{1}' does not match the picture string format '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMsg = replace(sMsg,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMsg = replace(sMsg,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[    sMsg = replace(sMsg,"{2}",CurrentObj.Variable("PictureString"))]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sMsg)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupNode = CurrentObj.SetupNode]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If oSetupNode is nothing then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Unable to get setupNode for field " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    If Trim(cstr(oSetupNode.Variable("STATUS")))="-1" then bHiddenField=True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Trim(cstr(CurrentObj.STATUS))="-1" then bHiddenField=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If bHiddenField=False then PIC_ValidateField = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="PIC_SetPictureCharacter" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim PicCharNum]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  PIC_SetPictureCharacter = FALSE]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  PicCharNum = Left(StrParam,1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if Len(StrParam) < 3 then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if Not IsNumeric(PicCharNum) then    'first character must be a digit]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if mid(StrParam,2,1) <> "," then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  CustomPicCharAr(PicCharNum) = Right(StrParam,Len(StrParam) - 2)  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Picture Character " & cStr(PicCharNum) & " is set to: " &  CustomPicCharAr(PicCharNum))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  PIC_SetPictureCharacter = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PIC_ApplyPictureString" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim PicRepeatChar]]>
<![CDATA[
]]>
<![CDATA[  Dim i]]>
<![CDATA[
]]>
<![CDATA[  Dim CharaterSet]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  PIC_ApplyPictureString = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Action is for use on a field object only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if Len(StrParam) > len(CurrentObj.Text) then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Picture String is longer than the detected field value.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  PicRepeatChar = Right(StrParam,1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  While len(StrParam) < len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[     StrParam = StrParam & PicRepeatChar   ]]>
<![CDATA[
]]>
<![CDATA[  wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Applying Picture String: " & StrParam & " to: " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  For i = 1 to Len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Checking " & mid(CurrentObj.Text,i,1) & " against picture character " & mid(StrParam,i,1) ) ]]>
<![CDATA[
]]>
<![CDATA[     if Not oPictureStringFormater.IsCharValid(cStr(mid(CurrentObj.Text,i,1)), cStr(mid(StrParam,i,1))) then   ]]>
<![CDATA[
]]>
<![CDATA[       'didn't find the current character in the characterset]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Picture Validation failed at character position " & cStr(i))    ]]>
<![CDATA[
]]>
<![CDATA[       Exit Function ]]>
<![CDATA[
]]>
<![CDATA[     end if  ]]>
<![CDATA[
]]>
<![CDATA[  next 'i]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  PIC_ApplyPictureString = TRUE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PIC_ReplaceBlankField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim TrimValue ' The current field value with spaces trimmed at front and end.]]>
<![CDATA[
]]>
<![CDATA[  Dim numChars  ' Number of characters in the new field, if changed.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  PIC_ReplaceBlankField = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  call Writelog("PIC_ReplaceBlankField Input: " & strParam)   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (strParam = "") Then]]>
<![CDATA[
]]>
<![CDATA[    Call Writelog("PIC_ReplaceBlankField requires a parameter. Exiting.")    ]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("PIC_ReplaceBlankField")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType <> 3) Then]]>
<![CDATA[
]]>
<![CDATA[    Call Writelog("PIC_ReplaceBlankField Object must be of Type Field. Exiting.")    ]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("PIC_ReplaceBlankField")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  PIC_ReplaceBlankField = True]]>
<![CDATA[
]]>
<![CDATA[  TrimValue = trim(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[  If (TrimValue = "") Then]]>
<![CDATA[
]]>
<![CDATA[    Call Writelog("Replacing empty field " & CurrentObj.Text & " with: " & strParam)    ]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Text = strParam        ]]>
<![CDATA[
]]>
<![CDATA[    numChars = len(strParam)]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.ConfidenceString = String(clng(numChars), "1") ' Set new confidence value to low]]>
<![CDATA[
]]>
<![CDATA[  Else  ]]>
<![CDATA[
]]>
<![CDATA[    Call Writelog("Field is not empty: " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("PIC_ReplaceBlankField")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<help>
  <![CDATA[
'----------------------------------------------------------------------
' Help.xml for picture.rrx
'----------------------------------------------------------------------
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'----------------------------------------------------------------------
 ]]>
	<ref id="PIC_FormatFields">
		<ap>None.</ap>
    <h>
      Lowers the Confidence Rating of any character in a field that does not satisfy the <i>PictureString</i> criteria.<br/><br/>
      This action adjusts the character confidence of a field, and optionally replaces characters, based on the picture string
      that has been set for the field.  It is very similar to the <b>FilterFields</b> action.<br/><br/>

      This action has two roles.  If a character in the field does not match the picture string format defined
      for that field:<br/><br/>

      1. It replaces any "problem" characters with an alternative character from a
      secondary recognition engine if one exists.  If an alternative recognition character does
      not exist, then the original character is left unchanged.<br/><br/>

      2. It lowers the Confidence Rating of any character in a field that does not
      satisfy the picture string's criteria.<br/><br/>

      Note: This Action is recursive and will affect all child fields of the calling node.<br/><br/>

      <b>Picture Strings:</b><br/>
      This action works with picture strings that are defined for a field.  The picture string
      must be stored in a field variable called '<i>PictureString</i>'.  Picture strings improve and filter recognition
      results, and are used to limit characters typed into that field during verify. The <b>PIC_FormatFields</b>
      and <b>PIC_FilterFields</b>  actions can be called to “enforce” the
      PictureString after recognition rules are invoked. The PIC_ApplyPictureString action
      is an exception that does not use the PictureString variable.<br/><br/>

      Recognition actions do not pay attention to this property, individual recognition engines have their own
      parameters to help guide the recognition.  The Web Verify task always enforces PictureString.
      Thick client Verify panels constructed by
      Batch Pilot Autoform also enforce PictureString specifications.<br/><br/>

      <b>PIC_FilterFields</b> replaces non-matching characters with low confidence spaces, <b>PIC_FormatFields</b>
      just lowers the confidence. The DCEdit control enforces them during verify.<br/><br/>

      There are two typical ways that the picture values can be set in PictureString.<br/><br/>
      <b>1.</b> Use the rrunner action rrSet in a ruleset.  With this action, you can specify the PictureString
      variable and set it to the desired value.<br/>
      <b>2.</b> In the Zones tab of Datacap Studio, right click on the desired field and choose "Manage Variables".
      Enter the new variable PictureString and set its value to the desired picture string characters.<br/><br/>

      While not direct input to this action as a standard parameter, here are the valid picture string characters
      that can be set in the PictureString field variable which are then used by this action.<br/><br/>

      A: Alphabetic characters only or a space. Numeric and/or punctuation characters are not valid.<br/>
      a: Alphabetic, space and punctuation characters.<br/>
      D: Dates. The dates must be expressed with numeric characters. You can delimit months, dates, and years with hyphens, periods, and forward slashes.<br/>
      F: Float numbers, which are fractional numbers. To accommodate fractional values, this picture string allows you to
      include both numbers and a period (for the decimal separator). The F character also allows minus signs to represent negative numbers.<br/>
      f: Numeric and punctuation characters.<br/>
      L: Lower-case alphabetic and space characters.<br/>
      l: Lower-case alphabetic, space and punctuation characters.<br/>
      N: Numeric characters only.<br/>
      n: Uppercase alphabetic, numeric or space characters.
      P: Punctuation and space characters.<br/>
      T: Time values. These values are expressed in numbers with a colon. In addition, the characters P, M, and A are allowed to distinguish between morning and afternoon times, and colon characters are allowed to delimit hours, minutes, and seconds.<br/>
      U: Upper-case alphabetic and space characters.<br/>
      u: Upper-case alphabetic, space and punctuation characters.<br/>
      X: Alphabetic, space and numeric characters.<br/>
      x: Alphabetic, space, numeric and punctuation characters.<br/>
      Z: Any character.<br/>
      #: Numeric characters and the minus sign.<br/><br/>

      PIC_SetPictureCharacter can be used to define up to 10 additional application specific picture strings
      at runtime, identified as 0 through 9.
      <e>
        rrSet("AN,@F.PictureString")<br/>
        <b>PIC_FormatFields()</b><br/><br/>

        This example expects the current field to contain a single alphabetic character followed by an
        unlimited number of digits.  Here the <i>PictureString</i> variable is set at runtime, but
        it can instead be configured at design time in the setup DCO in Datacap Studio.
      </e>
    </h>
		<lvl>All levels.</lvl>
		<ret>
			Always <b>True.</b>
		</ret>
		<see>PIC_FilterFields, PIC_ValidateField, PIC_SetPictureCharacter</see>
	</ref>
	<ref id="PIC_ValidateField">
		<ap>None.</ap>
		<h>
			Checks the value of all characters in a field against that field's <i>PictureString</i> criteria.<br/><br/>
			If a character in the field does not match the picture string format defined
			for that field, it lowers the Confidence Rating of any character in a field that does not
			satisfy the Picture String's criteria.  The criteria is stored in the <i>PictureString</i>
			variable that is bound to the field.<br/><br/>

			Note: Fields with a status of '-1' (Hidden) are checked but this action will not return false if
			the value does not match the picture string criteria.<br/><br/>

			While not direct input parameters to this action, this action works with picture strings
			that are defined for a field.  See the <b>PIC_FormatFields</b>
			action for a list of all available picture string codes and information about the PictureString variable.<br/><br/>
			<e>
				<b>PIC_ValidateField()</b>
			</e>
		</h>
		<lvl>Field level only.</lvl>
		<ret>
			<b>False</b> if the field value does not satisfy the field's Picture String criteria.
			Otherwise <b>True.</b>
		</ret>
		<see>PIC_FormatFields, PIC_FilterFields, PIC_SetPictureCharacter</see>
	</ref>
	<ref id="PIC_SetPictureCharacter">
		<ap>
			Two comma separated parameters:<br/>
			1. The picture string identifier.  This must be a value between 0 through 9.<br/>
			2. A string of characters to associate with the picture string identifier (the first parameter).
		</ap>
		<h>
			Configures application specific picture strings.<br/><br/>
			In addition to the predefined character strings, custom picture strings can be configured.  The picture string
			values 0 through 9 can be configured to allow validations that are not covered by the predefined settings.<br/><br/>

			It is possible to configure your verify panel edit control to restrict keyboard entry based on picture strings
			when you use the '<i>PictureString</i>' field variable.  Note that only predefined picture strings work with
			the edit control.  Any custom picture strings created by PIC_SetPictureCharacater action will not cause the edit control
			to restrict user input.
			<e>
				<b>PIC_SetPictureCharacter("0,01")</b><br/>
				<b>PIC_SetPictureCharacter("1,0123")</b><br/>
				<b>PIC_SetPictureCharacter("2,-./")</b><br/>
				PIC_ApplyPictureString("0N21N2NN")<br/><br/>

				This example creates custom picture strings for 0, 1 and 2.  They are then used here to provide
				tighter control on the allowed input.  "0N21N2NN" format matches a typical 6 digit date specification
				like "01/07/67".<br/><br/>

				<b>PIC_SetPictureCharacter("0,01")</b><br/>
				<b>PIC_SetPictureCharacter("1,0123")</b><br/>
				<b>PIC_SetPictureCharacter("2,-./")</b><br/>
				PIC_ValidateField()<br/><br/>

				This example is the same as the one above it, the difference is that the picture string has
				been setup in the PictureString variable in Datacap Studio, so it is not seen here.
			</e>
		</h>
		<lvl>Any level.</lvl>
		<ret>
			<b>False,</b> if the parameter input is invalid.  Otherwise, <b>True.</b>
		</ret>
		<see>PIC_FormatFields, PIC_FilterFields, PIC_ApplyPictureString</see>
	</ref>
	<ref id="PIC_ReplaceBlankField">
		<ap>
			A character or string that will be placed into the field if it is blank.<br/>
		</ap>
		<h>
			If a field is blank, it replaces it with a single character.<br/><br/>
			If a field is empty or only contains spaces, it is replaced with the character or string that is passed in as a parameter.
			If the field is replaced with the input parameter, the confidence is changed to a low confidence of 1.
			<e>
				<b>PIC_ReplaceBlankField("~")</b>
			</e>
		</h>
		<lvl>
			Field level.
		</lvl>
		<ret>
			<b>False</b> if it is called at the wrong level or if the parameter is missing, otherwise <b>True.</b>
		</ret>
	</ref>
	<ref id="PIC_FilterFields">
		<ap>None.</ap>
		<h>
			Replaces a character and adjusts the confidence based on the <i>PictureString</i> defined for the field.<br/><br/>
			Lowers the Confidence Rating of any character in a field that does not satisfy the Picture String's criteria
			and replaces the problem character with an alternative character from a secondary recognition engine if one exists.
			If an alternative character is not available, the problem character will be replaced with a low confidence space.
			It is very similar to the FormatFields action.<br/><br/>

			This action has two roles.  If a character in the field does not match the picture string format defined
			for that field:<br/><br/>

			1. It replaces any "problem" characters with an alternative character from a
			secondary recognition engine if one exists.  If an alternative recognition character does
			not exist, then the original character is changed to a space and marked as low confidence.<br/><br/>

			2. It lowers the Confidence Rating of any character in a field that does not
			satisfy the Picture String's criteria.<br/><br/>

			Note: This Action is recursive and will affect all child fields of the calling node.<br/><br/>

			While not direct input to this action, this action works with picture strings
			that are defined for a field.  See the <b>PIC_FormatFields</b>
			action for a list of all available picture string codes and information about the <i>PictureString</i> variable.<br/><br/>
			<e>
				rrSet("XxN,@F.PictureString")<br/>
				<b>PIC_FilterFields()</b><br/><br/>
				This example expects the current field to have the first character be either a alphabetic character or a digit,
				the second character can be an alphabetic character, digit or punctuation character and the remaining characters
				must only be digits.
			</e>
		</h>
		<lvl>All levels.</lvl>
		<ret>
			Always <b>True.</b>
		</ret>
		<see>PIC_FormatFields, PIC_ValidateField</see>
	</ref>
	<ref id="PIC_ApplyPictureString">
		<ap>
			The picture string to validate the field.
		</ap>
		<h>
			Validates the current field using a runtime <i>PictureString</i> as an argument.<br/><br/>
			Using the provided picture string, this action will test that each of the characters in the current field
			are allowed.  The provided picture string must be the same length or shorter than the data
			on the field.  If the picture string is shorter, then the last character of the picture
			string will be used to validate all remaining characters in the field.<br/><br/>

			See the help for action PIC_FormatFields for an overview of picture strings.
			Unlike PIC_FormatFields which uses the PictureString variable, PIC_ApplyPictureString
			accepts the picture string as a variable only.
			<e>
				PIC_SetPictureCharacter("0,01")<br/>
				PIC_SetPictureCharacter("1,0123")<br/>
				PIC_SetPictureCharacter("2,-./")<br/>
				<b>PIC_ApplyPictureString("0N21N2NN")</b><br/><br/>

				This example creates custom picture strings for 0, 1 and 2.  They are then used here to provide
				tighter control on the allowed input.  "0N21N2NN" format matches a typical 6 digit date specification
				like "01/07/67".
			</e>
		</h>
		<lvl>Field level.</lvl>
		<ret>
			<b>False,</b> if called at the wrong level, if the picture string is longer than the field value
			or if the field fails the picture string validation.  Otherwise, <b>True.</b>
		</ret>
	</ref>
</help></rrx>
<rrx namespace="POLR" src="c:\datacap\RRS\POLR.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="CallPOLR" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<br>
	</br>
	<br>
	</br>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[Dim SettingsFile ]]>
<![CDATA[
]]>
<![CDATA[Dim oObj]]>
<![CDATA[
]]>
<![CDATA[Dim oConn]]>
<![CDATA[
]]>
<![CDATA[Dim oCmd]]>
<![CDATA[
]]>
<![CDATA[Dim oRS]]>
<![CDATA[
]]>
<![CDATA[Dim oParam]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[Dim bQuantityMatch]]>
<![CDATA[
]]>
<![CDATA[Dim bItemIDMatch]]>
<![CDATA[
]]>
<![CDATA[Dim bPriceMatch]]>
<![CDATA[
]]>
<![CDATA[Dim bWriteUnusedPOLines]]>
<![CDATA[
]]>
<![CDATA[Dim retn]]>
<![CDATA[
]]>
<![CDATA[Dim strConnection]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CallPOLR = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = SPLIT(strParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Wrong number of parameters, expecting(ShowPOLR as TRUE or FALSE, ADODB PONum constant value).  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SettingsFile = DCO.Variable("Settings File")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Settings file:" & SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    retn = Pilot.GetProfileString("POLR","Qty","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[    If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 73 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 73 reading settings file."]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       If Retn = "1" Then]]>
<![CDATA[
]]>
<![CDATA[          bQuantityMatch = True]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          bQuantityMatch = False]]>
<![CDATA[
]]>
<![CDATA[       End If         ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    retn = Pilot.GetProfileString("POLR","ItemID","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[    If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 74 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 74 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       If Retn = "1" Then]]>
<![CDATA[
]]>
<![CDATA[          bItemIDMatch = True]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          bItemIDMatch = False]]>
<![CDATA[
]]>
<![CDATA[       End If         ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    retn = Pilot.GetProfileString("POLR","Price","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[    If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 75 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 75 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       If Retn = "1" Then]]>
<![CDATA[
]]>
<![CDATA[          bPriceMatch = True]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          bPriceMatch = False]]>
<![CDATA[
]]>
<![CDATA[       End If         ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    retn = Pilot.GetProfileString("POLR","WriteUnusedPOLInes","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[    If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 76 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 76 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       If Retn = "1" Then]]>
<![CDATA[
]]>
<![CDATA[          bWriteUnusedPOLines = True]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          bWriteUnusedPOLines = False]]>
<![CDATA[
]]>
<![CDATA[       End If         ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Right(Pilot.Station,5) = "-Test" Then    'please do not edit the two lines below]]>
<![CDATA[
]]>
<![CDATA[       strConnection = Pilot.GetProfileString("Database","TestPODSN","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[       sSQL = Pilot.GetProfileString("Database","TestPOLookup","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[	  Else]]>
<![CDATA[
]]>
<![CDATA[       strConnection = Pilot.GetProfileString("Database","PODSN","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[       sSQL = Pilot.GetProfileString("Database","POLookup","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[	  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    Writelog("PODSN:" & strConnection)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Smart Parameter]]>
<![CDATA[
]]>
<![CDATA[    sSmartParam=MetaWord(strConnection)]]>
<![CDATA[
]]>
<![CDATA[    If sSmartParam<>"" Then]]>
<![CDATA[
]]>
<![CDATA[      strConnection=sSmartParam]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'FIPS decryption]]>
<![CDATA[
]]>
<![CDATA[    strIN=strConnection]]>
<![CDATA[
]]>
<![CDATA[    bRes = [securecall]strIN,strConnection[/securecall]   ]]>
<![CDATA[
]]>
<![CDATA[    If bRes=False Then Writelog("Value was not decrypted.")]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[    strConnection = FormatADOConn(strConnection)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set oConn = CreateObject("ADODB.Connection")]]>
<![CDATA[
]]>
<![CDATA[ 	  oConn.Open(strConnection)]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[ 	  If oConn.State <> 1 Then]]>
<![CDATA[
]]>
<![CDATA[ 	    Writelog("Unable to open connection to PO database.  Contact administrator.")]]>
<![CDATA[
]]>
<![CDATA[            CurrentObj.Variable("POLRresult") = "Unable to open PO Database."]]>
<![CDATA[
]]>
<![CDATA[ 	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[ 	  End If   	 ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Set oCmd = CreateObject("ADODB.Command")]]>
<![CDATA[
]]>
<![CDATA[   	Set oParam = oCmd.CreateParameter("PONum",cLng(ParamAr(1)),1,50)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    oCmd.CommandText = sSQL]]>
<![CDATA[
]]>
<![CDATA[    oCMD.CommandType = 1]]>
<![CDATA[
]]>
<![CDATA[    oCmd.ActiveConnection = oConn]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    oCmd.Parameters.Append(oParam)]]>
<![CDATA[
]]>
<![CDATA[    Dim oField]]>
<![CDATA[
]]>
<![CDATA[    Set oField=Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set oField = CurrentObj.FindChild("PO_Number")]]>
<![CDATA[
]]>
<![CDATA[    if oField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "PO_Number field not found."]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Could not find PO_Number field.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[    if Trim(CurrentObj.FindChild("PO_Number").Text) = "" then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Variable("POLRresult") = "Missing PO Number"]]>
<![CDATA[
]]>
<![CDATA[         Writelog("PO number was blank.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    oCmd(0).Value = CurrentObj.FindChild("PO_Number").Text]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[    Set oRS = oCmd.Execute]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If oRS.BOF Or oRS.EOF Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("PO was not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Variable("POLRresult") = "PO was not found"]]>
<![CDATA[
]]>
<![CDATA[	  Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Pilot.SaveData(oPage)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If InStr(uCase(Pilot.DCOFile),"\BATCHES\") > 0 Then]]>
<![CDATA[
]]>
<![CDATA[      DCO.Write(Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      DCO.Write(Pilot.BatchDir & "\" & Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   Set oObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oObj = CreateObject("POLR.POLRClass")]]>
<![CDATA[
]]>
<![CDATA[   Writelog("POLR class instantiated")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If InStr(uCase(Pilot.DCOFile),"\BATCHES\") > 0 Then]]>
<![CDATA[
]]>
<![CDATA[      oObj.Init(Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      oObj.Init(Pilot.BatchDir & "\" & Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Init Done")   ]]>
<![CDATA[
]]>
<![CDATA[   oObj.SendPage(oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Sent pageID: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[   oObj.ClearPOLRVariables()]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Cleared POLR variables")]]>
<![CDATA[
]]>
<![CDATA[   oObj.WriteUnusedPOLines(bWriteUnusedPOLines)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Setting WriteUnusedPOLines: " & cStr(bWriteUnusedPOLines) )]]>
<![CDATA[
]]>
<![CDATA[   Call oObj.SetMatchCriteria(bQuantityMatch,bItemIDMatch,bPriceMatch)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Initial input done")]]>
<![CDATA[
]]>
<![CDATA[   retn = Pilot.GetProfileString("POLR","PriceTolerance","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[   If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 78 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 78 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[       If IsNumeric(retn) Then]]>
<![CDATA[
]]>
<![CDATA[          oObj.SetPriceTolerance(cDbl(retn))]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Set tolerance")]]>
<![CDATA[
]]>
<![CDATA[   oObj.SendRecordset(oRS)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Sent Recordset")]]>
<![CDATA[
]]>
<![CDATA[   retn = Pilot.GetProfileString("POLR","SeparatorCharacter","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[   If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 77 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 77 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[       oObj.SetSeparatorCharacter(retn)  ]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Set separator char")]]>
<![CDATA[
]]>
<![CDATA[   if uCASE(ParamAr(0)) = "TRUE" then]]>
<![CDATA[
]]>
<![CDATA[     writelog("Ready to show form")]]>
<![CDATA[
]]>
<![CDATA[     oObj.ShowForm()]]>
<![CDATA[
]]>
<![CDATA[     writelog("Form done")]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   oObj.SavePOLRData()]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Setting POLRresult: " & cStr(oObj.GEtUnmatchedNum))  ]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("POLRresult") = cStr(oOBj.GetUnmatchedNum) & " unmatched line item(s)."]]>
<![CDATA[
]]>
<![CDATA[   Writelog("POLRresult: " & CurrentObj.Variable("POLRresult"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("POLR done")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   bResult = oPage.Read(oPage.variable("DATAFILE"))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   oConn.Close]]>
<![CDATA[
]]>
<![CDATA[   Set oObj = Nothing ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'*****************************************************************************
' help.xml for POLR
'-----------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'*****************************************************************************
'
' Version 8.1.0.06 PHOFLE 05/25/2012
'  * New help xml 
'
'*****************************************************************************

]]>

<ref id="CallPOLR">
    <ap>
      The ADOBDB constant number for the PO number field.  When using bind variables, the data type
      of the PO Number is specified with this action.
    </ap>
    <h>
      This action is used to pre-match invoice line items with the PO prior to verify operator verification.
      The record set for the PO is retrieved using the information in the settings.ini.
      This calls the record set according to the DSN in the settings INI.
      PODSN and POLookup indicate how to obtain the record set.
      The record set is expected to be the line items for the PO for the current document and
      is keyed off of the PO number.  It then uses the POLR logic to perform the automatic matching.<br/><br/>
      
      NOTE: The TestPODSN and PODSN ini entries support smart parameters to allow for secure connection strings.
      <br/><br/>

      The settings ini file must contain values for these keys:<br/>
      [POLR]<br/>
      Qty=<br/>
      ItemID=<br/>
      Price=<br/>
      WriteUnusedPOLInes=<br/>
      PriceTolerance=<br/>
      SeparatorCharacter=<br/><br/>

      If the station name has a suffix of "-Test" then this key must exist:<br/>
      [Database]<br/>
      TestPODSN=<br/>
      TestPOLookup=<br/><br/>

      If the station name does not have a suffix of "-Test" then this key must exist:<br/>
      [Database]<br/>
      PODSN=<br/>
      POLookup=
      <e>
        <b>CallPOLR("200")</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>

  </ref>
  
  
</help>
</rrx>
<rrx namespace="rrunner" src="c:\datacap\RRS\rrunner.dll">

<g>
</g>
<ifrrx>
</ifrrx>
<ifrra>
</ifrra>
<g>
</g>
<ifrrx>
</ifrrx>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<af name="Status_Preserve_ON" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  If gbRRX = true then]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleFailure="Call StatCounter():Call OnRuleEnd()"]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd()"  ]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRulesetStart=""]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Call PreserveStatus(bInter,bDebug,True)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	Status_Preserve_ON = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Status_Preserve_OFF" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  If gbRRX = true then]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleStart="Call OnRuleStart():If CurrentObj.Status=nFail then CurrentObj.Status=nPass:CurrentObj.DeleteVariable(""MESSAGE""):nDefaultRtn = nRtn_Over"]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd()" ]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleFailure="Call StatCounter():Call OnRuleFailure():Call OnRuleEnd()"]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleSetStart="RRState.OnRuleFailure="""":RRState.OnRuleStart=""Call OnRuleStart()"""]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Call PreserveStatus(bInter,bDebug,False)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Status_Preserve_OFF = True]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Initializing Calling Object to status " & nPass)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Status = nPass]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.DeleteVariable("MESSAGE")	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DebugMode_ON" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  bDebug = True]]>
<![CDATA[
]]>
<![CDATA[	DebugLog("DebugMode ON")]]>
<![CDATA[
]]>
<![CDATA[	DebugMode_ON = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DebugMode_OFF" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Debuglog("DebugMode OFF")]]>
<![CDATA[
]]>
<![CDATA[	bDebug = False]]>
<![CDATA[
]]>
<![CDATA[	DebugMode_OFF = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckAllIntegrity" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim LastChecked]]>
<![CDATA[
]]>
<![CDATA[	Dim rtn]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CheckAllIntegrity = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rtn = DCO.CheckIntegrity(LastChecked)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If rtn <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[		If Not LastChecked Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("CheckIntegrity returned : " & rtn & vbCrLf & Space(5) & "ID of last checked: " & LastChecked.ID) ]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		CheckAllIntegrity = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckDocCount" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim nD]]>
<![CDATA[
]]>
<![CDATA[	Dim nDD]]>
<![CDATA[
]]>
<![CDATA[	Dim ED]]>
<![CDATA[
]]>
<![CDATA[	Dim aD]]>
<![CDATA[
]]>
<![CDATA[	Dim vD		]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	nD = Trim(Pilot.ExpectedDocs)]]>
<![CDATA[
]]>
<![CDATA[	If nD="" or Not(isnumeric(nD)) then nD=0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ED = Trim(DCO.Variable("ED"))]]>
<![CDATA[
]]>
<![CDATA[	If ED="" or Not(isnumeric(ED)) then ED=0]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If cint(nD)=cint(0) and Len(ED)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO variable ED value found. Setting Pilot.ExpectedDocs to " & cstr(ED))]]>
<![CDATA[
]]>
<![CDATA[		nD = ED		]]>
<![CDATA[
]]>
<![CDATA[		Pilot.ExpectedDocs = clng(nD)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aD = Trim(Pilot.AdjustedDocs)]]>
<![CDATA[
]]>
<![CDATA[	If aD="" or Not(isnumeric(aD)) then aD=0]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	vD = Trim(DCO.Variable("AD"))]]>
<![CDATA[
]]>
<![CDATA[	If vD="" or Not(isnumeric(vD)) then vD=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(aD)=cint(0) and Len(vD)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO variable AD value found. Setting Pilot.AdjustedDocs to " & cstr(vD))]]>
<![CDATA[
]]>
<![CDATA[		aD = vD		]]>
<![CDATA[
]]>
<![CDATA[		Pilot.AdjustedDocs = clng(aD)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Expected documents:" & nD & ".")]]>
<![CDATA[
]]>
<![CDATA[	If aD>0 then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Adjusted documents:" & aD & ".")]]>
<![CDATA[
]]>
<![CDATA[		nD=aD]]>
<![CDATA[
]]>
<![CDATA[	End if ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	nDD = ObjectCount(DCO, 1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Found " & cstr(nDD) & " documents")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(nDD) <> cint(nD) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Expected documents count does not match actual documents count!")]]>
<![CDATA[
]]>
<![CDATA[		CheckDocCount = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CheckDocCount = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckPageCount" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim nP]]>
<![CDATA[
]]>
<![CDATA[	Dim nPP]]>
<![CDATA[
]]>
<![CDATA[	Dim aP]]>
<![CDATA[
]]>
<![CDATA[	Dim vP]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	nP = Trim(Pilot.ExpectedPages)]]>
<![CDATA[
]]>
<![CDATA[	If nP="" or Not(isnumeric(nP)) then nP=0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nP = Trim(DCO.Variable("EP"))]]>
<![CDATA[
]]>
<![CDATA[	If nP="" or Not(isnumeric(nP)) then nP=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(nP)=cint(0) and Len(EP)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO variable EP value found. Setting Pilot.ExpectedDocs to " & cstr(EP))]]>
<![CDATA[
]]>
<![CDATA[		nP = EP]]>
<![CDATA[
]]>
<![CDATA[		Pilot.ExpectedPages = clng(nP)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aP = Trim(Pilot.AdjustedPages)]]>
<![CDATA[
]]>
<![CDATA[	If aP="" or Not(isnumeric(aP)) then aP=0]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	vP = Trim(DCO.Variable("AP"))]]>
<![CDATA[
]]>
<![CDATA[	If vP="" or Not(isnumeric(vP)) then vP=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(aP)=cint(0) and Len(vP)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO variable AP value found. Setting Pilot.AdjustedPages to " & cstr(vP))]]>
<![CDATA[
]]>
<![CDATA[		aP = vP		]]>
<![CDATA[
]]>
<![CDATA[		Pilot.AdjustedPages = clng(aP)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Expected Pages:" & nP & ".")]]>
<![CDATA[
]]>
<![CDATA[	If aP>0 then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Adjusted pages:" & aP & ".")]]>
<![CDATA[
]]>
<![CDATA[		nP=aP]]>
<![CDATA[
]]>
<![CDATA[	End if ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	nPP = ObjectCount(DCO, 2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Found " & cstr(nPP) & " pages")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(nPP) <> cint(nP) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Expected pages count does not match actual pages count!")]]>
<![CDATA[
]]>
<![CDATA[		CheckPageCount = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CheckPageCount = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Task_RaiseCondition" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[' Strparam is a CSV value]]>
<![CDATA[
]]>
<![CDATA[' 1) is the childindex]]>
<![CDATA[
]]>
<![CDATA[' 2) is the Condition to set the child to.			]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrparam]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim nConditionIndex]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Task_RaiseCondition= False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	nChildIndex = aStrParam(0)	]]>
<![CDATA[
]]>
<![CDATA[	nConditionIndex = aStrParam(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nChildIndex) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nConditionIndex) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nConditionIndex = CLng(nConditionIndex)]]>
<![CDATA[
]]>
<![CDATA[	nChildIndex= CLng(nChildIndex)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Pilot.ChildCondition(nChildIndex) = nConditionIndex]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Task_RaiseCondition= True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Task_NumberOfSplits" access="public" bInter="bInter" bDebug="bDebug" strParam="nNumOfSplits">
	<g>
<![CDATA[
]]>
<![CDATA[	Task_NumberOfSplits= False]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nNumOfSplits) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("NumOfSplits Value is not Numeric.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	pilot.ChildrenQuantity=(CLng(nNumOfSplits))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting Task Number Of Splits to : " & nNumOfSplits)]]>
<![CDATA[
]]>
<![CDATA[	Task_NumberOfSplits= True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetTaskStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ 'use global variable nTaskStatus to send status to RuleRunner]]>
<![CDATA[
]]>
<![CDATA[ Const RetAbort = 0]]>
<![CDATA[
]]>
<![CDATA[ Const RetFinished = 2]]>
<![CDATA[
]]>
<![CDATA[ Const RetPending = 8]]>
<![CDATA[
]]>
<![CDATA[ Const RetHold = 4]]>
<![CDATA[
]]>
<![CDATA[   if(isNumeric(StrParam)) then]]>
<![CDATA[
]]>
<![CDATA[      nTaskStatus = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[     	If gbRRX = true then ]]>
<![CDATA[
]]>
<![CDATA[        RRState.Data("nTaskStatus")=StrParam]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Set status of task to " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[      SetTaskStatus = true]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Action's parameter is not numeric")]]>
<![CDATA[
]]>
<![CDATA[     SetTaskStatus = false ]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SkipChildren" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	If gbRRX = true then ]]>
<![CDATA[
]]>
<![CDATA[    RRState.SkipChildren=True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	SkipChildren = True]]>
<![CDATA[
]]>
<![CDATA[	bprocesschildren = False]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AbortOnError" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	AbortOnError = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Select Case ucase(strparam)]]>
<![CDATA[
]]>
<![CDATA[		Case "TRUE"]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Setting Task to Abort On Errors")]]>
<![CDATA[
]]>
<![CDATA[			g_bAbortOnError = True]]>
<![CDATA[
]]>
<![CDATA[		Case "FALSE"]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Setting Task to Continue On Errors")]]>
<![CDATA[
]]>
<![CDATA[			g_bAbortOnError = False]]>
<![CDATA[
]]>
<![CDATA[		Case Else]]>
<![CDATA[
]]>
<![CDATA[			AbortOnError = False]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid Parameter. Expecting 'True' or 'False', received '" & StrParam & "'.")]]>
<![CDATA[
]]>
<![CDATA[	End Select		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="PilotMessage_Set" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If len(sSmartParam)="" then ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Smart Parameter parsing did not return a value. Defaulting message to the Action argument.")]]>
<![CDATA[
]]>
<![CDATA[     sSmartParam =StrParam]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("MESSAGE")= Trim(sSmartParam)	]]>
<![CDATA[
]]>
<![CDATA[	PilotMessage_Set=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PilotMessage_Clear" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	CurrentObj.DeleteVariable("MESSAGE")	]]>
<![CDATA[
]]>
<![CDATA[	PilotMessage_Clear=True]]>
<![CDATA[
]]>
	</g>
</af>
<g>
</g>
<f name="rrSet" access="public">
	<p name="varSource">
	</p>
	<p name="varTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Set was replaced by rrSet so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sSource]]>
<![CDATA[
]]>
<![CDATA[	Dim sDestination]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rrSet = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = Trim(varSource)]]>
<![CDATA[
]]>
<![CDATA[	sDestination = Trim(varTarget)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sDestination) = 0 Then sDestination = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' If sSource = sDestination Then we don't care, perform the copy anyway.		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValue = MetaWord(sSource)    ]]>
<![CDATA[
]]>
<![CDATA[	rrSet = DCONavSetValue(sDestination,sValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrSet") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<af name="rr_Get" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim sSource]]>
<![CDATA[
]]>
<![CDATA[	Dim sDestination]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rr_Get = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = StrParam]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sDestination) = 0 Then sDestination = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ' This condition will occur only if no parameter is supplied.]]>
<![CDATA[
]]>
<![CDATA[	If sSource = sDestination Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("A parameter is required for rr_Get(). Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValue = MetaWord(sSource)]]>
<![CDATA[
]]>
<![CDATA[	rr_Get = DCONavSetValue(sDestination, sValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rr_Get") ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<f name="rrCompare" access="public">
	<p name="object1">
	</p>
	<p name="object2">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Compare was replaced by rrCompare so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sSourceA]]>
<![CDATA[
]]>
<![CDATA[	Dim sSourceB]]>
<![CDATA[
]]>
<![CDATA[	Dim sValueA]]>
<![CDATA[
]]>
<![CDATA[	Dim sValueB]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rrCompare = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSourceA = Trim(object1)]]>
<![CDATA[
]]>
<![CDATA[	sSourceB = Trim(object2)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSourceA) = 0 Then sSourceA = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sSourceB) = 0 Then sSourceB = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If sSourceA = sSourceB Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Source A and B reference the same component. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    rr_Compare = True]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValueA = MetaWord(sSourceA)]]>
<![CDATA[
]]>
<![CDATA[	sValueB = MetaWord(sSourceB)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Comparing: '" & sValueA & "' = '" & sValueB & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If sValueA = sValueB Then]]>
<![CDATA[
]]>
<![CDATA[		rrCompare = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCompare") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="rrCompareNot" access="public">
	<p name="object1">
	</p>
	<p name="object2">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Copy was replaced by rrCopy so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	if rrCompare(object1, object2) Then]]>
<![CDATA[
]]>
<![CDATA[     rrCompareNot = False]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     rrCompareNot = True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCompareNot") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="rrCopy" access="public">
	<p name="varSource">
	</p>
	<p name="varTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Copy was replaced by rrCopy so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sSource]]>
<![CDATA[
]]>
<![CDATA[	Dim sTarget]]>
<![CDATA[
]]>
<![CDATA[	Dim oSource]]>
<![CDATA[
]]>
<![CDATA[	Dim oTarget]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigImageN]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigImageH]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	rrCopy = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = Trim(varSource)]]>
<![CDATA[
]]>
<![CDATA[	sTarget = Trim(varTarget)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sTarget) = 0 Then sTarget = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If sSource = sTarget Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source and Target are to the same component. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oSource = DCONav(sSource)]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oSource) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Copy from node not found.")]]>
<![CDATA[
]]>
<![CDATA[		rrCopy=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oTarget = DCONav(sTarget)]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oTarget) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Copy to node not found.")]]>
<![CDATA[
]]>
<![CDATA[		rrCopy=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Get Target original]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Target original values]]>
<![CDATA[
]]>
<![CDATA[	oTarget.Text=""]]>
<![CDATA[
]]>
<![CDATA[	oTarget.Variable("Position")="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check Source has value]]>
<![CDATA[
]]>
<![CDATA[	If oSource.Text="" then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source field has no value.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Copying Node: '" & oSource.ID & "' value:'" & oSource.Text & "' image:'" & oSource.Variable("IMAGEFILE") & "' to '" & oTarget.ID & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call RRCopyChars(oSource,oTarget,1,len(oSource.Text))]]>
<![CDATA[
]]>
<![CDATA[	Call RRCopyPos(oSource,oTarget,1,len(oSource.Text))]]>
<![CDATA[
]]>
<![CDATA[	Call RRCopyImage(oSource,oTarget)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("New Target Value:'" & oTarget.Text & "'  Position:'" & oTarget.Variable("Position") & "' image:'" & oTarget.Variable("IMAGEFILE") & "'")		]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCopy")   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="rrAppend" access="public">
	<p name="varSource">
	</p>
	<p name="varTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Append was replaced by rrAppend so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[  Dim sSource]]>
<![CDATA[
]]>
<![CDATA[  Dim sTarget]]>
<![CDATA[
]]>
<![CDATA[  Dim oSource]]>
<![CDATA[
]]>
<![CDATA[  Dim oTarget]]>
<![CDATA[
]]>
<![CDATA[  Dim sOrigImageN]]>
<![CDATA[
]]>
<![CDATA[  Dim sOrigImageH]]>
<![CDATA[
]]>
<![CDATA[  Dim oChild]]>
<![CDATA[
]]>
<![CDATA[  Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[  Dim oChar]]>
<![CDATA[
]]>
<![CDATA[  Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	rrAppend = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = Trim(varSource)]]>
<![CDATA[
]]>
<![CDATA[	sTarget = Trim(varTarget)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sTarget) = 0 Then sTarget = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If sSource = sTarget Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source and Target are to the same component. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValue = MetaWord(sSource)]]>
<![CDATA[
]]>
<![CDATA[	If Len(sValue)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No source Value found.")]]>
<![CDATA[
]]>
<![CDATA[		rrAppend=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oTarget = DCONav(sTarget)]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oTarget) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Append to node not found.")]]>
<![CDATA[
]]>
<![CDATA[		rrAppend=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Start Value of Target:'" & oTarget.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to Len(sValue)]]>
<![CDATA[
]]>
<![CDATA[		Set oChar = oTarget.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not oChar is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			oChar.CharValue(0)= Clng(ASCW(Mid(sValue,i,1)))]]>
<![CDATA[
]]>
<![CDATA[			oChar.CharConfidence(0) = Clng(9)]]>
<![CDATA[
]]>
<![CDATA[			bRes = oChar.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  Writelog("End Value of Target:'" & oTarget.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrAppend")   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="rrPrepend" access="public">
	<p name="varSource">
	</p>
	<p name="varTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Append was replaced by rrAppend so we could use the "f" tag with unique parameters.  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sSource]]>
<![CDATA[
]]>
<![CDATA[	Dim sTarget]]>
<![CDATA[
]]>
<![CDATA[	Dim oSource]]>
<![CDATA[
]]>
<![CDATA[	Dim oTarget]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigImageN]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigImageH]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim oChar]]>
<![CDATA[
]]>
<![CDATA[  Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	rrPrepend = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = Trim(varSource)]]>
<![CDATA[
]]>
<![CDATA[	sTarget = Trim(varTarget)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sTarget) = 0 Then sTarget = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If sSource = sTarget Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source and Target are to the same component. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValue = MetaWord(sSource)]]>
<![CDATA[
]]>
<![CDATA[	If Len(sValue)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No source Value found.")]]>
<![CDATA[
]]>
<![CDATA[		rrPrepend=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oTarget = DCONav(sTarget)]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oTarget) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Append to node not found.")]]>
<![CDATA[
]]>
<![CDATA[		rrPrepend=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Start Value of Target:'" & oTarget.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to Len(sValue)]]>
<![CDATA[
]]>
<![CDATA[		Set oChar = oTarget.AddChild(4,"",i-1)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not oChar is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			oChar.CharValue(0)= Clng(ASCW(Mid(sValue,i,1)))]]>
<![CDATA[
]]>
<![CDATA[			oChar.CharConfidence(0) = Clng(9)]]>
<![CDATA[
]]>
<![CDATA[			bRes = oChar.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  Writelog("End Value of Target:'" & oTarget.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrPrepend") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<g>
</g>
<af name="rr_WriteNode" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim sNodeFileName	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rr_WriteNode=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sNodeFileName=Pilot.BatchDir & "\" & CurrentObj.ID & ".xml"]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("DATAFILE")=sNodeFileName]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="rr_AbortBatch" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  	rr_AbortBatch = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Call AbortBatch()  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="GoToNextFunction" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoToNextFunction = False]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("GoToNextFunction returning " & GoToNextFunction & " so next function in the RuleSet will run.") ]]>
<![CDATA[
]]>
<![CDATA[	'Call ErrorHandler("Function GoToNextFunction") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<af name="SetReturnValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	on error resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetReturnValue = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Trim(StrParam)  ]]>
<![CDATA[
]]>
<![CDATA[  if (ucase(StrParam) = "TRUE") then]]>
<![CDATA[
]]>
<![CDATA[    SetReturnValue = True]]>
<![CDATA[
]]>
<![CDATA[  end if      ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("SetReturnValue returns: " & SetReturnValue)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ProcessChildren" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ProcessChildren = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If uBound(aStrParam) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Expecting comma separated arguments (Condition,Command). Wrong number of parameters. Exiting")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call u_RecurseObject(CurrentObj,aStrParam(0),aStrParam(1),cint(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ProcessChildren = TRUE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="SetBatchPriority" access="public">
	<p name="Priority">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[' Sets the Batch priority for the current Batch]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim SmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetBatchPriority=False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SmartVal=MetaWord(Priority)]]>
<![CDATA[
]]>
<![CDATA[  If Len(SmartVal)>0 then Priority=SmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not Isnumeric(Priority) Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Priority=cInt(Priority)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Priority<0 Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter must be a non negative integer.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Pilot.Priority=Priority ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number=0 then]]>
<![CDATA[
]]>
<![CDATA[    SetBatchPriority=True]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Batch Priority set to '" & cStr(Priority) & "'")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="SetOperatorID" access="public">
	<p name="OperatorID">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[' Sets the Batch OperatorID for the current Batch]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetOperatorID=False]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  SmartVal=MetaWord(OperatorID)]]>
<![CDATA[
]]>
<![CDATA[  If Len(SmartVal)>0 then OperatorID=SmartVal]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Pilot.Operator=cstr(OperatorID) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number=0 then]]>
<![CDATA[
]]>
<![CDATA[    SetOperatorID=True]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Operator set to '" & OperatorID & "'")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="SetStationID" access="public">
	<p name="StationID">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[' Sets the Batch StationID for the current Batch]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetStationID=False]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  SmartVal=MetaWord(StationID)]]>
<![CDATA[
]]>
<![CDATA[  If Len(SmartVal)>0 then StationID=SmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Pilot.Station=cStr(StationID) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number=0 then]]>
<![CDATA[
]]>
<![CDATA[    SetStationID=True]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Station set to '" & StationID & "'")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'*****************************************************************************
' help.xml for rrunner
'-----------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
' Version 8.1.0.83 RFerin 07/13/2011
'  * 29425 Updated help to show example of openconnection with a smart parameter.
'
'*****************************************************************************

'(Declarations)
]]>

<ref id="Status_Preserve_ON">
  <ap>None.</ap>
  <h>
    This action changes the <i>Status Preserve</i> condition of a <b>Page</b> object - and
    its <b>Field</b> objects - from <i>Off</i> to <i> On</i>.<br/><br/>

    The <i>On</i> condition prevents a rule and its actions from assigning a "problem" status to a
    field - even if the field's value fails validation.<br/>
    <e>
      <b>Status_Preserve_On()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="Status_Preserve_OFF">
  <ap>None.</ap>
  <h>
    This action turns the <i>Status Preserve</i> condition of a page and its fields from <i>On</i> to <i>Off</i>. <br/>
    <br/>
    An object's <i>Off </i>condition allows the actions of a <b>Validate</b> ruleset to assign a
    "problem" status to any <b>Field</b> object with an invalid captured value. The Verify task's Data Entry
    panel will then surround the value with a pink background, alerting the operator to the problem.
    <e>
      <b>Status_Preserve_Off()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="DebugMode_ON">
  <ap>None.</ap>
  <h>
    The example below shows enhanced logging during the course of several actions.
    <e>
      <b>DebugMode_On()</b><br/>
      ExportOpenConnection(@APPVAR(values/dsn/exportdb:cs))<br/>
      SetTableName(Invoice)<br/>
      ExportFieldToColumn(Number, db_Number)<br/>
      AddRecord()<br/>
      DebugMode_Off()
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="DebugMode_OFF">
  <ap>None.</ap>
  <h>
    This actions turns off the <b>
      <i>enhanced</i>
    </b> logging procedures turned on by an earlier
    <b>DebugMode_On</b> action.<br/><br/>

    Enhanced logging expands the scope and depth of a processing log's information, and of the logs
    that a rulerunner task generates when you are testing a rule and its actions.<br/><br/>

    This feature also increases a Log file's size significantly, and should only be used when you are
    testing the impact of an action and rule on the application's workflow.
    <e>
      <b>DebugMode_Off()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="CheckAllIntegrity">
  <ap>None.</ap>
  <h>
    Checks that the documents in the batch contain the correct type and number of pages, 
    in line with the Document Integrity requirements of the Document Hierarchy.
    <e>
      CreateDocuments()<br/>
      CheckAllIntegrity()<br/><br/>

      These actions are part of a rule applied to the <b>Batch</b> object of the Document
      Hierarchy. The first assembles documents from the pages in the batch; the second ensures
      that the makeup of each document is valid.
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    <b>True</b> if the Document Integrity of the current batch meets the requirements as defined
    in the setup of the Document Hierarchy. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="CheckDocCount">
  <ap>None.</ap>
  <h>
    The number of expected documents is usually provided by the operator of a job's Scan task.
    This very handy action can compare the actual amount to the estimate at any time after a
    <b>CreateDocuments</b> action has assembled the documents in the batch.<br/>
    <e>
      <b>CheckDocCount()</b>
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    <b>True</b> if the <b>
      <i>actual</i>
    </b> count is the same as the <b>
      <i>expected</i>
    </b>count.
    Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="CheckPageCount">
  <ap>None.</ap>
  <h>
    This is the action that confirms that the number of <b><i>actual</i></b>
    images - pages - in the current task's Page file (.xml) matches the count of
    <b><i>expected</i></b> pages.
    <e>
      <b>CheckPageCount()</b>
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    <b>True</b> if the two counts are equal. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="Task_RaiseCondition">
  <ap>
    Two comma-separated <i>Integer</i> values:<br/><br/>
    1. The applicable value of the sub-batch index. 0 is the first sub-batch,
    1 is the second, etc. The <b>Task_NumberOfSplits</b> action determines how many
    sub-batches are created.<br/><br/>

    2. The value that designates the Child Job Condition that should be assigned
    to the specified sub-batch. 0 is the first Child Job Condition, 1 is the second, etc.
  </ap>
  <h>
    Assigns the correct Child Job Condition to the correct sub-batch entry created by the Task_NumberOfSplits action.
    <e>
      Task_NumberOfSplits(1)<br/>
      Task_RaiseCondition(0,0)<br/>
      <br/>
      In this example, User Application is alerted to create one sub-batch entry and
      to raise the first Child Job Condition for this sub-batch entry.<br/><br/>      
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if either parameter is not <i>Numeric</i>. Otherwise, <b>True.</b>
  </ret>
  <see>Task_NumberOfSplits</see>
</ref>
  
<ref id="Task_NumberOfSplits">
  <ap>
    <i>Integer</i> value of the number of splits. In most cases, you will want to use "1" as the parameter.
  </ap>
  <h>
    Specifies how many times sub-batches have been created from the current batch.<br/>
    Important! The action communicates but does not use the Number_of_Splits value you enter as a parameter.
    <e>
      Task_NumberOfSplits(1)<br/>
      Task_RaiseCondition(0,0)<br/>
      <br/>
      Above, User Application is alerted to create one sub-batch entry, and to raise the
      second <b>child job condition</b> for this sub-batch entry. 
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not <i>Numeric</i>. Otherwise, <b>True.</b>
  </ret>
  <see>Task_RaiseCondition</see>
</ref>
  
<ref id="SetTaskStatus">
  <ap>
    <i>Numeric</i> value representing the status that the task is to return to User Application.
    The statuses include: <br/><br/>
    0 - Abort<br/>
    1 - Cancelled<br/>
    2 - Finished<br/>
    4 - Hold<br/>
    8 - Pending
  </ap>
  <h>
    Sets the Task Status value that is to be returned to User Application when the current task finishes processing.
    <e>
      <b>SetTaskStatus(4)</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is not <i>Numeric.</i> Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="SkipChildren">
  <ap>None.</ap>
  <h>
    Prevents rules applied to child objects of the current parent object from being run. 
    The action can optimize the execution of rules by eliminating the need to visit 
    every field on every page.
    <e>
      <b>SkipChildren()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
 
 
<ref id="AbortOnError">
  <ap>
    <b>True:</b> Abort the batch if an error occurs.<br/>
    <b>False:</b> Do not abort the batch if an error occurs.
  </ap>
  <h>
    Determines if tasks that encounter errors are to abort, or continue processing.
    <e>
      <b>AbortOnError("Yes")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is not "True" or "False". Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="PilotMessage_Set">
  <ap>
    The smart parameter message to be assigned to the <b>MESSAGE</b> variable. Be sure to
    surround the message in quotation marks.
  </ap>
  <h>
    Provides a runtime MESSAGE variable to the bound object of the Document Hierarchy, 
    and assigns the Action's parameter as the variable value. 
    <e>
      <b>PilotMessage_Set("Field +@F+ Value is not Valid")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="PilotMessage_Clear">
  <ap>None.</ap>
  <h>
    Removes the runtime MESSAGE variable from the bound object of the Document Hierarchy.
    <e>
      <b>PilotMessage_Clear()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="rrSet">
  <ap>
    Two parameters.  Smart parameters are supported:<br/>
    <br/><br/>
    <b>1.</b> A smart parameter referencing a value or which is a reference to a value that will be copied.<br/>
    <br/>
    <b>2.</b> A smart parameter referencing a target which is receiving the value.<br/>
    <br/><br/>
    
    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    For batch, document and page objects, it will use a variable called "Text", creating
    the variable if it does not exist.
  </ap>
  <h>
    Uses the parameter's elements to locate the value of a source object's variable,
    and assign it to a specific variable of a second, receiving object.
    The action rrSet will set the target with the value from the source.  If using a field, only the value of the
    field will be changed.  You can use rrCopy if you wish to copy a field's
    value, confidence and image references (field positions) of the source field object.<br/>
    <e>
      <b>rrSet("@F.MySourceVar","@P.MyTargetVar")</b><br/>
      Obtains the value from the calling field "MySourceVar" variable and assigns it to parent page 
      of the calling object "MyTartgetVar" variable.<br/><br/>

      <b>rrSet("@D.Tot_Pages","@B.Tot_Pages")</b><br/>      
      This example assumes that the calling object is a child of a <b>Document</b> object. 
      It locates the value in the calling document's
      <i>Tot_Pages</i> variable and assigns it to the <i>Tot_Pages</i> variable of the <b>Batch</b> object.
      <br/><br/>
      
      <b>rrSet("@DICT_VALUE(..\MONTH)","")</b><br/>
      This example shows how Smart Parameters translates the OMR recognized value of the 
      MONTH field to the text from a predefined dictionary.  The text is then assigned
      to the calling object's Text property, if it is a field, or Text variable if it is not a field.
    </e>
    <br/>
    <br/>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the action cannot locate the target object.  Otherwise, <b>True.</b>
  </ret>
  <see>
    rrCopy, rr_Get, rrCompare
  </see>
</ref>

<ref id="rr_Get">
  <ap>
    A smart parameter referencing a value or which is a reference to a value that will be copied to the calling object.
  </ap>  
  <h>
    Uses the parameter's elements to locate the value of a source object's variable,
    and assign it to the calling object.  If the calling object is a field, only the value of the
    field will be changed.
    <e>
      <b>rr_Get("@B.OPERATOR")</b><br/>
      This example retrieves the value of the <b>Batch</b> object's <b>Operator</b>
      property and assigns it to the calling object's <b>Text</b> property, if the calling object is a field.<br/><br/>
    
      <b>rr_Get("@DICT_WORD(..\MONTH)")</b><br/>
      This example shows how Smart Parameters translates the OMR recognized value of the
      MONTH field to the text from a predefined dictionary.  The text is then assigned
      to the calling object's Text property, if it is a field, or Text variable if it is not a field.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> the parameter is missing. Otherwise, <b>True.</b>
  </ret>
  <see>rrSet, rrCompare</see>
</ref>

<ref id="rrCompare">
  <ap>
    Two Smart Parameters.<br/><br/>

    <b>1.</b> A smart parameter referencing a value or which is a reference to a value.<br/><br/>

    <b>2.</b> A smart parameter referencing a value or which is a reference to a value for comparison.<br/><br/>

    <b>Note:</b> Either reference can specify a variable of the calling
    object (the bound object of the Document Hierarchy.) Alternatively, both references can
    identify a variable of an object that is a parent or child of the calling object.<br/><br/>

    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    For batch, document and page objects, it will use a variable called "Text", creating
    the variable if it does not exist.
  </ap>
  <h>
    Uses the Smart Parameters that you enter as the parameter to locate and
    compare the values of two object's variables.
    <e>
      rrCompare("Expected_Pages","@B.Tot_Pages")<br/><br/>

      This example shows how a value is solicited from the field <i>Expected_Pages</i>
      off of the calling object and the <b>Batch</b> object. The two values are then
      compared: the action returns False if the values are not the same.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the compared values do not match. Otherwise, <b>True.</b>
  </ret>
  <see>rrCompareNot</see>
</ref>  
 

<ref name="rrCompareNot">
  <ap>
    Two Smart Parameters.<br/>
    <br/>
    <b>1.</b> A smart parameter referencing a value or which is a reference to a value.<br/>
    <br/>
    <b>2.</b> A smart parameter referencing a value or which is a reference to a value for comparison.<br/><br/>
    
    <b>Note:</b> Either reference can specify a variable of the calling object.
    Alternatively, both references can identify 
    a variable of an object that is a parent or child of the calling object.<br/><br/>

    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    For batch, document and page objects, it will use a variable called "Text", creating
    the variable if it does not exist.
  </ap>
  <h>
    This action is the negation of rrCompare.  It can be handy for when an action should be
    performed only when two values are different.
    <e>
      <b>rrCompareNot("Expected_Pages","@B.Tot_Pages")</b><br/>
      rr_AbortBatch()<br/><br/>

      This example shows how a value is solicited from the field <i>Expected_Pages</i>
      off of the calling object and the <b>Batch</b> object. The two values are then compared: the action
      returns True if the values are not the same.  Here, the batch will abort if the expected
      pages do not match the total pages.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if the compared values do not match. Otherwise, <b>False.</b>
  </ret>
</ref>

<ref id="rrCopy">
  <ap>
    Two Smart Parameters:<br/><br/>
    <b>1.</b> A reference to the source field.<br/>
    <b>2.</b> A reference to the target field.<br/><br/>
    
    Either parameter is optional.  If a parameter is not specified, the calling object 
    must be a field.
  </ap>
  <h>
    The action retrieves the value, confidence and image references (field positions) of the source field object,
    and copies them to the target field object.
    Uses the Smart Parameters you enter as a parameter to copy the value of a source
    field object to a target field object. This action is unusual in that it is intended
    to work only on field objects.<br/><br/>

    Note: rrCopy copies more than just the value of the field as mentioned above.
    Use rrSet if only the field value should be copied.   
    This action is unusual in that it is intended to work only on field objects.<br/>
    <e>
      <b>rrCopy("@B\OPERATOR","@P\OPERATOR")</b>
    </e><br/>
    This example copies the Batch field <i>OPERATOR</i> value to the
    <i>OPERATOR</i> field of the bound object of the Document Hierarchy - whatever that happens to be.
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the action cannot retrieve the target or source object. Otherwise, <b>True.</b>
  </ret>
  <see>
    rrSet, rr_Get
  </see>
</ref>

<ref id="rrAppend">
  <ap>
    Two Smart Parameters:<br/><br/>
    <b>1.</b> The source value.<br/><br/>
    <b>2.</b> A reference to the target object.<br/><br/>

    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    For batch, document and page objects, it will use a variable called "Text", creating
    the variable if it does not exist.
  </ap>
  <h>
    The action retrieves the value of the source object, and "appends" it to the target value.
    <e>
      <b>rrAppend("@D.DocID","@F")</b><br/>
      <br/>
      This action inserts the current calling object's parent DocID variable value and
      appends it to the calling field's value.
    </e>
  </h>
  <lvl>All, target must be a field object.</lvl>
  <ret>
    <b>False</b> if the calling object and target object are the same, or if the action cannot
    locate the target object's variable. Otherwise, <b>True.</b>
  </ret>
  <see>rrPrepend</see>
</ref>

<ref id="rrPrepend">
  <ap>
    Two Smart Parameters:<br/><br/>
    <b>1.</b> The source value.<br/><br/>
    <b>2.</b> A reference to the target object.<br/><br/>

    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    For batch, document and page objects, it will use a variable called "Text", creating
    the variable if it does not exist.
  </ap>
  <h>
    The action retrieves the value of the source object, and "pre-appends" it to the target field value.
    <e>
      <b>rrPrepend("@D.DocID","@F")</b><br/>
      <br/>
      This action inserts the current calling object's parent DocID variable value and pre-appends
      it to the calling field's value.
    </e>
  </h>
  <lvl>All, target must be a field object.</lvl>
  <ret>
    <b>False</b> if the calling object and target object are the same, or if the action cannot
    locate the target object's variable. Otherwise, <b>True.</b>
  </ret>
  <see>rrAppend</see>
</ref>  
  
<ref id="rr_WriteNode">
  <ap>None.</ap>
  <h>
    Sets up a separate XML data file element for the calling object during rulerunner processing.
    <e>
      <b>rr_WriteNode()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="rr_AbortBatch">
  <ap>None.</ap>
  <h>
    Stops processing the current batch and sets the status of the batch to Abort.
    <e>rr_AbortBatch()</e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="GoToNextFunction">
  <ap>None.</ap>
  <h>
    Returns a <b>False</b> condition so that the next function in the RuleSet can run.
    <e>
      <scr>IsFieldMatching("Skip")</scr><br/>
      <b>GoToNextFunction()</b><br/><br/>

      If the condition in the first action is met, the sequence assigns a
      <b>False</b> status to the second action and to the rule of
      which it is a part. As a result, the RuleSet automatically summons the next function.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>

<ref id="SetReturnValue">
  <ap>
    <b>True:</b> The action will return true.<br/>
    <b>False:</b> The action will return false.
  </ap>
  <h>
    This action will return true or false based on the input parameter.<br/><br/>
    
    By passing in true, the action will return true and continue with the actions in the current function.  If it is the last
    action in a function, it will cause the following functions within the ruleset to be skipped.<br/><br/>

    One use for this action
    is a quick way to disable rulesets by adding a new function, that precedes all other functions
    in the ruleset, and the function only contains this action with a parameter of true.  This will cause
    all other functions in the ruleset to be skipped and the next ruleset will run.<br/><br/>

    Using a parameter of false, this action will return false, causing all following actions in the function 
    to be skipped and control carries forward to the next function in the same ruleset.  In this way, the operation
    is identical to the action GoToNextFunction.
    <e>
      <b>SetReturnValue("true")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True,</b> if the action is passed the parameter 'true'.  Otherwise, <b>False.</b>
  </ret>
  <see>GoToNextFunction, FailRuleSet, rr_AbortBatch</see>
</ref>

  <ref id="ProcessChildren">
    <ap>
      A two-part, comma-separated specification of a Condition and a Command.<br/><br/>

      The Condition is any valid VBScript expression. The Command is the VB executable
      that results from the Condition.
    </ap>
    <h>
      A follow-up action that initiates the processing of elements represented by the bound object, and all its children.
      <e>
        <b>ProcessChildren("1,Exit")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the number or sequence of the arguments are invalid. Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="SetBatchPriority">
    <ap>
      A Single value representing the Priority value to set as the batch priority at the end of the Task.<br/><br/>      
    </ap>
    <h> 
      Sets the priority of the batch to the at the completion of the Task. Values are typically 1-9 with 5 being the median.
      <e>
        <b>SetBatchPriority("1")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the value of the argument is invalid. Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="SetOperatorID">
    <ap>
      A Single value representing the new Operator ID value.<br/><br/>
    </ap>
    <h>
      Sets the Operator ID at the completion of the Task.
      <e>
        <b>SetOperatorID("admin")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if setting the value throws an error. Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="SetStationID">
    <ap>
      A Single value representing the new Station ID value.<br/><br/>
    </ap>
    <h>
      Sets the Station ID at the completion of the Task.
      <e>
        <b>SetStationID("4")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if setting the value throws an error. Otherwise, <b>True.</b>
    </ret>
  </ref>
</help>
</rrx>
<rrx namespace="SPExport" src="c:\datacap\RRS\SPExport.dll">

<i ref="rrunner">
</i>
<af name="SP_SetUrl" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_SetContentType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_Login" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_CreateFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_SetProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_Upload" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="SP_UploadDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_SetFileType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_SetUploadMode" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<help>
<![CDATA[

'************************************************************************
' SPExport.rrx - Microsoft SharePoint Server Upload Actions
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
' 
' Converted from SPExport.rrx, and 
' initial Help.xml created 6/12/2012 VKandasamy
'
]]>
  <ref id="SP_SetUrl">
    <ap>
      The full URL to the SharePoint repository.  Smart parameters are supported.  Refer to
      the Smart Parameter documentation for more information.
    </ap>
    <h>
      Sets target URL of location to which image files are uploaded.<br/><br/>
      Note: ”/Docs/Documents/” is default Document Library within SharePoint site.
      <e>
        <b>SP_SetUrl("http://blue/Docs/Documents/+@BatchID+/+@ID")</b><br/><br/>

        With this example, directories with names defined by /+@BatchID+/+@ID will be created
        automatically during upload.
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the action succeeded. Otherwise, <b>False.</b>
    </ret>
  </ref>
  
  <ref id="SP_SetContentType">
    <ap>
      A valid SharePoint content type in the selected Library. No error is raised if it
      is not a valid content type.  Smart Parameters are supported.
    </ap>
    <h>
      This action sets the SharePoint Content Type for each document that is subsequently
      uploaded. Content Type is a SharePoint concept that defines a subset of columns
      (fields) within a library of documents, to be displayed and edited for a specific purpose.
      <e>
        <b>SP_SetContentType("Invoice")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the content type was successfully set or if the content type is not a valid content type.<br/>
      <b>False</b> if there is failure returned from SharePoint.
    </ret>
  </ref> 
  
  <ref id="SP_Login" >
    <ap>
      A string containing 3 comma separated input parameters.<br/>
      <b>1.</b> SharePoint userID.<br/>
      <b>2.</b> Password. <br/>
      <b>3.</b> An optional SharePoint domain.  If not included, do not include the preceding comma.<br/><br/>

      Smart Parameters are supported.  Use smart parameters to prevent clear text
      passwords in your application by obtaining the password from
      the appliation service.
    </ap>
    <h>
      Login to SharePoint with credentials OTHER than the logged-in Windows User.
      <e>
        <b>SP_Login("userID,password,domain")</b><br/>
        SP_SetUrl("http://blue/Docs/Documents/+@BatchID+/+@ID")<br/>
        SP_SetContentType("Invoice")<br/>
        SP_SetFileType("jpg")<br/>
        SP_SetProperty("Date,@Value")<br/>
        SP_Upload()<br/><br/>

        Alternativly, you can use smart parameters to obtain information from
        the application service to prevent clear text passwords.  Here is an example
        where the password is stored in a custom value called SPPassword in
        the application service:<br/><br/>

        <b>SP_Login("userID,@APPVAR(values/adv/SPPassword),domain")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the login succeeded.  Otherwise, <b>False.</b><br/>
      Note that if the login parameters are invalid, a failure may not occur until you call "SP_Upload".
    </ret>
  </ref>
  
  <ref id="SP_CreateFolder">
    <ap>
      The URL that specifies the folder to create in SharePoint.  Smart parameters are supported.
      Refer to the Smart Parameter documentation for more information.
    </ap>
    <h>
      Creates the SharePoint folder specified in the parameter string.<br/>
      Note: The SP_SetUrl action optionally can define directories and subdirectories
      to be created during the upload.
      <e>
        <b>SP_CreateFolder("http://blue/Docs/Documents/Test")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the folder was created successfully or if it already exists.  Otherwise, <b>False.</b>
    </ret>
  </ref>
  
  <ref id="SP_SetProperty">
    <ap>
      Two comma separated values:<br/>
      <b>1.</b> Column name is the name or ID of the target column in SharePoint.<br/>
      <b>2.</b> Data value is the value to be uploaded to that column. Refer to
      the documentation for more information about the column types.<br/>
      Smart Parameters are supported.
    </ap>
    <h>
      Sets an index value (column in SharePoint) for the document(s) to follow.  Can be
      called multiple times to set multiple index values.<br/><br/>

      Notes:<br/>
      Any spaces in column names must be replaced with “_0x02c_”. <br/>
      The “real” column name may be different from what is displayed in SharePoint. To
      determine the real Column name select the column settings and check the browser address.
      For example for the property called "Description" you may
      see "....3F2%7D Field=Comments" at the end.  This means that the real name of the
      Column to be used in the SP_SetProperty action is "Comments".

      <e>
        <b>SP_SetProperty("Date,@Value")</b><br/>
        SP_Upload()<br/><br/>
        Moves the value of the current field to the SharePoint column named Date.
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the parameters are not blank.  The index information is uploaded to
      SharePoint when a document is subsequently uploaded.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="SP_SetProperty">
    <ap>
      Two comma separated values:<br/>
      <b>1.</b> Column name is the name or ID of the target column in SharePoint.<br/>
      <b>2.</b> Data value is the value to be uploaded to that column. Refer to
      the documentation for more information about the column types.<br/>
      Smart Parameters are supported.
    </ap>
    <h>
      Sets an index value (column in SharePoint) for the document(s) to follow.  Can be
      called multiple times to set multiple index values.<br/><br/>

      Notes:<br/>
      Any spaces in column names must be replaced with “_0x02c_”. <br/>
      The “real” column name may be different from what is displayed in SharePoint. To
      determine the real Column name select the column settings and check the browser address.
      For example for the property called "Description" you may
      see "....3F2%7D Field=Comments" at the end.  This means that the real name of the
      Column to be used in the SP_SetProperty action is "Comments".

      <e>
        <b>SP_SetProperty("Date,@Value")</b><br/>
        SP_Upload()<br/><br/>
        Moves the value of the current field to the SharePoint column named Date.
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the parameters are not blank.  The index information is uploaded to
      SharePoint when a document is subsequently uploaded.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="SP_Upload">
    <ap>None.</ap>
    <h>
      Uploads the image file and any indexes specified for the current page, document,
      or batch to SharePoint.  Uses TiffMerge file naming scheme to find document level or batch level
      image file: DocID.TIF or BatchID.TIF by default.  Pages associated with other image file types
      (e.g. TM000001.pdf, TM000001.jpg, etc) can be uploaded.<br/><br/>

      Note: after uploading, the variable “Upload_Folder” in the page/doc/batch will be set
      to the SharePoint URL where the document(s) were uploaded.<br/><br/>

      Note: if some documents in a batch are successfully uploaded and some fail, and the
      batch is re-run through the SharePoint Upload task, only documents that failed to upload will
      be re-uploaded.<br/><br/>

      Note: if any document is re-uploaded, SharePoint will replace the existing document with the
      newer one, or save the old version and replace it with the new version, depending on
      SharePoint Versioning settings.
      <e>
        <b>SP_Upload()</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if all documents and indexes were successfully uploaded.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="SP_UploadDir">
    <ap>
      Two comma separated parameters:<br/><br/>
      <b>1.</b> The Windows folder containing only document files to upload.<br/>
      <b>2.</b> A Boolean. True means delete file after upload, false means move file to the
      ‘Uploaded’ folder in current directory
    </ap>
    <h>
      Uploads all files in specified folder.
      <e>
        <b>SP_UploadDIR("C:\ParentDir\Invoice\Images\Input\,false")</b>
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      <b>True</b> if the upload succeeds for all files in the directory.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="SP_SetFileType">
    <ap>
      A string indicating the type or filename extension of the images to be uploaded for
      each document or batch. When uploading the Batch or Document this extension is
      appended to the BatchID or DocumentID to select the image. The IMAGEFILE property takes
      precedence for Page uploads. See the description of SP_Upload for details.<br/>
      Valid parameters include: tif, tiff, jpg, jpeg, jpe, gif or pdf.
      The parameter may optionally include a period (for example .tif and .jpeg are also valid).
    </ap>
    <h>
      NOTE: SP_SetUploadMode takes precedence over SP_SetFileType, if SP_SetUploadMode is called
      prior to SP_Upload this parameter has no effect.<br/>
      If neither SP_SetFileType nor SP_SetUploadMode are called, tif is used as the default file type.
      <e>
        <b>SP_SetFileType("jpg")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the parameter is not a three-character extension, jpeg, or tiff, with or without a leading period. .  Otherwise <b>True.</b><br/>
      Note: if a three-character extension is supplied that is invalid for Sharepoint images, the upload may fail.
    </ret>
    <see>SP_Upload</see>
  </ref>

  <ref id="SP_SetUploadMode">
    <ap>
      A string or Smart Parameter identifying the page level variable where file name stored.
      If this action is not called the value defaults to blank and regular upload logic applied.<br/>
      For example SP_SetUploadMode("ParentImage") will cause uploading file with the name stored
      in  'ParentImage' variable on the page level.
    </ap>
    <h>
      Use this action to identify the files that will be uploaded to SharePoint.
      <e>
        <b>SP_SetUploadMode(ParentImage)</b><br/>
        SP_Upload()
      </e>
    </h>
    <lvl>Batch, Document or Page level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>  
</help>
</rrx>
<rrx namespace="split" src="c:\datacap\RRS\split.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="SplitBatch" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Splits documents or pages in the batch into sub-batches, according to the value of the smart parameter you enter.]]>
<![CDATA[
]]>
<![CDATA[  ' If a page is part of a document, it goes along with all other pages in that parent document. For more information, ]]>
<![CDATA[
]]>
<![CDATA[  ' see the Parameters and Details sections below. "]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   'A <b>smart parameter</b> that determines the sub-batch for each document or page.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' <b>Important:</b> The action evaluates each document and loose page in the batch. ]]>
<![CDATA[
]]>
<![CDATA[   ' An unbound page is any page not inside a document.  ]]>
<![CDATA[
]]>
<![CDATA[   ' The set of smart parameter values found during the evaluation are grouped into "buckets":<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' 1. Identical values go into the same bucket.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' 2. If there are multiple buckets, all pages/documents that share the same value will ]]>
<![CDATA[
]]>
<![CDATA[   ' split to the same child batch.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' 3. There can be only <i>one child batch</i> for <i>each unique bucket value.</i><br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' ]]>
<![CDATA[
]]>
<![CDATA[   ' Child batches are named like the parent batch, but with a suffix such as .01, .02, etc.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' For example you might use for splitting:<br/><br/>  ]]>
<![CDATA[
]]>
<![CDATA[   ' <b>@D.Inbox.</b> If there is an Inbox variable in each document, this will split documents by ]]>
<![CDATA[
]]>
<![CDATA[   ' the value of the Inbox. Important! Any document or loose page ]]>
<![CDATA[
]]>
<![CDATA[   ' that does not have this value set will remain in the parent batch.]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim nPages]]>
<![CDATA[
]]>
<![CDATA[	Dim CurrentPage]]>
<![CDATA[
]]>
<![CDATA[	Dim retn]]>
<![CDATA[
]]>
<![CDATA[	Dim retSplit]]>
<![CDATA[
]]>
<![CDATA[	Dim sBucketValue]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[	Dim nIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Pilot.ChildrenQuantity = 0]]>
<![CDATA[
]]>
<![CDATA[	sBucketName = StrParam]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SplitBatch = False]]>
<![CDATA[
]]>
<![CDATA[	retSplit = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType <> DCO_BATCH Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("SplitBatch action must be bound at the batch level. Failed.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Force write DCO Data files]]>
<![CDATA[
]]>
<![CDATA[  If Instr(lcase(Pilot.dcofile),lcase(Pilot.BatchDir))<=0 Then]]>
<![CDATA[
]]>
<![CDATA[    sPageFile = Pilot.BatchDir + "\" + Pilot.dcofile]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sPageFile = Pilot.dcofile]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  bReturn=DCO.Write(sPageFile)]]>
<![CDATA[
]]>
<![CDATA[	If bReturn=False then ]]>
<![CDATA[
]]>
<![CDATA[		Call Writelog("ERROR Writing File: '" & Pilot.dcofile & "'. Aborting Batch.")]]>
<![CDATA[
]]>
<![CDATA[		Call Writelog("DCO Last Error:'" & DCO.GetLastError() & "'.")]]>
<![CDATA[
]]>
<![CDATA[    Call AbortBatch()]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SplitBatch on value: '" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sStatID = dco.Variable("ScanStation")]]>
<![CDATA[
]]>
<![CDATA[	sScanUser = dco.Variable("ScanUser")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nPages = CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	Call WriteLog("SplitBatch processing " + CStr(CurrentObj.NumOfChildren())+" pages or docs")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If nPages = 0 Then]]>
<![CDATA[
]]>
<![CDATA[		' abort the batch]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set dictBuckets = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ 	For CurrentPage = 0 To nPages - 1]]>
<![CDATA[
]]>
<![CDATA['		Call WriteLog("SplitBatch evaluate # " + CStr(CurrentPage+1))]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = CurrentObj.GetChild(CurrentPage)]]>
<![CDATA[
]]>
<![CDATA[		If oPage.ObjectType = DCO_PAGE or oPage.ObjectType = DCO_DOCUMENT Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If sBucketName = "" then ' for testing - when no parameter just use pageID]]>
<![CDATA[
]]>
<![CDATA[					sBucketValue = oPage.ID]]>
<![CDATA[
]]>
<![CDATA[				Else]]>
<![CDATA[
]]>
<![CDATA[					On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[					Set oSaveCurrentObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[					Set CurrentObj = oPage]]>
<![CDATA[
]]>
<![CDATA[					If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[					sBucketValue = CStr(MetaWord(sBucketName))]]>
<![CDATA[
]]>
<![CDATA[					Call WriteLog("Page or document value: " & sBucketValue)]]>
<![CDATA[
]]>
<![CDATA[					Set CurrentObj = oSaveCurrentObj]]>
<![CDATA[
]]>
<![CDATA[					If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[					On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				if sBucketValue <> "" then]]>
<![CDATA[
]]>
<![CDATA[					if Not dictBuckets.Exists(sBucketValue) then]]>
<![CDATA[
]]>
<![CDATA[							dictBuckets.Add sBucketValue, sBucketValue]]>
<![CDATA[
]]>
<![CDATA[			   	End If]]>
<![CDATA[
]]>
<![CDATA[			  End If]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Call WriteLog("Process unknown object - failed")	]]>
<![CDATA[
]]>
<![CDATA[	   	Set dictBuckets = Nothing]]>
<![CDATA[
]]>
<![CDATA[			bAbort = True]]>
<![CDATA[
]]>
<![CDATA[      nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next	' next page in batch]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Was maximum of 99 sub-batches now with new object 'oDCBase36' and AlphaDecimal names (01 to ZZ) allows 1295 sub-batches]]>
<![CDATA[
]]>
<![CDATA[	if dictBuckets.Count > 1295 Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("More than 1295 values in " & sBucketName & ", SplitBatch failed")]]>
<![CDATA[
]]>
<![CDATA[	   	Set dictBuckets = Nothing]]>
<![CDATA[
]]>
<![CDATA[			bAbort = True]]>
<![CDATA[
]]>
<![CDATA[      nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If dictBuckets.Count > 0 Then]]>
<![CDATA[
]]>
<![CDATA[		' we will split N batches]]>
<![CDATA[
]]>
<![CDATA[		Pilot.ChildrenQuantity = dictBuckets.Count	' this must be done before setting any of the conditions ]]>
<![CDATA[
]]>
<![CDATA[		aBuckets = dictBuckets.Keys]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 to dictBuckets.Count-1]]>
<![CDATA[
]]>
<![CDATA[			WriteLog ("SplitBatch process subbatch " & CStr(i) & " " & aBuckets(i))]]>
<![CDATA[
]]>
<![CDATA[			retSplit = SplitChildBatch(CurrentObj, aBuckets(i), i) ' split a subbatch for each bucket]]>
<![CDATA[
]]>
<![CDATA[			if retSplit <> True then ]]>
<![CDATA[
]]>
<![CDATA[				bAbort = True]]>
<![CDATA[
]]>
<![CDATA[	      nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[				Exit For]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next ' next i]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		' clear out all pages/docs that were split from the page file]]>
<![CDATA[
]]>
<![CDATA[		For nIndex = CurrentObj.NumOfChildren-1 to 0 Step -1]]>
<![CDATA[
]]>
<![CDATA[			Set oPage = CurrentObj.GetChild(nIndex)]]>
<![CDATA[
]]>
<![CDATA[			if sBucketName = "" then ' for testing - when no parameter just use pageID]]>
<![CDATA[
]]>
<![CDATA[				sBucketValue = oPage.ID]]>
<![CDATA[
]]>
<![CDATA[			else]]>
<![CDATA[
]]>
<![CDATA[				On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[				Set oSaveCurrentObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[				Set CurrentObj = oPage]]>
<![CDATA[
]]>
<![CDATA[				If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[				sBucketValue = CStr(MetaWord(sBucketName))]]>
<![CDATA[
]]>
<![CDATA[				Call WriteLog("Page or document value: " & sBucketValue)]]>
<![CDATA[
]]>
<![CDATA[				Set CurrentObj = oSaveCurrentObj]]>
<![CDATA[
]]>
<![CDATA[				If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[				On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[			if sBucketValue <> "" then  ' delete any page or doc that has a bucket value - e.g. is split]]>
<![CDATA[
]]>
<![CDATA[				CurrentObj.Deletechild(nIndex)]]>
<![CDATA[
]]>
<![CDATA[		  End If]]>
<![CDATA[
]]>
<![CDATA[		Next 'nIndex]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set dictBuckets = Nothing		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If retSplit = True Then]]>
<![CDATA[
]]>
<![CDATA[		SplitBatch = True]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' Batch Split Actions
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
]]>	
<ref id="SplitBatch" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    A <b>smart parameter</b> pointing to a Document or Page variable that determines if the Document or Page is to be split to a Child Batch.<br/><br/>
    <b>Important:</b> The action evaluates all documents and pages (including unbound* pages) in the batch.<br/> 
     
    The values of the smart parameter variable found during the document and page evaluation are grouped into "buckets":<br/><br/>
    1. Identical values go into the same bucket.<br/><br/>
    2. If there are multiple buckets, all pages/documents that share the same value will split to the same child batch.<br/><br/>
    3. There can be only <i>one child batch</i> for <i>each unique bucket value.</i><br/><br/>
    
    Child batches have the same name as the parent batch, but include an additional two character alphadecimal suffix such as .01, .02, .0A, .ZZ, etc.<br/><br/>
    Example:<br/><br/>  
    <b>@D.Inbox.</b> If there is an Inbox variable in each document, this will split documents by the value of the Inbox variable.<br/><br/>
    <b>Important:</b> Any document or unbound* page that does not have this Inbox variable value, will remain in the parent batch.<br/><br/>
    
    *An unbound page is any page not inside a document. 
  </ap>
  <h>
    Additional considerations:<br/>
    <br/>
    There is only one "job routing condition" raised by this action: it is the first one in the task's list of conditions.<br/>
    <br/>
    The task's <i>Task Setup/Task Settings</i> screen <b><i>must</i></b> be configured as <i>Job Router</i>, and a single condition defined (by convention, call it <b>Split</b>).<br/><br/>
    1. Any and all <b>child batches</b> will be routed via this single condition.<br/>
    2. If the application wants to treat the individual buckets differently, then the first step in the workflow after splitting can check the same smart parameter value and branch or re-route the child batch using that value.<br/>
    3. All the structure and variables, etc. that were in the parent batch docs/pages are retained in the child batches.<br/>
    4. In addition, new variables <b>ParentBatch</b> and <b>ParentBatchDir</b> are added.<br/>
    5. Can only be used once per Parent Batch.<br/>
    <e>
      SplitBatch(@D.Inbox)
    </e>
  </h>
  <lvl>Batch level only.</lvl>
  <ret>
    True if the operation succeeds, False if it does not.<br/><br/>
    Each child batch split off will generate a condition, which should be configured for <b>Split</b> in the workflow.<br/> 
    Any page or document with a blank value for the splitting value will remain in the original "parent" batch.
  </ret>
</ref>
</help>

</rrx>
<rrx namespace="TifMerge" src="c:\datacap\RRS\TifMerge.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="TifMerge_SetFileName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Sets the name of the multi-Image file (.tif) to be created by TifMerge."]]>
<![CDATA[
]]>
<![CDATA[  'String value of the file name to be assigned to the multi-page file.  Smart parameters are supported.<br/>]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  This action sets the name of the multi-Image file (.tif) to be created by the <b>TifMerge</b> actions.]]>
<![CDATA[
]]>
<![CDATA[  '  The file’s name can be text, or a combination of text and the value of a variable your enter as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  '  The action automatically adds the “.tif” extension to the file.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	g_TifMergeName = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	on error resume next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  g_TifMergeName = MetaWord(Trim(StrParam))  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if len(trim(g_TifMergeName))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("TifMerge Name has no value. Setting to Default name 'TifMerge'")]]>
<![CDATA[
]]>
<![CDATA[		g_TifMergeName = "TifMerge"]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting TifMerge File Name to : " & g_TifMergeName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TifMerge_SetFileName = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function TifMerge_SetFileName")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TifMerge_SetFilePath" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'Sets the path for the multi-Image file."]]>
<![CDATA[
]]>
<![CDATA[  'String value for the output path of the multi-Image TIF file.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sDriveName]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SET FILE PATH")]]>
<![CDATA[
]]>
<![CDATA[	TifMerge_SetPath = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strParam = MetaWord(Trim(strParam))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sDriveName = FileMgr.GetDriveName(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not FileMgr.DriveExists(sDriveName) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "SET TifMerge_SetFilePath FAILED. NO SUCH DRIVE : " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		TifMerge_SetFilePath = False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If FileMgr.FolderExists(strParam) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Folder Exists. Setting Export path to: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		g_TifMergePath = strParam]]>
<![CDATA[
]]>
<![CDATA[		TifMerge_SetFilePath = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "NO SUCH PATH : " & strParam & " Building New Path.")]]>
<![CDATA[
]]>
<![CDATA[		TifMerge_SetFilePath = TifMerge_MakePath(strParam)]]>
<![CDATA[
]]>
<![CDATA[		g_TifMergePath = strParam]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("Path set to " & g_TifMergePath)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("END TifMerge_SetFilePath")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function TifMerge_SetFilePath")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TifMerge_MergeImages" access="public" bInter="bInter" bDebug="bDebug" strParam="sPageType">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Merges the images associated with the object of the Document Hierarchy to which the action’s ruleset applies into a single, multi-Image file."]]>
<![CDATA[
]]>
<![CDATA['String value indicating either:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['  1. "All" if the multi-Image file is to contain images of all pages without regard to Page Type.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['  2. The Page Type(s) of the images to be included (comma-separated list, if the parameter includes more than one Page Type.)<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[  sPageType = MetaWord(Trim(sPageType))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If trim(ucase(sPageType)) = "ALL" then sPageType = "*"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TifMerge_MergeImages = tm_TifMerge_MergeImages(CurrentObj, sPageType)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TifMerge_MyImage" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Adds each single image to the multi-Image file."<ap>None.</ap>	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' Adds the current page image to the multi-Image TIF file.  Actions that proceed the TifMerge_MyImage action]]>
<![CDATA[
]]>
<![CDATA[   ' allow you to specify under which conditions an image is to be added to the multi-Image file.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' A rule with this action can only be applied to a Page object.  The output image file name]]>
<![CDATA[
]]>
<![CDATA[   ' and destination path must have been previously set using TifMerge_SetFileName and TifMerge_SetFilePath.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sMergeFile ]]>
<![CDATA[
]]>
<![CDATA[	Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim bRes]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	TifMerge_MyImage = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sMergeFile = g_TifMergePath & "\" & g_TifMergeName & ".tif"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType = DCO_PAGE Then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		StrParam = CurrentObj.ImageName         ' Get the filename for the current page.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If Not FileMgr.FileExists(StrParam) Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("File " & StrParam & " not Found. Skipping Image")	]]>
<![CDATA[
]]>
<![CDATA[		Elseif StrParam = sMergeFile then 	]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Image File is Merge to File. Image not Merged!")	]]>
<![CDATA[
]]>
<![CDATA[		Else				]]>
<![CDATA[
]]>
<![CDATA[			g_TifMergeFile.filename = StrParam ]]>
<![CDATA[
]]>
<![CDATA[			bRes=g_TifMergeFile.save(sMergeFile)]]>
<![CDATA[
]]>
<![CDATA[			If bRes=False then ]]>
<![CDATA[
]]>
<![CDATA[				writelog(StrParam & " ** Merge Failed: " & g_TifMergeFile.GetLastError)]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				writelog(StrParam & " Merged.")]]>
<![CDATA[
]]>
<![CDATA[				TifMerge_MyImage = True]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Calling Obj is not a Page object. No Image uploaded.")	]]>
<![CDATA[
]]>
<![CDATA[		TifMerge_MyImage = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="TifMerge_PreserveCompression" access="public">
	<p name="PreserveCompression">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Determines the output compression type for merged images."]]>
<![CDATA[
]]>
<![CDATA[  '  <b>TRUE</b> : Preserves the original compression type of the source image.<br/>]]>
<![CDATA[
]]>
<![CDATA[  '  <b>FALSE</b> : Uses G4 compression for black and white images.  JEPG is used for color images.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[			On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      TifMerge_PreserveCompression = true]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      If (UCase(PreserveCompression)="TRUE") Then ]]>
<![CDATA[
]]>
<![CDATA[				g_PreserveCompression = true]]>
<![CDATA[
]]>
<![CDATA[			Else ]]>
<![CDATA[
]]>
<![CDATA[				g_PreserveCompression = false]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	]]>
	</g>
</f>
<help>
  <![CDATA[
'******************************************************************************************
' TifMerge Actions 

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 
' 5725-C15 5725-C69
' 
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
' 
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
'
' Version = "8.1.0.1"
' Updated 01/03/2012 RFerin
' SPR 33487 changed examples of @DATE to @DATE(dd.mm.yyyy) because the default uses a slash separator which is invalid in a file name.
'
'*****************************************************************************************
]]>
<ref id="TifMerge_SetFileName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the name of the multi-Image file (.tif) to be created by TifMerge.">
  <ap>
   <i>String</i> value of the file name to be assigned to the multi-page file.  Smart parameters are supported.<br/>
  </ap>  
  <h>
    This action sets the name of the multi-Image file (.tif) to be created by the <b>TifMerge</b> actions.
    The file’s name can be text, or a combination of text and the value of a variable your enter as a parameter.
    The action automatically adds the “.tif” extension to the file.<br/><br/>
    <e>
      <b>TifMerge_SetFileName("Doc_+@ID+@DATE(dd.mm.yyyy)")</b><br/>
      TifMerge_SetFilePath("c:\ParentDir\Invoice\MultiImage")<br/>
      TifMerge_MergeImages("All")<br/><br/>
      
      The example above assumes that the rules with these actions are applied to a <b>Document</b> object. 
      The names combine text values such as “Doc_” with values assigned to variables by using smart parameters.<br/><br/>
      
      TifMerge_SetFileName("MultiTif_+@ID")<br/><br/>
      This example combines "MultiTif_" with the ID of the Document Hierarchy object to which the ruleset is applied.
      Usually, a rule containing this action applies to a <b>Batch</b> object or <b>Document</b> object,
      but can apply to a <b>Page</b> or <b>Field</b> object.  <br/><br/>
	  </e>  
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>TifMerge_SetFilePath</see>
</ref>

<ref id="TifMerge_SetFilePath" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Sets the path for the multi-Image file.">
  <ap>
    <i>String</i> value for the output path of the multi-Image TIF file.  Smart parameters are supported.
  </ap>
  <h>
    Sets the path for where the multi-Image file will be created. If the folder designated in the parameter does not exist, 
    the action will create the folder in which the TIF file will be placed.<br/><br/>
    Usually, a rule containing this action applies to a Batch object or Document object of the
    Document Hierarchy, but can apply to a Page or Field object.
    <e>
      TifMerge_SetFileName("Doc_+@ID+@DATE(dd.mm.yyyy)")<br/>
		  <b>TifMerge_SetFilePath("c:\ParentDir\Invoice\MultiImage")</b><br/>
      TifMerge_MergeImages("All")
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the specified drive does not exist or the path cannot be created. Otherwise, <b>True.</b>
  </ret>
  <see>TifMerge_SetFileName</see>
  </ref>

<ref id="TifMerge_MergeImages" access="public" bInter="bInter" bDebug="bDebug" strParam="sPageType" qi="Merges the images associated with the object of the Document Hierarchy to which the action’s ruleset applies into a single, multi-Image file.">
  <ap>
    <i>String</i> value indicating either:<br/><br/>
    1. "All" if the multi-Image file is to contain images of all pages without regard to Page Type.<br/><br/>
    2. The Page Type(s) of the images to be included (comma-separated list, if the parameter includes more than one Page Type.)<br/><br/>
    Smart parameters are supported.
  </ap>
  <h>    
    This action merges the images associated with the object to 
    which the action’s rule applies into a single, multi-Image file. <br/><br/>
    
    At the <b>Batch</b> level, the action merges all Image files in the 
    batch into one multi-Image file – or those Image files representing pages of the Page Type you specify as a parameter.

    At the <b>Document</b> level, the action assembles a new multi-Image file for each document in the batch. 
    If you specify a Page Type, the multi-Image file for each document will include only images of pages of that type.<br/><br/>

    Actions TifMerge_SetFileName and TifMerge_SetFilePath must be called before TifMerge_MergeImages.
    <e>
      TifMerge_SetFileName("@BATCHID+@DATE(dd.mm.yyyy)")<br/>
      TifMerge_SetFilePath("C:\ParentDir\Invoice\batches\MultiImage")<br/>
			<b>TifMerge_MergeImages("All")</b><br/><br/>

      TifMerge_SetFileName("Doc_+@ID+@DATE(dd.mm.yyyy)")<br/>
      TifMerge_SetFilePath("C:\ParentDir\Invoice\MultiImage")<br/>
      <b>TifMerge_MergeImages("Invoice,Attachment")</b><br/><br/>

      The first example merges all images into a multi-Image file that uses the Batch ID 
      and the processing Date for its name.<br/><br/>
      
      The second example applies to a <b>Document</b> object of the Document Hierarchy. 
      It assembles a multi-Image file for each document in the batch; the images in a 
      file are limited to <i>Invoice</i> and <i>Attachment</i> pages.
    </e>
  </h>
  <lvl>Batch or Document.</lvl>
  <ret>
    <b>False</b> if the action cannot create the multi-Image file. Otherwise, <b>True.</b>
  </ret>
  
</ref>

<ref id="TifMerge_MyImage" access="public" bInter="bInter" bDebug="bDebug"
  qi="Adds each single image to the multi-Image file.">
  <ap>None.</ap>	
  <h>
    Adds the current page image to the multi-Image TIF file.  Actions that proceed the TifMerge_MyImage action
    allow you to specify under which conditions an image is to be added to the multi-Image file.<br/><br/>
    A rule with this action can only be applied to a Page object.  The output image file name
    and destination path must have been previously set using TifMerge_SetFileName and TifMerge_SetFilePath.
    <e>      
      ChkDDCOStatus("0")<br/>
      <b>TifMerge_MyImage()</b><br/><br/>

      In this example, the <b>ChkDCOStatus</b> action checks that the status of the current page is “0”.
      If so, the image for the current page will be added to the multi-Image file.<br/><br/>

      If the current status of this page is not “0”, the rule will fail and the <b>TifMerge_MyImage</b>
      action will not be run; therefore, the current image will not be added to the multi-Image file.<br/><br/>

      This <b>ChkDCOStatus</b> action is used as an example.  You can use many other
      actions to be sure the current image meets your merging criteria.
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the action’s ruleset is not applied to a <b>Page</b> object or if the 
    corresponding image file for the current page cannot be found. Otherwise, <b>True.</b>
  </ret>
  <see>TifMerge_SetFileName, TifMerge_SetFilePath</see>
  
</ref>

<ref id="TifMerge_ExportToBatchDir" access="private" bInter="bInter" bDebug="bDebug" qi="Indicates that the path for the multi-Image file is to the current Batch directory. ">
	<ap>None.</ap>
	<lvl>Batch or Document usually, but Page or Field is permissable.</lvl>
	<ret>False if the path does not exist or is not accessible. Otherwise, True</ret>
	<h>
    When saving a multi-image file, this action is used to configure the current batch directory as the destination
    for the output file.  This action must be called before the action to merge the images.
		<e>
			<b>TifMerge_ExportToBatchDir()</b><br/>
      TifMerge_MergeImages("All")
    </e>
	</h>
</ref>
  
<ref id="TifMerge_PreserveCompression" access="public" qi="Determines the output compression type for merged images."><p name="PreserveCompression"/>
	<ap>
    <b>TRUE</b> : Preserves the original compression type of the source image.<br/>
    <b>FALSE</b> : Uses G4 compression for black and white images.  JEPG is used for color images.
  </ap>
	<lvl>Any.</lvl>
	<ret>Always True.</ret>
	<h>
    This action will configure the output format for TifMerge_MergeImages.
    If this action is not called, then the default value of "FALSE" is used, 
    so the original image compression is not preserved.
		<e>
			<b>TifMerge_PreserveCompression("TRUE")</b><br/>
      <b>TifMerge_MergeImages("All")</b>
		</e>
	</h>
</ref>
</help>
</rrx>
<rrx namespace="TM524" src="c:\datacap\RRS\TM524.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="TM524" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ' Makes changes to the Page file for the current batch so that it is backward-compatible]]>
<![CDATA[
]]>
<![CDATA[  ' with older tasks that are not rules-based, tasks such as Recog2K, or ExportTX."]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'This action alters the task's Page file for the current batch so that it is]]>
<![CDATA[
]]>
<![CDATA[  'backward-compatible with non-rules-based tasks, such as Recog2K, or ExportTX.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  '  These tasks expect certain batch-, document-, and page-level variables that are not ]]>
<![CDATA[
]]>
<![CDATA[  '  used in the rules-based environment.  After the action is run, old-style tasks will ]]>
<![CDATA[
]]>
<![CDATA[  '  proceed as if the batch was run entirely with that type of task.<br/><br/>  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCO.FindVariable("ED")= -1 then ]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("ED")= "0"]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCO.FindVariable("AD")= -1 then ]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("AD")= "0"]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCO.FindVariable("EP")= -1 then ]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("EP")= "0"]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCO.FindVariable("AP")= -1 then ]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("AP")= "0"]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_TM524_nIndex = 0]]>
<![CDATA[
]]>
<![CDATA[	TM524 = GetChildren(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Total fields Indexed: " & g_TM524_nIndex) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="TM4DocIdFormat" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 'Formats all Document ID's with a Taskmaster 4 layout style."]]>
<![CDATA[
]]>
<![CDATA[  'This action formats all Document ID's with a <i>Taskmaster 4</i>layout style.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[  ' Note: Rules that employ this action must be part of a RuleSet that is bound ]]>
<![CDATA[
]]>
<![CDATA[  '  to the Document Hierarchy's <b>Batch</b> object.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	TM4DocIdFormat = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType <> 0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Action Must be Bound at the Batch level. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim nSize]]>
<![CDATA[
]]>
<![CDATA[	Dim rChild]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[	Dim cIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigID	]]>
<![CDATA[
]]>
<![CDATA[	Dim sNewID]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nSize = CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Found " & cstr(nSize) & " children to Process.")]]>
<![CDATA[
]]>
<![CDATA[	cIndex = 1		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Starting w/ " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nSize-1]]>
<![CDATA[
]]>
<![CDATA[		Set rChild=CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		if Not(rChild is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[			Debuglog("Child is Type '" & rChild.ObjectType & "' ")]]>
<![CDATA[
]]>
<![CDATA[			If rChild.ObjectType = 1 Then ]]>
<![CDATA[
]]>
<![CDATA[				sOrigID = rChild.ID]]>
<![CDATA[
]]>
<![CDATA[				sNewID = Pilot.BatchID & "." & Right("00" & cstr(cIndex),2)]]>
<![CDATA[
]]>
<![CDATA[				rChild.ID = sNewID]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Renaming Document '" & sOrigID & "' to '" & sNewID & "' ")]]>
<![CDATA[
]]>
<![CDATA[				cIndex = cIndex + 1]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("TM4DocIdFormat")]]>
<![CDATA[
]]>
<![CDATA[	TM4DocIdFormat = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>

<help>
<![CDATA[
'********************************************************************************
' TM524.rra Actions
'--------------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'********************************************************************************
]]>
  
<ref id="TM524" access="public" bInter="bInter" bDebug="bDebug" qi="Makes changes to the Page file for the current batch so that it is backward-compatible with older tasks that are not rules-based, tasks such as Recog2K, or ExportTX.">
  <ap>None.</ap>  
  <h>
    This action alters the task's Page file for the current batch so that it is 
    backward-compatible with non-rules-based tasks, such as Recog2K, or ExportTX.<br/><br/>
    
    These tasks expect certain batch-, document-, and page-level variables that are not 
    used in the rules-based environment.  After the action is run, old-style tasks will 
    proceed as if the batch was run entirely with that type of task.<br/><br/>
    
    <b>Note:</b> Rules that employ this action must be part of a RuleSet that is bound  
    to the Document Hierarchy's <b>Batch</b> object.
    <e>
      <b>TM524()</b>
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>

</ref>
	
<ref id="TM4DocIdFormat" access="public" bInter="bInter" bDebug="bDebug" qi="Formats all Document ID's with a Taskmaster 4 layout style.">
  <ap>None.</ap>  
  <h>
    This action formats all Document ID's with a <i>Taskmaster 4</i>layout style.<br/><br/>
    <b>Note:</b>R ules that employ this action must be part of a RuleSet that is bound 
    to the Document Hierarchy's <b>Batch</b> object.
    <e>
      <b>TM4DocIdFormat()</b>
    </e>
  </h>
  <lvl>Batch only.</lvl>
  <ret>
    <b>False,</b> if not called at the batch level.  Otherwise, <b>True.</b>
  </ret>
</ref>
</help>

</rrx>
<rrx namespace="Validations" src="c:\datacap\RRS\Validations.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="IsFieldPercentNumeric" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['A number (0-100) indicating the percentage that results in a  condition. The ]]>
<![CDATA[
]]>
<![CDATA['default percentage is 100.  The value must be numeric, without the percent sign.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	Dim Value, TrueCount, FalseCount, TFRatio, Lval, sCharacter]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldPercentNumeric percentage parameter set to " & StrParam & " percent.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldPercentNumeric = False]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ' \p{N} or \p{Number}: any kind of numeric character in any script. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nd} or \p{Decimal_Digit_Number}: a digit zero through nine in any script except ideographic scripts. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nl} or \p{Letter_Number}: a number that looks like a letter, such as a Roman numeral. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{No} or \p{Other_Number}: a superscript or subscript digit, or a number that is not a digit 0..9 (excluding numbers from ideographic scripts). ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	For Cx = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[    sCharacter=Mid(value,Cx,1)]]>
<![CDATA[
]]>
<![CDATA[		If DCGlobalStrings.RegExIsMatch(sCharacter,"\p{N}") Then]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*Len(value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio and Len(Value)>0 Then IsFieldPercentNumeric = True]]>
<![CDATA[
]]>
<![CDATA[	If Len(Value) <= 0 Then Lval = 1 Else Lval = Len(value)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "Value is " & (TrueCount/Lval)*100 & "% Numeric") ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldPercentNumeric returns " & IsFieldPercentNumeric ) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldPercentNumeric = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sReturn = RRState.LoadString("validations","IsFieldPercentNumeric_01","Field '{0}' value '{1}' contains less than the expected {2} percent of numeric characters.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call ErrorHandler("Function IsFieldPercentNumeric")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldPercentAlpha" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	' A number (0-100) indicating the percentage necessary to return a  condition.  The value must be numeric, without the percent sign.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim Value, TrueCount, FalseCount, TFRatio, Cx, Lval]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldPercentAlpha = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' StrParam is a value between 0 and 100]]>
<![CDATA[
]]>
<![CDATA[	' This action determines the percentage of numbers required to return True]]>
<![CDATA[
]]>
<![CDATA[	' Defaults to 100% ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("IsFieldPercentAlpha percentage parameter set to " & StrParam & " percent.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' \p{L} or \p{Letter}: any kind of letter from any language. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Ll} or \p{Lowercase_Letter}: a lowercase letter that has an uppercase variant. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lu} or \p{Uppercase_Letter}: an uppercase letter that has a lowercase variant. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lt} or \p{Titlecase_Letter}: a letter that appears at the start of a word when only the first letter of the word is capitalized. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{L&} or \p{Letter&}: a letter that exists in lowercase and uppercase variants (combination of Ll, Lu and Lt). ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lm} or \p{Modifier_Letter}: a special character that is used like a letter. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lo} or \p{Other_Letter}: a letter or ideograph that does not have lowercase and uppercase variants. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  For Cx = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[    sCharacter=Mid(value,Cx,1)]]>
<![CDATA[
]]>
<![CDATA[		If DCGlobalStrings.RegExIsMatch(sCharacter,"\p{L}") Then]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*Len(value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio and Len(Value)>0 Then IsFieldPercentAlpha = True]]>
<![CDATA[
]]>
<![CDATA[	If Len(Value) <= 0 Then Lval = 1 Else Lval = Len(value)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "Value is " & (TrueCount/Lval)*100 & "% Alphabetic") ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldPercentAlpha returns " & IsFieldPercentAlpha) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldPercentAlpha = False Then ]]>
<![CDATA[
]]>
<![CDATA[		sReturn = RRState.LoadString("validation","IsFieldPercentAlpha_01","Field '{0}' value '{1}' contains less than the expected {2} percent of Alphabetic characters.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call ErrorHandler("Function IsAlpha")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDate" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   Checks that the captured value of the field represented by the bound Field ]]>
<![CDATA[
]]>
<![CDATA[ '   object has an acceptable Date format.]]>
<![CDATA[
]]>
<![CDATA[ '   This action will accept any valid date from 01/01/0001 through 12/31/9999.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim value]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  IsFieldDate = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[    locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  If Not DCGlobalDates.IsDate(value,locale) Then ]]>
<![CDATA[
]]>
<![CDATA[		  IsFieldDate = False]]>
<![CDATA[
]]>
<![CDATA[      sReturn = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[      sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[		  DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog(DCGlobalDates.GetLog)]]>
<![CDATA[
]]>
<![CDATA[	  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	  WriteLog("IsFieldDate returns " & IsFieldDate)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateEqualOrAfter" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Field object of the Document Hierarchy to be compared with the ]]>
<![CDATA[
]]>
<![CDATA[ '   current field's Date value.]]>
<![CDATA[
]]>
<![CDATA[ '   Checks that the Date value in the current field represented by the bound Field]]>
<![CDATA[
]]>
<![CDATA[ '   object of the Document Hierarchy is greater than or equal to the Date value in the]]>
<![CDATA[
]]>
<![CDATA[ '   field specified as the parameter.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim oDcoObj]]>
<![CDATA[
]]>
<![CDATA[	Dim sDateFrom]]>
<![CDATA[
]]>
<![CDATA[	Dim sDateThru]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateEqualOrAfter=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDcoObj = ReturnNamedComponent(trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	If oDcoObj is nothing then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Compare to Field '" & StrParam & "' not found.")]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrAfter=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sDateFrom = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[  locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(sDateFrom,locale) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrAfter = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.Loadstring("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sDateThru = oDcoObj.Text]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(sDateThru,locale) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrAfter = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.Loadstring("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",oDcoObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sDateThru)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldDateEqualOrAfter=False Then ]]>
<![CDATA[
]]>
<![CDATA[		Set oDcoObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Select Case DCGlobalDates.CompareDate(sDateFrom,sDateThru,locale)]]>
<![CDATA[
]]>
<![CDATA[  	Case "-1"]]>
<![CDATA[
]]>
<![CDATA[	  	IsFieldDateEqualOrAfter = False]]>
<![CDATA[
]]>
<![CDATA[      sMessage = RRState.Loadstring("validations","IsDateEqualorAfter_01","Field '{0}' date of '{1}' must be after or the same date as Field '{2}' date of '{3}'.")]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{1}",sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{2}",oDcoObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{3}",sDateThru)]]>
<![CDATA[
]]>
<![CDATA[	  	DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		  Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Case "1","0"]]>
<![CDATA[
]]>
<![CDATA[      sMessage = "From date is greater than or equal to through date"]]>
<![CDATA[
]]>
<![CDATA[		  Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Case else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("unknown result")]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateEqualOrBefore" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ' The name of the Field object of the Document Hierarchy to be compared with ]]>
<![CDATA[
]]>
<![CDATA[  ' the current field's Date value.]]>
<![CDATA[
]]>
<![CDATA[  ' Checks that the date in the current field represented by the bound Field object of the]]>
<![CDATA[
]]>
<![CDATA[  ' Document Hierarchy is less than or equal to the Date value in the field specified as the parameter.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim oDcoObj]]>
<![CDATA[
]]>
<![CDATA[	Dim sDateFrom]]>
<![CDATA[
]]>
<![CDATA[	Dim sDateThru]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateEqualOrBefore=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDcoObj = ReturnNamedComponent(trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	If oDcoObj is nothing then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Compare to Field '" & StrParam & "' not found.")]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrBefore=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sDateFrom = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[  locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(sDateFrom,locale) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrBefore = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.Loadstring("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[   	DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sDateThru = oDcoObj.Text]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(sDateThru,locale) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrBefore = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.Loadstring("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",oDcoObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sDateThru)]]>
<![CDATA[
]]>
<![CDATA[   	DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldDateEqualOrBefore=False Then ]]>
<![CDATA[
]]>
<![CDATA[		Set oDcoObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Select Case DCGlobalDates.CompareDate(sDateFrom,sDateThru,locale)]]>
<![CDATA[
]]>
<![CDATA[  	Case "-1","0"]]>
<![CDATA[
]]>
<![CDATA[      sMessage = "From field date is less than or equal to through date."]]>
<![CDATA[
]]>
<![CDATA[	    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Case "1"]]>
<![CDATA[
]]>
<![CDATA[      IsFieldDateEqualOrBefore = False]]>
<![CDATA[
]]>
<![CDATA[      sMessage = RRState.Loadstring("validations","IsDateEqualorBefore_01","Field '{0}' date of '{1}' must be before or the same date as Field '{2}' date of '{3}'.")]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{1}",sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{2}",oDcoObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{3}",sDateThru)]]>
<![CDATA[
]]>
<![CDATA[      DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Case else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("unknown result")]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="CalculateDateDifference" access="public">
	<p name="startDate">
	</p>
	<p name="endDate">
	</p>
	<p name="targetVariable">
	</p>
	<p name="dateProperty">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CalculateDateDifference=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  startDate    = MetaWord(startDate) ]]>
<![CDATA[
]]>
<![CDATA[  endDate      = MetaWord(endDate) ]]>
<![CDATA[
]]>
<![CDATA[  dateProperty = MetaWord(dateProperty)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("startDate = " & startDate & ". endDate = " & endDate & ". dateProperty = " & dateProperty & ".")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(startDate) Then]]>
<![CDATA[
]]>
<![CDATA[		CalculateDateDifference = False    ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "The startDate value of '{1}' is not a valid date or recognised date format."]]>
<![CDATA[
]]>
<![CDATA[   ' sMessage = RRState.Loadstring("validations","IsFieldDate_01","The date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",startDate)]]>
<![CDATA[
]]>
<![CDATA[   ' DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("Start date error: " & sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(endDate) Then]]>
<![CDATA[
]]>
<![CDATA[		CalculateDateDifference = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "The endDate value of '{1}' is not a valid date or recognised date format."]]>
<![CDATA[
]]>
<![CDATA[   ' sMessage = RRState.Loadstring("validations","IsFieldDate_01","The date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",endDate)]]>
<![CDATA[
]]>
<![CDATA[   ' DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("End date error: " & sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  dim result]]>
<![CDATA[
]]>
<![CDATA[  result = DCGlobalDates.SubtractDates(startDate,endDate, dateProperty, "")  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog(DCGlobalDates.GetLog())]]>
<![CDATA[
]]>
<![CDATA[  Writelog("SubtractDates result: " & result)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If len(targetVariable) = 0 Then targetVariable = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  targetVariable = Trim(targetVariable)]]>
<![CDATA[
]]>
<![CDATA[  CalculateDateDifference = DCONavSetValue(targetVariable, result)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</f>
<af name="AssignFieldDefault" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['   Assigns a default value to the current field.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(CurrentObj is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Clear]]>
<![CDATA[
]]>
<![CDATA[		AssignFieldDefault = u_ModifyText("","",1,StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Elseif not(isObject(LogWindow)) then]]>
<![CDATA[
]]>
<![CDATA[		AssignFieldDefault = False]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("AssignFieldDefault returns " & AssignFieldDefault)	]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	end If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AssignFieldDefault returns " & AssignFieldDefault)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldLengthMax" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    Checks that the character length of the current Field object's captured value is equal to ]]>
<![CDATA[
]]>
<![CDATA['    or less than the value set as a parameter..]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim wCount, msg]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " "]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsFieldLengthMax = False ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	wCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		If wCount <= CInt(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[			IsFieldLengthMax = True]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		msg = vbCr & "Parameter is not Numeric."]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLengthMax is " & StrParam & " character(s). Character count is " & wCount & msg)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLengthMax returns: " & IsFieldLengthMax)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldLengthMax = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldLengthMax_01","Field '{0}' value of '{1}' is too long. The field has {3} characters and the maximum allowed length is {2}.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{3}",wCount)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldLengthMax")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldLengthMin" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['   Checks the character length of the current Field object's captured value to see if its ]]>
<![CDATA[
]]>
<![CDATA['   length is equal to or longer than a number <var>n</var>]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim wCount, msg]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	IsFieldLengthMin = False]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then WriteLog("IsFieldLengthMin: Invalid Parameter '" & strParam & "' . Function Failed")]]>
<![CDATA[
]]>
<![CDATA[	wCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("IsFieldLengthMin: Start Value = '" & GetFieldValue() & "'   Length = " & wCount)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		If wCount >= CInt(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[			IsFieldLengthMin = True]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		msg = vbCr & "Parameter is not Numeric."]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLengthMin is " & StrParam & " character(s). Character count is " & wCount & msg)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLengthMin returns: " & IsFieldLengthMin)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldLengthMin = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldLengthMin_01","Field '{0}' value of '{1}' is too short. The field has {3} characters and the minium allowed length is {2}.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{3}",wCount)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldLengthMin")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="InsertChars" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' 1. The characters or character string to be inserted; defaults to a space.]]>
<![CDATA[
]]>
<![CDATA['	2. A number n indicating the target position within the captured value; ]]>
<![CDATA[
]]>
<![CDATA['    defaults to the end of the value.]]>
<![CDATA[
]]>
<![CDATA[' 3. The number of insertions; defaults to 1.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Inserts a character or string of characters into the captured value, one or more times.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim l,w,c]]>
<![CDATA[
]]>
<![CDATA[	Dim w_left,v_top,w_right,v_bottom]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam, PlaceAt, sInsert, addPos, Cx]]>
<![CDATA[
]]>
<![CDATA[	Dim Tstring]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	StrParam = StrParam & ", , "]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	CurCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " , ,1"]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam &",," ,",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If isnumeric(aStrParam(1)) then]]>
<![CDATA[
]]>
<![CDATA[		If aStrParam(1) < 1 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(aStrParam(1)) Or aStrParam(1) = " " Then ]]>
<![CDATA[
]]>
<![CDATA[		aStrParam(1) = CurCount + 1]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		PlaceAt = aStrParam(1) ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(aStrParam(2)) Then aStrParam(2) = "1"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sInsert = aStrParam(0)  'string to insert]]>
<![CDATA[
]]>
<![CDATA[	PlaceAt = aStrParam(1)  'position to insert]]>
<![CDATA[
]]>
<![CDATA[	iNumber = aStrParam(2)  'times to insert]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("InsertChars Insert String '" & sInsert & "' starting at position# '" & PlaceAt & "' , '" & iNumber & "' times.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Tstring = ""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If CInt(CurCount) < CInt(PlaceAt) Then PlaceAt = CurCount + 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Len(sInsert)= 0 Then sInsert = " "]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Cnt = 1 To CInt(iNumber)]]>
<![CDATA[
]]>
<![CDATA[		Tstring = Tstring & sInsert]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cnt]]>
<![CDATA[
]]>
<![CDATA[		      ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Inserting value:'" & Tstring & "'")         ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  if CurrentObj is Nothing then exit Function         ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  For xChar = 1 To Len(Tstring)]]>
<![CDATA[
]]>
<![CDATA[    NewValue = Mid(Tstring,xChar,1)]]>
<![CDATA[
]]>
<![CDATA[    Set oNewChar = CurrentObj.AddChild(4,"",PlaceAt-1)	]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Adding character '" & NewValue & "' to position '" & PlaceAt)]]>
<![CDATA[
]]>
<![CDATA[    nChar = oNewChar.AddValue(CLng(Ascw(NewValue)), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[    bRes = oNewChar.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[		Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[    PlaceAt = PlaceAt + 1]]>
<![CDATA[
]]>
<![CDATA[  Next 'xChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Field value after InsertChars is '" & GetFieldValue() & "' ")]]>
<![CDATA[
]]>
<![CDATA[ 		]]>
<![CDATA[
]]>
<![CDATA[	InsertChars = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddPaddingToRight" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA['    A number <var>n</var> indicating the maximum permissible length of the value. If the]]>
<![CDATA[
]]>
<![CDATA['    action finds that a value's length is less than this number, it will insert spaces until]]>
<![CDATA[
]]>
<![CDATA['    the maximum length is reached.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    Pads the current Field object's captured value with spaces to the right.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  CurCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not isnumeric(strParam) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = CurCount]]>
<![CDATA[
]]>
<![CDATA[ 			]]>
<![CDATA[
]]>
<![CDATA[	ActionNum = Abs(CInt(strParam)) - CurCount]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If cint(ActionNum)>cint(0) then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("AddPaddingToRight: add " & ActionNum & " space(s)")]]>
<![CDATA[
]]>
<![CDATA[		AddPaddingToRight = InsertChars(bInteractive, bDebug, Space(ActionNum) & "," & CurCount+1 & ",1")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Field Value is greater or equal to parameter '" & StrParam & "' no padding will be performed.")]]>
<![CDATA[
]]>
<![CDATA[		AddPaddingToRight = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddPaddingToLeft" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['    A number <var>n</var> indicating the maximum permissible length of the value. If the]]>
<![CDATA[
]]>
<![CDATA['    action finds that a value's length is less than this number, it will insert spaces]]>
<![CDATA[
]]>
<![CDATA['    until the maximum length is reached.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   Pads the current Field object's captured value with spaces to the left of the first character.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not isnumeric(strParam) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = CurCount ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ActionNum = Abs(CInt(strParam)) - CurCount]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(ActionNum)>cint(0) then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("AddPaddingToLeft: add " & ActionNum & " space(s)")]]>
<![CDATA[
]]>
<![CDATA[		AddPaddingToLeft = InsertChars(bInteractive, bDebug,Space(ActionNum) & ",1,1")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Field Value is greater or equal to parameter '" & StrParam & "' no padding will be performed.")]]>
<![CDATA[
]]>
<![CDATA[		AddPaddingToLeft = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TrimSpaces" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['    Deletes extra spaces at the beginning and end of the current Field object's captured value.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim CurCount]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[  Dim Tcnt]]>
<![CDATA[
]]>
<![CDATA[  Dim nChilds]]>
<![CDATA[
]]>
<![CDATA[  Dim bRes]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[    CurCount = Len(Value)]]>
<![CDATA[
]]>
<![CDATA[    nChilds = CurrentObj.Numofchildren - CurCount	]]>
<![CDATA[
]]>
<![CDATA[    Tcnt = 0	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Start Value'" & Value & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If not(CurrentObj is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      CharValue = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If len(CurrentObj.Text) > 0 then CharValue = CurrentObj.Getchild(nChilds).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      While clng(CharValue)= clng(32)]]>
<![CDATA[
]]>
<![CDATA[        bRes = CurrentObj.DeleteChild(nChilds)]]>
<![CDATA[
]]>
<![CDATA[        CharValue = 0  		]]>
<![CDATA[
]]>
<![CDATA[        If len(CurrentObj.Text) > 0 then CharValue = CurrentObj.Getchild(nChilds).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[        Tcnt = Tcnt + 1]]>
<![CDATA[
]]>
<![CDATA[      Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If len(CurrentObj.Text) > 0 then CharValue = CurrentObj.Getchild(CurrentObj.Numofchildren-1).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      While clng(CharValue)= clng(32)]]>
<![CDATA[
]]>
<![CDATA[        bRes = CurrentObj.DeleteChild(CurrentObj.Numofchildren-1)]]>
<![CDATA[
]]>
<![CDATA[        CharValue = 0  		]]>
<![CDATA[
]]>
<![CDATA[        If len(CurrentObj.Text) > 0 then CharValue = CurrentObj.Getchild(CurrentObj.Numofchildren-1).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[        Tcnt = Tcnt + 1]]>
<![CDATA[
]]>
<![CDATA[      Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TrimSpaces = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("TrimSpaces: " & Tcnt & " position(s) trimmed.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="RightTruncate" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' A number that is the value's maximum length.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' This action deletes characters from the start of the current object's captured ]]>
<![CDATA[
]]>
<![CDATA[' value until the value's length equals the length specified by the parameter. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	RightTruncate = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not isnumeric(strParam) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If clng(Len(Value)) > Clng(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Start Field Value:'" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[		If not (CurrentObj is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[			While clng(len(GetFieldValue))>clng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[				bRes = CurrentObj.DeleteChild(0)]]>
<![CDATA[
]]>
<![CDATA[			Wend]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Writelog("New Field Value:'" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	RightTruncate = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("RightTruncate returns " & RightTruncate)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LeftTruncate" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    A Number <var>n</var> that is the value's maximum length.]]>
<![CDATA[
]]>
<![CDATA['    This action deletes characters from the end of the current object's captured value until the value's length equals the length indicated by the parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftTruncate = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not isnumeric(StrParam) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If clng(Len(Value)) > clng(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Start Field Value:'" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[		If not (CurrentObj is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[			For DelPos = (Len(Value)-1) to (StrParam) step -1	]]>
<![CDATA[
]]>
<![CDATA[				bRes = CurrentObj.DeleteChild(DelPos)]]>
<![CDATA[
]]>
<![CDATA[			Next 'DelPos]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[		Writelog("New Field Value:'" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftTruncate = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("LeftTruncate returns " & LeftTruncate)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddLeadingZeros" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    A number <var>n</var> which is the value's maximum length.]]>
<![CDATA[
]]>
<![CDATA['    Adds zeros ("0") to the beginning of the current Field object's captured value until the value's total length reaches the maximum n you specify as the parameter.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim CurCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ActionNum]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	AddLeadingZeros = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not isnumeric(strParam) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[    AddLeadingZeros = False]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = CurCount ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ActionNum = Abs(CInt(strParam)) - CurCount]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AddLeadingZeros: add " & ActionNum & " space(s)")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If clng(ActionNum)>clng(0) then  ]]>
<![CDATA[
]]>
<![CDATA[	  AddLeadingZeros = InsertChars(bInteractive, bDebug,String(ActionNum,"0") & ",1,1")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddTrailingZeros" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' A number <var>n</var> which is the value's maximum length.]]>
<![CDATA[
]]>
<![CDATA[' Adds zeros ("0") to the end of the current Field's captured value until the value's length reaches the maximum <var>n</var> you enter as the parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim CurCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ActionNum	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	AddTrailingZeros = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not isnumeric(strParam) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[    AddTrailingZeros = False]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CurCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = CurCount]]>
<![CDATA[
]]>
<![CDATA[ 			]]>
<![CDATA[
]]>
<![CDATA[	ActionNum = Abs(CInt(strParam)) - CurCount]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AddTrailingZeros: add " & ActionNum & " Zero(s)")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If clng(ActionNum)>clng(0) then ]]>
<![CDATA[
]]>
<![CDATA[    	AddTrailingZeros = InsertChars(bInteractive, bDebug, String(ActionNum,"0") & "," & CurCount+1 & ",1")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteSelectedChars" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['     The character or string of characters to be deleted.]]>
<![CDATA[
]]>
<![CDATA['		 A number indicating the starting index within the string to start deletion.  If this parameter]]>
<![CDATA[
]]>
<![CDATA['    is blank or is not a number, the starting index value will default to 1, the first position in the string.]]>
<![CDATA[
]]>
<![CDATA['		 The number of times the character or character string is to be deleted from the ]]>
<![CDATA[
]]>
<![CDATA['    value. The default is "1" and  "*" deletes all instances.]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['   Deletes specific characters from the current Field object's captured value.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = StrParam & ",,"]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = ",,1"]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	DeleteSelectedChars = u_ModifyText(aStrParam(0), aStrParam(1), aStrParam(2),"")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("DeleteSelectedChars end value: '" & GetFieldValue() & "' ") 		 		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllAlpha" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Deletes all alphabetic characters from the current Field object's captured value.  ]]>
<![CDATA[
]]>
<![CDATA[	' \p{L} or \p{Letter}: any kind of letter from any language. ]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace("\p{L}+",cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllAlpha=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Alphabetic characters deleted")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllNumeric" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Removes all Numeric characters from the current Field object's captured value. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{N} or \p{Number}: any kind of numeric character in any script. ]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace("\p{N}+",cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllNumeric=TRUE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllPunct" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllPunct=TRUE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Removes all punctuation characters current Field object's captured value. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{P} or \p{Punctuation}: any kind of punctuation character.]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace("\p{P}+",cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllMiscChars" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Removes all characters with ASCII values 123 through 191 from the current Field object's captured value. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{S} or \p{Symbol}: math symbols, currency signs, dingbats, box-drawing characters, etc.. ]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace("\p{S}+",cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllMiscChars = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllSysChars" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' The action removes all characters with ASCII values 0 through 31 from the current ]]>
<![CDATA[
]]>
<![CDATA[  '  object's captured value.]]>
<![CDATA[
]]>
<![CDATA[  ' \p{C} or \p{Other}: invisible control characters and unused code points.]]>
<![CDATA[
]]>
<![CDATA[  sResult=DCGlobalStrings.RemoveReplace("\p{C}+",cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllSysChars = True]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("System characters deleted")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FilterFieldSelectedChars" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[  '  A String containing the character(s) to be removed.]]>
<![CDATA[
]]>
<![CDATA[  '  Every instance of the character(s) will be removed from the captured 	value.]]>
<![CDATA[
]]>
<![CDATA[  '  Removes all instances of the character(s) you enter as the parameter from the current]]>
<![CDATA[
]]>
<![CDATA[  '  Field object's captured value.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"*","\*")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"\","\\")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"^","\^")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"$","\$")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"+","\+")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"?","\?")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,".","\.")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"[","\[")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"]","\]")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"(","\(")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,")","\)")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"|","\|")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"{","\{")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"}","\}")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,",","\,")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"-","\-")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FilterFieldSelectedChars = u_RemoveReplace("[" & Strparam &"]+",1,"","*")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("'" & StrParam & "' character(s) removed from field value")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReplaceChars" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  '   The character or string of characters to be replaced; defaults to a space. SmartParameter Enabled.]]>
<![CDATA[
]]>
<![CDATA[  '   The character(s) of the replacement String. SmartParameter Enabled.]]>
<![CDATA[
]]>
<![CDATA[  '   The number of times replacement is to occur. The default is "1"	and  "*" replaces all instances.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Replaces a character or string of characters in the current Field object's captured value with a String you enter as one of the parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sFind, sPush, iIndex]]>
<![CDATA[
]]>
<![CDATA[  Dim sFindMW, sPushMW ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ReplaceChars=False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = StrParam & ",,"]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Len(aStrParam(0)) = 0 Then aStrParam(0) = " "]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(aStrParam(2)) And Not(Trim(aStrParam(2)) = "*") Then aStrParam(2) = 1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sFind = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	sPush = aStrParam(1)]]>
<![CDATA[
]]>
<![CDATA[	iIndex = aStrParam(2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sFindMW = MetaWord(sFind)]]>
<![CDATA[
]]>
<![CDATA[  sPushMW = MetaWord(sPush)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Only use MetaWord result if it returns a value]]>
<![CDATA[
]]>
<![CDATA[  If sFindMW<>"" Then sFind=sFindMW]]>
<![CDATA[
]]>
<![CDATA[  If sPushMW<>"" Then sPush=sPushMW]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sFind="" Then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("String to replace (search string) is empty.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	ReplaceChars = u_ModifyText(sFind,1,iIndex,sPush)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("ReplaceChars new field value is '" & GetFieldValue & "'")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AllowOnlyChars" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'A Regular Expression that specifies permitted characters in the current word.]]>
<![CDATA[
]]>
<![CDATA[  'This action employs a Regular Expression as its parameter to identify ]]>
<![CDATA[
]]>
<![CDATA[  'remove all characters NOT in the parameter from the Field's value.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sFormat]]>
<![CDATA[
]]>
<![CDATA[  sFormat = ".+"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  AllowOnlyChars=TRUE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Check for and protect against RegEx reserved characters]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"*","\*")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"\","\\")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"^","\^")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"$","\$")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"+","\+")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"?","\?")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,".","\.")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"[","\[")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"]","\]")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"(","\(")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,")","\)")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"|","\|")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"{","\{")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"}","\}")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,",","\,")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"-","\-")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If len(StrParam)>0 then sFormat = "[^" & StrParam &"]+"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  AllowOnlyChars = u_RemoveReplace(sFormat,1,"","*")]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Removed all characters NOT included in " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DateStampField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'A Date format such as mm/dd/yy or dd/mm/yy.  (* defaults to 	mm/dd/yyyy)]]>
<![CDATA[
]]>
<![CDATA[  'Updates the current Field object with today's date. ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim dd,ddd,mm,yyyy,yy,y,m,d,mmm]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	DateStampField = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with current Date value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to update the field with]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to default value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if strParam = "" then strParam = "*"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Check Parameter for invalid chars]]>
<![CDATA[
]]>
<![CDATA[	Dim sCheck ]]>
<![CDATA[
]]>
<![CDATA[	sCheck = Ucase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"C","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ," ","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"/","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"-","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,".","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"&","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"DAY","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"MONTH","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"YEAR","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"JULIAN","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"Y","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"D","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"M","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If len(trim(sCheck))>0 then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid characters in parameter:'" & sCheck & "' ")]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'End Check]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim RX]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set RX = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	RX.ignoreCase = False]]>
<![CDATA[
]]>
<![CDATA[	RX.Global = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If InStr(StrParam,"*")>0 Then StrParam = "mm/dd/yyyy"]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"c","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam," "," & CHR(32) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"/"," & CHR(47) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"-"," & CHR(45) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"."," & CHR(46) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"day","dd")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"month","mm")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"year","yyyy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"julian","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"jjj","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"j","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"yd","y & d")			]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"ym","y & m")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"my","m & y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"md","m & d")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"dy","d & y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"dm","d & m")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	RX.Pattern = "& *&"]]>
<![CDATA[
]]>
<![CDATA[	StrParam = RX.Replace(StrParam, "&")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Strparam after character substitution:'" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	d = Day(Now)]]>
<![CDATA[
]]>
<![CDATA[	dd = Right("0" & d,2)]]>
<![CDATA[
]]>
<![CDATA[	yyyy = Year(Now)]]>
<![CDATA[
]]>
<![CDATA[	yy = Right(yyyy,2)]]>
<![CDATA[
]]>
<![CDATA[	m = Month(Now)]]>
<![CDATA[
]]>
<![CDATA[	mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[	mmm = MonthName(Month(Now), True)]]>
<![CDATA[
]]>
<![CDATA[	ccyy = yyyy]]>
<![CDATA[
]]>
<![CDATA[	y = DatePart("y",Now)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Text = Eval(Strparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("DateStampField returns True. Date value: '" & CurrentObj.text & "'")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function DateStampField")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set RX = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
	</g>
</af>
<af name="TimeStampField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ' A time format (for example, HH:MM:SS, or HH:MM.)]]>
<![CDATA[
]]>
<![CDATA[  '  * defaults to HH:MM:SS]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	Dim mm,ss,hh,hhhh,m,s,h]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	TimeStampField = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with current Time value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to update the field with]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to default value]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check Parameter for invalid chars]]>
<![CDATA[
]]>
<![CDATA[		Dim sCheck ]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Ucase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"M","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"H","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"S","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,":","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ," ","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"/","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"&","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"MIN","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"MINUTE","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"SEC","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"SECOND","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"HR","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"HOUR","")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If len(trim(sCheck))>0 then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid characters in parameter:'" & sCheck & "' ")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'End Check]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Trim(StrParam) = "*" Then StrParam = "HH:MM:SS"]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"/"," & CHR(47) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam," "," & CHR(32) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,":"," & CHR(58) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"min","mm")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"minute","mm")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"sec","ss")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"second","ss")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"hr","hh")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"hour","hh")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Strparam after character substitution:'" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	m = Minute(Now)]]>
<![CDATA[
]]>
<![CDATA[	s = Second(Now)]]>
<![CDATA[
]]>
<![CDATA[	h = Hour(Now)]]>
<![CDATA[
]]>
<![CDATA[	hhhh = hh]]>
<![CDATA[
]]>
<![CDATA[	mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[	ss = Right("0" & s,2)]]>
<![CDATA[
]]>
<![CDATA[	hh = Right("0" & h,2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text = Eval(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("TimeStampField returns True. Time value: " & CurrentObj.text) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
	</g>
</af>
<af name="SetIsOverrideable" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  '  Specifies that if the validation fails for the current object, If it is non-overrideable ]]>
<![CDATA[
]]>
<![CDATA[  '  or overrideable by the user.]]>
<![CDATA[
]]>
<![CDATA[  '  This status may prevent an operator from overriding a field's validations ]]>
<![CDATA[
]]>
<![CDATA[  '  and then continuing to subsequent pages. ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SetIsOverrideable parameter is " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If Ucase(StrParam) = Ucase("True") Then]]>
<![CDATA[
]]>
<![CDATA[		nDefaultRtn = nRtn_Over]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Setting Rule to Overrideable.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		nDefaultRtn = nRtn_Fail]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Setting Rule to NON Overrideable.")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	SetIsOverrideable = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateUpToToday" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Checks that the current Field object's Date value is today's date or	earlier. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[	Dim dNow]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[  Dim sCompare]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateUpToToday = False]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()	]]>
<![CDATA[
]]>
<![CDATA[	locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If len(Trim(value))=0 then ]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("Field value is empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[	  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Check Date]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(Value,locale) then]]>
<![CDATA[
]]>
<![CDATA[	  writelog("Current field value ( " & value & " ) is a valid Date value.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[	  sReturn = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call Writelog(DCGlobalDates.GetLog)]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[  dNow = cstr(MonthName(month(Now)) & Space(1) & Day(now) & space(1) & Year(now))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sCompare = DCGlobalDates.CompareDate(Value,dNow,locale)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Select Case sCompare]]>
<![CDATA[
]]>
<![CDATA[  	Case "-1","0"]]>
<![CDATA[
]]>
<![CDATA[	  	IsFieldDateUpToToday = True]]>
<![CDATA[
]]>
<![CDATA[      sMessage= "Field date value is today or earlier"]]>
<![CDATA[
]]>
<![CDATA[		  WriteLog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Case "1"]]>
<![CDATA[
]]>
<![CDATA[      sMessage=RRState.LoadString("validations","IsFieldDateUpToToday_01","Field '{0}' date value of '{1}' must be today's date or earlier.") ]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{2}",dNow)]]>
<![CDATA[
]]>
<![CDATA[		  DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		  WriteLog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Case else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Unknown result from Date Compare call. Returned value:'" & sCompare & "'")]]>
<![CDATA[
]]>
<![CDATA[	End Select  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ 	Call Writelog(DCGlobalDates.GetLog)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldDateUpToToday") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateWithinXDays" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  'A number <var>n</var> that specifies how many days make up the review period.]]>
<![CDATA[
]]>
<![CDATA[  'Checks that current Field object's captured Date value is within <var>n</var> days of ]]>
<![CDATA[
]]>
<![CDATA[  'the number entered as a parameter.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim XDays, ActualDays]]>
<![CDATA[
]]>
<![CDATA[  Dim dNow]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateWithinXDays = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	XDays = Trim(StrParam)	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(XDays) Or Len(XDays)=0 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If len(Trim(value))=0 then]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("Field value is empty. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ 	'Check Date]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(Value,locale) then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Current field value ( " & value & " ) is a valid Date value.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sReturn = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  dNow = Now]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ValueShortFormat = DCGlobalDates.FormatDateTime(value,"d",locale)]]>
<![CDATA[
]]>
<![CDATA[	ActualDays = DateDiff("d",ValueShortFormat,dNow)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("[IsFieldDateWithinXDays] Action Limit = " & XDays & "   Calculated Days = " & ActualDays)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If ABS(CLng(ActualDays)) <= CLng(XDays) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateWithinXDays = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldDateWithinXDays returns " & IsFieldDateWithinXDays) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldDateWithinXDays = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage=RRState.LoadString("validations","IsFieldDateWithinXDays","Field '{0}' date value of '{1}' is {3} days from today's date. The date must be within {2} of days of today's date.") ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",XDays)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{3}",ABS(CLng(ActualDays)))]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateWithinRange" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Comma-separated Dates that define the range: Start Date,  End Date]]>
<![CDATA[
]]>
<![CDATA[  '  TODAY can represent the current Date.]]>
<![CDATA[
]]>
<![CDATA[  '  Checks that the value assigned to the Text property of the bound object 	is a valid Date. If so, the action confirms that the Date is within the 	range specified by the parameters. ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sFromDate]]>
<![CDATA[
]]>
<![CDATA[	Dim sThruDate]]>
<![CDATA[
]]>
<![CDATA[	Dim sTempDate	]]>
<![CDATA[
]]>
<![CDATA[  Dim bExit]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  bExit = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateWithinRange = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Check CurrentObj for Valid Date Value]]>
<![CDATA[
]]>
<![CDATA[	sValue = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[  locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Convert Format]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(sValue,locale) then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Current field value (" & sValue & ") is a valid Date value. Locale:(" & DCGlobalDates.FormatDateTime(sValue,"D",locale) & ")")]]>
<![CDATA[
]]>
<![CDATA[		sValue = DCGlobalDates.FormatDateTime(sValue,"d",locale)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sReturn = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[    writelog(sReturn)]]>
<![CDATA[
]]>
<![CDATA[    writelog(DCGlobalDates.Getlog())]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Writelog("-----")		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking Action Parameters...")		]]>
<![CDATA[
]]>
<![CDATA[	'Parse CSV StrParam]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	sFromDate=Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sThruDate=Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Checking Parameters for Valid Date Values or Keywords		]]>
<![CDATA[
]]>
<![CDATA[	If instr(ucase(sFromDate),"TODAY") then sFromDate = now]]>
<![CDATA[
]]>
<![CDATA[	If instr(ucase(sThruDate),"TODAY") then sThruDate = now]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sFromDate)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Action Parameter 1 (From Date) is Empty. Using Current Date '" & now & "'")]]>
<![CDATA[
]]>
<![CDATA[		sFromDate = now]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sThruDate)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Action Parameter 2 (Thru Date) is Empty. Using Current Date '" & now & "'")]]>
<![CDATA[
]]>
<![CDATA[		sThruDate = now]]>
<![CDATA[
]]>
<![CDATA[	end if	]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	'Convert format]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(sFromDate,locale) then]]>
<![CDATA[
]]>
<![CDATA[    writelog("FROM Date field value (" & sFromDate & ") is a valid Date value. Locale:(" & DCGlobalDates.FormatDateTime(sFromDate,"D",locale) &")")]]>
<![CDATA[
]]>
<![CDATA[		sFromDate = DCGlobalDates.FormatDateTime(sFromDate,"d",locale)]]>
<![CDATA[
]]>
<![CDATA[    'writelog(DCGlobalDates.Getlog)]]>
<![CDATA[
]]>
<![CDATA[    'writelog("'d' format:" & sFromDate)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "FROM Date parameter does not have a valid date Format:'" & sFromDate & "'")]]>
<![CDATA[
]]>
<![CDATA[    writelog(DCGlobalDates.Getlog())]]>
<![CDATA[
]]>
<![CDATA[		bExit=True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Convert format]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(sThruDate,locale) then]]>
<![CDATA[
]]>
<![CDATA[    writelog("THRU Date field value (" & sThruDate & ") is a valid Date value. Locale:(" & DCGlobalDates.FormatDateTime(sThruDate,"D",locale) & ")")]]>
<![CDATA[
]]>
<![CDATA[		sThruDate = DCGlobalDates.FormatDateTime(sThruDate,"d",locale)]]>
<![CDATA[
]]>
<![CDATA[   ' writelog(DCGlobalDates.Getlog)]]>
<![CDATA[
]]>
<![CDATA[   'writelog("'d' format:" & sThruDate)]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Thru-Date parameter does not have a valid date Format:'" & sThruDate & "'")]]>
<![CDATA[
]]>
<![CDATA[    writelog(DCGlobalDates.Getlog())]]>
<![CDATA[
]]>
<![CDATA[		bExit=True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'If the parameters failed authenticity then exit the function]]>
<![CDATA[
]]>
<![CDATA[  If bExit then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Check That FromDate is before ThruDate]]>
<![CDATA[
]]>
<![CDATA[  If DCGlobalDates.CompareDate(sFromDate,sThruDate,locale)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Warning: From-date (" + sFromDate + ") is after Thru-date (" + sThruDate + ") : Switching Values.")]]>
<![CDATA[
]]>
<![CDATA[    writelog(DCGlobalDates.Getlog)]]>
<![CDATA[
]]>
<![CDATA[		sTempDate=sFromDate]]>
<![CDATA[
]]>
<![CDATA[		sFromDate=sThruDate]]>
<![CDATA[
]]>
<![CDATA[		sThruDate=sTempDate]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Writelog("-----")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking Field Value Against Parameter Range...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check Range]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.CompareDate(sValue,sFromDate,locale)<0 or DCGlobalDates.CompareDate(sValue,sThruDate,locale)>0 Then]]>
<![CDATA[
]]>
<![CDATA[		sMessage=RRState.LoadString("validations","IsFieldDateWithinRange_01","Field '{0}' date value of '{1}' must be between the dates of '{2}' to '{3}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sValue)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",sFromDate)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{3}",sThruDate)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Current Date Value '" & cstr(sValue) & "' is within range: '" & cstr(sFromDate) & "' - '" & cstr(sThruDate) & "'")]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateWithinRange=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldDateWithinRange returns " & IsFieldDateWithinRange)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateWithReformat" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  The Date format you want to use.]]>
<![CDATA[
]]>
<![CDATA[  '  mm/dd/yy]]>
<![CDATA[
]]>
<![CDATA[  '  dd/mm/yy]]>
<![CDATA[
]]>
<![CDATA[  '  mm.dd.yy, etc.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  y yy yyy yyyy  "8 08 008 2008"   year]]>
<![CDATA[
]]>
<![CDATA[  '  M MM MMM MMMM  "3 03 Mar March"  month]]>
<![CDATA[
]]>
<![CDATA[  '  d dd ddd dddd  "9 09 Sun Sunday" day]]>
<![CDATA[
]]>
<![CDATA[  '  h hh H HH      "4 04 16 16"      hour 12/24]]>
<![CDATA[
]]>
<![CDATA[  '  m mm           "5 05"            minute]]>
<![CDATA[
]]>
<![CDATA[  '  s ss           "7 07"            second]]>
<![CDATA[
]]>
<![CDATA[  '  f ff fff ffff  "1 12 123 1230"   sec.fraction]]>
<![CDATA[
]]>
<![CDATA[  '  F FF FFF FFFF  "1 12 123 123"    without zeroes]]>
<![CDATA[
]]>
<![CDATA[  '  t tt           "P PM"            A.M. or P.M.]]>
<![CDATA[
]]>
<![CDATA[  '  z zz zzz       "-6 -06 -06:00"   time zone]]>
<![CDATA[
]]>
<![CDATA[  '              ]]>
<![CDATA[
]]>
<![CDATA[  '  t ShortTimePattern h:mm tt ]]>
<![CDATA[
]]>
<![CDATA[  '  d ShortDatePattern M/d/yyyy ]]>
<![CDATA[
]]>
<![CDATA[  '  T LongTimePattern h:mm:ss tt ]]>
<![CDATA[
]]>
<![CDATA[  '  D LongDatePattern dddd, MMMM dd, yyyy ]]>
<![CDATA[
]]>
<![CDATA[  '  f (combination of D and t) dddd, MMMM dd, yyyy h:mm tt ]]>
<![CDATA[
]]>
<![CDATA[  '  F FullDateTimePattern dddd, MMMM dd, yyyy h:mm:ss tt ]]>
<![CDATA[
]]>
<![CDATA[  '  g (combination of d and t) M/d/yyyy h:mm tt ]]>
<![CDATA[
]]>
<![CDATA[  '  G (combination of d and T) M/d/yyyy h:mm:ss tt ]]>
<![CDATA[
]]>
<![CDATA[  '  m, M MonthDayPattern MMMM dd ]]>
<![CDATA[
]]>
<![CDATA[  '  y, Y YearMonthPattern MMMM, yyyy ]]>
<![CDATA[
]]>
<![CDATA[  '  r, R RFC1123Pattern ddd, dd MMM yyyy HH':'mm':'ss 'GMT' (*) ]]>
<![CDATA[
]]>
<![CDATA[  '  s SortableDateTi­mePattern yyyy'-'MM'-'dd'T'HH':'mm':'ss (*) ]]>
<![CDATA[
]]>
<![CDATA[  '  u UniversalSorta­bleDateTimePat­tern yyyy'-'MM'-'dd HH':'mm':'ss'Z' (*) 	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsFieldDateWithReformat = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("IsFieldDateWithReformat argument = '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start Field Value:'" & value & "' ")]]>
<![CDATA[
]]>
<![CDATA[  locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If DCGlobalDates.IsDate(value,locale)=False then]]>
<![CDATA[
]]>
<![CDATA[    IsFieldDateWithReformat = False			]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with reformatted Date value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to format to]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to short date format value]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"*","d")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"c","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"day","dd")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"month","MM")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"year","yyyy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"ccyy","yyyy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"julian","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"jjj","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"j","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"yd","yd")			]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"ym","yM")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"my","My")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"md","Md")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"dy","dy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"dm","dM")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"m","M")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'default to short date format]]>
<![CDATA[
]]>
<![CDATA[  If len(trim(StrParam))= 0 then StrParam = "d"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Eval String:'" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Text = DCGlobalDates.FormatDateTime(value, StrParam,locale)]]>
<![CDATA[
]]>
<![CDATA[  		     	]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[  	IsFieldDateWithReformat = False			]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Err:" & err.number & ":" & Err.description)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldDateWithReformat_01","There was a problem formatting the date value '{1}' in field '{0}' to the pattern '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldDateWithReformat returns " & IsFieldDateWithReformat & ". Date value:'" & CurrentObj.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[	Set RX = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldCurrency" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Determines if the current Field object's captured value is 100% Numeric 	]]>
<![CDATA[
]]>
<![CDATA[  '  and includes a two-digit decimal amount. When determining the Numeric %, 	]]>
<![CDATA[
]]>
<![CDATA[  '  the action ignores spaces and punctuation such as commas and decimal points. ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	IsFieldCurrency = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[  locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsFieldCurrency = DCGlobalCurrency.IsCurrency(value,locale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("IsFieldCurrency returns " & IsFieldCurrency)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldCurrency = False Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(DCGlobalCurrency.Getlog())]]>
<![CDATA[
]]>
<![CDATA[    sMessage=RRState.LoadString("validations","IsFieldCurrency_01","Field '{0}' value of '{1}' was not recognised as a valid currency format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldCurrency")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FailRuleSet" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Causes the entire RuleSet to fail. ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If bFail=True then]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("RuleSet already set to FAIL.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("Setting RuleSet to FAIL.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	bFail = True]]>
<![CDATA[
]]>
<![CDATA[	FailRuleSet = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function FailRuleSet") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GoToNextRule" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'This action has been deprecated. It has been replaced by "GoToNextFunction".]]>
<![CDATA[
]]>
<![CDATA[	GoToNextRule = False]]>
<![CDATA[
]]>
<![CDATA[	GoToNextRule = GoToNextFunction()]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldMatching" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'The value to be checked against the Field object's value.]]>
<![CDATA[
]]>
<![CDATA[	'Determines if the value entered as the parameter is identical to the captured value of the current Field object. ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	IsFieldMatching = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Checking if field value" & value & " matches " & strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Trim(value) = Trim(strParam) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldMatching = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldMatching returns " & IsFieldMatching)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldMatching = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldMatching_01","Field '{0}' value of '{1}' did not match '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",strParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldMatching") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CopyFieldToField" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'The name of the target Field object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[  'Copies the captured value of the current Field object to the Field object designated as the action's parameter. ]]>
<![CDATA[
]]>
<![CDATA[   		]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld,bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyFieldToField = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("GET FIELD " & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & StrParam & "'. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oFld.Text=""	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Append New Characters]]>
<![CDATA[
]]>
<![CDATA[	nChildren=Currentobj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	For xChar = 1 to nChildren]]>
<![CDATA[
]]>
<![CDATA[		'Add Characters ]]>
<![CDATA[
]]>
<![CDATA[		Set oCurChar = CurrentObj.GetChild(xChar-1)]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oCurChar) then]]>
<![CDATA[
]]>
<![CDATA[      If oCurChar.objecttype=4 Then]]>
<![CDATA[
]]>
<![CDATA[        Set oNewChar = oFld.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[        nChar = oNewChar.AddValue(CLng(oCurChar.CharValue(0)), CLng(oCurChar.CharConfidence(0)))]]>
<![CDATA[
]]>
<![CDATA[        bRes = oCurChar.GetPosition(nLeft,nTop,nRight,nBottom) ]]>
<![CDATA[
]]>
<![CDATA[        bRes = oNewChar.SetPosition(nLeft,nTop,nRight,nBottom)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'xChar	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New value for Field " & StrParam  & " : '" & oFld.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyFieldToField = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AppendToField" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'The name of the Field object to which the value is to be 	appended.]]>
<![CDATA[
]]>
<![CDATA[  'Appends the captured value of the current Field object to the captured value of the ]]>
<![CDATA[
]]>
<![CDATA[  'Field object specified by the parameter.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld,bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim nAdjust]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	AppendToField= False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("GET FIELD " & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & StrParam & "'. Exiting Action") ]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nChildren=CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	For xChar = 1 to nChildren]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Set oCurChar = CurrentObj.GetChild(xChar-1)]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oCurChar) Then]]>
<![CDATA[
]]>
<![CDATA[      If oCurChar.ObjectType=4 then]]>
<![CDATA[
]]>
<![CDATA[        'Add Characters ]]>
<![CDATA[
]]>
<![CDATA[        Set oNewChar = oFld.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[        nChar = oNewChar.AddValue(CLng(oCurChar.CharValue(0)), CLng(oCurChar.CharConfidence(0)))]]>
<![CDATA[
]]>
<![CDATA[        bRes = oCurChar.GetPosition(nLeft,nTop,nRight,nBottom) ]]>
<![CDATA[
]]>
<![CDATA[        bRes = oNewChar.SetPosition(nLeft,nTop,nRight,nBottom)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'xChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New value for Field '" & oFld.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AppendToField= True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AppendFromField" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'The name of the Field object whose text value is to be appended to the 	current field's value.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Appends the captured value of the specified Field object to the]]>
<![CDATA[
]]>
<![CDATA[  '  captured value of the current Field object.  You can also apply this 	]]>
<![CDATA[
]]>
<![CDATA[  '  action at the Page level.  A Text page-level variable with the appended 	]]>
<![CDATA[
]]>
<![CDATA[  '  value will be added to the page's Data file. ]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld,bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim nAdjust]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	AppendFromField= False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("GET FIELD " & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & StrParam & "'. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nChildren=oFld.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	For xChar = 1 to nChildren		]]>
<![CDATA[
]]>
<![CDATA[		Set oCurChar = oFld.GetChild(xChar-1)]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oCurChar) then]]>
<![CDATA[
]]>
<![CDATA[      If oCurChar.ObjectType=4 then]]>
<![CDATA[
]]>
<![CDATA[        'Add Characters ]]>
<![CDATA[
]]>
<![CDATA[	  	  Set oNewChar = CurrentObj.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[		    nChar = oNewChar.AddValue(CLng(oCurChar.CharValue(0)), CLng(oCurChar.CharConfidence(0)))]]>
<![CDATA[
]]>
<![CDATA[        bRes = oCurChar.GetPosition(nLeft,nTop,nRight,nBottom) ]]>
<![CDATA[
]]>
<![CDATA[        bRes = oNewChar.SetPosition(nLeft,nTop,nRight,nBottom)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'xChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New value for Field '" & CurrentObj.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<3 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Non-Field Object. Saving as 'Text' variable")]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("Text") = CurrentObj.Variable("Text") & oFld.Text]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AppendFromField= True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReadFieldValue" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'The name of the source Field object.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Retrieves the captured value from a sibling Field object specified as 	]]>
<![CDATA[
]]>
<![CDATA[  '  the parameter, and assigns the value to the current Field object.  ]]>
<![CDATA[
]]>
<![CDATA[  '  If the action is not bound at the Field level, then a variable called Text will be ]]>
<![CDATA[
]]>
<![CDATA[  '  created in the current object, and the found value will be written to this variable.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld,bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim chrValue]]>
<![CDATA[
]]>
<![CDATA[	Dim chrConf]]>
<![CDATA[
]]>
<![CDATA[	Dim nchildren]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ReadFieldValue = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Reading Field '" & Ucase(StrParam) & "'")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & StrParam & "'. Exiting Action") ]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ReadField value:'" & oFld.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Append New Characters]]>
<![CDATA[
]]>
<![CDATA[	nChildren=oFld.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	For xChar = 1 to nChildren]]>
<![CDATA[
]]>
<![CDATA[		 ]]>
<![CDATA[
]]>
<![CDATA[		Set oCurChar = oFld.GetChild(xChar-1)]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oCurChar) then]]>
<![CDATA[
]]>
<![CDATA[      If oCurChar.ObjectType=4 then]]>
<![CDATA[
]]>
<![CDATA[        'Add Characters]]>
<![CDATA[
]]>
<![CDATA[      Set oNewChar = CurrentObj.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[      chrValue = oCurChar.CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[      chrConf = oCurChar.CharConfidence(0)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Adding char:'" & chrValue & "' conf:'" & chrConf & "'")]]>
<![CDATA[
]]>
<![CDATA[      nChar = oNewChar.AddValue(CLng(chrValue), CLng(chrConf))]]>
<![CDATA[
]]>
<![CDATA[      bRes = oCurChar.GetPosition(nLeft,nTop,nRight,nBottom) ]]>
<![CDATA[
]]>
<![CDATA[      bRes = oNewChar.SetPosition(nLeft,nTop,nRight,nBottom)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'xChar]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New value for calling field '" & CurrentObj.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.Variable("Position")="" or Currentobj.Variable("Position")="0,0,0,0" then]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("Position")=oFld.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<3 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Non-Field Object. Saving as 'Text' variable")]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("Text") = oFld.Text]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ReadFieldValue = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CopyField" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'The name of the target Field object.]]>
<![CDATA[
]]>
<![CDATA[  'Assigns the current Field object's captured value to a sibling Field object you specify as the parameter.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld, bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim FieldNm, NewValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyField = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & "," , ",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FieldNm = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	NewValue = aStrParam(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Getting Field '" & FieldNm & "'" )]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(FieldNm)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & FieldNm & "'. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	oFld.Text = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(Trim(NewValue))=0 then]]>
<![CDATA[
]]>
<![CDATA[		NewValue=CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Append New Characters]]>
<![CDATA[
]]>
<![CDATA[	For xChar = 1 to len(NewValue)]]>
<![CDATA[
]]>
<![CDATA[		'Add Characters ]]>
<![CDATA[
]]>
<![CDATA[		Set oNewChar = oFld.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[		nChar = oNewChar.AddValue(CLng(Ascw( Mid(NewValue,xChar,1))), CLng(9)) ]]>
<![CDATA[
]]>
<![CDATA[     	bRes = oNewChar.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[	Next 'xChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New value for Field " & oFld.ID & " is '" & oFld.Text & "'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyField = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="EmptyFieldValue" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'The name of the Field object that is to be emptied.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Clears the text value in the field represented by the Field object of the ]]>
<![CDATA[
]]>
<![CDATA[  '  Document Hierarchy specified by the parameter.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld, bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim FieldNm, NewValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	EmptyFieldValue = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FieldNm = Trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting Field '" & FieldNm & "'" )]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(FieldNm)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & FieldNm & "'. Exiting Action") ]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Start value for field '" & oFld.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[	oFld.Text=""]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("End value for field '" & oFld.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	EmptyFieldValue = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldGreaterOrEqual" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[  'The Numeric or Currency value which is the basis for comparison.]]>
<![CDATA[
]]>
<![CDATA[  'Determines if the captured value of the current Field object is greater than (or equal to) the value entered as a parameter. If the field's value is not Numeric or currency, the action will return a  condition.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim value]]>
<![CDATA[
]]>
<![CDATA[	Dim sMsg	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldGreaterOrEqual= False]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	sMsg = ""	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(strParam) and IsNumeric(value) then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If CDBL(value) >= CDBL(strParam) Then ]]>
<![CDATA[
]]>
<![CDATA[		   IsFieldGreaterOrEqual = True]]>
<![CDATA[
]]>
<![CDATA[		   WriteLog(value & " is greater than or equal to " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[		   WriteLog(value & " is less than " & strParam)]]>
<![CDATA[
]]>
<![CDATA[       sMessage = RRState.LoadString("validations","IsFieldGreaterOrEqual_01","Field '{0}' value of '{1}' must be greater than '{2}'.") ]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(strParam) Then writelog("Action Parameter is not Numeric!")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(value) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Field's value is not numeric!")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","NotNumeric_01","Field '{0}' value of '{1}' must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldGreaterOrEqual returns " & IsFieldGreaterOrEqual)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldGreaterOrEqual = False then]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",strParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldLessOrEqual" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  'The Numeric or Currency value you want to compare against.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Determines if the captured value of the current Field object is less than (or equal to) ]]>
<![CDATA[
]]>
<![CDATA[  '  the value entered as a parameter.  If the field's value is not Numeric or Currency, the ]]>
<![CDATA[
]]>
<![CDATA[  '  action will return a  condition.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim Value]]>
<![CDATA[
]]>
<![CDATA[	Dim sMsg]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sMsg = ""	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldLessOrEqual= False]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(strParam) and IsNumeric(value) then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If CDBL(value) <= CDBL(strParam) Then ]]>
<![CDATA[
]]>
<![CDATA[		   IsFieldLessOrEqual = True]]>
<![CDATA[
]]>
<![CDATA[		   WriteLog(value & " is less than or equal to " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[		   WriteLog(value & " is greater than " & strParam)]]>
<![CDATA[
]]>
<![CDATA[       sMessage = RRState.LoadString("validations","IsFieldLessOrEqual_01","Field '{0}' value of '{1}' must be less than '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	end if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(strParam) Then WriteLog("Action Parameter is not Numeric!") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(value) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Field's value is not numeric!") ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","NotNumeric_01","Field '{0}' value of '{1}' must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLessOrEqual returns " & IsFieldLessOrEqual)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldLessOrEqual = False then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",strParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="InsertDecimalPoint" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'A number <var>n</var> indicating the character position at which to place the decimal.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Places a decimal character in the captured value, at the character position specified as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  '  The parameter indicates the position of the decimal point, moving from right to left.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim Place]]>
<![CDATA[
]]>
<![CDATA[  Dim sDecimalSeparator]]>
<![CDATA[
]]>
<![CDATA[  Dim sGroupSeparator]]>
<![CDATA[
]]>
<![CDATA[  Dim sDecimalDigits]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sDecimalDigits = DCGlobalCurrency.CurrencyDecimalDigits(locale)]]>
<![CDATA[
]]>
<![CDATA[  sGroupSeparator = DCGlobalCurrency.CurrencyGroupSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[  sDecimalSeparator = DCGlobalCurrency.CurrencyDecimalSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsNumeric(strparam) or Trim(strparam)="" then]]>
<![CDATA[
]]>
<![CDATA[    strParam = sDecimalDigits]]>
<![CDATA[
]]>
<![CDATA[    writelog("Number of decimal places defaulted to " & strparam)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Place = CInt(strParam)-1]]>
<![CDATA[
]]>
<![CDATA[	InsertDecimalPoint = True]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start Field value:'" & value & "'")]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If InStr(value,sDecimalSeparator) then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Decimal separator found. Value unchanged. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(value) then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Non-numeric value found. Value unchanged. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Len(value)<2 then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Value has less than 2 characters. Value unchanged. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If InStr(Right(value,3),sGroupSeparator)>0 Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Group Separator detected in third position. Value unchanged. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	 	]]>
<![CDATA[
]]>
<![CDATA[  value=InsertCharacters(sDecimalSeparator,Cstr(Len(value)-Place),1)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("End field value:'" & CurrentObj.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="CalculateFields" access="public">
	<p name="Equation">
	</p>
	<p name="DecimalDigits">
	</p>
	<p name="PreserveStatus">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  The equation that is the basis for the calculation.]]>
<![CDATA[
]]>
<![CDATA[	']]>
<![CDATA[
]]>
<![CDATA[  '  You can use a Field object's name or numeric values with any arithmetic operator (+,-,*,/,^). ]]>
<![CDATA[
]]>
<![CDATA[  '  To use a Field object's name, surround the field name with single quotation marks (').  ]]>
<![CDATA[
]]>
<![CDATA[  '  A null is treated as a "0".]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Calculates the equation entered as a parameter and compares the result to the current Field object's captured value.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim nNum]]>
<![CDATA[
]]>
<![CDATA[	Dim aDecimal]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim Sobj    ]]>
<![CDATA[
]]>
<![CDATA[	Dim Nx  ]]>
<![CDATA[
]]>
<![CDATA[	Dim nDecimal]]>
<![CDATA[
]]>
<![CDATA[  Dim nDecimalDefault]]>
<![CDATA[
]]>
<![CDATA[	Dim sExpression]]>
<![CDATA[
]]>
<![CDATA[	Dim nValue]]>
<![CDATA[
]]>
<![CDATA[	Dim sBasicExpression]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurParent]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim bHasChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim dictCalcObj]]>
<![CDATA[
]]>
<![CDATA[	Dim sTempNode]]>
<![CDATA[
]]>
<![CDATA[	Dim sCResult]]>
<![CDATA[
]]>
<![CDATA[	Dim bPreserveStatus	]]>
<![CDATA[
]]>
<![CDATA[	Dim nDigits]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set dictCalcObj = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurParent = CurrentObj.Parent()]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	bHasChildren = CurrentObj.NumOfChildren > Len(CurrentObj.Text) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  StrParam=Equation]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  bPreserveStatus = FALSE]]>
<![CDATA[
]]>
<![CDATA[  PreserveStatus=Trim(Ucase(PreserveStatus))]]>
<![CDATA[
]]>
<![CDATA[  If PreserveStatus="TRUE" or PreserveStatus="1" then]]>
<![CDATA[
]]>
<![CDATA[    bPreserveStatus=TRUE]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Set and log number of decimal digits to use for formatting]]>
<![CDATA[
]]>
<![CDATA[  nDigits = 8 'final eval default to prevent memory error for very small remainders]]>
<![CDATA[
]]>
<![CDATA[	nDecimal = Trim(DecimalDigits)]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Decimal digits:'" & nDecimal & "'  (Blank if not set, defaults to regional setting)")]]>
<![CDATA[
]]>
<![CDATA[  if len(nDecimal)>0 then nDigits=nDecimal]]>
<![CDATA[
]]>
<![CDATA[  sCResult = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Split the array based on the apostrophe character ]]>
<![CDATA[
]]>
<![CDATA[  'surrounding all dco types]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strparam & "'", "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Get the Group and Decimal Separator regional characters]]>
<![CDATA[
]]>
<![CDATA[  Dim GroupSeparator]]>
<![CDATA[
]]>
<![CDATA[  Dim DecimalSeparator]]>
<![CDATA[
]]>
<![CDATA[  GroupSeparator = DCGlobalCurrency.CurrencyGroupSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[  DecimalSeparator = DCGlobalCurrency.CurrencyDecimalSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim elements]]>
<![CDATA[
]]>
<![CDATA[  elements=Ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Process each element]]>
<![CDATA[
]]>
<![CDATA[  For Nx = 1 to Ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[    aNode = aStrParam(Nx-1) ]]>
<![CDATA[
]]>
<![CDATA[    bNode = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Processing node " & Nx & " of " & elements & " value:'" & aStrParam(Nx-1) & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Check if Blank, Numeric or special character]]>
<![CDATA[
]]>
<![CDATA[    If instr("<>+=/*-abs()^",Trim(aNode))>0 or Trim(aNode) = "" or IsNumeric(Trim(aNode))=True Then bNode = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Check if self]]>
<![CDATA[
]]>
<![CDATA[    If aStrParam(Nx-1)= CurrentObj.Type Then ]]>
<![CDATA[
]]>
<![CDATA[      if err.number<>0 then err.clear]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      If(Trim(CurrentObj.Text) = "") Then ]]>
<![CDATA[
]]>
<![CDATA[        aStrParam(Nx-1) = 0]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        'Remove the regional Group separator]]>
<![CDATA[
]]>
<![CDATA[        aStrParam(Nx-1)= Trim(replace(CurrentObj.Text,GroupSeparator,""))]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      bNode = True]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(CurrentObj.Type & " is Calling Object. Value is " & aStrParam(Nx-1))]]>
<![CDATA[
]]>
<![CDATA[      if err.number<>0 then writelog("err 1 :" + err.description):err.clear]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Check Page/Document of Self]]>
<![CDATA[
]]>
<![CDATA[    If Not(bNode) And Not(oCurParent Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[      nValue = ""			]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      'If no DCO path is present	]]>
<![CDATA[
]]>
<![CDATA[      If instr(aStrParam(Nx-1),"..\")=0 then ]]>
<![CDATA[
]]>
<![CDATA[          'Search Parent Page, or Document(If called at Page or Document level)]]>
<![CDATA[
]]>
<![CDATA[          Set oParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[          While (oParent.ObjectType>2 or (oParent.ObjectType>1 And CurrentObj.ObjectType=2)) And oParent.ObjectType<>0 And nValue=""]]>
<![CDATA[
]]>
<![CDATA[            Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[            'nValue will return 0+ if children found and "" if no children found.]]>
<![CDATA[
]]>
<![CDATA[            nValue = u_SumFields(aStrParam(Nx-1),oParent)]]>
<![CDATA[
]]>
<![CDATA[          Wend]]>
<![CDATA[
]]>
<![CDATA[          Set oParent = Nothing	]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[          writelog("DCO path detected. Using fixed path navigation.")]]>
<![CDATA[
]]>
<![CDATA[          nValue = u_SumFields(aStrParam(Nx-1),CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      If nValue <> "" then]]>
<![CDATA[
]]>
<![CDATA[        'Remove the digits separator]]>
<![CDATA[
]]>
<![CDATA[        aStrParam(Nx-1) = Trim(replace(nValue,GroupSeparator,""))]]>
<![CDATA[
]]>
<![CDATA[        bNode = True]]>
<![CDATA[
]]>
<![CDATA[                       ]]>
<![CDATA[
]]>
<![CDATA[        'Writelog("Sibling Node(s) found. New Value is " & aStrParam(Nx-1))]]>
<![CDATA[
]]>
<![CDATA[        For Each fKey in dictTypeVars.keys]]>
<![CDATA[
]]>
<![CDATA[          If not(dictCalcObj.Exists(fKey)) then Set dictCalcObj(fKey) = dictTypeVars.Item(fKey)]]>
<![CDATA[
]]>
<![CDATA[        Next]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Node value is:'" & aStrParam(Nx-1) & "'")]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If bNode = False Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Node not found as Sibling or Child. Value '" & aStrParam(Nx-1) & "'.")]]>
<![CDATA[
]]>
<![CDATA[      'Check for complex operators]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"<","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,">","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"+","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"=","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"/","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"*","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"-","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"abs","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"(","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,")","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"^","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=Trim(aNode)]]>
<![CDATA[
]]>
<![CDATA[      If len(aNode)>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        If Not IsNumeric(aStrParam(Nx-1)) then aStrParam(Nx-1)=0]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      If Not IsNumeric(aStrParam(Nx-1)) And Trim(aNode)<>"" And instr("<>+=/*-abs()^",Trim(aNode))<=0 Then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Node is not numeric or contains an unrecognized Mathmatical operator: Calculate Fails. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[        CalculateFields = False ]]>
<![CDATA[
]]>
<![CDATA[        Exit Function			]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[      'Convert Numeric for use with Eval function (Requires US numeric decimal separator)      ]]>
<![CDATA[
]]>
<![CDATA[      If IsNumeric(aStrParam(Nx-1)) then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[          If DecimalSeparator<>"." then aStrParam(Nx-1)=replace(aStrParam(Nx-1),DecimalSeparator,".")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[          If nDecimal<>"" Then          ]]>
<![CDATA[
]]>
<![CDATA[            aStrParam(Nx-1) = FormatNumber(cdbl(aStrParam(Nx-1)),nDecimal,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[          Else ]]>
<![CDATA[
]]>
<![CDATA[            aStrParam(Nx-1) = FormatNumber(cdbl(aStrParam(Nx-1)),-1,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          'If DecimalSeparator<>"." then aStrParam(Nx-1)=replace(aStrParam(Nx-1),DecimalSeparator,".")]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Next	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sExpression = Join(astrparam,"")]]>
<![CDATA[
]]>
<![CDATA[  sBasicExpression = sExpression]]>
<![CDATA[
]]>
<![CDATA[  Writelog("BASIC Expression is: " & sBasicExpression)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Equalize Expression Decimal Places ]]>
<![CDATA[
]]>
<![CDATA[  If instr(sExpression,"=") Then]]>
<![CDATA[
]]>
<![CDATA[    aDecimal = Split(sExpression,"=")]]>
<![CDATA[
]]>
<![CDATA[    For Nx = 0 to Ubound(aDecimal)]]>
<![CDATA[
]]>
<![CDATA[        sLeft = ""]]>
<![CDATA[
]]>
<![CDATA[        sRight = ""]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        'Check for < or > symbols]]>
<![CDATA[
]]>
<![CDATA[        If Len(aDecimal(Nx))>2 then]]>
<![CDATA[
]]>
<![CDATA[  			]]>
<![CDATA[
]]>
<![CDATA[            If left(aDecimal(Nx),1) = "<" or left(aDecimal(Nx),1) = ">" then]]>
<![CDATA[
]]>
<![CDATA[              sLeft = left(aDecimal(Nx),1)]]>
<![CDATA[
]]>
<![CDATA[              aDecimal(Nx) = right(aDecimal(Nx),len(aDecimal(Nx))-1)]]>
<![CDATA[
]]>
<![CDATA[            End if		]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[            If right(aDecimal(Nx),1) = "<" or right(aDecimal(Nx),1) = ">" then]]>
<![CDATA[
]]>
<![CDATA[              sRight = right(aDecimal(Nx),1)]]>
<![CDATA[
]]>
<![CDATA[              aDecimal(Nx) = left(aDecimal(Nx),len(aDecimal(Nx))-1)]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            If IsNumeric(aDecimal(Nx)) and nDecimal<>"" then]]>
<![CDATA[
]]>
<![CDATA[              If DecimalSeparator<>"." and instr(aDecimal(Nx),".")>0 then aDecimal(Nx)=replace(aDecimal(Nx),".",DecimalSeparator)]]>
<![CDATA[
]]>
<![CDATA[              writelog("Formatting number[1]: " & aDecimal(Nx)) ]]>
<![CDATA[
]]>
<![CDATA[              aDecimal(Nx) =  FormatNumber(cdbl(aDecimal(Nx)),nDecimal,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[              If DecimalSeparator<>"." then aDecimal(Nx)=replace(aDecimal(Nx),DecimalSeparator,".")]]>
<![CDATA[
]]>
<![CDATA[           End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Elseif IsNumeric(aDecimal(Nx)) then			 ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[           If IsNumeric(aDecimal(Nx)) and nDecimal<>"" then]]>
<![CDATA[
]]>
<![CDATA[              If DecimalSeparator<>"." and instr(aDecimal(Nx),".")>0 then aDecimal(Nx)=replace(aDecimal(Nx),".",DecimalSeparator)]]>
<![CDATA[
]]>
<![CDATA[              writelog("Formatting number[2]: " & aDecimal(Nx))]]>
<![CDATA[
]]>
<![CDATA[              aDecimal(Nx) = FormatNumber(cdbl(aDecimal(Nx)),nDecimal,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[              If DecimalSeparator<>"." then aDecimal(Nx)=replace(aDecimal(Nx),DecimalSeparator,".")]]>
<![CDATA[
]]>
<![CDATA[           End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[  			]]>
<![CDATA[
]]>
<![CDATA[        aDecimal(Nx) = sLeft & aDecimal(Nx) & sRight]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
<![CDATA[
]]>
<![CDATA[        'EVAL statement does not interpret numbers not using the decimal characters as the decimal separator]]>
<![CDATA[
]]>
<![CDATA[        ' for the eval ONLY we change the system to use the decimal character.]]>
<![CDATA[
]]>
<![CDATA[        If DecimalSeparator<>"." then aDecimal(Nx)=replace(aDecimal(Nx),DecimalSeparator,".")]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[        aDecimal(Nx)= "FormatNumber(" & aDecimal(Nx) & "," & nDigits & ",0,0)"]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		Next 'Nx]]>
<![CDATA[
]]>
<![CDATA[		sExpression = Join(aDecimal,"=")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	If instr(sExpression,"<>") Then]]>
<![CDATA[
]]>
<![CDATA[		aDecimal = Split(sExpression,"<>")]]>
<![CDATA[
]]>
<![CDATA[		For Nx = 0 to Ubound(aDecimal)]]>
<![CDATA[
]]>
<![CDATA[			aDecimal(Nx) = "FormatNumber(" & aDecimal(Nx) & "," & nDigits & ",0,0)"]]>
<![CDATA[
]]>
<![CDATA[		Next 'Nx]]>
<![CDATA[
]]>
<![CDATA[		sExpression = Join(aDecimal,"<>")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Formatted Expression: '" & sExpression & "'")	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sCResult = Eval(Trim(sExpression))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("EVAL returns: '" & sCResult & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Instr(sExpression,">")>0 or Instr(sExpression,"<")>0 or Instr(sExpression,"=")>0 then]]>
<![CDATA[
]]>
<![CDATA[    Select Case sCResult]]>
<![CDATA[
]]>
<![CDATA[        Case False]]>
<![CDATA[
]]>
<![CDATA[            CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[            sMessage = RRState.LoadString("validations","CalculateFields_01","Field '{0}' failed Calculation '{1}'.") ]]>
<![CDATA[
]]>
<![CDATA[            sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[            sMessage = replace(sMessage,"{1}",sExpression)]]>
<![CDATA[
]]>
<![CDATA[            sMessage = replace(sMessage,"FormatNumber(","")]]>
<![CDATA[
]]>
<![CDATA[            sMessage = replace(sMessage,"," & nDigits & ",0,0)","")]]>
<![CDATA[
]]>
<![CDATA[            DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If bPreserveStatus = FALSE then]]>
<![CDATA[
]]>
<![CDATA[                For Each fKey in dictCalcObj.keys]]>
<![CDATA[
]]>
<![CDATA[                    Set kObj = dictCalcObj.Item(fKey)]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[                    If kObj.Variable("STATUS")<>cstr(nFail) then ]]>
<![CDATA[
]]>
<![CDATA[                        writelog("Setting " & kObj.ID & " to STATUS '1'")]]>
<![CDATA[
]]>
<![CDATA[                        kObj.Variable("STATUS")=1]]>
<![CDATA[
]]>
<![CDATA[                        txtmsg = RRState.LoadString("validations","CalculateFields_03","Field '{0}' failed by Calculate Action on by Field '{1}'.")]]>
<![CDATA[
]]>
<![CDATA[                        txtmsg = replace(txtmsg,"{0}",kObj.ID)]]>
<![CDATA[
]]>
<![CDATA[                        txtmsg = replace(txtmsg,"{1}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[                        If Not kObj.AddVariable("MESSAGE",txtmsg) Then ]]>
<![CDATA[
]]>
<![CDATA[                            kObj.Variable("MESSAGE") = txtmsg]]>
<![CDATA[
]]>
<![CDATA[                        End If]]>
<![CDATA[
]]>
<![CDATA[                    End if]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[                Next 'fKey]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[        Case True ]]>
<![CDATA[
]]>
<![CDATA[            writelog("Expression returns TRUE")]]>
<![CDATA[
]]>
<![CDATA[            CalculateFields = True]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            'Check related field status]]>
<![CDATA[
]]>
<![CDATA[            If bPreserveStatus = FALSE then]]>
<![CDATA[
]]>
<![CDATA[                For Each fKey in dictCalcObj.keys]]>
<![CDATA[
]]>
<![CDATA[                    Set kObj = dictCalcObj.Item(fKey)]]>
<![CDATA[
]]>
<![CDATA[                    If trim(kObj.Variable("STATUS"))=cstr(nFail) then ]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[                        If instr(kObj.Variable("MESSAGE"),"Failed By Calculate Action On Field")>0 then]]>
<![CDATA[
]]>
<![CDATA[                            'Change Status to pass]]>
<![CDATA[
]]>
<![CDATA[                            kObj.Variable("STATUS")=cstr(nPass)]]>
<![CDATA[
]]>
<![CDATA[                            Call kObj.DeleteVariable("MESSAGE")]]>
<![CDATA[
]]>
<![CDATA[                        End if]]>
<![CDATA[
]]>
<![CDATA[                        ]]>
<![CDATA[
]]>
<![CDATA[                    End if]]>
<![CDATA[
]]>
<![CDATA[                Next 'fKey]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[        Case Else]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Expression returns unexpected result:'" & sCResult & "'.")]]>
<![CDATA[
]]>
<![CDATA[            CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[    End Select]]>
<![CDATA[
]]>
<![CDATA[  Else		]]>
<![CDATA[
]]>
<![CDATA[      If Isnumeric(sCResult) then ]]>
<![CDATA[
]]>
<![CDATA[          If Isnumeric(nDecimal) then sCResult = FormatNumber(sCResult, nDecimal,,,0)]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Expression = " & sCResult)]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Text = sCResult]]>
<![CDATA[
]]>
<![CDATA[          CalculateFields = True]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[          sMessage = RRState.LoadString("validations","CalculateFields_02","Field '{0}' calling the calculate action has an unexpected result from the expression '{1}'.")]]>
<![CDATA[
]]>
<![CDATA[          sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[          sMessage = replace(sMessage,"{1}",sExpression)]]>
<![CDATA[
]]>
<![CDATA[          sMessage = replace(sMessage,"FormatNumber(","")]]>
<![CDATA[
]]>
<![CDATA[          sMessage = replace(sMessage,"," & nDigits & ",0,0)","")]]>
<![CDATA[
]]>
<![CDATA[          DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[          Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[          CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	dictCalcObj.RemoveAll()]]>
<![CDATA[
]]>
<![CDATA[	Set dictCalcObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Err.Number <> 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[		Err.Clear]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</f>
<af name="IsFieldEmpty" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'The Field object's name.]]>
<![CDATA[
]]>
<![CDATA[  'Checks if the Field object designated as a parameter does not have a captured value.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldEmpty = False]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Checking field " & strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(strParam)]]>
<![CDATA[
]]>
<![CDATA[	if oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldEmpty_01","Unable to locate Field '{0}' to check if the field value is empty.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(oFld.Text) = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		IsFieldEmpty = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldEmpty_02","Field '{0}' is not Empty.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldEmpty returns: " & IsFieldEmpty)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldFilled" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'The name of the Field object.]]>
<![CDATA[
]]>
<![CDATA[  'Determines whether the Field object designated as a parameter contains a captured value or is empty. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldFilled = False]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Checking field " & strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(strParam)]]>
<![CDATA[
]]>
<![CDATA[	if oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldFilled_01","Unable to locate Field '{0}' to check if the field has a value.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(sMessage) ]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(oFld.Text) > 0 Then  ]]>
<![CDATA[
]]>
<![CDATA[		IsFieldFilled = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldFilled_02","Field '{0}' is Empty.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)  ]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldFilled returns " & IsFieldFilled)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckSubFields" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[  '  An "expression" that specifies which child fields are to be checked for the presence or absence ]]>
<![CDATA[
]]>
<![CDATA[  '  of captured values. Within the expression, each child Field object's name needs to be surrounded ]]>
<![CDATA[
]]>
<![CDATA[  '  with single quotation marks ('). You can also use parentheses () in your expression.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CheckSubFields=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim aDel()]]>
<![CDATA[
]]>
<![CDATA[	Dim NumChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim oSuperField]]>
<![CDATA[
]]>
<![CDATA[	Dim tNode]]>
<![CDATA[
]]>
<![CDATA[	Dim aNode]]>
<![CDATA[
]]>
<![CDATA[	Dim eString]]>
<![CDATA[
]]>
<![CDATA[	Dim nValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ReDim Preserve aDel(CurrentObj.NumofChildren + 1)]]>
<![CDATA[
]]>
<![CDATA[	Set Sobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For i = 0 To CurrentObj.NumOfChildren -1]]>
<![CDATA[
]]>
<![CDATA[		bNoGood = False]]>
<![CDATA[
]]>
<![CDATA[		Set oSuperField = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		If Not (oSuperField Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			'Check Sub-fields for Data	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			eString = ""]]>
<![CDATA[
]]>
<![CDATA[			aStrParam = Split(strparam, "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			For aNode = 0 to ubound(aStrParam) ]]>
<![CDATA[
]]>
<![CDATA[				nValue = Trim(ucase(aStrParam(aNode)))]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,"(","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,")","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,"OR","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,"AND","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue," ","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,"'","")	]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				If Len(nValue)>0 Then				]]>
<![CDATA[
]]>
<![CDATA[					Set Sobj = oSuperField.FindChild(TRIM(aStrParam(aNode)))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					If Not(Sobj Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[						If Len(Trim(Sobj.Text))>0 Then ]]>
<![CDATA[
]]>
<![CDATA[							eString = eString & " Cbool(True) " ]]>
<![CDATA[
]]>
<![CDATA[						Else ]]>
<![CDATA[
]]>
<![CDATA[							eString = eString & " Cbool(False) " ]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						Set Sobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				Else]]>
<![CDATA[
]]>
<![CDATA[					eString = eString & aStrParam(aNode) & " "]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next	]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[			writelog("Expression: " & eString)]]>
<![CDATA[
]]>
<![CDATA[		    ]]>
<![CDATA[
]]>
<![CDATA[			bGood = Eval(eString)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Expression not valid.")]]>
<![CDATA[
]]>
<![CDATA[				Err.Clear]]>
<![CDATA[
]]>
<![CDATA[				bGood=False]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			If not bGood Then ]]>
<![CDATA[
]]>
<![CDATA[			    aDel(i) = CStr(i)	]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[			    aDel(i) = ""	]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Next 'i	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set Sobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Fx = (CurrentObj.NumOfChildren - 1) To 0 Step -1]]>
<![CDATA[
]]>
<![CDATA[		If Not aDel(Fx)="" Then ]]>
<![CDATA[
]]>
<![CDATA[			Call CurrentObj.Deletechild(aDel(fx))]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("CheckSubFields returns " & CheckSubFields)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SumFields" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value of a Field object's Type property or the name of a variable.]]>
<![CDATA[
]]>
<![CDATA[  'Sums captured values of any "child" Field if a child object's Type property is identical to the Type you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  dictTypeVars.RemoveAll()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call fFindTypeValues(CurrentObj, StrParam,"")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim kObj]]>
<![CDATA[
]]>
<![CDATA[	Dim fKey]]>
<![CDATA[
]]>
<![CDATA[	Dim nTally]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nTally = cdbl(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Each fKey in dictTypeVars.keys]]>
<![CDATA[
]]>
<![CDATA[		Set kObj = dictTypeVars.Item(fKey)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		writelog("Checking '" & fKey & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		if kObj.Type = StrParam then ]]>
<![CDATA[
]]>
<![CDATA[			sVal = kObj.Text]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			sVal = kObj.Variable(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If isNumeric(sVal) then ]]>
<![CDATA[
]]>
<![CDATA[			nTally = nTally + cdbl(sVal)]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Value '" & cdbl(sVal) & "' is numeric. New tally is '" & nTally & "' ")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Value '" & sVal & "' is not numeric.")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Next 'kObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If dictTypeVars.Count = 0 then ]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Fields or Variables of Type '" & StrParam & "' were found.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("SumFields_" & StrParam) = nTally]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	dictTypeVars.RemoveAll()]]>
<![CDATA[
]]>
<![CDATA[	SumFields = True ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ResetField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  '  This action deletes the selected Field object's captured value, and sets the field's ]]>
<![CDATA[
]]>
<![CDATA[  '  attribute to 0,0,0,0.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ResetField = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<> 3 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Not a field object. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("Position") = "0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If isObject(Logwindow) then]]>
<![CDATA[
]]>
<![CDATA[ 		ValueUP.Text = ""]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ResetField = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Current captured value and field position attributes reset.") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SaveAsCurrentObjVariable" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  '   The name of the variable]]>
<![CDATA[
]]>
<![CDATA[  '   The String value to be assigned.]]>
<![CDATA[
]]>
<![CDATA[  '   These are comma-separated parameters, and the second is optional. If you do not include this parameter,]]>
<![CDATA[
]]>
<![CDATA[  '   the action will automatically assign the captured value of the selected Field object to the variable.]]>
<![CDATA[
]]>
<![CDATA[  '   This action has been replaced by rrSet.  Use the @F smart variable to access the current field value.]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sVarName]]>
<![CDATA[
]]>
<![CDATA[	Dim nComma]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nComma = instr(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If nComma>0 Then]]>
<![CDATA[
]]>
<![CDATA[		sVarName = Trim(Mid(Strparam,1,nComma-1))]]>
<![CDATA[
]]>
<![CDATA[		sValue = Mid(StrParam,nComma+1,len(Strparam)-nComma)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sVarName = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		sValue = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable(sVarName) = sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting Variable '" & sVarName & "' to :'" & sValue & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SaveAsCurrentObjVariable = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SaveAsCurrentObjVariable returns " & SaveAsCurrentObjVariable)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReadCurrentObjVariable" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'The name of the bound object's property or variable.]]>
<![CDATA[
]]>
<![CDATA[  'Reads the Text value of the bound object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[  'For a Field object, this is the value of the object's Text property. For objects at other levels, the value is in a runtime variable of the bound object (see the examples).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ReadCurrentObjVariable = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.FindVariable(StrParam)<0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Variable '" & StrParam & "' not found.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sValue = CurrentObj.Variable(StrParam) ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Variable '" & StrParam & "' found :" & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.text = sValue]]>
<![CDATA[
]]>
<![CDATA[		If IsObject(LogWindow) then ValueUp.text = sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.ObjectType<3 then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Non-Field Object. Saving as 'Text' variable")]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.Variable("Text") = sValue]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		ReadCurrentObjVariable = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End if ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("ReadCurrentObjVariable returns " & ReadCurrentObjVariable)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SaveAsPageVariable" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[' The name of the variable	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[' The String value to be assigned.	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[' These are comma-separated parameters, and the second is optional. If you do not include this parameter, 	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[' the action will automatically assign the Text property of the calling object to the variable.	Dim sVarName]]>
<![CDATA[
]]>
<![CDATA[' Assigns a value to a variable of the current Page object. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim nComma]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	nComma = instr(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If nComma>0 Then]]>
<![CDATA[
]]>
<![CDATA[		sVarName = Trim(Mid(Strparam,1,nComma-1))]]>
<![CDATA[
]]>
<![CDATA[		sValue = Mid(StrParam,nComma+1,len(Strparam)-nComma)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sVarName = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		sValue = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While Not(oParent.ObjectType=2 Or oParent.objectType=0)	]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()	]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oParent.ObjectType<>2 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Parent Page found. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		SaveAsPageVariable = False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Set Variable '" & sVarName & "' to :" & sValue)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oParent.Variable(sVarName) = sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SaveAsPageVariable = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SaveAsPageVariable returns " & SaveAsPageVariable)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Nothing ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReadPageVariableValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'The name of the Page object's variable.]]>
<![CDATA[
]]>
<![CDATA[  'Assigns the value of a variable of the Page object to the selected Field object. If the action is not placed at the field level, then a variable called Text will be created in the current object, and the found value will be written to this variable.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On error resume next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ReadPageVariableValue = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While not(oParent.ObjectType=2 Or oParent.objectType=0)	]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()	]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If oParent.FindVariable(StrParam)<0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Variable '" & StrParam & "' not found.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sValue = oParent.Variable(StrParam) ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Variable '" & StrParam & "' found :" & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.text = sValue]]>
<![CDATA[
]]>
<![CDATA[		If IsObject(LogWindow) then ValueUp.text = sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.ObjectType<3 then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Non-Field Object. Saving as 'Text' variable")]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.Variable("Text") = sValue]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		ReadPageVariableValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("ReadPageVariableValue returns: " & ReadPageVariableValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ConvertToUpperCase" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Converts the lower case characters in a Field object's captured value to Upper Case characters. ]]>
<![CDATA[
]]>
<![CDATA[  ' A Validate rule with this action, if applied to a State Field object which accepts only abbreviations, ]]>
<![CDATA[
]]>
<![CDATA[  '  would be sure the captured values contain Upper Case letters (AZ, AL, etc.) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sConf]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If value <> "" Then]]>
<![CDATA[
]]>
<![CDATA[		Value = Ucase(Value)]]>
<![CDATA[
]]>
<![CDATA[		sConf = CurrentObj.ConfidenceString ]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Text = Value]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.ConfidenceString = sConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If IsObject(LogWindow) then ValueUp.text = Value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Value converted to all caps. New value is: '" & value & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	ConvertToUpperCase = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ConvertToLowerCase" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Converts any Upper Case characters in a Field object's captured value to lower case characters. ]]>
<![CDATA[
]]>
<![CDATA[  'To ensure that the characters in all Product ID's are lower case, a Validate rule that applies to a Document Hierarchy's Item Field object would include this action. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim sConf]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	If value <> "" Then]]>
<![CDATA[
]]>
<![CDATA[		Value = Lcase(Value)]]>
<![CDATA[
]]>
<![CDATA[		sConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Text = Value]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.ConfidenceString = sConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If IsObject(LogWindow) then ValueUp.text = Value		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Value converted to all lowercase. New value is: " & Value)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	ConvertToLowerCase = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SplitFieldValueRight" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value of the separating character. SmartParameter Enabled.]]>
<![CDATA[
]]>
<![CDATA[  'Splits a Field object's captured value at the first instance of the character specified as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  'The action deletes all characters to the left of the separating character, as well as the separation character.  All text to the right of the separating character remains. ]]>
<![CDATA[
]]>
<![CDATA[  'If the object's value is "InvNumber=A1234," this action truncates it to "A1234".  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim pos]]>
<![CDATA[
]]>
<![CDATA[	Dim sConf]]>
<![CDATA[
]]>
<![CDATA[	Dim Fleft,FTop,FBottom,FRight]]>
<![CDATA[
]]>
<![CDATA[	Dim Cleft,CTop,Cbottom,CRight]]>
<![CDATA[
]]>
<![CDATA[	Dim sNewParam]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Fleft=""]]>
<![CDATA[
]]>
<![CDATA[	FTop=""]]>
<![CDATA[
]]>
<![CDATA[	FBottom=""]]>
<![CDATA[
]]>
<![CDATA[	FTop=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValueRight = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start value is: '" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sNewParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  'Only use MetaWord result if it returns a value]]>
<![CDATA[
]]>
<![CDATA[  If sNewParam<>"" Then strParam=sNewParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	pos = InStr(Value, strParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If pos = 0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Split value '" & strParam & "' not found in field.")]]>
<![CDATA[
]]>
<![CDATA[        Exit function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Character Index begins after any child fields]]>
<![CDATA[
]]>
<![CDATA[	nFields = (CurrentObj.NumOfChildren - len(CurrentObj.Text))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For Cx = (CurrentObj.NumOfChildren-1) to nFields Step-1 ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If Cx>=(pos+nFields) then]]>
<![CDATA[
]]>
<![CDATA[			Set cObj = CurrentObj.GetChild(Cx)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			If Not cObj is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[				bRes = cObj.GetPosition(Cleft,Ctop,Cright,Cbottom)]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[				If Not(Cleft=0 and Ctop=0 and Cright=0 and Cbottom=0) Then 			]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[					If Fleft="" then FLeft=Clng(Cleft)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cleft)<Fleft then FLeft=Clng(Cleft)]]>
<![CDATA[
]]>
<![CDATA[					If Ftop="" then Ftop=Clng(Ctop)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Ctop)<Ftop then Ftop=Clng(Ctop)]]>
<![CDATA[
]]>
<![CDATA[					If Fright="" then Fright=Clng(Cright)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cright)>Fright then Fright=Clng(Cright)]]>
<![CDATA[
]]>
<![CDATA[					If Fbottom="" then Fbottom=Clng(Cbottom)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cbottom)>Fbottom then Fbottom=Clng(Cbottom)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Delete Character Node]]>
<![CDATA[
]]>
<![CDATA[			If CurrentObj.Deletechild(Cx)=False then]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Child Index '" & Cx & "' not deleted successfully.")]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Fleft="" then FLeft=Clng(0)		]]>
<![CDATA[
]]>
<![CDATA[	If Ftop="" then Ftop=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Fright="" then Fright=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Fbottom="" then Fbottom=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("Position") = cstr(Fleft) & "," & cstr(Ftop) & "," & cstr(Fright) & "," & cstr(Fbottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) then ValueUp.text = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Value split at position " & pos & " . New value is: '" & GetFieldValue() & "' , confidence: '" & GetFieldConf() & "'.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValueRight = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SplitFieldValueLeft" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'String value of the separating character. SmartParameter Enabled.]]>
<![CDATA[
]]>
<![CDATA[  'Splits a Field object's captured value at the first instance of the character specified as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  'The action deletes all characters to the right of the separating character, including the separating character. ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[	Dim pos]]>
<![CDATA[
]]>
<![CDATA[	Dim sConf]]>
<![CDATA[
]]>
<![CDATA[	Dim Fleft,FTop,FBottom,FRight]]>
<![CDATA[
]]>
<![CDATA[	Dim Cleft,CTop,Cbottom,CRight]]>
<![CDATA[
]]>
<![CDATA[	Dim sNewParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Fleft=""]]>
<![CDATA[
]]>
<![CDATA[	FTop=""]]>
<![CDATA[
]]>
<![CDATA[	FBottom=""]]>
<![CDATA[
]]>
<![CDATA[	FTop=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValueLeft = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start value is: '" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sNewParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  'Only use MetaWord result if it returns a value]]>
<![CDATA[
]]>
<![CDATA[  If sNewParam<>"" Then strParam=sNewParam]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  pos = InStr(Value, strParam)]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    If pos = 0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Split value '" & strParam & "' not found in field.")]]>
<![CDATA[
]]>
<![CDATA[        Exit function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	'Character Index begins after any child fields]]>
<![CDATA[
]]>
<![CDATA[	nFields = (CurrentObj.NumOfChildren - len(CurrentObj.Text))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For Cx = (CurrentObj.NumOfChildren-1) to nFields Step-1 ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If Cx<(pos+nFields-1) then]]>
<![CDATA[
]]>
<![CDATA[			Set cObj = CurrentObj.GetChild(Cx)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			If Not cObj is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[				bRes = cObj.GetPosition(Cleft,Ctop,Cright,Cbottom)]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[				If Not(Cleft=0 and Ctop=0 and Cright=0 and Cbottom=0) Then 			]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[					If Fleft="" then FLeft=Clng(Cleft)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cleft)<Fleft then FLeft=Clng(Cleft)]]>
<![CDATA[
]]>
<![CDATA[					If Ftop="" then Ftop=Clng(Ctop)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Ctop)<Ftop then Ftop=Clng(Ctop)]]>
<![CDATA[
]]>
<![CDATA[					If Fright="" then Fright=Clng(Cright)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cright)>Fright then Fright=Clng(Cright)]]>
<![CDATA[
]]>
<![CDATA[					If Fbottom="" then Fbottom=Clng(Cbottom)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cbottom)>Fbottom then Fbottom=Clng(Cbottom)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Delete Character Node]]>
<![CDATA[
]]>
<![CDATA[			If CurrentObj.Deletechild(Cx)=False then]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Child Index '" & Cx & "' not deleted successfully.")]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Fleft="" then FLeft=Clng(0)		]]>
<![CDATA[
]]>
<![CDATA[	If Ftop="" then Ftop=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Fright="" then Fright=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Fbottom="" then Fbottom=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("Position") = cstr(Fleft) & "," & cstr(Ftop) & "," & cstr(Fright) & "," & cstr(Fbottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) then ValueUp.text = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Value split at position " & pos & " .  New value is: '" & GetFieldValue() & "' , confidence: '" & GetFieldConf() & "'.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValueLeft = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldPercentNonNumeric" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    A number (0-100) indicating the percentage that results in a  condition. The default percentage is 100.]]>
<![CDATA[
]]>
<![CDATA['    The value must be numeric, without the percent sign.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim Value, TrueCount, FalseCount, TFRatio, Cx, Lval]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldPercentNonNumeric = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Percentage parameter not numeric. Value defaults to 100 percent.")]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("IsFieldPercentNonNumeric percentage parameter set to " & StrParam & " percent.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' \p{N} or \p{Number}: any kind of numeric character in any script. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nd} or \p{Decimal_Digit_Number}: a digit zero through nine in any script except ideographic scripts. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nl} or \p{Letter_Number}: a number that looks like a letter, such as a Roman numeral. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{No} or \p{Other_Number}: a superscript or subscript digit, or a number that is not a digit 0..9 (excluding numbers from ideographic scripts). ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	For Cx = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[    sCharacter=Mid(value,Cx,1)]]>
<![CDATA[
]]>
<![CDATA[		If DCGlobalStrings.RegExIsMatch(sCharacter,"\p{N}") Then]]>
<![CDATA[
]]>
<![CDATA[      FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*Len(value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio and Len(Value)>0 Then IsFieldPercentNonNumeric = True]]>
<![CDATA[
]]>
<![CDATA[	If Len(Value) <= 0 Then Lval = 1 Else Lval = Len(value)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "Value is " & (TrueCount/Lval)*100 & "% non-numeric") ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldPercentNonNumeric returns " & IsFieldPercentNonNumeric) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldPercentNonNumeric = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldPercentNonNumeric_01","Field '{0}' value '{1}' contains less than the required percentage of '{2}' non-numeric characters.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.id)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",Value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsMaxOMRChecked" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'An Integer value specifying this maximum.]]>
<![CDATA[
]]>
<![CDATA[  'Indicates the maximum number of checkboxes that can contain a value (a check, for example). ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue ]]>
<![CDATA[
]]>
<![CDATA[	Dim sMsg]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsMaxOMRChecked = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(StrParam)) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter '" & StrParam & "' is required to be numeric.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.variable("RecogType")<>"4" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Field is not OMR type.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'remove unchecked values]]>
<![CDATA[
]]>
<![CDATA[	sValue = Replace(sValue,"0","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If len(sValue)<=cint(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("'" & Len(sValue) & "' checked boxes found. Maximum permitted is '" & StrParam & "'.") ]]>
<![CDATA[
]]>
<![CDATA[		IsMaxOMRChecked = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsMaxOMRChecked_01","OMR Field '{0}' has '{1}' selected boxes. The maximum permitted number of selected boxes for this field is {2}.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",len(sValue))]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsMaxOMRChecked returns " & IsMaxOMRChecked) ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsMinOMRChecked" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue ]]>
<![CDATA[
]]>
<![CDATA[	Dim sMsg]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'An Integer value specifying this minimum.]]>
<![CDATA[
]]>
<![CDATA[  'Indicates the minimum number of checkboxes that can contain a value (a check, for example).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsMinOMRChecked = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(StrParam)) then ]]>
<![CDATA[
]]>
<![CDATA[		sMsg = "Parameter '" & StrParam & "' is required to be numeric. Ask Admin for assistance."]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMsg)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.variable("RecogType")<>"4" Then]]>
<![CDATA[
]]>
<![CDATA[		sMsg = "Field is not OMR type. Ask Admin for assistance."]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMsg)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'remove unchecked values]]>
<![CDATA[
]]>
<![CDATA[	sValue = Replace(sValue,"0","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If len(sValue)>=cint(StrParam) then ]]>
<![CDATA[
]]>
<![CDATA[		IsMinOMRChecked = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsMinOMRChecked_01","OMR Field '{0}' has '{1}' selected boxes. The minimum permitted number of selected boxes for this field is {2}.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",len(sValue))]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsMinOMRChecked returns " & IsMinOMRChecked)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CompareFields" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Five comma-separated values: ]]>
<![CDATA[
]]>
<![CDATA[  'String value of the source field's name.  This is the field with a value to be compared.]]>
<![CDATA[
]]>
<![CDATA[  'String value of the target field's name.  This is the field with a value to be compared to.]]>
<![CDATA[
]]>
<![CDATA[  'String value: Y or Yes; N or No. Alternatively, a Numeric value: 0 = No or 1=Yes.  ]]>
<![CDATA[
]]>
<![CDATA[  '"Yes" (or Y or 1) allows the action to carry out a fuzzy rather precise comparison of the fields' values.]]>
<![CDATA[
]]>
<![CDATA[  ' Numeric value of the percentage of required precision. Numbers less than ]]>
<![CDATA[
]]>
<![CDATA[  ' "100" permit increasing fuzziness.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	Dim SourceField]]>
<![CDATA[
]]>
<![CDATA[	Dim CompareToField]]>
<![CDATA[
]]>
<![CDATA[	Dim byWord]]>
<![CDATA[
]]>
<![CDATA[	Dim bPFuzzy]]>
<![CDATA[
]]>
<![CDATA[	Dim nFuzzy]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim SourceValue]]>
<![CDATA[
]]>
<![CDATA[	Dim CompareToValue]]>
<![CDATA[
]]>
<![CDATA[	Dim SourceObj]]>
<![CDATA[
]]>
<![CDATA[	Dim CompareToObj]]>
<![CDATA[
]]>
<![CDATA[	Dim regEx]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim Pattern]]>
<![CDATA[
]]>
<![CDATA[	Dim StrStart]]>
<![CDATA[
]]>
<![CDATA[	Dim FirstChar		]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim nWCount]]>
<![CDATA[
]]>
<![CDATA[	Dim sWords]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CompareFields = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set SourceObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set CompareToObj = Nothing	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",,,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SourceField = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	CompareToField = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	bPFuzzy = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[	nFuzzy = Trim(aStrParam(3))]]>
<![CDATA[
]]>
<![CDATA[	byWord = ucase(Trim(aStrParam(4)))	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If SourceField = "" Then SourceField = CurrentObj.ID ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set SourceObj = ReturnNamedComponent(SourceField)]]>
<![CDATA[
]]>
<![CDATA[	Set CompareToObj = ReturnNamedComponent(CompareToField)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If (SourceObj is Nothing) or (CompareToObj is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Fields not found to compare. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set SourceObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set CompareToObj = Nothing	]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SourceValue = SourceObj.Text]]>
<![CDATA[
]]>
<![CDATA[	CompareToValue = CompareToObj.Text]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Comparing " & SourceValue & " to " & CompareToValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	bPFuzzy = UCase(bPFuzzy)]]>
<![CDATA[
]]>
<![CDATA[	byWord = UCase(byWord)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If bPFuzzy = "Y" or bPFuzzy = "YES" or bPFuzzy = "1" then ]]>
<![CDATA[
]]>
<![CDATA[		bPFuzzy = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		bPFuzzy = False	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not isnumeric(nFuzzy) then nFuzzy = cint(100)]]>
<![CDATA[
]]>
<![CDATA[	nFuzzy = cint(nFuzzy)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If byWord = "Y" or byWord = "YES" or byWord = "1" then ]]>
<![CDATA[
]]>
<![CDATA[		byWord = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		byWord = False	]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sWords=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If byWord = False Then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If bPFuzzy Then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Root search value: '" & Cstr(SourceValue) & "' ")]]>
<![CDATA[
]]>
<![CDATA[		      ]]>
<![CDATA[
]]>
<![CDATA[			StrStart = SourceValue	]]>
<![CDATA[
]]>
<![CDATA[			FirstChar = Left(SourceValue,1)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If Len(SourceValue)>1 Then SourceValue = Right(SourceValue, Len(SourceValue)-1)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue,"[:#]", "[:#]+")   ]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[B8]", "[B8]")         ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[Z2]", "[Z2]")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[S5]", "[S5]")]]>
<![CDATA[
]]>
<![CDATA[		                                                 					]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[o0O]", "[o0O]")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[ilt1I]", "[ilt1I]")]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "\ +", "[ ]*")  ]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[			SourceValue = "^?[\b\s\n\r]*" & FirstChar & SourceValue & "[\b\s\$]*"]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Search value: '" & Cstr(SourceValue) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If DCGlobalStrings.RegExIsMatch(CompareToValue,SourceValue,True) Then ]]>
<![CDATA[
]]>
<![CDATA[       Writelog(DCGlobalStrings.GetLog)]]>
<![CDATA[
]]>
<![CDATA[       sWords = 1]]>
<![CDATA[
]]>
<![CDATA[       CompareFields = True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    'Check for Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & SourceValue & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      CompareFields = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if       ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Else		]]>
<![CDATA[
]]>
<![CDATA[		'Find number of source Words to find in compare to value]]>
<![CDATA[
]]>
<![CDATA[		aSourceVal = Split(SourceValue & Space(1),Chr(32))]]>
<![CDATA[
]]>
<![CDATA[		nWords = ubound(aSourceVal)]]>
<![CDATA[
]]>
<![CDATA[		nWCount = 0	]]>
<![CDATA[
]]>
<![CDATA[		bFound = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 to (nWords-1)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If bPFuzzy Then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Root search value: '" & Cstr(aSourceVal(i)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[		    			      ]]>
<![CDATA[
]]>
<![CDATA[				StrStart = aSourceVal(i)	]]>
<![CDATA[
]]>
<![CDATA[				FirstChar = Left(aSourceVal(i),1)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				If Len(aSourceVal(i))>1 Then aSourceVal(i) = Right(aSourceVal(i), Len(aSourceVal(i))-1)]]>
<![CDATA[
]]>
<![CDATA[			    ]]>
<![CDATA[
]]>
<![CDATA[	      SourceValue = DCGlobalStrings.RegExReplace(SourceValue,"[:#]", "[:#]+")   ]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[B8]", "[B8]")         ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[Z2]", "[Z2]")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[S5]", "[S5]")]]>
<![CDATA[
]]>
<![CDATA[		                                                 					]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[o0O]", "[o0O]")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[ilt1I]", "[ilt1I]")]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "\ +", "[ ]*")  ]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[				aSourceVal(i) = "^?[\b\s\n\r]*" & FirstChar & aSourceVal(i) & "[\b\s\$]*"]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If len(aSourceVal(i))>0 Then]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Search Value: '" & Cstr(aSourceVal(i)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[        If DCGlobalStrings.RegExIsMatch(CompareToValue,Cstr(aSourceVal(i))) Then]]>
<![CDATA[
]]>
<![CDATA[          Writelog(DCGlobalStrings.GetLog)]]>
<![CDATA[
]]>
<![CDATA[          CompareFields = True]]>
<![CDATA[
]]>
<![CDATA[          bfound=true]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[    					]]>
<![CDATA[
]]>
<![CDATA[        'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[        If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[          Writelog(Space(3) & "Invalid Pattern '" & Cstr(aSourceVal(i)) & "'")]]>
<![CDATA[
]]>
<![CDATA[          Err.Clear]]>
<![CDATA[
]]>
<![CDATA[          CompareFields = False]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[        End if  ]]>
<![CDATA[
]]>
<![CDATA[          			]]>
<![CDATA[
]]>
<![CDATA[				sWords = sWords + 1]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[				If bFound=False then WriteLog(Space(4) & "No value matched.")				]]>
<![CDATA[
]]>
<![CDATA[			End if	]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			If bFound = True then ]]>
<![CDATA[
]]>
<![CDATA[				nWCount = nWCount + 1	]]>
<![CDATA[
]]>
<![CDATA[				bFound = False]]>
<![CDATA[
]]>
<![CDATA[			End if	]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Check % vs nFuzzy value	]]>
<![CDATA[
]]>
<![CDATA[		If sWords <= 0 then sWords = 1]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		PMatch = cint((nWCount/sWords)*100)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(PMatch & "% of the 'Compare To' value matched the search words.")]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		If PMatch >= cint(nFuzzy) And nWCount>0 Then ]]>
<![CDATA[
]]>
<![CDATA[			CompareFields = True				]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Minimum match percentage is set to " & nFuzzy & "%. Not enough words matched, Returning 'Failed'.")	]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set SourceObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set CompareToObj = Nothing ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsThisFieldEmpty" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Confirms if the current field has no captured value. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If(CurrentObj.ObjectType = DCO_FIELD) Then]]>
<![CDATA[
]]>
<![CDATA[    If(CurrentObj.Text="") Then]]>
<![CDATA[
]]>
<![CDATA[      IsThisFieldEmpty = true]]>
<![CDATA[
]]>
<![CDATA[	  Else]]>
<![CDATA[
]]>
<![CDATA[      IsThisFieldEmpty = false  ]]>
<![CDATA[
]]>
<![CDATA[      sMessage = RRState.LoadString("validations","IsThisFieldEmpty_01","Field '{0}' is not empty.")]]>
<![CDATA[
]]>
<![CDATA[      sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = Replace(sMessage,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[      DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  End if]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action IsThisFieldEmpty works only on field level")]]>
<![CDATA[
]]>
<![CDATA[    IsThisFieldEmpty = false]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsThisFieldEmpty returns " & IsThisFieldEmpty) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsThisFieldFilled" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Confirms if the current field has a captured value.]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  If(CurrentObj.ObjectType = DCO_FIELD) Then]]>
<![CDATA[
]]>
<![CDATA[		If(Trim(CurrentObj.Text)<>"") Then]]>
<![CDATA[
]]>
<![CDATA[			IsThisFieldFilled = true]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			IsThisFieldFilled = false]]>
<![CDATA[
]]>
<![CDATA[      sMessage = RRState.LoadString("validations","IsThisFieldFilled_01","Field '{0}' is not filled.")]]>
<![CDATA[
]]>
<![CDATA[      sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = Replace(sMessage,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[			DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    writelog("Action IsThisFieldFilled works only on field level")]]>
<![CDATA[
]]>
<![CDATA[    IsThisFieldFilled = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsThisFieldFilled returns " & IsThisFieldFilled)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteLCSpaces" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim ReqConf]]>
<![CDATA[
]]>
<![CDATA[	Dim sTemp]]>
<![CDATA[
]]>
<![CDATA[	Dim oSetupNode]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Deletes all low confidence spaces from the captured value. Uses ReqConf Setup dco variable as threshold for low confidence values; defaults to 9]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ReqConf = 10 ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupNode = CurrentObj.SetupNode]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If(oSetupNode is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[	  writelog ("Unable to get setupNode for field " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[	  DeleteLCSpaces = False]]>
<![CDATA[
]]>
<![CDATA[	  Exit function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sTemp = Trim(oSetupNode.Variable("ReqConf"))]]>
<![CDATA[
]]>
<![CDATA[	If len(sTemp)<>0 and IsNumeric(sTemp) then ReqConf = sTemp]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Spaces with confidence below " & ReqConf & " will be removed.")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	nNumOfChar = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Character ASCII value : Character Confidence")]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to nNumOfChar]]>
<![CDATA[
]]>
<![CDATA[		Writelog CurrentObj.GetChild(nNumOfChar - i).CharValue(0) & ":" & CurrentObj.GetChild(nNumOfChar - i).CharConfidence(0)]]>
<![CDATA[
]]>
<![CDATA[		If((CurrentObj.GetChild(nNumOfChar - i).CharValue(0) = 32) and (CurrentObj.GetChild(nNumOfChar - i).CharConfidence(0) < (ReqConf-1))) then ]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.DeleteChild(nNumOfChar - i)]]>
<![CDATA[
]]>
<![CDATA[	 	End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	DeleteLCSpaces = true ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsMatchingJobID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value of the Job ID to be compared to the current Job ID.]]>
<![CDATA[
]]>
<![CDATA[  'Checks that the Job ID of the current User Application job matches the parameter's Job ID value. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  IsMatchingJobID = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Strparam = trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Ucase(Pilot.JobID)=ucase(StrParam) Then ]]>
<![CDATA[
]]>
<![CDATA[		IsMatchingJobID = True]]>
<![CDATA[
]]>
<![CDATA[		Writelog("JobID: '" & Pilot.JobID & "' matches.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "Current JobID '{0}' does not match '{1}'."]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",Ucase(Pilot.JobID))]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GetJobID" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Assigns the Job ID of the current User Application job - the job's 	Pilot.JobID property - to the CurrentObj.Text variable of the bound object 	of the Document Hierarchy. ]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[  GetJobID = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text = Pilot.JobID]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(CurrentObj.Text)>0 then ]]>
<![CDATA[
]]>
<![CDATA[		GetJobID = True]]>
<![CDATA[
]]>
<![CDATA[		Writelog("JobID of '" & Pilot.JobID & "' set as field value.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No JobID Found.")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FieldContainsValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Text that the action is looking for in the current field.]]>
<![CDATA[
]]>
<![CDATA[  'This action determines if a field represented by the bound object of the ]]>
<![CDATA[
]]>
<![CDATA[  'Document Hierarchy contains some or all of the parameter's text value, without additional unspecified text. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sCurrentValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FieldContainsValue = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sCurrentValue = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Checking if string '" & sCurrentValue & "' contains value '" & strParam & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If instr(sCurrentValue,StrParam)>0 Then]]>
<![CDATA[
]]>
<![CDATA[		FieldContainsValue = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","FieldContainsValue_01","Field '{0}' with value '{1}' does not contain the value '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",sCurrentValue)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",strParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("FieldContainsValue action returns " & FieldContainsValue & " for value: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteChildType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim x]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   String value of the child object Type. ]]>
<![CDATA[
]]>
<![CDATA[ '   "Field", for example, will eliminate all  objects. In the <i>Invoices</i> ]]>
<![CDATA[
]]>
<![CDATA[ '   application, however, "LineItem" will remove child fields of the parent <i>Details</i> ]]>
<![CDATA[
]]>
<![CDATA[ '   parent  object. ]]>
<![CDATA[
]]>
<![CDATA[ '   Deletes child objects of the type you designate as a parameter from the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  x = CurrentObj.NumOfChildren - len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Current number of Children: " & x)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For i = x to 0 Step -1]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		If Not(oChild is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[			if oChild.Type = StrParam Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Deleting Child " & oChild.ID)]]>
<![CDATA[
]]>
<![CDATA[				CurrentObj.DeleteChild(i)]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Removal of ChildType " & StrParam & " complete")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ParseName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Three comma separated parameters:]]>
<![CDATA[
]]>
<![CDATA[  'The name of the Last Name Field object.]]>
<![CDATA[
]]>
<![CDATA[  'The name of the First Name Field object.]]>
<![CDATA[
]]>
<![CDATA[  'The name of the Middle Name or Middle Initial Field object.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ParseName = u_ParseName(CurrentObj,StrParam)]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("ParseName returns " & ParseName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ParseMultilineAddress" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' Comma-separated Smart Parameter String values of the names of fields which will hold the]]>
<![CDATA[
]]>
<![CDATA[  ' parsed data, in the following order:]]>
<![CDATA[
]]>
<![CDATA[  ' Name, AddressLine1, AddressLine2, City , State , Zip , Phone]]>
<![CDATA[
]]>
<![CDATA[  ' Comma-separated String values of the names of fields which will hold the parsed data,]]>
<![CDATA[
]]>
<![CDATA[  '  in the following order: Name, AddressLine1, AddressLine2, City, State, Zip, Phone.]]>
<![CDATA[
]]>
<![CDATA[  '  Example below assumes fields are sibling fields of the calling object. For other relationships]]>
<![CDATA[
]]>
<![CDATA[  '  please review smart parameter syntax.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim oFldParse]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[	Dim oValue]]>
<![CDATA[
]]>
<![CDATA[	Dim oConf]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld_Parsed]]>
<![CDATA[
]]>
<![CDATA[	Dim nStart]]>
<![CDATA[
]]>
<![CDATA[	Dim nEnd]]>
<![CDATA[
]]>
<![CDATA[  Dim ParentValue]]>
<![CDATA[
]]>
<![CDATA[  Dim ParentConf]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(StrParam) = "" ) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter list of: Name, AddressLine1 ,AddressLine2 ,City ,State ,Zip , Phone, is empty!")]]>
<![CDATA[
]]>
<![CDATA[		ParseMultilineAddress = false]]>
<![CDATA[
]]>
<![CDATA[		Exit function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arFieldList = Split(StrParam & ",,,,,",",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(CurrentObj.Text))=0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Calling object has no value. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		ParseMultilineAddress = False]]>
<![CDATA[
]]>
<![CDATA[		Exit function		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oFldParse = CreateObject("Datacap.FldParse")]]>
<![CDATA[
]]>
<![CDATA[	If (oFldParse is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Unable to create Datacap.FldParse object")]]>
<![CDATA[
]]>
<![CDATA[		ParseMultilineAddress = False]]>
<![CDATA[
]]>
<![CDATA[		Exit function		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ParentValue = CurrentObj.text]]>
<![CDATA[
]]>
<![CDATA[  ParentConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'oFldParse requires pipe char as line terminator value]]>
<![CDATA[
]]>
<![CDATA[  ParentValue = replace(ParentValue,vbcrlf,"|")]]>
<![CDATA[
]]>
<![CDATA[  ParentValue = replace(ParentValue,vbcr,"|")]]>
<![CDATA[
]]>
<![CDATA[  ParentValue = replace(ParentValue,vblf,"|")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Current Field Value:" & Currentobj.Text)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Choices for testing...]]>
<![CDATA[
]]>
<![CDATA[	Set oFld_Parsed = oFldParse.GetHCField33Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetHCField32Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetUBField1Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetUBField13Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetUBField38Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetUBField66Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If (oFld_Parsed is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Did not create Datacap oFld_Parsed object")]]>
<![CDATA[
]]>
<![CDATA[		ParseMultilineAddress = false]]>
<![CDATA[
]]>
<![CDATA[		Exit function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (Trim(arFieldList(0)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(0),"\")<=0 then arFieldList(0)="..\" & arFieldList(0)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(0))]]>
<![CDATA[
]]>
<![CDATA[    If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("did not find Name Field")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Name]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.NameConf]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (Trim(arFieldList(1)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(1),"\")<=0 then arFieldList(1)="..\" & arFieldList(1)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild  = DCONav(arFieldList(1))]]>
<![CDATA[
]]>
<![CDATA[    If oChild Is CurrentObj then Set oChild = Nothing  ]]>
<![CDATA[
]]>
<![CDATA[		If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find Address1 Field")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Add1]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.Add1Conf]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(2)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(2),"\")<=0 then arFieldList(2)="..\" & arFieldList(2)]]>
<![CDATA[
]]>
<![CDATA[    Set oChild = DCONav(arFieldList(2))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find Address2 Field")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Add2]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.Add2Conf]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(3)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(3),"\")<=0 then arFieldList(3)="..\" & arFieldList(3)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(3))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find City Field.")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.City]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.CityConf]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(4)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(4),"\")<=0 then arFieldList(4)="..\" & arFieldList(4)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(4))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find State field.")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.State]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.StateConf]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(5)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(5),"\")<=0 then arFieldList(5)="..\" & arFieldList(5)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(5))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find Zip field.")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Zip]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.ZipConf]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(6)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(6),"\")<=0 then arFieldList(6)="..\" & arFieldList(6)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(6))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find phone field.")]]>
<![CDATA[
]]>
<![CDATA[		Else		]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Phone]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.PhoneConf ]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[				oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[				Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[				Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[        Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[				Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oFld_Parsed = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFldParse = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Err.Number<>0 then Err.Clear]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ParseMultilineAddress = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsVariableEmpty" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Name of the current object's variable to be checked.]]>
<![CDATA[
]]>
<![CDATA[	'Confirms if the variable specified by the parameter does not contain a value.  This action only checks variables of the current object. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsVariableEmpty = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.FindVariable(strparam) < 0 then]]>
<![CDATA[
]]>
<![CDATA[        sMessage = "Variable " & StrParam & " was not found"]]>
<![CDATA[
]]>
<![CDATA[        Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Len(CurrentObj.Variable(strParam)) = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		IsVariableEmpty = True]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Variable " & strParam & "is empty")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "Variable " & strParam & " is not empty."]]>
<![CDATA[
]]>
<![CDATA[    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsVariableEmpty returns " & IsVariableEmpty)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsVariableFilled" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Name of the current object's variable to be checked.]]>
<![CDATA[
]]>
<![CDATA[  'Confirms if the variable specified by the parameter contains a value.  This action ]]>
<![CDATA[
]]>
<![CDATA[  'only checks variables of the current object.]]>
<![CDATA[
]]>
<![CDATA[      	]]>
<![CDATA[
]]>
<![CDATA[	IsVariableFilled = False]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.FindVariable(strparam) < 0 then]]>
<![CDATA[
]]>
<![CDATA[        sMessage = "Variable " & StrParam & " was not found"]]>
<![CDATA[
]]>
<![CDATA[        Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	If Len(CurrentObj.Variable(strParam)) > 0 Then  ]]>
<![CDATA[
]]>
<![CDATA[		IsVariableFilled = True]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Variable " & strParam & " contains a value")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "Variable " & strparam & "is not filled" ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsVariableFilled returns " & IsVariableFilled) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="HasChildOfType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'The name of a level of the Document Hierarchy (Batch, Document, Page, Field) or of a runtime variable.]]>
<![CDATA[
]]>
<![CDATA[  'Determines if the bound object of the Document Hierarchy has a child or children of the type specified by the parameter. The action can also determine if a runtime variable specified as a parameter has been assigned to the bound object.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim n, i]]>
<![CDATA[
]]>
<![CDATA[	Dim sType]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sType = ""	]]>
<![CDATA[
]]>
<![CDATA[	Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	n = 0]]>
<![CDATA[
]]>
<![CDATA[	i = 0	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	HasChildOfType = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	n = CurrentObj.NumOfChildren - len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[	sType = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking for Children of type: '" & sType & "' .")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to n]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = CurrentObj.GetChild(i-1)]]>
<![CDATA[
]]>
<![CDATA[		If Not(oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			If oChild.Type = sType Then ]]>
<![CDATA[
]]>
<![CDATA[				HasChildOfType = True]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Found Child of type: '" & sType & "' .")]]>
<![CDATA[
]]>
<![CDATA[				Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[  sMessage = cstr(n) & space(1) & "children checked. Type not found:" & strparam ]]>
<![CDATA[
]]>
<![CDATA[	Writelog(sMessage) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteParentObj" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Deletes the parent of the Document Hierarchy object to which a rule with this action is bound. ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  DeleteParentObj = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim x, i]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim oGrandParent]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = CurrentObj.Parent()]]>
<![CDATA[
]]>
<![CDATA[	If oParent is Nothing then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parent Object is Nothing.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Parent ID to delete is '" & oParent.ID & "'.")	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oGrandParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[	If oGrandParent is Nothing then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("GrandParent Object is Nothing.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	i = oGrandParent.FindChildIndex(oParent.ID)	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Parent Index is:'" & cstr(i) & "'.")	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Nothing	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	DeleteParentObj = oGrandParent.DeleteChild(i)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Set oGrandParent = Nothing ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsPatternInField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	' String value of the Regular Expression. The expression can include any Regular Expression characters.]]>
<![CDATA[
]]>
<![CDATA[  ' Uses VBScript Regular Expression Pattern entered as parameter to search for a matching pattern in ]]>
<![CDATA[
]]>
<![CDATA[  ' current object's Text value.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	IsPatternInField = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue= Replace(GetFieldValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Looking for value '" & strParam & "' in string: '" & sValue & "'")		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	regEx.Pattern = StrParam]]>
<![CDATA[
]]>
<![CDATA[	regEx.IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set Matches = regEx.Execute(sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[  If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[     Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[     Err.Clear]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	For Each Match In Matches]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Matched value:'" & CStr(Match.value) & "'")]]>
<![CDATA[
]]>
<![CDATA[		bFound = True]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ' Use dcglobal dotNet regex engine:]]>
<![CDATA[
]]>
<![CDATA[ ' If DCGlobalStrings.RegExIsMatch(sValue,StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[ '   WriteLog("Match Found")]]>
<![CDATA[
]]>
<![CDATA[ '	 bFound = True]]>
<![CDATA[
]]>
<![CDATA[ ' End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		IsPatternInField = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsPatternInField_01","Field '{0}' value of '{1}' does not contain the pattern '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",sValue)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Debuglog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsPatternInField returns " & IsPatternInField)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ConvertFieldToCurrency" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Formats a field's text value as a currency value.  The following steps are performed on the field:]]>
<![CDATA[
]]>
<![CDATA[  '      ]]>
<![CDATA[
]]>
<![CDATA[  '   1. Removes existing currency symbols.Off]]>
<![CDATA[
]]>
<![CDATA[  '   2. Replaces negative value characters such as parenthesis, 'NEG', 'CR' and trailing hyphen ]]>
<![CDATA[
]]>
<![CDATA[  '   with a leading hyphen.]]>
<![CDATA[
]]>
<![CDATA[  '   3. If a decimal exists, its position is not changed.]]>
<![CDATA[
]]>
<![CDATA[  '   4. If a decimal does not exist and the field contains 2 or more characters, a decimal is inserted ]]>
<![CDATA[
]]>
<![CDATA[  '   before the last two characters in the field.]]>
<![CDATA[
]]>
<![CDATA[  '   5. If a decimal does not exist and the field contains less than 2 characters, no decimal is inserted.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim cObj]]>
<![CDATA[
]]>
<![CDATA[	Dim nLen]]>
<![CDATA[
]]>
<![CDATA[	Dim nChar]]>
<![CDATA[
]]>
<![CDATA[	Dim RegEx]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim Match	]]>
<![CDATA[
]]>
<![CDATA[	Dim m	]]>
<![CDATA[
]]>
<![CDATA[	Dim Index		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim sLocalNum]]>
<![CDATA[
]]>
<![CDATA[	Dim sDecimal]]>
<![CDATA[
]]>
<![CDATA[	Dim sGroup	]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sDecimal = DCGlobalCurrency.CurrencyDecimalSeparator(locale) ]]>
<![CDATA[
]]>
<![CDATA[	sGroup = DCGlobalCurrency.CurrencyGroupSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[  sSymbol = DCGlobalCurrency.CurrencySymbol(locale)  ]]>
<![CDATA[
]]>
<![CDATA[  sDecimalDigits = DCGlobalCurrency.CurrencyDecimalDigits(locale)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	ConvertFieldToCurrency = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Start value: '" & currentobj.text & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Remove all currency symbols]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace("[\s\p{Sc}_]*",cint(0),"",cint(0), CurrentObj) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check for Negative Currency values]]>
<![CDATA[
]]>
<![CDATA[  If DCGlobalStrings.RegExIsMatch(CurrentObj.Text,"\(\d\d+\)|\d\d+CR|\d\d+NEG|\d\d+-") then]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'If we found Negative currency indicator(s), remove the symbols and then replace with a leading hyphen character]]>
<![CDATA[
]]>
<![CDATA[    sResult = DCGlobalStrings.RemoveReplace("[\(\)-]|CR|NEG",cint(0),"",cint(0), CurrentObj) ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Check to see if the value is already Negative]]>
<![CDATA[
]]>
<![CDATA[		If instr(CurrentObj.text,"-")<>1 then]]>
<![CDATA[
]]>
<![CDATA[			Set cObj = CurrentObj.AddChild(4,"",CurrentObj.NumOfchildren-Len(Currentobj.Text))]]>
<![CDATA[
]]>
<![CDATA[			nChar = cObj.AddValue(CLng(45), CLng(10))]]>
<![CDATA[
]]>
<![CDATA[		  bRes = cObj.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End if				]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Numeric Check - look at a copy of the field value  ]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalStrings.RegExIsMatch(CurrentObj.Text,"[^\p{N}\.,-']") then  ]]>
<![CDATA[
]]>
<![CDATA[		ConvertFieldToCurrency = False]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Value must be numeric to format as currency. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Current locale decimal separator character is { " & sDecimal & " }")        ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[	'Add Decimal Character - preserve confidence of existing values]]>
<![CDATA[
]]>
<![CDATA[  'Assumes two position decimal if no decimal symbols are found]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalStrings.RegExIsMatch(CurrentObj.Text,"[\.,\u066b]") and (len(CurrentObj.Text)>2) then]]>
<![CDATA[
]]>
<![CDATA[	  Set cObj = CurrentObj.AddChild(4,"",len(CurrentObj.Text)-2)]]>
<![CDATA[
]]>
<![CDATA[		nChar = cObj.AddValue(CLng(ASCW(sDecimal)), CLng(10))]]>
<![CDATA[
]]>
<![CDATA[    bRes = cObj.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  If Not DCGlobalStrings.RegExIsMatch(CurrentObj.Text,"[^\p{N}\.,-'\u066b]") then]]>
<![CDATA[
]]>
<![CDATA[    If len(CurrentObj.Text)>=2 then  ]]>
<![CDATA[
]]>
<![CDATA[		  ConvertFieldToCurrency = True]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Non currency character in value")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("Formatted value: '" & currentobj.text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set cObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldHidden" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Note: This action returns True if the calling field is 'Hidden'...if the corresponding object of the Document Hierarchy has a variable STATUS equal to -1.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim oSetupNode]]>
<![CDATA[
]]>
<![CDATA[  Dim oNodeValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsFieldHidden=False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called on a DCO field. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupNode = CurrentObj.SetupNode]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If oSetupNode is nothing then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Unable to get setupNode for field " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    If Trim(cstr(oSetupNode.Variable("STATUS")))="-1" then IsFieldHidden=True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Trim(cstr(CurrentObj.STATUS))="-1" then IsFieldHidden=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("IsFieldHidden returns " & IsFieldHidden)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupNode=Nothing ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsSupportedImageFile" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamInput">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   ' A Boolean that determines the type of test to perform.]]>
<![CDATA[
]]>
<![CDATA[   ']]>
<![CDATA[
]]>
<![CDATA[   '  True: Tests the validity of the image by checking the file extension and attempting to load the image.]]>
<![CDATA[
]]>
<![CDATA[   '  False: Only a file extension check is performed to determine if it is a supported file.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim oDCImage]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsSupportedImageFile = FALSE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>2 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called on a DCO page. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strParam = UCase(Trim(strParamInput))  ]]>
<![CDATA[
]]>
<![CDATA[  If (trim(strParam) = "") then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter missing.  A parameter of True or False is required.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If ((strParam <> "TRUE") and (strParam <> "FALSE")) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("A parameter of True or False is required.  Parameter is: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ImageName <> "" Then]]>
<![CDATA[
]]>
<![CDATA[    If CBool(strParam) = TRUE Then]]>
<![CDATA[
]]>
<![CDATA[      Set oDCImage = createObject("DCIMAGE.DcimageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      oDCImage.FileName = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is not supported."]]>
<![CDATA[
]]>
<![CDATA[        Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        If oDCImage.Filename = "" Then]]>
<![CDATA[
]]>
<![CDATA[	        Writelog "Image file '" & CurrentObj.ImageName & "' is not supported."]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[	        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[          IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        End If ]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Set oDCImage = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      sFileName = UCase(CurrentObj.ImageName)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If InStr(sFileName,".TIF") >  0 Then]]>
<![CDATA[
]]>
<![CDATA[        IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[      ElseIf InStr(sFileName,".TIFF") >  0 Then]]>
<![CDATA[
]]>
<![CDATA[        IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[      ElseIf InStr(sFileName,".JPG") >  0 Then]]>
<![CDATA[
]]>
<![CDATA[        IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[      ElseIf InStr(sFileName,".JPEG") >  0 Then]]>
<![CDATA[
]]>
<![CDATA[        IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is not supported."]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    End  If]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog "The current page does not have an image associated with it."]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ReplaceValueAtPosition" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' Two-part comma-separated value:]]>
<![CDATA[
]]>
<![CDATA[  ' 1. The position that contains the value to be replaced.]]>
<![CDATA[
]]>
<![CDATA[  ' 2. The replacement string; this parameter defaults to "" indicating a deletion.]]>
<![CDATA[
]]>
<![CDATA[  ' This action replaces the value at a specific position with a string replacement value, or a deletion.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ReplaceValueAtPosition = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = StrParam & ","]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(aStrParam(0)) And Not(Trim(aStrParam(0)) = "*") Then aStrParam(0) = "1"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nStartIndex = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	ReplaceWithString = aStrParam(1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Start value:'" & CurrentObj.Text & "' Replace character index:'" & sFind & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If clng(sFind)<=clng(Len(currentobj.text)) then]]>
<![CDATA[
]]>
<![CDATA[      FindString=Mid(CurrentObj.Text,nStartIndex,1)]]>
<![CDATA[
]]>
<![CDATA[    	ReplaceValueAtPosition = u_ModifyText(FindString,nStartIndex,1,ReplaceWithString)]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Replace position is outside of field length.")]]>
<![CDATA[
]]>
<![CDATA[    End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("End value:'" & CurrentObj.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="FormatNumberToLocale" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  	    ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  FormatNumberToLocale = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim StartValue ]]>
<![CDATA[
]]>
<![CDATA[  Dim EndValue]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  Dim sLogVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  locale = CurrentObj.Variable("hr_locale")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Start Field value:" & CurrentObj.text)]]>
<![CDATA[
]]>
<![CDATA[  EndValue = DCGlobalCurrency.NormalizeNumber(CurrentObj,locale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sLogVal=DCGlobalCurrency.GetLog]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog(sLogVal)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("End value:" & CurrentObj.text)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.number=0 then ]]>
<![CDATA[
]]>
<![CDATA[    FormatNumberToLocale = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
F<help>
  <![CDATA[
'************************************************************************
' Validation Action help
'------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'------------------------------------------------------------------------
' Version 8.0.1.73 12/13.2010 PHofle
' * Copied help out of validations.rrx version 8.0.1.72
'
' Updated 4/20/2011 
' * Added help for FormatNumberToLocale action.
'
' Updated 4/29/2011 
' * Updated help for CalculateFields action.
'
' Updated 5/06/2011 PHofle
' * Help for IsFieldDateWithReformat corrected to specify system short date
'   format is the default. SPR 32026
'
' Updated 6/1/2011 PHofle
' * Updated Help for action 'SumFields' SPR 31988
' * Updated Help for actions 'IsFieldPercentNonNumeric' and 'IsFieldPercentNumeric' SPR 32118
'
' Updated 6/2/2011 PHofle
' * Updated Help for action 'DeleteAllMiscChars' SPR 32132
'
' Updated 6/27/2011 PHofle 8.1.0.28
' * Updated Help for action 'IsFieldCurrency' SPR 32095 
'
' Updated 9/30/2011 PHofle 8.0.1.30
' * Updated Help for action 'AllowOnlyChars' SPR 32983
'
' Updated 10/3/2011 PHofle 8.0.1.31
' * Corrected Help for action 'FieldContainsValue'. Some of the example use cases in help 
'   were not correct. PMR 58280,180,000
'
' Updated 4/13/2012 PHofle 8.1.0.46
' * FormatNumberToLocale help includes additional details about detected number patterns.
'
' Updated 4/13/2012 PHofle 8.1.0.47
' * Updated help for actions IsFieldPercentNumeric IsFieldpercentNonNumeric
'
' Updated 4/13/2012 PHofle 8.1.0.48
' * FormatNumberToLocale help includes example number patterns.
'
' Updated 5/04/2012 PHofle 8.1.0.54
' * Corrected Help for 'IsFieldDate' to include note that the action is locale aware and fix the
'   example to show results for when the locale setting is en-US.
'
' Updated 5/21/2012 PHofle 8.1.0.56
' * Added usage details for action ParseMultilineAddress help. 34252
'
' Updated 6/21/2012 CMcGhee 8.1.0.58
' * Corrected desc of SplitFieldValueLeft per 34261
'
' Updated 8/6/2012 PHofle 8.1.0.59
' * Updated help for 'DeleteSelectedChars' to only list the default character position for starting 
'   character substitution is the first character in the string.
'
' Updated 8/6/2012 PHofle 8.1.0.61
' * Updated <ret> help for actions SplitFieldValueLeft and SplitFieldValueRight that the
'   Actions will return false if the separator character is not found.
'
'************************************************************************
    
  ]]>
<ref id="IsFieldPercentAlpha">
  <ap>
    A number (0-100) indicating the percentage necessary to return a <b>True</b> condition.  The value must be numeric, without the percent sign.
  </ap>
  <lvl>Field level.</lvl>
  <ret><b>True</b> if the parameter's requirement is met. Otherwise <b>False</b>, including if the Field is empty.</ret>
  <h>Determines if the characters in the current Field object's captured value are <var>n%</var> alphabetic. 
    <e>
      <b>IsFieldPercentAlpha("50")</b>   #RPR-1421 returns <b>False</b><br/>
      <b>IsFieldPercentAlpha("30")</b>   #RPR1421 returns <b>True</b>
    </e>
</h>
<see><scr>IsFieldPercentNumeric</scr>,<scr>IsFieldMatching</scr></see>
</ref>
<ref id="IsFieldDate">
    <ap>None.</ap>
    <h>
      Checks that the value of the field has an acceptable Date format. Uses the current locale setting to determine
      valid patterns.<br/><br/>

      This action will accept any valid date from January 1st year 1 through December 31st 9999.
      <e>
        <b>IsFieldDate()</b><br/><br/>

        In locale en-US (United States):<br/>

        April 6, 1944   returns <b>True</b><br/>
        04/06/44   returns <b>True</b><br/>
        30.6.44   returns <b>False</b><br/>
        Feb 31,2003   returns <b>False</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>True</b> if the action's specifications are met. Otherwise, <b>False.</b>
    </ret>
  </ref>
  <ref id="IsFieldDateEqualOrAfter">
    <ap>
      The name of the Field object of the Document Hierarchy to be compared with the
      current field's Date value.
    </ap>
    <h>
      Checks that the Date value in the current field represented by the bound Field
      object of the Document Hierarchy is greater than or equal to the Date value in the
      field specified as the parameter.
      <e>
        <b>IsFieldDateEqualOrAfter("24aDtFr1")</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the date condition is not met, if the action is not applied at the Field level, or either field
      does not contain a valid date. Otherwise, <b>True.</b>
    </ret>
    <see>
      <scr>IsFieldDateEqualOrBefore</scr>
    </see>
  </ref>
  <ref id="IsFieldDateEqualOrBefore">
    <ap>
      The name of the Field object of the Document Hierarchy to be compared with
      the current field's Date value.
    </ap>
    <h>
      Checks that the date in the current field represented by the bound Field object of the
      Document Hierarchy is less than or equal to the Date value in the field specified as the parameter.
      <e>
        <b>IsFieldDateEqualOrBefore("24aDtFr1")</b>
      </e>
    </h>
    <lvl>Field Level.</lvl>
    <ret>
      <b>False</b> if the date condition is not met, if the action is not applied at the Field level, or if either field
      does not contain a valid date value.  Otherwise, <b>True.</b>
    </ret>
    <see>
      <scr>IsFieldDateEqualOrAfter</scr>
    </see>
  </ref>

  <ref id="CalculateDateDifference">
    <ap>
      <b>startDate</b> : The starting date.<br/>
      <b>endDate</b> : The ending date.<br/>
      <b>targetVariable</b> : The variable to hold the calculated result value.<br/>
      <b>dateProperty</b> : The value to calculate.  0 = days, 1 = months, 2 = quarters, 3 = years.<br/><br/>
      
      Smart parameters are supported.
    </ap>
    <h>
      Calculates the number of days, months, quarters or years between two dates.  
      Only whole numbers are returned.  Any fractional parts of the value are dropped.
      Quarters are calculated simply by dividing the number of months by 3.
      The order of the dates does not matter.<br/>
      <e>
        <b>CalculateDateDifference("4/20/2012", "5/19/2012", "@P.Months", 1)</b><br/>
        This example will create the page variable "Months" with a value of "0".<br/><br/>
        
        <b>CalculateDateDifference("4/20/2012", "5/20/2012", "@P.Months", 1)</b><br/>
        This example will create the page variable "Months" with a value of "1".<br/><br/>
        
        <b>CalculateDateDifference("4/20/2012", "4/19/2013", "@P.Years", 3)</b><br/>
        This example will create the page variable "Years" with a value of "0".<br/><br/>
        
        <b>CalculateDateDifference("4/20/2012", "4/20/2013", "@P.Years", 3)</b><br/>
        This example will create the page variable "Years" with a value of "1".<br/><br/>

        <b>CalculateDateDifference(@P\MyDate1, @P\MyDate2, "@P.Days", 0)</b><br/>
        This example will create the page variable "Days" with the number of days between the dates specified by the values in field MyDate1 and field MyDate2.<br/><br/>

        <b>CalculateDateDifference(@P.MyDate1, @P.MyDate2, "@P.Days", 0)</b><br/>
        This example will create the page variable "Days" with the number of days between the dates specified by page variables MyDate1 and MyDate2.
      </e>
    </h>
    <lvl>Any level.</lvl>
    <ret>
      <b>False,</b> If the format of either date is invalid.  Otherwise, <b>True.</b>
    </ret>
  </ref>
  
  <ref id="AssignFieldDefault">
    <ap>The String value you're assigning to the field.</ap>
    <h>
      Assigns a default value to the current field.
      <e>
        <b>AssignFieldDefault("Bill Paid")</b><br/>
        or<br/>
        <b>AssignFieldDefault("PastDue!")</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if not called on the correct level.  Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="IsFieldLengthMax">
    <ap>
      A number <var>n</var> designating the value's maximum length.
    </ap>
    <h>
      Checks that the character length of the current Field object's captured value is equal to
      or less than the value set as a parameter..
      <e>
        <b>IsFieldLengthMax("6")</b>
        <br/>
        <scr>
          EU2240 returns <b>True</b>
        </scr>
        <br/>
        <scr>
          EU002240 returns <b>False</b>
        </scr>
        <br/>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the parameter you enter is not numeric, or if the number of characters
      exceeds the parameter's value. Otherwise, <b>True.</b>
    </ret>
    <see>
      <scr>IsFieldLengthMin</scr>
    </see>
  </ref>

  <ref id="IsFieldLengthMin">
    <ap>
      A number <var>n</var> designating the value's minimum length.
    </ap>
    <h>
      Checks the character length of the current Field object's captured value to see if its
      length is equal to or longer than a number <var>n</var>
      <e>
        <b>IsFieldLengthMin("6")</b><br/>
        EU2240 returns <b>True</b>
        EU22 returns <b>False</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the parameter you enter is not numeric, or if the number of characters
      is less than the parameter's value. Otherwise, <b>True</b>.
    </ret>
    <see>
      <scr>IsFieldLengthMax</scr>
    </see>
  </ref>
  <ref id="InsertChars">
    <ap>
      <b>1.</b> The characters or character string to be inserted; defaults to a space.<br/>
      <b>2.</b> A number <var>n</var> indicating the target position within the captured value;
      defaults to the end of the value.<br/>
      <b>3.</b> The number of insertions; defaults to 1.<br/>
    </ap>
    <h>
      Inserts a character or string of characters into the captured value, one or more times.
      <e>
        <b>InsertChars("=$,1,1")</b><br/>
        345.67 becomes  =$345.67<br/><br/>

        <b>InsertChars("=$,1,2")</b><br/>
        345.67 becomes  =$=$345.67
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>
  <ref id="AddPaddingToRight">
    <ap>
      A number <var>n</var> indicating the maximum permissible length of the value. If the
      action finds that a value's length is less than this number, it will insert spaces until
      the maximum length is reached.
    </ap>
    <h>
      Pads the current Field object's captured value with spaces to the right.
      <e>
        <b>AddPaddingToRight("10")</b> uses spaces to expand a value with less than 10 characters.<br/><br/>

        For example:<br/>
        456.11 becomes 456.11_ _ _ _
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>AddPaddingToLeft</scr>
    </see>
  </ref>
  <ref id="AddPaddingToLeft">
    <ap>
      A number <var>n</var> indicating the maximum permissible length of the value. If the
      action finds that a value's length is less than this number, it will insert spaces
      until the maximum length is reached.
    </ap>
    <h>
      Pads the current Field object's captured value with spaces to the left of the first character.
      <e>
        <b>AddPaddingToLeft("12")</b> uses spaces to expand a value with less than 12 characters. <br/><br/>
        For example: RSJ-112 becomes _ _ _ _ _RSJ-112
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>AddPaddingToRight</scr>
    </see>
  </ref>
  <ref id="TrimSpaces">
    <ap>None.</ap>
    <h>
      Deletes extra spaces at the beginning and end of the current Field object's captured value.
      <e>
        <b>TrimSpaces()</b><br/><br/>

        456.11_ _ _ _ becomes 456.11
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>RightTruncate</scr>
    </see>
  </ref>
  <ref id="RightTruncate">
    <ap>
      A number <var>n</var> that is the value's maximum length.
    </ap>
    <h>
      This action deletes characters from the start of the current <b>Field</b>object's captured
      value until the value's length equals the length specified by the parameter.
      <e>
        <scr>RightTruncate("6")</scr> reduces the following value:<br/>
        3,344.01 becomes 344.01
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>LeftTruncate</scr>
    </see>
  </ref>
<ref id="LeftTruncate">
  <ap>
    A Number <var>n</var> that is the value's maximum length.
  </ap>
  <h>
    This action deletes characters from the end of the current <b>Field</b>object's captured value until the value's length equals the length indicated by the parameter.
    <e>
      <b>LeftTruncate("6")</b><br/><br/>
      EU0002240 becomes EU0002
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter is not Numeric. Otherwise, <b>True.</b>
  </ret>
  <see><scr>RightTruncate, IsFieldLengthMax</scr></see>
</ref>
<ref id="AddLeadingZeros">
  <ap>
    A number <var>n</var> which is the value's maximum length.
  </ap>
  <h>
    Adds zeros ("0") to the beginning of the current Field object's captured value until the value's total length reaches the maximum n you specify as the parameter.
    <e>
      <scr>AddLeadingZeros("10")</scr><br/><br/>

      2240.00 becomes       0002240.00
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not numeric; otherwise, <b>True.</b>
  </ret>
  <see><scr>AddTrailingZeros, IsFieldLengthMax, AddPaddingToLeft</scr></see>
</ref>
<ref id="AddTrailingZeros">
	<ap>A number <var>n</var> which is the value's maximum length.</ap>
  <h>
    Adds zeros ("0") to the end of the current Field's captured value until the value's length reaches the maximum <var>n</var> you enter as the parameter.
    <e>
      <scr>AddTrailingZeros("10")</scr><br/><br/>
      2240.00 becomes 2240.00000
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not numeric; otherwise, <b>True.</b>
  </ret>
  <see><scr>AddLeadingZeros</scr></see>	
</ref>
<ref id="DeleteSelectedChars">
	<ap>
    <b>1.</b> The character or string of characters to be deleted.<br/>
		<b>2.</b> A number indicating the starting index within the string to start deletion.  If this parameter
    is blank or is not a number, the starting index value will default to the first position in the string.<br/>
		<b>3.</b> The number of times the character or character string is to be deleted from the 
    value. The default is "1" and  "*" deletes all instances.
  </ap>
  <h>Deletes specific characters from the current Field object's captured value.
    <e>
      <b>DeleteSelectedChars("-, ,*")</b><br/>
      223-56-7669 becomes 223567669<br/><br/>
      
      <b>DeleteSelectedChars("-,5,*")</b><br/>
      223-86-7669 becomes 223-867669
    </e>	
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteAllAlpha, DeleteAllMiscChars, DeleteAllNumeric, DeleteAllPunct</scr></see>	
</ref>
<ref id="DeleteAllAlpha">
  <ap>None.</ap>
  <h>Deletes all alphabetic characters from the current Field object's captured value. 
    <e>
      <b>DeleteAllAlpha()</b><br/><br/>
      JAN2003 becomes 2003
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteSelectedChars, DeleteAllMiscChars, DeleteAllNumeric, DeleteAllPunct</scr></see>
</ref>  
<ref id="DeleteAllNumeric">
  <ap>None.</ap>
  <h>Removes all Numeric characters from the current Field object's captured value. 
    <e>
      <b>DeleteAllNumeric()</b><br/><br/> 

      JAN2003 becomes JAN
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteAllAlpha, DeleteSelectedChars, DeleteAllMiscChars, DeleteAllPunct</scr></see>
</ref>  
<ref id="DeleteAllPunct">
  <ap>None.</ap>  
  <h>
    Removes all characters with ASCII values 33-47,58-64,91-96, and 123-191 from the 
    current Field object's captured value. 
    <e><b>DatePUNCT()</b> 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteAllAlpha, DeleteSelectedChars, DeleteAllMiscChars, DeleteAllNumeric</scr></see>
</ref>  
<ref id="DeleteAllMiscChars">
  <ap>None.</ap>
  <h>Removes all UNICODE Symbol Category characters from the current Field object's captured value.
    <e>
      <b>DeleteAllMiscChars()</b><br/><br/>
      '100¢ = $1' becomes '100  1'
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteAllAlpha, DeleteSelectedChars, 	DeleteAllMiscChars, DeleteAllNumeric</scr></see>
</ref>  
<ref id="DeleteAllSysChars">	
  <ap>None.</ap>
  <h>
    The action removes all characters with ASCII values 0 through 31 from the current 
    <b>Field </b>object's captured value.
    <e>
      <b>DeleteAllSysChars()</b><br/><br/>
      A field containing <i>Hello Dolly</i> will become <i>HelloDolly.</i> 
    </e>	
  </h>
  <lvl>Field only.</lvl>
  <ret>True.</ret>
</ref>
<ref id="FilterFieldSelectedChars">
  <ap>
    A String containing the character(s) to be removed.<br/><br/>

    Every instance of the character(s) will be removed from the captured 	value.
  </ap>
  <h>
    Removes all instances of the character(s) you enter as the parameter from the current
    Field object's captured value.
    <e>
      <b>FilterFieldSelectedChars(0)</b><br/><br/>
      11002900 becomes 1129
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
  <see><scr>DeleteSelectedChars</scr></see>
</ref>  
<ref id="ReplaceChars">
  <ap>
    <b>1.</b> The character or string of characters to be replaced; defaults to a space. SmartParameter Enabled.<br/><br/>

    <b>2.</b> The character(s) of the replacement String. SmartParameter Enabled.<br/><br/>

    <b>3.</b> The number of times replacement is to occur. The default is "1"	and  "*" replaces all instances.
  </ap>
  <h>
    Replaces a character or string of characters in the current Field object's captured value with a String you enter as one of the parameters.
    <e>
      <b>ReplaceChars(".,/,*")</b><br/><br/>

      01.02.2005 becomes 01/02/2005
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="AllowOnlyChars">
  <ap>A Regular Expression that specifies permitted characters in the current word.</ap>
  <h>This action employs a Regular Expression as its parameter to identify 
    <b><i>and</i></b>remove all characters NOT in the parameter from the Field's value.<br/><br/>
    Note: An empty argument will remove ALL characters.
    <e>
      AllowOnlyChars("ABCDEFG.")<br/><br/>
      HELLO DOLLY. becomes ED.</e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
<ref id="DateStampField">
  <ap>A Date format such as mm/dd/yy or dd/mm/yy.  (* defaults to 	mm/dd/yyyy)</ap>
  <h>Updates the current Field object with today's date. 
    <e>
      <b>DateStampField("*")</b> produces<br/>      
      01/20/2005<br/><br/>
      
      <b>DateStampField("dd/mm/yy")</b> produces<br/>
      20/01/05 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
<ref id="TimeStampField">
  <ap>
    A time format (for example, HH:MM:SS, or HH:MM.)<br/><br/>

    * defaults to HH:MM:SS
  </ap>
  <h>Updates the current Field object with the current time.
    <e>
      <b>TimeStampField("*")</b> produces<br/>
      09:20:02<br/><br/>

     <b>TimeStampField("HH:MM")</b> produces<br/>
     09:20 
	</e>
</h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
  <see><scr>DateStampField</scr></see>
</ref>
<ref id="SetIsOverrideable">
  <ap>None.</ap>
  <h>
    Specifies that if the validation fails for the current object, If it is non-overrideable 
    or overrideable by the user.<br/><br/>

    <b>Important!</b> This status may prevent an operator from overriding a field's validations 
    and then continuing to subsequent pages. 
    <e>
      <b>SetIsOverrideable("False")</b><br/>
      IsFieldPercentNumeric("100")<br/><br/>

      In this sequence, if the field's captured value is not 100% Numeric, an operator 
      cannot override a Validation rule's subsequent rejection of the value. 
   </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
<ref id="IsFieldDateUpToToday">
  <ap>None.</ap>
  <h>Checks that the current Field object's Date value is today's date or	earlier. 
    <e>
      <scr>IsFieldDate()</scr><br/>
      <b>IsFieldDateUpToToday()</b><br/><br/>

      This sequence confirms that a value is a date and that it is the same as, or earlier than, today's date. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the field's value is not a valid date or if the date is after "Today". Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldDate, DateStampField</scr></see>
</ref>
<ref id="IsFieldDateWithinXDays">
  <ap>A number <var>n</var> that specifies how many days make up the review period.</ap>
  <h>Checks that current Field object's captured Date value is within <var>n</var> days of 
  the number entered as a parameter.
    <e>
      <scr>IsFieldDate()</scr><br/>
      <b>IsFieldDateWithinXDays("30")</b><br/><br/>
      This sequence checks that a value is a date within 30 days of today's date. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b>if the field's value is not a valid date or if the date is
    older than the number of days in the parameter; otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldDate, IsFieldDateUpToToday</scr></see>
</ref>
<ref id="IsFieldDateWithinRange">
  <ap>
    Comma-separated Dates that define the range:<br/>
    <b>1.</b> Start Date<br/>
    <b>2.</b> End Date<br/><br/>

    TODAY can represent the current Date.</ap>
  <h>Checks that the value assigned to the Text property of the bound object 	is a valid Date. If so, the action confirms that the Date is within the 	range specified by the parameters. 
	  <e>
      <b>IsFieldDateWithinRange("1/1/2006, 1/31/2006")</b><br/>
	    <b>IsFieldDateWithinRange("1/1/2006,TODAY")</b>
	  </e>
  </h>
  <lvl>All, but generally at the Field Level.</lvl>
  <ret>
    <b>False</b> if the value assigned to the current object's Text property is not a valid date;
    if either parameters is invalid; or the Text property's Date value is not within the range
    specified by the parameters.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="MessageBox">
  <ap>The message you want to display to the Data Entry operator.</ap>
  <h>
     * This Action has been Deprecated and this functionality is no longer supported. *
    
    Causes a Message Box with two buttons, labeled "Yes" and "No," to appear on the operator's 
    screen during the Verification task, and displays a message you enter as the parameter.<br/><br/>  

    <b>Alert!</b> This action should only be placed in a rule that is run interactively. 
    If a background station runs this rule, it will stop processing until a user responds to the message box.<br/><br/>

    If the Data Entry operator clicks on the Yes button in the Message Box, 	
    the action returns <b>True</b> and the rule continues.  If the 	
    operator chooses the No button, the action returns False and the rule fails. 
    <e>
      IsFieldEmpty("Date")<br/> 
      <b>MessageBox("Date missing! Do you want to Continue?")</b><br/><br/> 

      After checking to be sure the Date field does not have a value, the 		
      MessageBox action issues a warning, and asks the operator to respond 		
      by clicking on the Yes or No button. 
    </e>
</h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the current task is not interactive - or if the operator clicks on the
    Message Box's No button. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="IsFieldDateWithReformat">
  <ap>
    The Date format you want to use.<br/><br/>

    mm/dd/yyyy<br/>
    mm/dd/yy<br/>
    dd/mm/yy<br/>
    mm.dd.yy, etc.
    
    Defaults to system short date format if no format or single '*' is used.
    
  </ap>
  <h>
    Confirms that a field's data is a valid date and then formats its Date 
    value according to the format entered as the parameter. 
    <e>
      <b>IsFieldDateWithReformat("*")</b><br/>
      June 3, 2002 becomes 06/03/2002<br/><br/>

      <b>IsFieldDateWithReformat("mm.dd.yy")</b><br/>
      June 3, 2002 becomes 06.03.02 
    </e>	
</h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter is invalid, or the current field value is not a valid date given the specified format.  Otherwise <b>True.</b>
  </ret>
</ref>
<ref id="IsFieldCurrency">
  <ap>None.</ap>
  <h>
    Determines if the Field's captured value meets the current locale's currency format,
    including the number of decimal places, decimal and digit separator characters and 
    any present currency indicators.
	  <e>
      <b>IsFieldCurrency()</b><br/><br/>
	    $1,200 returns <b>False</b><br/> 
	    $1,200.00 returns <b>True</b>
	  </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the current locale's format criteria are met. Otherwise, <b>False.</b>
  </ret>
</ref>
<ref id="FailRuleSet">
  <ap>None.</ap>
  <h>Causes the entire RuleSet to fail. 
  <e>
    IsFieldMatching("False")<br/>
    <b>FailRuleSet()</b> 
  </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>
<ref id="IsFieldMatching">
	<ap>The value to be checked against the Field object's value.</ap>
	<h>Determines if the value entered as the parameter is identical to the captured value of the current Field object. 
		<e>If the Field object's value is 525.00<br/><br/>
      <b>IsFieldMatching("525.00")</b> returns <b>True</b>
      <b>IsFieldMatching("525")</b> returns <b>False</b> 
		</e>
	</h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the action's requirement is met. Otherwise, <b>False.</b>
  </ret>
  <see><scr>IsFieldPercentAlpha, IsFieldPercentNumeric</scr></see>
	</ref>
<ref id="CopyFieldToField">
  <ap>The name of the target Field object of the Document Hierarchy.</ap>
  <h>
    Copies the captured value of the current Field object to the Field object designated as the action's parameter. 
    <e>
      If the current field's value is "1/1/05"<br/><br/>

      <b>CopyFieldToField("Date")</b><br/><br/>

      assigns "1/1/05" (without the quotation marks) to the Document Hierarchy's Date field. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter does not match a Field object's name. Otherwise, <b>True.</b>
  </ret>
  <see><scr>CopyField</scr></see>
</ref>
<ref id="AppendToField">
  <ap>The name of the Field object to which the value is to be 	appended.</ap>
  <h>
    Appends the captured value of the current Field object to the captured value of the 
    Field object specified by the parameter.
    <e>
      <b>AppendToField("FirstName")</b><br/><br/>

      If the current Field object is MiddleInitial, a rule with this action would 
      append the value of the Middle Initial field to the FirstName Field object. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter is not a Field object's name. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="AppendFromField">
  <ap>The name of the Field object whose text value is to be appended to the 	current field's value.</ap>
  <h>
    Appends the captured value of the specified Field object to the
    captured value of the current Field object.  You can also apply this 	
    action at the Page level.  A Text page-level variable with the appended 	
    value will be added to the page's Data file. 
    <e>
      <b>AppendFromField("Number")</b> 
    </e>
  </h>
  <lvl>Page or Field Level.</lvl>
  <ret>
    <b>False</b> if the parameter is not a Field object's name. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="ReadFieldValue">
  <ap>The name of the source Field object.</ap>
  <h>
    Retrieves the captured value from a sibling Field object specified as 	
    the parameter, and assigns the value to the current Field object.  
    If the action is not bound at the Field level, then a variable called Text will be 
    created in the current object, and the found value will be written to this variable.
    <e>
      <b>ReadFieldValue("Date")</b><br/><br/>

      This action assigns the captured value in the Date field to the working fingerprint's current field. 
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter does not match a Field object's name. Otherwise, <b>True.</b>
  </ret>
  <see><scr>CopyField</scr></see>
</ref>
<ref id="CopyField">
  <ap>The name of the target Field object.</ap>
  <h>Assigns the current Field object's captured value to a sibling Field object you specify as the parameter.
    <e>
      <b>CopyField("Date")</b><br/><br/>

      This action places the captured value of the current field into the Date field. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter does not match a Field object's name. Otherwise, <b>True.</b>
  </ret>
  <see><scr>GetFieldValue</scr></see>
</ref>
<ref id="EmptyFieldValue">
  <ap>The name of the Field object that is to be emptied.</ap>
  <h>
    Clears the text value in the field represented by the Field object of the 
    Document Hierarchy specified by the parameter.
  </h>
  <lvl>Page or Field level.</lvl>
  <ret>
    <b>False</b> if the field specified by the parameter does not exist.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="IsFieldGreaterOrEqual">
  <ap>The Numeric or Currency value which is the basis for comparison.</ap>
  <h>Determines if the captured value of the current Field object is greater than (or equal to) the value entered as a parameter. If the field's value is not Numeric or currency, the action will return a <b>False</b> condition.
    <e>
      <b>IsFieldGreaterOrEqual("624")</b><br/>
      Returns <b>True</b> if the Field object's value is 625.00<br/>
      Returns <b>False</b> if the value is 623.99.<br/>
      Returns <b>True</b> if the value is 624.00. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter or Field object's captured value is not Numeric - or if the
    result does not meet the action's requirements. Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldLessOrEqual</scr></see>
</ref>
<ref id="IsFieldLessOrEqual">
  <ap>The Numeric or Currency value you want to compare against.</ap>
  <h>
    Determines if the captured value of the current Field object is less than (or equal to) 
    the value entered as a parameter.  If the field's value is not Numeric or Currency, the 
    action will return a <b>False</b> condition.
    <e>
      <b>IsFieldLessOrEqual("625")</b><br/>
      Returns <b>True</b> if the Field object's value is 624.99<br/>
      Returns <b>False</b> if the value is 625.01<br/>
      Returns <b>True</b> if the value is 625.00 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter or Field object's captured value is not Numeric - 
    or if the result does not meet the action's requirements. Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldGreaterOrEqual</scr></see>
</ref>
<ref id="InsertDecimalPoint">
  <ap>A number <var>n</var> indicating the character position at which to place the decimal.</ap>
  <h>
    Places a decimal character in the captured value, at the character position specified as a parameter.
    The parameter indicates the position of the decimal point, moving from right to left.
    <e>
      <b>InsertDecimalPoint("2")</b><br/>
      324556 becomes 3245.56<br/><br/> 
      
      <b>InsertDecimalPoint("2")</b><br/>
      355 becomes 3.55
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  <ref id="Calculate">
    <h>
      This Action has been marked for Deprecation and will removed in a future release. It has been replaced with Action <b>CalculateFields</b>.
    </h>
  </ref>
  <ref id="CalculateFields">
  <ap>
    <b>1.</b>The equation that is the basis for the calculation.<br/>
	  You can use a Field object's name or numeric values with any arithmetic operator (+,-,*,/,^). 
    To use a Field object's name, surround the field name with single quotation marks (').  
    A null is treated as a "0".<br/>
    <b>2.</b>The number of decimal places to limit the logical comparison.(Optional)<br/>
    <b>3.</b>A True/<b>False</b>(Default) operator to toggle Failure of all associated fields if the calculation fails. (Optional)<br/>
</ap>
  <h>
    Calculates the equation entered as a parameter and compares the result to the current Field object's captured value.<br/><br/>

    <b>Note:</b> If the result does not match the equation's result, all fields involved in the 
    equation will receive a Failed status and  will appear pink in the applicable field of the Data Entry panel. 
	  <e>
      <b>CalculateFields("'SubTotal' + 'Shipping' + 'Tax' = 'Total'")</b><br/>
      or<br/>
      <b>CalculateFields("('SubTotal' + 'Shipping' + 'Tax') - '0.05' = 'Total'")</b><br/><br/>
      
      for use with a 'tolerance' use two actions in sequence:<br/>
      <b>CalculateFields("('Wages' + 'Interest' + 'Unemployment')&gt;=('Gross'-'.05')")</b><br/>
      <b>CalculateFields("('Wages' + 'Interest' + 'Unemployment')&lt;=('Gross'+'.05')")</b><br/>
    </e>    
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the expression is valid. <b>False</b> if a field's value is not numeric or if the expression is not valid.
  </ret>
</ref>
<ref id="IsFieldEmpty">
  <ap>The Field object's name.</ap>
  <h>Checks if the Field object designated as a parameter does not  have a captured value.
  <e>
    <b>IsFieldEmpty("Shipping")</b><br/>
    <scr>AssignFieldDefault("NoShipping")</scr><br/><br/>
	
    In this example, if the Shipping Field object's captured value is $921.11, this action will 
    return a <b>False</b> condition and therefore terminate the rule.<br/><br/>
	
    If the Shipping Field object does not have a value (<b>True</b>), the AssignFieldDefault action 
    enters its parameter ("NoShipping") as the Field object's captured value.  
  </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the Field object's name does not exist - or if the field contains a captured value. Otherwise, <b>True.</b>
  </ret>
  <see><scr>AssignFieldDefault, IsFieldFilled</scr></see>
</ref>
<ref id="IsFieldFilled">
  <ap>The name of the Field object.</ap>
  <h>Determines whether the Field object designated as a parameter contains a captured value or is empty. 
	  <e>
      <b>IsFieldFilled("PaymentDue")</b><br/><br/>

	    If the action returns <b>True</b> - if the field does contain a value - the rule invokes its next action. If the action returns <b>False</b>, the rule closes and the task applies the next 			rule, which might include a <scr>CopyFieldToField</scr> action. 
	  </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the Field object's name does not exist - or if the field does not contain a captured value. Otherwise, <b>True.</b>
  </ret>
  <see><scr>AssignFieldDefault, IsFieldEmpty</scr></see>
</ref>
<ref id="CheckSubFields">
	<ap>
    An "expression" that specifies which child fields are to be checked for the presence or absence 
    of captured values. Within the expression, each child Field object's name needs to be surrounded 
    with single quotation marks ('). You can also use parentheses () in your expression.
  </ap>
	<h>Validates an instance of a parent Field object by confirming the presence (or absence) of 
     captured values for one or more of its child fields. (In the Invoices application, as an example, 
     child fields of the LINEITEM parent include: ItemID, ItemDesc, Quantity, Price and LineTotal.)
     <br/><br/>
	   Invalid parent Field objects are deleted if they do not meet this criteria.<br/><br/>
	   This action usually runs in its own RuleSet (for example, in a Filter RuleSet) and would be applied 
     to the DETAILS Field object in the Invoices example.
		<e><b>Example 1:</b> The captured values for a LINEITEM field are:<br/> 
       ItemID = 12345<br/>
       ItemDesc =<br/>
       Price = 12.00<br/>
       LineTotal = <br/><br/>

       The action's parameter contains this expression:<br/> 
       <b>CheckSubFields("('ItemID' OR 'ItemDesc') AND ('Price' OR 'LineTotal')")</b><br/><br/>

       In this example the action returns <b>True</b> and the current 	LINEITEM object is Valid.<br/><br/>

       <b>Example 2:</b> The captured values for the LINEITEM field are:<br/> 
       ItemID = 12345<br/>
       ItemDesc = Thank you for your order<br/>
       Price =<br/>
       LineTotal = <br/><br/>

       The action's parameter contains this expression:<br/>
       <b>CheckSubFields("('ItemID' OR 'ItemDesc') AND ('Price' OR 'LineTotal')")</b><br/><br/>

       In this example the action's equation returns is <b>False</b> and the current LINEITEM 
       object is Invalid. The field and the values of its child fields are deleted from the Data file.<br/><br/>

       <b>Example 3:</b>  The captured values for the LINEITEM field are:<br/>
       ItemID = 12345<br/>
       LineTotal = gonetolunch<br/><br/>

       The action's parameter contains this expression:<br/>
       <b>CheckSubFields("('ItemID') AND ('LineTotal')")</b><br/><br/>

       In this case, the action returns <b>True</b> and validates the LINEITEM field - despite the 
       presence of a nonsense entry in the LineTotal child field! 
		</e>
	</h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
<ref id="SumFields">
  <ap>String value of a Field object's Type property or the name of a variable.</ap>
  <h>Sums captured values of any "child" Field if a child object's Type property is identical to the Type you specify as a parameter.<br/><br/>

	Alternatively, the actions sums values assigned to a variable of the child Field objects - a variable which is the same as the variable entered as a	parameter.<br/><br/>

	<b>Remember:</b> This action must be applied to the parent object. 
		<e>
      <b>SumFields("Detail")</b><br/><br/>

		  <b>SumFields("LineTotal")</b><br/><br/>

		The first action above sums the captured values of Detail Field objects which are children of the current Field object.<br/><br/>

		The second action sums values assigned to the LineTotal variable of child Field objects.<br/><br/>

		The result, in both cases, is a Long number. 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
<ref id="ResetField">
  <ap>None.</ap>
  <h>
    This action deletes the selected Field object's captured value, and sets the field's <b>Position</b>
    attribute to 0,0,0,0.<br/><br/>
    
    Note, however, that the action does not clear any Alt-Text values 
    associated with the bound <b>Field</b>object. (Typically, that is the responsibility of a 
    <b>ClearAltText</b>action.)
    <e>
      <b>ResetField()</b><br/><br/>

      This action typically belongs to a follow-up Validate rule that deals with a <b>False</b> response to 
      an action such as IsDate() in the previous rule. If the field's value is not a date (in this example), 
      the <b>ResetField</b> action will remove the value that is there. <b>Note:</b>It will also set the 
      field's <b>Position</b> attribute to 0,0,0,0.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if not called on the field level.  Otherwise, <b>True.</b>
  </ret>
  </ref>
<ref id="SaveAsCurrentObjVariable">
  <ap>
    <b>1.</b> The name of the variable<br/>
    <b>2.</b> The String value to be assigned.<br/><br/>

    These are comma-separated parameters, and the second is optional. If you do not include this parameter,
    the action will automatically assign the captured value of the selected Field object to the variable.
  </ap>
  <h>
    This action has been replaced by rrSet.  Use the @F smart variable to access the current field value.
  </h>
  <lvl>All.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
<ref id="ReadCurrentObjVariable">
  <ap>The name of the bound object's property or variable.</ap>
  <h>
    Reads the Text value of the bound object of the Document Hierarchy.<br/><br/>

    For a Field object, this is the value of the object's Text property. For objects at other levels, the value is in a runtime variable of the bound object (see the examples).
    <e>
      <b>ReadCurrentObjVariable("Text")</b>
      <br/>
      <br/>

      <b>ReadCurrentObjVariable("TemplateID")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the property or variable specified by the parameter is not found.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="SaveAsPageVariable">
  <ap>
    <b>1.</b> The name of the variable<br/>
    <b>2.</b>The String value to be assigned.<br/><br/>

    These are comma-separated parameters, and the second is optional. If you do not include this parameter, 
    the action will automatically assign the Text property of the calling object to the variable.
  </ap>
  <h>Assigns a value to a variable of the current Page object. 
    <e>
      <b>SaveAsPageVariable("Amount")</b><br/><br/>

      <b>SaveAsPageVariable("Amount,15000")</b><br/><br/>

      The first example assigns the captured value of the current Field object to the current Page's Amount 
      variable. The second example assigns "15000" to the variable. 
    </e>
  </h>
  <lvl>Page or Field Level.</lvl>
  <ret>
    <b>False</b> if the parent page cannot be found.  Otherwise, <b>True.</b>
  </ret>
  <see><scr>ReadPageVariableValue</scr></see>
</ref>
<ref id="ReadPageVariableValue">
  <ap>The name of the Page object's variable.</ap>
  <h>
    Assigns the value of a variable of the Page object to the selected Field object. If the action is not placed at the field level, then a variable called Text will be created in the current object, and the found value will be written to this variable.
    <e>
      <b>ReadPageVariableValue("FieldCount")</b><br/><br/>

      A Validate rule with this action could transfer the number of fields in the Page object 
      that is the "parent" of a selected Field object such as TotalFields.<br/><br/>

      <b>Important!</b> A Document Hierarchy may well include multiple Page objects and certain 
      variables that are the same for both pages. This action refers to variables of the Page 
      object to which the selected Field object belongs. 
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is not a valid Page-level variable; otherwise, <b>True.</b>
  </ret>
  <see><scr>ReadBatchVariableValue, ReadDocumentVariableValue</scr></see>
</ref>
<ref id="ConvertToUpperCase">
  <ap>None.</ap>
  <h>Converts the lower case characters in a Field object's captured value to Upper Case characters. 
  <e>
    <b>ConvertToUpperCase()</b><br/><br/>

    A Validate rule with this action, if applied to a State Field object which accepts only abbreviations, 
    would be sure the captured values contain Upper Case letters (AZ, AL, etc.) 
  </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
  <see><scr>ConvertToLowerCase</scr></see>
</ref>
<ref id="ConvertToLowerCase">
  <ap>None.</ap>
  <h>Converts any Upper Case characters in a Field object's captured value to lower case characters. 
    <e>
      <b>ConvertToLowerCase()</b><br/><br/>

      To ensure that the characters in all Product ID's are lower case, a Validate rule that applies to a Document Hierarchy's Item Field object would include this action. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
  <see><scr>ConvertToUpperCase</scr></see>
</ref>
<ref id="SplitFieldValueRight">
  <ap>String value of the separating character. SmartParameter Enabled.</ap>
  <h>Splits a Field object's captured value at the first instance of the character specified as a parameter.<br/><br/>

    The action deletes all characters to the left of the separating character, as well as the separation character.  All text to the right of the separating character remains. 
    <e>
      <b>SplitFieldValueRight("=")</b><br/><br/>

      If the object's value is "InvNumber=A1234," this action truncates it to "A1234".  
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret><b>True</b> if the separator character is found. Otherwise <b>False.</b>
</ret>
  <see><scr>SplitFieldValueLeft</scr></see>
</ref>
<ref id="SplitFieldValueLeft">
  <ap>String value of the separating character. SmartParameter Enabled.</ap>
  <h>Splits a Field object's captured value at the first instance of the character specified as a parameter.<br/><br/>

    The action deletes all characters to the right of the separating character, as well as the separation character.
    All text to the left of the separating character remains.
    <e>
      <b>SplitFieldValueLeft("c")</b><br/><br/>

      If the object's value is "Description," this action truncates it to "Des". 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the separator character is found. Otherwise <b>False.</b>
  </ret>
  <see><scr>SplitFieldValueRight</scr></see>
</ref>
<ref id="IsFieldPercentNonNumeric">
  <ap>
    A number (0-100) indicating the percentage that results in a <b>True</b> condition. The default percentage is 100.
    The value must be numeric, without the percent sign.
  </ap>
  <h>Determines if any of the characters in the captured value of the current Field object are <var>n%</var> not numeric
  characters, this includes and is not limited to valid decimal and numeric separator characters.   
    <e>Given the current value is "1,234.56US"<br/><br/>
    (Percentage of non-numeric characters is 40%)
    <b>IsFieldPercentNonNumeric("0")</b> returns <b>True</b><br/><br/>
    <b>IsFieldPercentNonNumeric("30")</b> returns <b>True</b><br/><br/>
    <b>IsFieldPercentNonNumeric("40")</b> returns <b>True</b><br/><br/>
    <b>IsFieldPercentNonNumeric("70")</b> returns <b>False</b><br/><br/>  
    <b>IsFieldPercentNonNumeric("100")</b> returns <b>False</b> 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter is non-numeric, if the field is empty, or if the field's 
    value exceeds the parameter's percentage of numeric characters. Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldPercentAlpha, IsFieldMatching</scr></see>
</ref>
  <ref id="IsFieldPercentNumeric">
    <ap>
      A number (0-100) indicating the percentage that results in a <b>True</b> condition. The default percentage is 100.
      The value must be numeric, without the percent sign.
    </ap>
    <h>
      Determines if the characters in the captured value of the current Field object are <var>n%</var> numeric
      characters. Does not include, and is not limited to, valid decimal and numeric separator characters.
      <e>
        Given the current value is "1,234.56US"<br/><br/>
        (Percentage of numeric characters is 60%)
        <b>IsFieldPercentNumeric("0")</b> returns <b>True</b><br/><br/>
        <b>IsFieldPercentNumeric("50")</b> returns <b>True</b><br/><br/>
        <b>IsFieldPercentNumeric("60")</b> returns <b>True</b><br/><br/>
        <b>IsFieldPercentNumeric("70")</b> returns <b>False</b><br/><br/>
        <b>IsFieldPercentNumeric("100")</b> returns <b>False</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the parameter is non-numeric, if the field is empty, or if the field's
      value exceeds the parameter's percentage of numeric characters. Otherwise, <b>True.</b>
    </ret>
    <see>
      <scr>IsFieldPercentAlpha, IsFieldMatching</scr>
    </see>
  </ref>
<ref id="IsMaxOMRChecked">
  <ap>An Integer value specifying this maximum.</ap>
  <h>Indicates the maximum number of checkboxes that can contain a value (a check, for example). 
    <e>
      <b>IsMaxOMRChecked("1")</b> 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not numeric, or the field is not an OMR field.<br/><br/>

    <b>True</b> if the number of OMR boxes checked is less than or equal to the parameter you entered.
  </ret>
  <see><scr>IsMinOMRChecked</scr></see>
</ref>
<ref id="IsMinOMRChecked">
  <ap>An Integer value specifying this minimum.</ap>
  <h>Indicates the minimum number of checkboxes that can contain a value (a check, for example).
    <e>
      <b>IsMinOMRChecked("1")</b> 
    </e>	
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not numeric, or the field is not an OMR field.<br/><br/>
    <b>True</b> if the number of OMR boxes checked is greater than or equal to the parameter you entered.
  </ret>
  <see><scr>IsMaxOMRChecked</scr></see>
</ref>
<ref id="CompareFields">
  <ap>Five comma-separated values:<br/><br/> 

  <b>1.</b>String value of the source field's name.  This is the field with a value to be compared.<br/><br/>

  <b>2.</b>String value of the target field's name.  This is the field with a value to be compared to.<br/><br/>

  <b>3.</b>String value: Y or Yes; N or No. Alternatively, a Numeric value: 0 = No or 1=Yes.  
  "Yes" (or Y or 1) allows the action to carry out a fuzzy rather precise comparison of the fields' values.<br/><br/>

  <b>4.</b>Numeric value of the percentage of required precision. Numbers less than 
  "100" permit increasing fuzziness.<br/><br/>

  <b>5.</b>String value: Y or Yes; N or No. Alternatively, a Numeric value: 0 = No or 1=Yes.  "Yes" (or Y or 1) directs the action to compare values in 	the fields word-by-word. 
  </ap>
  <h>Locates values in two fields specified by the first two parameters.<br/><br/>

  If values are present in both fields, the action compares the values according to the matching criteria of the last three parameters. 
  <e>
    <b>CompareFields("Invoice_Date,Due_Date,Yes,100,Yes")</b> 
  </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the designations of  Field objects in the first two parameters are not valid, or if
    the Data Types of the values in the first two fields do not match.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="IsThisFieldEmpty">
  <ap>None.</ap>
  <h>Confirms if the current field has no captured value. 
    <e>
      <b>IsThisFieldEmpty()</b> 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if not applied to the Field level, or if the current field has a text value.  Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsThisFieldFilled, IsFieldEmpty</scr></see>
</ref>	
<ref id="IsThisFieldFilled">
  <ap>None.</ap>
  <h>
    Confirms if the current field has a captured value.
    <e>
      <b>IsThisFieldFilled()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if not applied to the Field level, or if the current field has no text value. Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsThisFieldEmpty, IsFieldFilled</scr></see>
</ref>
<ref id="DeleteLCSpaces">
  <ap>None.</ap>
  <h>Deletes all low confidence spaces from the captured value. Uses ReqConf Setup dco variable as threshold for low confidence values; defaults to 9
  <e>
    <b>DeleteLCSpaces()</b> 
  </e>
  </h>
  <lvl>All, but generally at the Field level.</lvl>
  <ret>
    <b>False</b> if the action is unable to isolate the spaces in a field's value. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="IsMatchingJobID">
  <ap>String value of the Job ID to be compared to the current Job ID.</ap>
  <h>Checks that the Job ID of the current User Application job matches the parameter's Job ID value. 
    <e><b>IsMatchingJobID("Main")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if the current Job ID matches the parameter's value. Otherwise, <b>False.</b>
  </ret>
</ref>
<ref id="GetJobID">
  <ap>None.</ap>
  <h>Assigns the Job ID of the current User Application job - the job's 	Pilot.JobID property - to the CurrentObj.Text variable of the bound object 	of the Document Hierarchy. 
    <e><b>GetJobID()</b> 
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the action cannot find a JobID value. Otherwise, <b>True.</b>
  </ret>
</ref>	
<ref id="FieldContainsValue">
  <ap>Text that the action is looking for in the current field.</ap>
  <h>
    This action determines if a field represented by the bound object of the 
    Document Hierarchy contains some or all of the parameter's text value, without additional unspecified text. 
    <e>
      <b>FieldContainsValue("NEW")</b><br/><br/>
      Parameter: "NEW" = TRUE<br/>
      Parameter: "NEW Action" = TRUE<br/>
      Parameter: "Project" = FALSE<br/>
      Parameter: "NEW Project" = TRUE<br/>
      Parameter: "Development" = FALSE 
    </e>
  </h>
  <lvl>All, but generally at the Field level.</lvl>
  <ret>
    <b>False</b> if the object's <b>CurrentObj.Text</b>variable does not contain the parameter's value. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="DeleteChildType">
  <ap>
    String value of the child object Type. <br/><br/>
    "Field", for example, will eliminate all <b>Field</b> objects. In the <i>Invoices</i> 
    application, however, "LineItem" will remove child fields of the parent <i>Details</i> 
    parent <b>Field</b> object. 
  </ap>
  <h>
    Deletes child objects of the type you designate as a parameter from the Document Hierarchy.
    <e>
      <b>DeleteChildType("Field")</b>
    </e>	
  </h>
  <lvl>All except Batch.</lvl>
  <ret>
    <b>False</b> if the child objects do not exist. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="ParseName">	
  <ap>Three comma separated parameters:<br/>
    <b>1.</b> The name of the Last Name Field object.<br/>
    <b>2.</b> The name of the First Name Field object.<br/>
    <b>3.</b> The name of the Middle Name or Middle Initial Field object.
  </ap>
  <h>
    Parses a name Field object's captured value.<br/><br/>

    Applied to a "Name" field, the action will parse the Last, First, and Middle names into the fields specified by the parameter. 
    <e><b>ParseName("LastName,FirstName,MidName")</b><br/><br/>

    Bound to a Name Field object which includes values for all three names, the action will place the Last name into the "LastName" 	field, the First name into the "FirstName" field, and the Middle name (or middle initial) into the "MidName" field. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if not placed at the Field level; if the current field contains no data; 
    or if the parameters are invalid.  Otherwise, <b>True.</b>
  </ret>
  <see><scr>ParseMultilineAddress</scr></see>
</ref>

<ref id="ParseMultilineAddress">
  <ap>
    Comma-separated Smart Parameter String values of the names of fields which will hold the
    parsed data, in the following order:<br/><br/>

    Name, AddressLine1, AddressLine2, City , State , Zip , Phone
  </ap>
  <h>
    Parses a multiline U.S. address Field object's captured value.<br/><br/>
    
    Comma-separated String values of the names of fields which will hold the parsed data,
    in the following order: Name, AddressLine1, AddressLine2, City, State, Zip, Phone.
    Example below assumes fields are sibling fields of the calling object. For other relationships
    please review smart parameter syntax.<br/><br/>

    <b>Expected Pattern:</b><br/><br/>   
    Phone Number (optional)<br/>
    Name<br/>
    Address Line One<br/>
    Address Line Two (optional)<br/>
    City, State, Zip code <br/>
    Phone Number (optional)<br/><br/>    
        
    NOTE: Parsing logic assumes State and Zip are on the same address line. Only one Phone number per address 
    field is supported, the expected pattern shows the two optional positions for this value.
    <e>
      <b>ParseMultilineAddress("VendorName,VenAddress1,VenAddress2,VenCity,VenState,VenZip,VenPhone")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameters are invalid, or parsing cannot take place.  Otherwise, <b>True.</b><br/>
  </ret>
</ref>
<ref id="IsVariableEmpty">
	<ap>Name of the current object's variable to be checked.</ap>
	<h>Confirms if the variable specified by the parameter does not contain a value.  This action only checks variables of the current object. 
		<e><b>IsVariableEmpty("TemplateID")</b> 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is invalid, or if the variable contains a value.  Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsVariableFilled</scr></see>
</ref>
<ref id="IsVariableFilled">
  <ap>Name of the current object's variable to be checked.</ap>
  <h>
    Confirms if the variable specified by the parameter contains a value.  This action 
    only checks variables of the current object.
    <e>
      <b>IsVariableFilled("TemplateID")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is invalid, or if the variable contains a value.  Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsVariableEmpty</scr></see>
</ref>

<ref id="HasChildOfType">
  <ap>The name of a level of the Document Hierarchy (Batch, Document, Page, Field) or of a runtime variable.</ap>
  <h>
    Determines if the bound object of the Document Hierarchy has a child or children of the type specified by the parameter. The action can also determine if a runtime variable specified as a parameter has been assigned to the bound object.
    <e>
      <b>HasChildOfType("Page")</b><br/><br/>

      This example determines if the bound object is the parent of one or more pages.<br/><br/>

      <b>HasChildOfType("IGNORE")</b><br/><br/>

      In this example, the action determines if IGNORE is a runtime variable of the bound object.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the bound object does not include a child or children specified by the parameter, or a variable identified by the parameter.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="DeleteParentObj">
  <ap>None.</ap>
  <h>Deletes the parent of the Document Hierarchy object to which a rule with this action is bound. 
    <e><b>DeleteParentObj()</b> 
    </e>
  </h>
  <lvl>Document, Page, and Field.</lvl>
  <ret>
    <b>False</b> if a parent or grandparent object cannot be found, or if the deletion 
    of the parent object fails.  Otherwise, <b>True.</b>
  </ret>
</ref>  
<ref id="IsPatternInField">
	<ap>
    String value of the Regular Expression. The expression can include any Regular Expression characters.
  </ap>
  <h>Uses VBScript Regular Expression Pattern entered as parameter to search for a matching pattern in 
     current object's Text value.<br/><br/>
     Note: If you are using an input boundary, ^, it must be followed by a space and then the remainder
     of the search string.
    <e>
       <b>IsPatternInField("[\^\b\s\n\r]*Inv[oO0][iItl1]ce[\b\s]*")</b>
      <br/><br/>
      This example searches for the word “Invoice” in the current field.
      To allow for recognition errors, the search allows for common recognition 
      substitutions in “o” and “i” by matching “Invoice”, “InvOice”, “Inv0ice”, 
      “Inv01ce”, “Involce”, etc.  The search will also ignore any text placed before or after the word.
    </e>
  </h>
  <lvl>All, but generally at the Field level.</lvl>
  <ret>
    <b>True</b> if the pattern is found within the field.  Otherwise, <b>False.</b>
  </ret>
</ref>
<ref id="ConvertFieldToCurrency">
	<ap>None.</ap>
	<h>Formats a field's text value as a currency value.  The following steps are performed on the field:<br/>
    <br/>   
     1. Removes existing currency symbols.<br/>
     2. Replaces negative value characters such as parenthesis, 'NEG', 'CR' and trailing hyphen 
     with a leading hyphen.<br/>
     3. If a decimal exists, its position is not changed.<br/>
     4. If a decimal does not exist and the field contains 2 or more characters, a decimal is inserted 
     before the last two characters in the field.<br/>
     5. If a decimal does not exist and the field contains less than 2 characters, no decimal is inserted.
    <br/>
		<e><b>ConvertFieldToCurrency()</b><br/>
      A value of <b>1</b> remains <b>1</b><br/>
      A value of <b>12</b> becomes <b>.12</b><br/>
      A value of <b>105</b> becomes <b>1.05</b><br/>
      A value of <b>104.009</b> remains <b>104.009</b><br/>
    </e>
	</h>
  <lvl>All levels, but generally applied at the Field level.</lvl>
  <ret>
    <b>True</b> if the text value is numeric and greater than one character. Otherwise, <b>False</b>.
  </ret>
	</ref>
      
<ref id="IsFieldHidden">
  <ap>None.</ap>
  <h>
    Note: This action returns True if the calling field is 'Hidden'...if the corresponding <b>Field</b>object of the Document Hierarchy has a variable STATUS equal to -1.
    <e>
      <b>IsFieldHidden()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the <b>Field</b>object's STATUS = -1; Otherwise <b>False.</b>
  </ret>
</ref>

<ref id="IsSupportedImageFile">
    <ap>
      A Boolean that determines the type of test to perform.<br/><br/>

      True: Tests the validity of the image by checking the file extension and attempting to load the image.<br/>
      False: Only a file extension check is performed to determine if it is a supported file.
    </ap>
    <h>
      This action tests a file to determine if the file format is supported.  The extension is checked to
      determine if it denotes a supported image type.  If True is passed as a parameter, it also attempts to load
      the file into the Image view control.<br/><br/>
      
      Using False as a parameter will greatly improve the speed of this action.  A parameter of True will
      slow down the processing, especially if the images are very large, but it will add an extra confirmation
      that the file is not corrupted and confirm that any subformat of the file type, such as compression type, 
      is also supported.      
      <e>
        <b>IsSupportedImageFile()</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>True,</b> if parameter is valid, the action is called at the page level and the page's IMAGEFILE variable 
      (set at scan time by the scan tasks) points to a file whose format 
      is supported (can be displayed) by the Image view control. 
      Otherwise <b>False.</b>
    </ret>
    </ref>
      
<ref id="ReplaceValueAtPosition">
  <ap>
    Two-part comma-separated value:
    <br/><br/>
    1. The position that contains the value to be replaced.<br/><br/>
    2. The replacement string; this parameter defaults to "" indicating a deletion.
  </ap>
  <h>
    This action replaces the value at a specific position with a string replacement value, or a deletion.
    <e>
      <b>ReplaceValueAtPosition("3,/")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the character replacement is successful. Otherwise, <b>False.</b>
  </ret>
</ref>
  <ref id="FormatNumberToLocale">
    <h>
      This action evaluates the current field value for known number patterns and if a known pattern is detected,
      updates the decimal and digit separators characters (if present) to match that of the current locale,
      for use when processing fields with number types formatted incorrectly for the current locale. ie USA vs European.

      Known patterns are industry standard digits with or without 3 digit group separators, and 1-2 digits following a decimal separator.

      Distinct Analyzed groups:

      1) Numerals with decimal point
      Group Separators using comma, apostrope or space characters.
      Decimal Separator using decimal character.

      2) Numerals with decimal comma
      Group Separator using decimal, apostrope or space characters.
      Decimal Separator using comma character.

      3) Numerals with Arabic/Persian characters
      Group Separator using Arabic/Persian character.
      Decimal Separator using Arabic/Persian character.

      Note: Numerals with lakhs layout and decimal mark (pattern of n,nn,nn,nnn.dd) are not supported.
  
      <e>
        a) Given a US number 1,234.56 to be formatted to UK.<br/>
         <b>FormatNumberToLocale()</b><br/>
        New format will be 1.234,56<br/><br/>

        b) Given a US number 1234.5 to be formatted to UK.<br/>
        <b>FormatNumberToLocale()</b><br/>
        New format will be 1234,5<br/><br/>
        
        c) Given a US number 1,234.567 to be formatted to UK.<br/>
        <b>FormatNumberToLocale()</b><br/>
        Format will remain 1,234.567 since 3 digits following the decimal are not supported.<br/><br/>

        d) Given a US number 12345678.90 to be formatted to UK.<br/>
        <b>FormatNumberToLocale()</b><br/>
        New format will be 12345678.90<br/><br/>

        e) Given a UK number 1.234.567,89 to be formatted to US.<br/>
        <b>FormatNumberToLocale()</b><br/>
        New format will be 1,234,567.89<br/><br/>

        f) Given a UK number 0,5 to be formatted to US.<br/>
        <b>FormatNumberToLocale()</b><br/>
        New format will be 0.5<br/><br/>
        
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>True</b> if no errors are encountered. Otherwise, <b>False.</b>
    </ret>
  </ref>
  
</help>
</rrx>
<rrx namespace="Vote" src="c:\datacap\RRS\Vote.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="VoteFld" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Checks to see if the data entered for by the first Data Entry operator matches the data enter by the second Data Entry operator."]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   Checks to see if the data entered for by the first Data Entry operator matches the]]>
<![CDATA[
]]>
<![CDATA['   data enter by the second Data Entry operator.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   Failed (mismatched) values set the confidence for the entire string to '1', ]]>
<![CDATA[
]]>
<![CDATA['   therefore flagging the field as Low Confidence.   Positive matches set the ]]>
<![CDATA[
]]>
<![CDATA['   entire string's confidence to '9' (High Confidence).<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['   This action needs to run after the second Data Entry task has been completed.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim nLen	]]>
<![CDATA[
]]>
<![CDATA[	Dim aVal]]>
<![CDATA[
]]>
<![CDATA[	Dim aConf]]>
<![CDATA[
]]>
<![CDATA[	Dim nVal]]>
<![CDATA[
]]>
<![CDATA[	Dim nConf]]>
<![CDATA[
]]>
<![CDATA[	Dim j,i,k]]>
<![CDATA[
]]>
<![CDATA[	Dim sAllSame]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	VoteFld = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nLen = CurrentObj.Variable("Length")]]>
<![CDATA[
]]>
<![CDATA[	if nLen="" Then nLen=Len(CurrentObj.AltText(g_nPrime))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(g_nPrime)<>"0" then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Primary Index is set to: " & cstr(g_nPrime))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Redim aVal(1, nLen-1)]]>
<![CDATA[
]]>
<![CDATA[	Redim aConf(1, nLen-1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Read text & confidence Data for Primary value]]>
<![CDATA[
]]>
<![CDATA[	sVal = CurrentObj.AltText(g_nPrime)]]>
<![CDATA[
]]>
<![CDATA[	nConf = CurrentObj.AltConfidenceString(g_nPrime)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(" Primary Character string '" & sVal & "' and confidence '" & nConf & "'.")]]>
<![CDATA[
]]>
<![CDATA[	For j = 1 To nLen]]>
<![CDATA[
]]>
<![CDATA[		'check to see if length of current string is less than array length]]>
<![CDATA[
]]>
<![CDATA[		If j > Len(sVal) then]]>
<![CDATA[
]]>
<![CDATA[			aVal(0, j-1) = ""]]>
<![CDATA[
]]>
<![CDATA[			aConf(0, j-1) = 1]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			aVal(0, j-1) = Mid(sVal, j, 1)]]>
<![CDATA[
]]>
<![CDATA[			aConf(0, j-1) = Mid(nConf, j, 1)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Read text & confidence Data for 1st Alt-Text ]]>
<![CDATA[
]]>
<![CDATA[	sVal = CurrentObj.AltText(1)]]>
<![CDATA[
]]>
<![CDATA[	nConf = CurrentObj.AltConfidenceString(1)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Alternate Character string '" & sVal & "' and confidence '" & nConf & "'.")]]>
<![CDATA[
]]>
<![CDATA[	For j = 1 To nLen]]>
<![CDATA[
]]>
<![CDATA[		'check to see if length of current string is less than array Length]]>
<![CDATA[
]]>
<![CDATA[		If j > Len(sVal) then]]>
<![CDATA[
]]>
<![CDATA[			aVal(1, j-1) = ""]]>
<![CDATA[
]]>
<![CDATA[			aConf(1, j-1) = 1]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			aVal(1, j-1) = Mid(sVal, j, 1)]]>
<![CDATA[
]]>
<![CDATA[			aConf(1, j-1) = Mid(nConf, j, 1)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sVal=""]]>
<![CDATA[
]]>
<![CDATA[	nConf=""	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Compare values - Primary vs. 1st Alt-Text. and update confidence accordingly.]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 To nLen-1]]>
<![CDATA[
]]>
<![CDATA[		If aVal(0,k)<> aVal(1,k) Then]]>
<![CDATA[
]]>
<![CDATA[			'Character Values are different	]]>
<![CDATA[
]]>
<![CDATA[			Writelog("'" & aVal(0,k) & "' <> '" & aVal(1,k) & "' : Mismatch at position " & cstr(k) & ".") ]]>
<![CDATA[
]]>
<![CDATA[			VoteFld = False]]>
<![CDATA[
]]>
<![CDATA[			Select Case g_VoteType]]>
<![CDATA[
]]>
<![CDATA[				Case 0]]>
<![CDATA[
]]>
<![CDATA[					'predefined confidence]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) = 1					]]>
<![CDATA[
]]>
<![CDATA[				Case 1]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) = aConf(0,k) - g_VoteAdj			'adj confidence ]]>
<![CDATA[
]]>
<![CDATA[					If aConf(0,k) < 0 Then aConf(0,k) = 0]]>
<![CDATA[
]]>
<![CDATA[				Case 2]]>
<![CDATA[
]]>
<![CDATA[					'WriteLog("Clearing Confidence & Value")]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) =""					'clear value]]>
<![CDATA[
]]>
<![CDATA[					aVal(0,k) = ""]]>
<![CDATA[
]]>
<![CDATA[			End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			sVal = sVal & aVal(0,k)]]>
<![CDATA[
]]>
<![CDATA[			nConf = nConf & aConf(0,k)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Character Values are the same]]>
<![CDATA[
]]>
<![CDATA[			Select Case g_VoteType]]>
<![CDATA[
]]>
<![CDATA[				Case 0]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) = 9					'predefined confidence]]>
<![CDATA[
]]>
<![CDATA[				Case 1]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) = aConf(0,k) + g_VoteAdj]]>
<![CDATA[
]]>
<![CDATA[					'WriteLog("Confidence: +" & aConf(0,m)) ]]>
<![CDATA[
]]>
<![CDATA[					If aConf(0,k) > 9 Then aConf(0,k) = 9]]>
<![CDATA[
]]>
<![CDATA[			End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			sVal = sVal & aVal(0,k)]]>
<![CDATA[
]]>
<![CDATA[			nConf = nConf & aConf(0,k)]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Update Primary value & confidence]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltText(g_nPrime)=sVal]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltConfidenceString(g_nPrime)=nConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New Primary Character string.  " & sVal & ". New Confidence string: " & nConf)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************
' Vote.rra help

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'****************************************************
]]>
  	
<ref id="VoteFld" access="public" bInter="bInter" bDebug="bDebug" qi="Checks to see if the data entered for by the first Data Entry operator matches the data enter by the second Data Entry operator.">
  <ap>None.</ap>
  <h> 
    Checks to see if the data entered for by the first Data Entry operator matches the 
    data enter by the second Data Entry operator.<br/><br/>

    Failed (mismatched) values set the confidence for the entire string to '1', 
    therefore flagging the field as Low Confidence.   Positive matches set the 
    entire string's confidence to '9' (High Confidence).<br/><br/>

    This action needs to run after the second Data Entry task has been completed.<br/><br/>

    This action is used for workflows using third pass data entry.
    <e><b>VoteFld()</b> 
    </e>
	</h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the values do not match.  Otherwise, <b>True.</b>
  </ret>

</ref></help>

</rrx>
<rrx namespace="VScan" src="c:\datacap\RRS\VScan.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="SetImageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['   String value of the file's identifying extension.  If you are listing multiple types, separate]]>
<![CDATA[
]]>
<![CDATA['   each one with a comma.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   It is not necessary to include a period before each extension. The parameters are not case-sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  StrParam=Replace(StrParam,".","")]]>
<![CDATA[
]]>
<![CDATA[  StrParam=Replace(StrParam,Chr(32),"")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetImageType = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sExtn = LCase(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Remove period from extension]]>
<![CDATA[
]]>
<![CDATA[  sExtn = Replace(sExtn,".","")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If sExtn<>"tiff" and sExtn<>"tif" and sExtn<>"jpg" and sExtn<>"jpeg"then ]]>
<![CDATA[
]]>
<![CDATA[     'If the input is not a single file type of tiff, tif or jpg, then disable fast mode.]]>
<![CDATA[
]]>
<![CDATA[     oOut.SetDoNotOpenInputFiles(True)]]>
<![CDATA[
]]>
<![CDATA[     Writelog("special or multiple extensions were provided : setting Fast Mode to TRUE.")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  oIn.SetImageExtension(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  oOut.SetImageExtension(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  SetImageType = True        ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SetImageType")   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetMultiPageTiff" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  'Permits the use of multipage source image files.]]>
<![CDATA[
]]>
<![CDATA[  oOut.SetMultiPageTiff(True)]]>
<![CDATA[
]]>
<![CDATA[  SetMultiPageTiff = true]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SetMultiPageTiff") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFastMode" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' Increases speed by preventing the Scan action from opening the files it is scanning.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA['    This action is provided as backwards compatibility to older applications where this action was]]>
<![CDATA[
]]>
<![CDATA['    required to properly enable fast mode for PDF files.  SetImageType will automatically enable]]>
<![CDATA[
]]>
<![CDATA['    fast mode, if it is called with a PDF extension.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ oOut.SetDoNotOpenInputFiles(True)]]>
<![CDATA[
]]>
<![CDATA[  SetFastMode = true]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SetFastMode") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SearchInSubdirectory" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['  Looks for source files in sub-directories of the directory you designated with a ]]>
<![CDATA[
]]>
<![CDATA['  SetSourceDirectory action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  oIn.SearchInSubDirectory(True)]]>
<![CDATA[
]]>
<![CDATA[  SearchInSubdirectory = true]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SearchInSubdirectory") ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="SetSourceDirectory" access="public" bInter="bInter" bDebug="bDebug" strParam="SmartParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' String value of the directory's name and path. Instead, you can use a Smart Parameter such ]]>
<![CDATA[
]]>
<![CDATA[' as @Path to establish the Source Directory's name and path.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[  Dim oFolder]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  SetSourceDirectory = False]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(SmartParam)]]>
<![CDATA[
]]>
<![CDATA[  If len(Trim(StrParam))=0 Then StrParam=SmartParam]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("looking for:" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If trim(StrParam)="" Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Error: Folder '" & StrParam & "' does not exist.")]]>
<![CDATA[
]]>
<![CDATA[    SetSourceDirectory = False]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If FileMgr.FolderExists(StrParam)=False Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Error: Folder '" & StrParam & "' does not exist")]]>
<![CDATA[
]]>
<![CDATA[    nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Check existing directory and insert DRIVER LETTER: required for Mail Object]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  Set oFolder = FileMgr.GetFolder(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  StrParam = oFolder.Path ]]>
<![CDATA[
]]>
<![CDATA[  Set oFolder = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  oIn.SetSourceDir(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  oOutLook.SetSourceDir(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If err.number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Fatal error: Outlook is not running")]]>
<![CDATA[
]]>
<![CDATA[    SetSourceDirectory = FALSE]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    SourceDir = StrParam]]>
<![CDATA[
]]>
<![CDATA[    SetSourceDirectory = TRUE]]>
<![CDATA[
]]>
<![CDATA[  End If  ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetMaxImageFiles" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    An optional string value specifying the maximum number of files.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   If you do not enter a value, the task will scan all images in the target folder - and ]]>
<![CDATA[
]]>
<![CDATA['   this action will return True.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim strTrimParam  ' Input with leading / trailing space removed]]>
<![CDATA[
]]>
<![CDATA[  Dim lParmValue    ' Value as a long]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strTrimParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Always return success.  If the parameter value is not a valid integer, then we will just]]>
<![CDATA[
]]>
<![CDATA[  'log the problem and use the default value.  Let's set that up as the default condition.]]>
<![CDATA[
]]>
<![CDATA[  SetMaxImageFiles = True]]>
<![CDATA[
]]>
<![CDATA[  oOut.SetMaxImageFiles(MaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if len(strTrimParam) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[     ' In this one case where no parameter is present, we will use the largest size.]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("SetMaxImageFiles: No parameter, using largest value: 32767")]]>
<![CDATA[
]]>
<![CDATA[     oOut.SetMaxImageFiles(32767)]]>
<![CDATA[
]]>
<![CDATA[     Exit function]]>
<![CDATA[
]]>
<![CDATA[  end if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ' CInt will cause an error if the value is a number that is bigger than an int.  ]]>
<![CDATA[
]]>
<![CDATA[ ' We will validate it is a positive integer.]]>
<![CDATA[
]]>
<![CDATA[ if (Not IsNumeric(strTrimParam)) Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetMaxImageFiles: Parameter: " & strTrimParam & " is not a number, using default value: " & MaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[ end if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ' We have some kind of number.  It can be an int or a long.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ if (Len(strTrimParam) > 5) then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetMaxImageFiles: Parameter: " & strTrimParam & " is too big, using default value: " & MaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[ end if   ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ ' Might or might not be an int, but it must be a long by now.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ lParmValue = CLng(strTrimParam)    ' Set value to a long to prevent overflow]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ if ((lParmValue > 32767) or (lParmValue < 1)) Then]]>
<![CDATA[
]]>
<![CDATA[    ' bigger than signed int or 0 or negative]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetMaxImageFiles: Parameter: " & strTrimParam & " is too big or 0, using default value: " & MaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[ end if   ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ ' We have a valid, positive integer.]]>
<![CDATA[
]]>
<![CDATA[ oOut.SetMaxImageFiles( CInt(strTrimParam) )  ' Note, CInt rounds and uses system numeric settings]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Call ErrorHandler("SetMaxImageFiles")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="DeleteImageFile" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['A housekeeping action that deletes the current source image file.  A Scan action ]]>
<![CDATA[
]]>
<![CDATA['must follow this action.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call oIn.ResetFileOption(FILE_DELETE,"")]]>
<![CDATA[
]]>
<![CDATA[  DeleteImageFile = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("DeleteImageFile")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CopyFile" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamSP">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    <b>1.</b> The String value of the name of the target file system folder.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>2.</b> Optional. The file extension you wish to use for each file. If you provide an extension, it must]]>
<![CDATA[
]]>
<![CDATA['    not be preceded by a period.  The action defaults to "tif" if this parameter is blank.<br/>]]>
<![CDATA[
]]>
<![CDATA['    Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim aParam]]>
<![CDATA[
]]>
<![CDATA[  Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(trim(StrParamSP)) ]]>
<![CDATA[
]]>
<![CDATA[  writelog("Input after processing smart parameters: '" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  aParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If uBound(aParam) = 1 Then]]>
<![CDATA[
]]>
<![CDATA[    call oIn.ResetFileOption(FILE_COPY,  StrParam) ]]>
<![CDATA[
]]>
<![CDATA[    CopyFile = true]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    call oIn.ResetFileOption(FILE_COPY,  StrParam & ",tif") ]]>
<![CDATA[
]]>
<![CDATA[    CopyFile = true]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("CopyFile") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetMailSourceFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="SmartParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value of the Outlook folder you want to search.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume next    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetMailSourceFolder = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam=MetaWord(SmartParam)  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If len(Trim(StrParam))=0 Then StrParam=SmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If trim(StrParam) <> "" Then]]>
<![CDATA[
]]>
<![CDATA[     oOutLook.InitializeOutlook(StrParam) ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[      ' leave Mail Source folder untouched]]>
<![CDATA[
]]>
<![CDATA[    writelog("StrParam is empty, leave Mail Source folder as Inbox")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' we always put result of action in true, because we can manage badly created oOutlook object]]>
<![CDATA[
]]>
<![CDATA[  ' by  variable CMailFolder::bInitializeComplete]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SetMailSourceFolder = True]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Scan" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '    Scans a set of waiting Image files, according to the parameters set by earlier actions.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[  '    This is usually the last action in a vScan rule.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  Scan = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If cInt(CurrentObj.ObjectType) <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("The Scan action is required to run at the Batch level.  Returning False.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (Not FileMgr.FolderExists(SourceDir)) Then]]>
<![CDATA[
]]>
<![CDATA[    If len(trim(SourceDir))=0 then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Source Directory is not setup correctly, an empty path exists for this value. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      writelog("Source Directory '" & SourceDir & "' not Found. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    Scan = False]]>
<![CDATA[
]]>
<![CDATA[    Exit function]]>
<![CDATA[
]]>
<![CDATA[  End if  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If IsAlive(oOutLook) then oOutLook.SaveAttachmentsAndDeleteMail()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  nImages = Ubound(oIn.GetArray())]]>
<![CDATA[
]]>
<![CDATA[  writelog("Found '" & nImages & "' image files in Source folder:'" & SourceDir & "'.")]]>
<![CDATA[
]]>
<![CDATA[  nMaxImageFiles = oOut.GetMaxImageFiles()]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Get image files]]>
<![CDATA[
]]>
<![CDATA[  If cInt(nImages)<>cInt(0) Then ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    If bDocumentStructurePresents=TRUE then]]>
<![CDATA[
]]>
<![CDATA[      'Set the Expected Pages variable]]>
<![CDATA[
]]>
<![CDATA[      DCO.Variable("EP") = cStr(nMaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Process Image Files]]>
<![CDATA[
]]>
<![CDATA[    For i = 1 to min(nImages,oOut.GetMaxImageFiles) 'nImages]]>
<![CDATA[
]]>
<![CDATA[      sUnderProcessFile = oIn.GetFile(i)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Select Case cStr(oOut.Perform(sUnderProcessFile))]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Case cStr(PerformPageOk)]]>
<![CDATA[
]]>
<![CDATA[            'we will release files at the end]]>
<![CDATA[
]]>
<![CDATA[            'oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Case cStr(PerformPageAbort)]]>
<![CDATA[
]]>
<![CDATA[            'oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[            writelog("Files not released - File Processing Aborting.")]]>
<![CDATA[
]]>
<![CDATA[            nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[            Scan = false]]>
<![CDATA[
]]>
<![CDATA[            Exit function]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Case cStr(PerformPageFinish)]]>
<![CDATA[
]]>
<![CDATA[            'we did not process  oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[            nTaskStatus = RetFinished]]>
<![CDATA[
]]>
<![CDATA[            Exit for]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Case Else]]>
<![CDATA[
]]>
<![CDATA[            'oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[            writelog("Files not released - Unexpected result from File Processing.")]]>
<![CDATA[
]]>
<![CDATA[            Scan = False]]>
<![CDATA[
]]>
<![CDATA[            Exit function]]>
<![CDATA[
]]>
<![CDATA[      End Select]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If nTaskStatus = RetFinished Then]]>
<![CDATA[
]]>
<![CDATA[       writelog("Releasing files...")]]>
<![CDATA[
]]>
<![CDATA[       For i = 1 to min(nImages,oOut.GetMaxImageFiles) 'nImages]]>
<![CDATA[
]]>
<![CDATA[          sUnderProcessFile = oIn.GetFile(i)]]>
<![CDATA[
]]>
<![CDATA[          oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[       Next]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Files Released.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Pilot.ExpectedPages = cStr(nImages)]]>
<![CDATA[
]]>
<![CDATA[    nTaskStatus = RetFinished]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    nTaskStatus = RetPending]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Scan = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Scan") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddDocument" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   Places all scanned pages into a single, batch-wide document.]]>
<![CDATA[
]]>
<![CDATA['   This action must be called before the Scan action.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   The action also adds ED (Expected Documents), AD (Actual Documents), EP (Expected Pages)]]>
<![CDATA[
]]>
<![CDATA['   and AP (Actual Pages) properties to a task's Page file (.xml).<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   This action allows a VScan task to create a batch that has all the same ]]>
<![CDATA[
]]>
<![CDATA['   characteristics of a batch that is created using a standard scan task such as kScan or iScan.]]>
<![CDATA[
]]>
<![CDATA['   It is not required to call this action.  Use this action if your application relies on a]]>
<![CDATA[
]]>
<![CDATA['   document structure on import.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  AddDocument = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If cInt(CurrentObj.ObjectType) <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("The AddDocument action is required to run at the Batch level. Returning False.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupObject = DCO.SetupObject]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  writelog("Checking Setup DCO for a document structure...")]]>
<![CDATA[
]]>
<![CDATA[  nDocs = oSetupObject.NumOfNodes(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If(nDocs >= 1 ) Then '  we suppose there is just one document]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Found '" & cstr(nDocs) & "' document structures in current setup DCO.")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If DCO.NumOfChildren = 0 Then]]>
<![CDATA[
]]>
<![CDATA[         Set oDoc = DCO.AddChild(1,Pilot.BatchID & ".01" ,-1)]]>
<![CDATA[
]]>
<![CDATA[         'oDoc.Type=oSetupObject.GetNode(1,0).Name]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[         DCO.Variable("ED") = cStr(nDocs)]]>
<![CDATA[
]]>
<![CDATA[         DCO.Variable("AD") = "0"]]>
<![CDATA[
]]>
<![CDATA[         DCO.Variable("EP") = "0"]]>
<![CDATA[
]]>
<![CDATA[         DCO.Variable("AP") = "0"]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Set oDoc = DCO.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    bDocumentStructurePresents = True]]>
<![CDATA[
]]>
<![CDATA[    AddDocument = True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No document structures found in current setup DCO. No Document structure will be created.")]]>
<![CDATA[
]]>
<![CDATA[    bDocumentStructurePresents = false]]>
<![CDATA[
]]>
<![CDATA[    AddDocument = false]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupObject = Nothing ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetSortOrder" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['   Two comma-separated String values:]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    1. Designation of the images' sorting field: ImageName=1, Type=2, DateCreated=3,]]>
<![CDATA[
]]>
<![CDATA['    DateLastAccessed=4, DateLastModified=5, or Size=6.]]>
<![CDATA[
]]>
<![CDATA['    2. Optional: ASC or 1 (Ascending), DESC or 2 (Descending). If you do not include this ]]>
<![CDATA[
]]>
<![CDATA['    parameter, the action defaults to ASC (1).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim bValid]]>
<![CDATA[
]]>
<![CDATA[  Dim arParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SetSortOrder = false]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strParam=trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If len(strParam)=0 then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Expecting 1 or 2 parameter values. None found.")]]>
<![CDATA[
]]>
<![CDATA[    Exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  arParam = split(strParam,",")]]>
<![CDATA[
]]>
<![CDATA[  if Ubound(arParam) > 1 Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Wrong number of parameters, should be 1 or 2")]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  arParam(0)=Trim(cStr(arParam(0)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Select Case Ucase(arParam(0))]]>
<![CDATA[
]]>
<![CDATA[	Case "NAME","1"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "Name"]]>
<![CDATA[
]]>
<![CDATA[ 	Case "TYPE","2"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "Type"]]>
<![CDATA[
]]>
<![CDATA[	Case "DATECREATED","3"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "DateCreated"]]>
<![CDATA[
]]>
<![CDATA[	Case "DATELASTACCESSED","4"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "DateLastAccessed"]]>
<![CDATA[
]]>
<![CDATA[	Case "DATELASTMODIFIED","5"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "DateLastModified"]]>
<![CDATA[
]]>
<![CDATA[	Case "SIZE","6"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "Size"]]>
<![CDATA[
]]>
<![CDATA[	Case Else]]>
<![CDATA[
]]>
<![CDATA[		writelog ("first argument has to be one of the names: Name,Type,DateCreated,DateLastAccessed,DateLastModified,Size")]]>
<![CDATA[
]]>
<![CDATA[      	Exit function]]>
<![CDATA[
]]>
<![CDATA[  End Select]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Default to assending sort order.]]>
<![CDATA[
]]>
<![CDATA[  gSortOrder = "ASC"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If uBound(arParam)=1 Then]]>
<![CDATA[
]]>
<![CDATA[    arParam(1)=Trim(cStr(arParam(1)))	]]>
<![CDATA[
]]>
<![CDATA[    Select Case uCase(arParam(1))]]>
<![CDATA[
]]>
<![CDATA[	Case "DESC","2"]]>
<![CDATA[
]]>
<![CDATA[	      gSortOrder = "DESC"]]>
<![CDATA[
]]>
<![CDATA[      	writelog("sort order is DESC")]]>
<![CDATA[
]]>
<![CDATA[    	Case Else]]>
<![CDATA[
]]>
<![CDATA[      	writelog("sort order is ASC")	]]>
<![CDATA[
]]>
<![CDATA[    end Select]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SetSortOrder = true ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="MoveImageFileToDirectory" access="public" bInter="bInter" bDebug="bDebug" strParam="SmartParam">
	<g>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[ 'The full path to the target location of the Image file.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '   A housekeeping action that moves the current Image file to a location you specify.  The source]]>
<![CDATA[
]]>
<![CDATA[ '   image file will be removed from the input directory and moved to the specified directory.]]>
<![CDATA[
]]>
<![CDATA[ '   This action is typically used when it is desired to place images into a specific]]>
<![CDATA[
]]>
<![CDATA[ '   location for archiving.  A copy of the image will still be placed into the batch directory.]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '   If the target directory already contains a file of the same name, it will give a unique name to the new file.]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '  This action must precede the Scan action.  If MoveImageFileToDirectory is used and the Scan action]]>
<![CDATA[
]]>
<![CDATA[ '  is never subsequently called, the file move will not be performed.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ Dim StrParam   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam=Metaword(SmartParam)]]>
<![CDATA[
]]>
<![CDATA[  If len(Trim(StrParam))=0 Then StrParam=SmartParam]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If trim(StrParam)<>"" Then]]>
<![CDATA[
]]>
<![CDATA[    If ( Not FileMgr.FolderExists(StrParam) ) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Fatal error: Folder " & StrParam & " does not exist")]]>
<![CDATA[
]]>
<![CDATA[      nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[      MoveImageFileToDirectory = False]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      ' check existing directory]]>
<![CDATA[
]]>
<![CDATA[      ' AND insert DRIVER LETTER : it is needed for Mail Object]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Dim folder]]>
<![CDATA[
]]>
<![CDATA[      Set folder = FileMgr.GetFolder(StrParam)]]>
<![CDATA[
]]>
<![CDATA[      StrParam = folder.Path ]]>
<![CDATA[
]]>
<![CDATA[      Set Folder = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      call oIn.ResetFileOption(FILE_MOVE, StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      MoveImageFileToDirectory = True ]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("MoveImageFileToDirectory: Parameter is not correct.")]]>
<![CDATA[
]]>
<![CDATA[    nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[    MoveImageFileToDirectory = False]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("MoveImageFileToDirectory")]]>
<![CDATA[
]]>
	</g>
</af>
<help>
<![CDATA[
'************************************************************
' help.xml for VScan
'------------------------------------------------------------
'
' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'------------------------------------------------------------
'Version = "8.0.1.12"
' Updated 12/23/2010 PHofle
'  * Converted into a .NET DLL for using resources that allow translation of the Datacap Studio help 
'
'Version = "8.0.1.13"
' Updated 02/22/2011 RFerin
'  * 31154 Fixed smart parameter example from +\Input to +\+Input 
'
'Version = "8.1.0.18"
' Updated 05/17/2011
' * Added maximim number of files to be scanned is 32767 files to help for SetMaxImagefiles
'
'Version = "8.1.0.17"
' Updated 07/19/2011
' * 20511 20513 Updated help for SetFastMode, AddDocument and help tweaks in most actions.
'
'Version = "8.1.0.18"
' Updated 07/19/2011
' * 21543 Expanded the help for SetSortOrder.
'
'Version = "8.1.0.19"
' Updated 03/13/2012
' * 20511 Updated the help text to say that SetMultiPageTiff cannot be used when fast mode is enabled.
'************************************************************

]]>
  <ref id="SetImageType">
    <ap>
      String value of the file's identifying extension.  If you are listing multiple types, separate
      each one with a comma.<br/><br/>

      It is not necessary to include a period before each extension. The parameters are not case-sensitive.<br/><br/>
    </ap>
    <h>
      Uses the value of a file extension(s) to specify the type of files the task will scan.<br/><br/>

      This is an optional vScan action: the task will scan .tif files by default.
      For this action to take effect, it must be called before the Scan action.<br/><br/>

      This action will automatically enable Fast Mode scanning if the input parameter
      is not a single extension of type "tiff", "tif", "jpeg" or "jpg".

      <e>
        <b>SetImageType(".tif)</b><br/>
        Scan()<br/>
        This sequence will scan only TIF files and will not enable Fast Mode.<br/><br/>

        <b>SetImageType("tiff")</b><br/>
        Scan()<br/>
        This sequence will scan only TIFF files and will not enable Fast Mode.<br/><br/>

        <b>SetImageType("bmp,jpg,jpeg,msg,tif,tiff,pdf,zip,doc,docx,xls,xlsx,eml,gif")</b><br/>
        Scan()<br/>
        This sequence will scan all file types listed and will enable Fast Mode.<br/>
      </e>
    </h>
    <lvl>Any level but usually the batch level.</lvl>
    <ret>
      <b>True</b> if the parameter is one of the values specified above. Otherwise, <b>False.</b>
    </ret>
     </ref>
  
 <ref id="SetMultiPageTiff">
   <ap>None.</ap>
   <h>
     Permits the use of multipage source image files.
     For this action to take effect, it must be called before the Scan action.<br/><br/>
     
     This action cannot be used if fast mode is enabled.  It also requires that
     SetImageType be called with only one extension of TIF, TIFF, JPG or JPEG.
     If this action is used when fast mode is enabled, the Scan action will return false.
     <e>
       SetImageType(".tif")<br/>
       <b>SetMultiPageTiff()</b><br/>
       Scan()<br/><br/>

       If the Scan action in this sequence encounters a multipage .tif file, then it will
       read each one into the current batch as a separate image, thereby "bursting" the multipage
       file into individual images.
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>
   </ret>
     </ref>
  
 <ref id="SetFastMode">
   <ap>None.</ap>
   <h>
     Increases speed by preventing the Scan action from opening the files it is scanning.
     This action prevents the testing that the TIF files are valid and avoid conversion of TIF files to G4 compression for processing.
     Calling this action will allow TIF files that are not compatible with Taskmaster to be placed into a batch.
     <br/><br/>

     This action is provided as backwards compatibility to older applications where this action was
     required to properly enable fast mode for PDF files.<br/><br/>

     SetImageType will automatically enable
     fast mode, if it is called with a extension other than TIF or JPG.
     For this action to take effect, it must be called before the Scan action.<br/>
     <e>
       SetImageType(.pdf)<br/>
       <b>SetFastMode()</b><br/>
       Scan()
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>
   </ret>
 </ref>
  
 <ref id="SearchInSubdirectory">
   <ap>None.</ap>
   <h>
     Looks for source files in sub-directories of the directory you designated with a
     SetSourceDirectory action.
     For this action to take effect, it must be called before the Scan action.<br/>
     <e>
       SetSourceDirectory("@APPPATH(vscanimagedir)")<br/>
       <b>SearchInSubdirectory()</b><br/><br/>
       In this example, if the scan directory obtained from the application service includes sub-directories, this action will
       direct the Scan action to process the contents of the sub-directories.
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>
   </ret>
   <see>SetSourceDirectory</see>
     </ref>
  
 <ref id="SetSourceDirectory">
   <ap>
     String value of the directory's name and path. Instead, you can use a Smart Parameter,
     such as @APPPATH, to establish the Source Directory's name and path.
   </ap>
   <h>
     This action indicates the name and path of the directory containing the Image files to be scanned.<br/><br/>
     This is a required action; a task which employs a vScan rule cannot process images
     unless it has this key locator.  This action must be called prior to the scan action.
     <e>
       <b>SetSourceDirectory("c:\ParentDirectory\Application\Images")</b><br/><br/>
       In the above example, the full path to the images directory is coded directly into the application rules.
       <br/><br/>
       <b>SetSourceDirectory("@APPPATH(vscanimagedir)+\+Input")</b><br/><br/>

       In the example above, @APPPATH obtains the vscan directory from the application service.
       This makes the application more flexible in that the same application that is installed in two different
       environments, such as test vs. production, can use two different input directories.  The subdirectory "Input"
       is appended to the path.
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     <b>False</b> if the parameter is blank or the directory does not exist. Otherwise, <b>True.</b><br/><br/>

     If the source directory does not exist, the batch status will be set to abort.
   </ret>
     </ref>
  
  <ref id="SetMaxImageFiles">
    <ap>
      An optional string value specifying the maximum number of files.<br/><br/>

      If you do not enter a value, the task will scan all images in the target folder (up to 32767 files)- and
      this action will return <b>True.</b>
    </ap>
    <h>
      Limits the number of Image files the vScan task will add to a single batch.  This action must
      be placed before the Scan action for the setting to take effect during Scan.
      <e>
        <b>SetMaxImageFiles("50")</b><br/>
        Scan()<br/>
        Sets the maximum number of files to add to a batch at fifty.<br/><br/>

        <b>Remember!</b> A vScan task is a Batch Creation task: it sets up a new batch each
        time it scans Image files.
      </e>
    </h>
    <lvl>Any level but usually the batch level.</lvl>
    <ret>
      <b>False</b> if the parameter is not Numeric. Otherwise, <b>True.</b>
    </ret>
  </ref>
  
  <ref id="DeleteImageFile">
    <ap>None.</ap>
    <h>
      A housekeeping action that deletes the current source image file.  A Scan action
      must follow this action, which will perform the delete during the vscan process.
      If Scan is never called, the files will not be deleted.
      <e>
        <b>DeleteImageFile()</b><br/>
        <scr>Scan()</scr><br/><br/>

        This sequence deletes the image files from their current location after they
        have been added to the current batch folder.
      </e>
    </h>
    <lvl>Any level but usually the batch level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>
  
 <ref id="CopyFile">
   <ap>
     <b>1.</b> The String value of the name of the target file system folder.<br/>
     <b>2.</b> Optional. The file extension you wish to use for each file. If you provide an extension, it must
     not be preceded by a period.  The action defaults to "tif" if this parameter is blank.<br/>
     Smart parameters are supported.
   </ap>
   <h>
     A housekeeping action that copies the current source image file to a location
     you specify and specifies the copied file's extension.<br/><br/>

     The source image file will remain in the input directory while a copy is placed into the specified directory.
     This action is typically used when it is desired to place images into a specific
     location for archiving.  A copy of the image will still be placed into the batch directory as well. <br/><br/>

     If the target directory already contains a file of the same name, it will give a unique name to the new file.<br/><br/>

     This action must precede the Scan action.  The CopyFile sets an indicator for the Scan action
     to copy the file.  If CopyFile is used and the Scan action
     is never subsequently called, the copy will not be performed.
     The destination directory must already exist or a message will be logged and no files will be copied.
     <e>
       <b>CopyFile("C:\ParentDirectory\Application\Images\copies,tif")</b><br/>
       <scr>Scan()</scr><br/><br/>

       This example copies the source image file to the "copies" folder and then adds it to the batch.
       It does not delete the image from the source folder.<br/><br/>

       <b>CopyFile("@APPPATH(vscancopydir),tif")</b><br/>
       <scr>Scan()</scr><br/><br/>

       This variant example copies the source image file to the "copies" folder that has been specified
       within the application service.<br/><br/>
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>  If the target directory does not exist or if the files cannot be created, the files will
     not be copied but the action will still return <b>True.</b>
   </ret>
   <see>
     <scr>Scan</scr>
   </see>
     </ref>
  
 <ref id="SetMailSourceFolder">
   <ap>String value of the Outlook folder you want to search.</ap>
   <h>
     Searches the location you specify for e-mails that contain Image file attachments.
     For this action to take effect, it must be called before the Scan action.<br/>
     <e>
       <b>SetMailSourceFolder("Inbox/Images")</b><br/>
       Scan()<br/><br/>

       This example will search the Images subfolder for any e-mails with attachments,
       and copy these Image files into the newly created batch.<br/><br/>

       <b>SetMailSourceFolder("Inbox+/+@VAR(FOLDERNAME)")</b><br/>
       Scan()<br/><br/>

       This example will get the name of the subfolder from the runtime variable "FOLDERNAME".
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>
   </ret>
     </ref>
  
 <ref id="Scan">
   <ap>None.</ap>
   <h>
     Scans a set of waiting Image files, according to the parameters set by earlier actions.<br/><br/>
     This is usually the last action in a vScan rule.
     <e>
       <scr>SetImageType(".tif")</scr><br/>
       <scr>SetSourceDirectory("@APPPATH(vscanimagedir)")</scr><br/>
       <scr>SetMaxImageFiles("100")</scr><br/>
       <b>Scan()</b><br/><br/>

       These are the elements of a sample vScan Rule. The Scan action will load the specified
       number of images (if available) from the specified folder into the current batch folder.
     </e>
   </h>
   <lvl>Batch level.</lvl>
   <ret>
     <b>False</b> if a <scr>SetSourceDirectory</scr> action does not precede this action. False will
     also be returned if fast mode is enabled and SetMultiPageTiff was called.
     Otherwise, <b>True.</b>
   </ret>
     </ref>
  
 <ref id="AddDocument">
  <ap>None.</ap>
   <h>
     Places all scanned pages into a single, batch-wide document.
     This action must be called before the Scan action.<br/><br/>

     The action also adds ED (Expected Documents), AD (Actual Documents), EP (Expected Pages)
     and AP (Actual Pages) properties to a task's Page file (.xml).<br/><br/>

     This action allows a VScan task to create a batch that has all the same
     characteristics of a batch that is created using a standard scan task.
     It is not required to call this action.  Use this action if your application relies on a
     document structure on import.<br/><br/>

     This action must precede the Scan action.  If AddDocument is used and the Scan action
     is never subsequently called, the action will not be performed.<br/>
     <e>
       <b>AddDocument()</b><br/>
       SetSortOrder("Name,ASC")<br/>
       SetMaxImageFiles("100")<br/>
       Scan()
     </e>
   </h>
   <lvl>Batch level.</lvl>
   <ret>
     <b>False</b> if this action is invoked or if called at the wrong level or
     if the setup DCO does not contain any document structure.  
     In this case, the action will not add a document. Otherwise, <b>True.</b>
   </ret>
     </ref>
  
 <ref id="SetSortOrder">
   <ap>
     Two comma-separated String values:<br/><br/>

     <b>Parameter 1.</b> Designation of the images' sorting field can be specified with text or numerically: <br/><br/>
     
     <b>1</b> or <b>Name</b> : The input file name.<br/>
     <b>2</b> or <b>Type</b> : The file type.<br/>
     <b>3</b> or <b>DateCreated</b> : The File creation date.<br/>
     <b>4</b> or <b>DateLastAccessed</b> : The last file access date.<br/>
     <b>5</b> or <b>DateLastModified</b> : The last file modification date.<br/>
     <b>6</b> or <b>Size</b> : The file size.<br/><br/>
     
     <b>Parameter 2.</b> Optional: ASC or 1 (Ascending), DESC or 2 (Descending). If you do not include this
     parameter, the action defaults to ASC (1).
   </ap>
   <h>
     Sets the order in which Image files will be imported to the batch.
     The input files can be sorted by their file name, file type, date created,
     date accessed, date modified or file size.  Using the optional second
     parameter, you can control if the values are sorted in ascending or descending order.
     <br/>
     For this action to take effect, it must be called before the Scan action.<br/>
     <e>
       <b>SetSortOrder("Name,ASC")</b><br/>
       <scr>Scan()</scr>
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     <b>False</b> if the parameters are not valid.  Otherwise, <b>True.</b>
   </ret>
     </ref>
  
 <ref id="MoveImageFileToDirectory">
   <ap>The full path to the target location of the Image file.  Smart parameters are supported.</ap>
   <h>
     A housekeeping action that moves the current Image file to a location you specify.  The source
     image file will be removed from the input directory and moved to the specified directory.
     This action is typically used when it is desired to place images into a specific
     location for archiving.  A copy of the image will still be placed into the batch directory.<br/><br/>

     If the target directory already contains a file of the same name, it will give a unique name to the new file.<br/><br/>

     This action must precede the Scan action.  If MoveImageFileToDirectory is used and the Scan action
     is never subsequently called, the file move will not be performed.  If the move to the new
     directory fails, the batch will be set to abort.
     <e>
       <b>MoveImageFiletoDirectory("C:\ParentDirectory\Application\backup")</b><br/>
       SetMaxImageFiles("100")<br/>
       Scan()<br/><br/>

       This sequence copies the source image files to the current batch, then moves the Image
       files to the specified directory.<br/><br/>

       <b>MoveImageFiletoDirectory("@APPPATH(vscanmovedir)")</b><br/>
       <scr>Scan()</scr><br/><br/>

       This variant example uses a smart parameter to obtain the directory path from the application service.
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     <b>False</b> if the parameter is not a valid directory, or if permission to access/write
     to the directory is denied.  Otherwise, <b>True.</b><br/><br/>

     If the file cannot be written to the destination directory, the batch status will be set to abort.
   </ret>
     </ref>
  
  <ref id="SetAlternateImageNames">
    <ap>
      <b>0</b> : Sets the naming scheme of the input files to the format used by eDocument Conversion actions.<br/>
      Any other input value uses the traditional naming schmeme of TM000001, TM000002, etc.
    </ap>
    <h>
      This action sets the file naming scheme of the Scan action.
      If you are using the Convert action library, it is recommended
      that you enable this batch file naming scheme.<br/><br/>      
      
      If this action is not called prior to the Scan action, 
      then the Scan uses the traditional naming schmeme of TM000001, TM000002, etc.
      <e>
        <b>SetAlternateImageNames("0")</b><br/>
        Scan()
      </e>
    </h>
    <lvl>Any level but usually the batch level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>Scan</see>
    </ref>
 </help>

 </rrx>
<rrx namespace="Zones" src="c:\datacap\RRS\Zones.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="PopulateZNField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	PopulateZNField=DCOFieldFromCCO(CurrentObj, CCO)]]>
<![CDATA[
]]>
<![CDATA[	writelog("Found Value: '" & CurrentObj.Text & "' ")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PopulateZNLineItemField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	PopulateZNLineItemField=False]]>
<![CDATA[
]]>
<![CDATA[    sPos=CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If( sPos<>"" and sPos <> "0,0,0,0" ) Then]]>
<![CDATA[
]]>
<![CDATA[		If Not AdjustPosToParent(CurrentObj,"1") Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[		PopulateZNLineItemField=DCOFieldFromCCO(CurrentObj, CCO)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		PopulateZNLineItemField=true]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="RegisterPage" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	RegisterPage=True]]>
<![CDATA[
]]>
<![CDATA[	sName=CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Page Fingerprint number " & sName)]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	nChildren = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For nChild = 0 to nChildren -1]]>
<![CDATA[
]]>
<![CDATA[		Set oField = CurrentObj.GetChild(nChild)]]>
<![CDATA[
]]>
<![CDATA[		Do While Not oField is Nothing		]]>
<![CDATA[
]]>
<![CDATA[			If oField Is Nothing Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			If Not left(oField.ID & Space(6),6) = "Anchor" Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			sWord=oField.Variable("Word" & sName)	]]>
<![CDATA[
]]>
<![CDATA[			If sWord="" Then Exit Do	]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Searchword is '" & sWord & "' ")]]>
<![CDATA[
]]>
<![CDATA[			If Not FindKey(bInter, bDebug, sWord) Then ]]>
<![CDATA[
]]>
<![CDATA[				Dim tmpStr]]>
<![CDATA[
]]>
<![CDATA[				tmpStr = RegExBuild(bInteractive, bDebug, sWord)]]>
<![CDATA[
]]>
<![CDATA[				If not FindKey(bInter, bDebug, tmpStr) then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			end if]]>
<![CDATA[
]]>
<![CDATA[			nL=0]]>
<![CDATA[
]]>
<![CDATA[			nW=0]]>
<![CDATA[
]]>
<![CDATA[			Call CCO.GetCurrentPosition(nL, nW)]]>
<![CDATA[
]]>
<![CDATA[			Set oWord=CCO.Item(nL).Item(nW)]]>
<![CDATA[
]]>
<![CDATA[			If oWord Is Nothing Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			arField=SplitNumber(oField.Variable("Pos" & sName))]]>
<![CDATA[
]]>
<![CDATA[			If UBound(arField)<3 Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			'nXOffset=oWord.Left-arField(0)]]>
<![CDATA[
]]>
<![CDATA[			nYOffset=oWord.Top-arField(1)]]>
<![CDATA[
]]>
<![CDATA[			nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[			writelog("Y offset - " & CStr(nYOffset))]]>
<![CDATA[
]]>
<![CDATA[			For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[				Set oField=CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[				Writelog(oField.Variable(sName))]]>
<![CDATA[
]]>
<![CDATA[				arField=SplitNumber(oField.Variable("Pos" & sName))]]>
<![CDATA[
]]>
<![CDATA[				If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[					'arField(0)=arField(0)+nXOffset]]>
<![CDATA[
]]>
<![CDATA[					arField(1)=arField(1)+nYOffset]]>
<![CDATA[
]]>
<![CDATA[					'arField(2)=arField(2)+nXOffset]]>
<![CDATA[
]]>
<![CDATA[					arField(3)=arField(3)+nYOffset]]>
<![CDATA[
]]>
<![CDATA[					oField.Variable("Position")=CStr(arField(0)) & "," & CStr(arField(1)) & "," & CStr(arField(2)) & "," & CStr(arField(3))]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		loop]]>
<![CDATA[
]]>
<![CDATA[	Next 'nChild]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanDetails" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ScanDetails=False]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ScanDetailsEnter")]]>
<![CDATA[
]]>
<![CDATA[	If Not DivideChildsByLines(CurrentObj, CCO, 1)>0 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.GetChild(i).CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanDetails=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanDetailsByLines" access="public" bInter="bInter" bDebug="bDebug" strParam="sParam">
	<g>
<![CDATA[
]]>
<![CDATA[	ScanDetailsByLines=False    ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ScanDetailsByLinesEnter")]]>
<![CDATA[
]]>
<![CDATA[	If Not DivideChildsByLines(CurrentObj, CCO, CLng(sParam))>0 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.GetChild(i).CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanDetailsByLines=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanDetailsByVSpace" access="public" bInter="bInter" bDebug="bDebug" strParam="sParam">
	<g>
<![CDATA[
]]>
<![CDATA[	ScanDetailsByVSpace=False]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ScanDetailsByVSpaceEnter")]]>
<![CDATA[
]]>
<![CDATA[	If Not DivideChildsByVSpace(CurrentObj, CCO, CLng(sParam))>0 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.GetChild(i).CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanDetailsByVSpace=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanLineItem" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim newPos]]>
<![CDATA[
]]>
<![CDATA[	ScanLineItem=False]]>
<![CDATA[
]]>
<![CDATA[	sName=oCurPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	Writelog(sName)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		Set oField=CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(oField.ID)]]>
<![CDATA[
]]>
<![CDATA[		If Not oField Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[            newPos=Trim(oField.Variable("Pos" & sName))]]>
<![CDATA[
]]>
<![CDATA[            If newPos="" then newPos="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[			      oField.Variable("Position")=newPos]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanLineItem=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneTOP_UpperBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,UpperBound,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & UpperBound & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ZoneTOP_UpperBound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call zn_CheckIMAGEFILE(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneTOP_LowerBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[  Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,LowerBound,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & LowerBound & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP_LowerBound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call zn_CheckIMAGEFILE(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneBOTTOM_UpperBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,UpperBound)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & UpperBound)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM_UpperBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneBOTTOM_LowerBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,LowerBound)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & LowerBound)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM_LowerBound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneLEFT_LeftBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(LEFTBound,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & LEFTBound & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT_LeftBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneLEFT_RightBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(RIGHTBound,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & RIGHTBound & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT_RightBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneRIGHT_LeftBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[		Dim l,w]]>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,LeftBound,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & LeftBound & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT_LeftBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneRIGHT_RightBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,RIGHTBound,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & RIGHTBound & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT_RightBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneRIGHT_ImageRight" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,RIGHTBound,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & RIGHTBound & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT_ImageRight= True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneLEFT_ImageLeft" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(LEFTBound,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & LEFTBound & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT_ImageLeft= True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneBOTTOM_ImageBottom" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,LowerBound)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & LowerBound)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM_ImageBottom = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneTOP_ImageTop" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,UpperBound,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & UpperBound & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP_ImageTop= True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call zn_CheckIMAGEFILE(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReadZones" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim PosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage]]>
<![CDATA[
]]>
<![CDATA[	Dim bPos]]>
<![CDATA[
]]>
<![CDATA[	Dim bPM]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ReadZones=True]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If len(sOffSet)=0 then sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sName=oCurPage.Variable("TemplateID")	]]>
<![CDATA[
]]>
<![CDATA[	PosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ReadZones for " & PosName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = (-1*aOffSet(0))]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = (-1*aOffSet(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offsets : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oSet = 0]]>
<![CDATA[
]]>
<![CDATA[	xAdj = clng(nXoffSet)]]>
<![CDATA[
]]>
<![CDATA[	Yadj = clng(nYoffSet)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType < 4 then ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		sZonePos = CurrentObj.variable(PosName)]]>
<![CDATA[
]]>
<![CDATA[		'writelog("DCO pos:" & sZonePos)]]>
<![CDATA[
]]>
<![CDATA[		bPM = Not(CurrentObj.Variable("PatternMatch")="1")]]>
<![CDATA[
]]>
<![CDATA[		bPos = CurrentObj.Variable("Position")="0,0,0,0" or CurrentObj.Variable("Position")="" ]]>
<![CDATA[
]]>
<![CDATA[		If sZonePos <> "" and sZonePos <> "0,0,0,0" and bPM and bPos then]]>
<![CDATA[
]]>
<![CDATA[			arZonePos=split(sZonePos,",")]]>
<![CDATA[
]]>
<![CDATA[			If UBound(arZonePos)=3 Then]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(0)=arZonePos(0)+Xadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(1)=arZonePos(1)+Yadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(2)=arZonePos(2)+Xadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(3)=arZonePos(3)+Yadj]]>
<![CDATA[
]]>
<![CDATA[				CurrentObj.Variable("Position")=CStr(arZonePos(0)) & "," & CStr(arZonePos(1)) & "," & CStr(arZonePos(2)) & "," & CStr(arZonePos(3))]]>
<![CDATA[
]]>
<![CDATA[				writelog("new pos:" & CurrentObj.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		Set oSetupNode = CurrentObj.SetupNode()]]>
<![CDATA[
]]>
<![CDATA[		If Not(oSetupNode is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[			If oSetupNode.variable("RecogType")="4" then]]>
<![CDATA[
]]>
<![CDATA[				writelog(space(oSet+2) & "OMR recogtype found.") ]]>
<![CDATA[
]]>
<![CDATA[				For nChar = 1 to oSetupNode.NumOfRules]]>
<![CDATA[
]]>
<![CDATA[					Set oSubRule = oSetupNode.GetRule(nChar-1)]]>
<![CDATA[
]]>
<![CDATA[					Set oSubChar = CurrentObj.GetChild(nChar-1)]]>
<![CDATA[
]]>
<![CDATA[					If Not(oSubRule is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[						If oSubChar is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[							Set oSubChar = CurrentObj.AddChild(4, "", -1)]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						sZonePos = oSubRule.variable(PosName)]]>
<![CDATA[
]]>
<![CDATA[						writelog(space(oSet+2) & "Found ZonePos: " & sZonePos)]]>
<![CDATA[
]]>
<![CDATA[						if sZonePos <> "" and sZonePos <> "0,0,0,0" then]]>
<![CDATA[
]]>
<![CDATA[							arZonePos=split(sZonePos,",")]]>
<![CDATA[
]]>
<![CDATA[							If UBound(arZonePos)=3 Then]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(0)=arZonePos(0)+Xadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(1)=arZonePos(1)+Yadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(2)=arZonePos(2)+Xadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(3)=arZonePos(3)+Yadj]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[								bRes = oSubChar.SetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))]]>
<![CDATA[
]]>
<![CDATA[								bRes = oSubChar.GetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[								'writelog("Saved X Y (" & CStr(arZonePos(2)- arZonePos(0)) & "," & CStr(arZonePos(3)-arZonePos(1)) & ") " & vbcrlf)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							end if]]>
<![CDATA[
]]>
<![CDATA[						end if]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				Next 'nChar]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oSetupNode = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call ZoneChildren(CurrentObj, PosName, oSet, Xadj, Yadj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LoadZones" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	LoadZones=True]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If len(sOffSet)=0 then sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sName=StrParam	]]>
<![CDATA[
]]>
<![CDATA[	sPosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	Writelog("LoadZones for " & sPosName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = (-1*aOffSet(0))]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = (-1*aOffSet(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offsets : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ZoneChildren(CurrentObj, sPosName, 0, clng(nXoffSet), clng(nYoffSet))]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="FindZoneLineItems" access="public">
	<p name="createSubfields">
	</p>
	<p name="createTempCCO">
	</p>
	<p name="subfieldFillType">
	</p>
	<p name="offsetPercent">
	</p>
	<p name="intersectionRatio">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['Dev Comments - Documentation Dept. do not remove this information ]]>
<![CDATA[
]]>
<![CDATA['1)  If true then create and find lineitem subfields]]>
<![CDATA[
]]>
<![CDATA['    If false then only find lineitem]]>
<![CDATA[
]]>
<![CDATA['2)  If true (default) then Analyze the area & create block cco]]>
<![CDATA[
]]>
<![CDATA['    If false then use existing CCO as zone CCO to search]]>
<![CDATA[
]]>
<![CDATA['3)  Fill SubFields Option]]>
<![CDATA[
]]>
<![CDATA['	 1 - Fill by CCO word (default)]]>
<![CDATA[
]]>
<![CDATA['		 Optional setting of colon followed by groupwords value. i.e. '1:1.5']]>
<![CDATA[
]]>
<![CDATA['	 2 - Fill by CCO character]]>
<![CDATA[
]]>
<![CDATA['4)  Adjust Search LineItem Area to CCO Line start if start of line within x% difference of line length]]>
<![CDATA[
]]>
<![CDATA['	   Numeric Value of 0-100% - Larger values for Shorter Search Lines. Defaults to 0.]]>
<![CDATA[
]]>
<![CDATA['5)  Change Intersection Ration of Lines & Words for populating Lineitems & Subfields. Defaults to .25]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim arLine(3)]]>
<![CDATA[
]]>
<![CDATA[	Dim arWord(3)]]>
<![CDATA[
]]>
<![CDATA[	Dim arCurrLine]]>
<![CDATA[
]]>
<![CDATA[	Dim arSubField]]>
<![CDATA[
]]>
<![CDATA[	Dim arRoot]]>
<![CDATA[
]]>
<![CDATA[	Dim arChild]]>
<![CDATA[
]]>
<![CDATA[	Dim arFieldAdj	]]>
<![CDATA[
]]>
<![CDATA[	Dim arSub]]>
<![CDATA[
]]>
<![CDATA[	Dim arZone]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oSubField	]]>
<![CDATA[
]]>
<![CDATA[	Dim oSubchildField]]>
<![CDATA[
]]>
<![CDATA[ 	Dim oRootItem]]>
<![CDATA[
]]>
<![CDATA[	Dim oRootPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oSubRootChild]]>
<![CDATA[
]]>
<![CDATA[	Dim ochildfield]]>
<![CDATA[
]]>
<![CDATA[	Dim oLine]]>
<![CDATA[
]]>
<![CDATA[	Dim oWord]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurrLine]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sPos]]>
<![CDATA[
]]>
<![CDATA[	Dim nLastLine]]>
<![CDATA[
]]>
<![CDATA[	Dim nLines]]>
<![CDATA[
]]>
<![CDATA[	Dim sConfString]]>
<![CDATA[
]]>
<![CDATA[	Dim OrigConf ]]>
<![CDATA[
]]>
<![CDATA[	Dim sBaseName ]]>
<![CDATA[
]]>
<![CDATA[	Dim zoneCCO]]>
<![CDATA[
]]>
<![CDATA[	Dim nLastLineHeight]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sName]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim i,j,k,u,z]]>
<![CDATA[
]]>
<![CDATA[	Dim hDiff,lDiff,pDiff	]]>
<![CDATA[
]]>
<![CDATA[	Dim IRatio]]>
<![CDATA[
]]>
<![CDATA[	Dim iName]]>
<![CDATA[
]]>
<![CDATA[	Dim bAnalyzeBlock]]>
<![CDATA[
]]>
<![CDATA[	Dim bCreateFields]]>
<![CDATA[
]]>
<![CDATA[	Dim bCharBounds	]]>
<![CDATA[
]]>
<![CDATA[	Dim pNm]]>
<![CDATA[
]]>
<![CDATA[	Dim pHt]]>
<![CDATA[
]]>
<![CDATA[	Dim Px]]>
<![CDATA[
]]>
<![CDATA[	Dim Tobj,zTop]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim sMCCO]]>
<![CDATA[
]]>
<![CDATA[	Dim sFillType]]>
<![CDATA[
]]>
<![CDATA[	Dim nGroupValue]]>
<![CDATA[
]]>
<![CDATA[	Dim arGroup]]>
<![CDATA[
]]>
<![CDATA[	Dim bLineAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim nRatio]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	FindZoneLineItems = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Parse and Check Parameter Values	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	bCreateFields = ucase(Trim(createSubfields))  ' Parameter 1]]>
<![CDATA[
]]>
<![CDATA[	bAnalyzeBlock = ucase(Trim(createTempCCO))    ' Parameter 2]]>
<![CDATA[
]]>
<![CDATA[	sFillType     = trim(subfieldFillType)        ' Parameter 3]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj      = ucase(trim(offsetPercent))    ' Parameter 4]]>
<![CDATA[
]]>
<![CDATA[	nRatio        = trim(intersectionRatio)       ' Parameter 5]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'PARAMETER 1]]>
<![CDATA[
]]>
<![CDATA[	If bCreateFields = "" Then bCreateFields = "TRUE"]]>
<![CDATA[
]]>
<![CDATA[	If bCreateFields="TRUE" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("CreateFields option is 'ON'.")]]>
<![CDATA[
]]>
<![CDATA[	ElseIf bCreateFields="FALSE" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("CreateFields option is 'OFF'.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Unknown CreateFields Parameter. Using Default of 'ON'.")]]>
<![CDATA[
]]>
<![CDATA[		bCreateFields="TRUE"]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'PARAMETER 2	]]>
<![CDATA[
]]>
<![CDATA[	If bAnalyzeBlock = "" Then bAnalyzeBlock = "TRUE"]]>
<![CDATA[
]]>
<![CDATA[	If bAnalyzeBlock="TRUE" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("AnalyzeBlock option is 'ON'.")]]>
<![CDATA[
]]>
<![CDATA[	ElseIf bAnalyzeBlock="FALSE" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("AnalyzeBlock option is 'OFF'.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Unknown bAnalyzeBlock Parameter. Using Default of 'ON'.")]]>
<![CDATA[
]]>
<![CDATA[		bAnalyzeBlock="TRUE"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'PARAMETER 3]]>
<![CDATA[
]]>
<![CDATA[	If sFillType = "" Then sFillType = "1:0"]]>
<![CDATA[
]]>
<![CDATA[	If instr(sFillType,":")>0 Then]]>
<![CDATA[
]]>
<![CDATA[		aFillType = Split(sFillType,":")]]>
<![CDATA[
]]>
<![CDATA[		sFillType = aFillType(0)		]]>
<![CDATA[
]]>
<![CDATA[		nGroupvalue = aFillType(1)]]>
<![CDATA[
]]>
<![CDATA[		If Not isnumeric(Trim(nGroupvalue)) Then ]]>
<![CDATA[
]]>
<![CDATA[			nGroupValue=clng(0)]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			nGroupvalue=clng(nGroupValue)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		nGroupValue = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	If NOT instr("1,2",sFillType)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid FillType Parameter")]]>
<![CDATA[
]]>
<![CDATA[		sFillType="1"]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'PARAMETER 4]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(bLineAdj) then]]>
<![CDATA[
]]>
<![CDATA[		bLineAdj = "0"]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  Writelog("offsetPercent = '" & bLineAdj & "'.")]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = cint(bLineAdj)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    'PARAMETER 5]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nRatio) then]]>
<![CDATA[
]]>
<![CDATA[		nRatio = ".25"]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  Writelog("intersectionRatio = '" & nRatio & "'.")]]>
<![CDATA[
]]>
<![CDATA[	nRatio = cdbl(nRatio)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Note: The "LineItem" field Defaults to the first child for the calling field.]]>
<![CDATA[
]]>
<![CDATA[	Set oRootItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oRootPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	Set oCurrLine = Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'look for local offset value before page offset value]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = oRootPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While oRootPage.ObjectType > 2 And Not(oRootPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oRootPage = oRootPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If sOffSet = "" then sOffSet = oRootPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'loading current Fingerprint ID]]>
<![CDATA[
]]>
<![CDATA[	sPosName = "Pos" & oRootPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Calculate offset string]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = aOffSet(0)]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = aOffSet(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(IsNumeric(nXoffSet)) Or Len(Trim(nXoffSet))=0 Then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = (-1*nXoffset)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(IsNumeric(nYoffSet)) Or Len(Trim(nYoffSet))=0 Then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = (-1*nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offset Value : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nLines=0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Current Position limits]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)<>3 then arField=SplitNumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	nStarted=0]]>
<![CDATA[
]]>
<![CDATA[	nLastLine = -1]]>
<![CDATA[
]]>
<![CDATA[	hdiff = 0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField(0) = arField(0)-10]]>
<![CDATA[
]]>
<![CDATA[	arField(1) = arField(1)-10]]>
<![CDATA[
]]>
<![CDATA[	If arField(2)>0 then arField(2) = arField(2)+10]]>
<![CDATA[
]]>
<![CDATA[	If arField(3)>0 then arField(3) = arField(3)+10]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Establish Search Limits for ZEROED zone values]]>
<![CDATA[
]]>
<![CDATA[	If arField(0) <= 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If arField(1) <= 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Count > 0 Then arField(1) = CCO.Item(1).Top]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If arField(2) > CCO.Right Or arField(2) <= 0 Then arField(2) = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Lowest zoneCCO Position]]>
<![CDATA[
]]>
<![CDATA[	If arField(3) > CCO.Bottom Or arField(3) <= 0  Then ]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Count>0 then ]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = CCO.item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If arField(0)>arField(2) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Swapping left and right zone positions")]]>
<![CDATA[
]]>
<![CDATA[		Dim tval]]>
<![CDATA[
]]>
<![CDATA[		tval = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		arField(2) = tval]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If arField(1)>arField(3) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Swapping top and bottom zone positions")]]>
<![CDATA[
]]>
<![CDATA[		tval = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = arField(3)]]>
<![CDATA[
]]>
<![CDATA[		arField(3) = tval]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.Variable("Position") = "0,0,0,0" or CurrentObj.Variable("Position") = "" then]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("Position") = cstr(arField(0)) & "," & cstr(arfield(1)) & "," & cstr(arfield(2)) & "," & cstr(arField(3))]]>
<![CDATA[
]]>
<![CDATA[	End if ]]>
<![CDATA[
]]>
<![CDATA[		 ]]>
<![CDATA[
]]>
<![CDATA[	iName = oCurPage.Imagename ]]>
<![CDATA[
]]>
<![CDATA[	iName = Left(iName, Len(iName)-4) & "_"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If bAnalyzeBlock = "FALSE" Then]]>
<![CDATA[
]]>
<![CDATA[		Set ZoneCCO = CCO]]>
<![CDATA[
]]>
<![CDATA[	ElseIf Not FileMgr.FileExists(iName & CurrentObj.ID & ".CCO") Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Analyzing New BlockCCO...")]]>
<![CDATA[
]]>
<![CDATA[		Set zoneCCO = CCOCreator.AnalyzeBlock(oRootPage.Imagename,arField(0),arField(1),arField(2),arField(3))	]]>
<![CDATA[
]]>
<![CDATA[		Call GetBlockChars(zoneCCO, arField(0),arField(1),arField(2),arField(3))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call zoneCCO.Save(iName & CurrentObj.ID & ".CCO")]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("CCOBlock") = iName & CurrentObj.ID & ".CCO"]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Dim lbCCOCreator]]>
<![CDATA[
]]>
<![CDATA[		set lbCCOCreator = CreateObject("CCO._CCOCreator.1")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		set zoneCCO = lbCCOCreator.load(iName & CurrentObj.ID & ".CCO")]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Loading BlockCCO '" & iName & CurrentObj.ID & ".CCO" & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 		Set lbCCOCreator = nothing]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Writelog("** FindLineItems v7.5.29 **")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Create and Init Page Height Dictionary - cumulative height counter by page number]]>
<![CDATA[
]]>
<![CDATA[	pNm=0]]>
<![CDATA[
]]>
<![CDATA[	pHt=0]]>
<![CDATA[
]]>
<![CDATA[	prevHt=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Initialize MCCO Page Counter]]>
<![CDATA[
]]>
<![CDATA[	sMCCO=oCurPage.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[	If sMCCO<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = FileMgr.GetFileName(sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("MCCO file loaded: " & sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = sMCCO & "_"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Function to Find Start Line here! ]]>
<![CDATA[
]]>
<![CDATA[	Dim LookTop]]>
<![CDATA[
]]>
<![CDATA[	Dim LookLine]]>
<![CDATA[
]]>
<![CDATA[	Dim LookEnd]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	LookTop = 1]]>
<![CDATA[
]]>
<![CDATA[	LookEnd = zoneCCO.Count]]>
<![CDATA[
]]>
<![CDATA[	LookLine = LookEnd]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call zoneCCO.LocateLines(arField(1),arField(3),LookTop,LookEnd)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("ZNTop='" & arField(1) & "' ZNBottom='" & arField(3) & "' LineTop=" & LookTop & " LBottom=" & LookEnd)]]>
<![CDATA[
]]>
<![CDATA[    If LookTop = 0 or LookEnd = 0 or zoneCCO.Count=0 then ]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("No Recognition Characters in Search Area.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	For i=LookTop To LookEnd	]]>
<![CDATA[
]]>
<![CDATA[		Set oLine=zoneCCO.Item(i)]]>
<![CDATA[
]]>
<![CDATA[		arLine(0)=oLine.Left]]>
<![CDATA[
]]>
<![CDATA[		arLine(1)=oLine.Top]]>
<![CDATA[
]]>
<![CDATA[		arLine(2)=oLine.Right]]>
<![CDATA[
]]>
<![CDATA[		arLine(3)=oLine.Bottom]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		'Cumulative Page Height Counter	- for merged CCO's		]]>
<![CDATA[
]]>
<![CDATA[		If oLine.ImageNum>pNm then 		]]>
<![CDATA[
]]>
<![CDATA[			pNm = oLine.ImageNum		]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		'Calculate an intersection ratio of oLine to Search Area]]>
<![CDATA[
]]>
<![CDATA[		IRatio = 1 'IntersectRatio(arField, arLine)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		ErrorHandler("FindZoneLineItems Position 100")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If IRatio>0 Then 'CCO line is within the Details Search Area	- Line (i) Intersects Detail Area. ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(4) & "Line " & cstr(i) & " Image " & pNm & " '" & oLine.Value & "'")]]>
<![CDATA[
]]>
<![CDATA[			For j=1 To zoneCCO.Item(i).Count]]>
<![CDATA[
]]>
<![CDATA[				Set oWord = zoneCCO.Item(i).Item(j)			]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				arWord(0)=oWord.Left]]>
<![CDATA[
]]>
<![CDATA[				arWord(1)=oWord.Top]]>
<![CDATA[
]]>
<![CDATA[				arWord(2)=oWord.Right]]>
<![CDATA[
]]>
<![CDATA[				arWord(3)=oWord.Bottom]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				'Calculate an intersection ratio of oWord to Search Area]]>
<![CDATA[
]]>
<![CDATA[				IRatio = IntersectRatio(arField, arWord)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				'Calculate GroupWords Area - for SubField Population]]>
<![CDATA[
]]>
<![CDATA[				arGroup=arWord]]>
<![CDATA[
]]>
<![CDATA[				If nGroupValue>clng(0) AND oWord.Count>0 Then]]>
<![CDATA[
]]>
<![CDATA[					'Calculate nPixels]]>
<![CDATA[
]]>
<![CDATA[					nPixels = nGroupValue * ((oWord.Right-oWord.Left)/oWord.Count)]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'Check Word Left]]>
<![CDATA[
]]>
<![CDATA[					If j>1 then ]]>
<![CDATA[
]]>
<![CDATA[						If (oWord.Left-oLine.Item(j-1).Right)<=nPixels Then]]>
<![CDATA[
]]>
<![CDATA[							arGroup(0)=oLine.Item(j-1).left]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'Check Word Right]]>
<![CDATA[
]]>
<![CDATA[					If j<oLine.Count then]]>
<![CDATA[
]]>
<![CDATA[						if (oLine.Item(j+1).Left-oWord.Right)<=nPixels Then	]]>
<![CDATA[
]]>
<![CDATA[							arGroup(2)=oLine.Item(j+1).Right]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					End if	]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				ErrorHandler("FindZoneLineItems Position 200")]]>
<![CDATA[
]]>
<![CDATA[				If IRatio>0 Then 'CCO Word is within the Details Search Area - Word (j) Intersects Detail Area. 							]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'Find Next Child to Create (could be the first child)]]>
<![CDATA[
]]>
<![CDATA[					If nLastLine = -1 Then 							]]>
<![CDATA[
]]>
<![CDATA[						If (CurrentObj.NumOfChildren - Len(CurrentObj.Text)) = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[							'No existing sub-fields found - creating first child]]>
<![CDATA[
]]>
<![CDATA[							CurrentObj.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							'Existing sub-fields found - Creating Next child]]>
<![CDATA[
]]>
<![CDATA[							For Px = 1 To (CurrentObj.NumOfChildren - Len(CurrentObj.Text)) ]]>
<![CDATA[
]]>
<![CDATA[								sBaseName = CurrentObj.SetupNode().GetRule(0).Name ]]>
<![CDATA[
]]>
<![CDATA[								Set TObj = CurrentObj.GetChild(Px-1)]]>
<![CDATA[
]]>
<![CDATA[								sNum = Replace(TObj.Id,sBaseName,"")]]>
<![CDATA[
]]>
<![CDATA[								If Len(sNum) > 0 And IsNumeric(sNum) Then]]>
<![CDATA[
]]>
<![CDATA[									If CInt(sNum) > nLines Then ]]>
<![CDATA[
]]>
<![CDATA[										nLines = CInt(sNum)]]>
<![CDATA[
]]>
<![CDATA[										'writelog(Space(6) & "Next Line number changes to:" & nLines)]]>
<![CDATA[
]]>
<![CDATA[									End If]]>
<![CDATA[
]]>
<![CDATA[								End If 	]]>
<![CDATA[
]]>
<![CDATA[								Set Tobj=nothing]]>
<![CDATA[
]]>
<![CDATA[							Next 'P	]]>
<![CDATA[
]]>
<![CDATA[							nLines = nLines + 1					]]>
<![CDATA[
]]>
<![CDATA[						End If					]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'THIS SECTION CREATES NEW LINES ONLY]]>
<![CDATA[
]]>
<![CDATA[					If nLines = 0 And i <> nLastLine Then ]]>
<![CDATA[
]]>
<![CDATA[						'ONLY 1ST LINE LOGIC						]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						Set oCurrLine=CurrentObj.GetChild(nLines)]]>
<![CDATA[
]]>
<![CDATA[						If oCurrLine Is Nothing Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[						If oCurrLine.variable(sPosName)<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine = splitnumber(oCurrLine.variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[						ElseIf oCurrLine.Variable("Position")<>"" then]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine = splitnumber(oCurrLine.Variable("Position")) ]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine = splitnumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						'Calculate Zone Height]]>
<![CDATA[
]]>
<![CDATA[						zTop = arCurrLine(1)]]>
<![CDATA[
]]>
<![CDATA[						hDiff = arCurrLine(3)-arCurrLine(1)]]>
<![CDATA[
]]>
<![CDATA[						lDiff = arLine(3)-arLine(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'Calculate % difference in height]]>
<![CDATA[
]]>
<![CDATA[						If hDiff>lDiff Then pDiff = lDiff/hDiff		]]>
<![CDATA[
]]>
<![CDATA[				 		If lDiff>hDiff Then pDiff = hDiff/lDiff]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'Calculate local offset]]>
<![CDATA[
]]>
<![CDATA[						'Writelog("LOF%:'" & cint(abs(oLine.Left-arCurrLine(0))/(arCurrLine(2)-arCurrLine(0))*100) & "%'")]]>
<![CDATA[
]]>
<![CDATA[						'Writelog("CurXoff:'" & nXoffset & "' PercentXoff:'" & (oLine.Left-arCurrLine(0))& "'")]]>
<![CDATA[
]]>
<![CDATA[						If bLineAdj>cint(0) Then]]>
<![CDATA[
]]>
<![CDATA[							If cint(abs(oLine.Left-arCurrLine(0))/(arCurrLine(2)-arCurrLine(0))*100)<=bLineAdj then]]>
<![CDATA[
]]>
<![CDATA[								nXoffset = (oLine.Left-arCurrLine(0))]]>
<![CDATA[
]]>
<![CDATA[								Writelog("Line X offset:'" & nXoffset & "'")]]>
<![CDATA[
]]>
<![CDATA[							End if	]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'Adjust Zone Positions]]>
<![CDATA[
]]>
<![CDATA[                        If arCurrLine(2)>arCurrLine(0) Then]]>
<![CDATA[
]]>
<![CDATA[    						arCurrLine(0) = arCurrLine(0) + CLng(nXoffset)					]]>
<![CDATA[
]]>
<![CDATA[		    				arCurrLine(2) = arCurrLine(2) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[                        End if]]>
<![CDATA[
]]>
<![CDATA[                        arCurrLine(1) = arLine(1) 'Set Top of new line to current CCO line]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'Need to check zone height restrictions for 1 or 2+ lines-]]>
<![CDATA[
]]>
<![CDATA[						'i.e. are all subfields on same H plane or check line height vs Zone height as a percentage.]]>
<![CDATA[
]]>
<![CDATA[						If pDiff<.8 Then ]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine(3) = arCurrLine(1) + CLng(hdiff) 'Set Bottom of new line to current + zone height]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine(3) = arLine(3) ]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						'Save Adjusted Zone & ID]]>
<![CDATA[
]]>
<![CDATA[						oCurrLine.Id = oCurrLine.Id & CStr(nLines)]]>
<![CDATA[
]]>
<![CDATA[						oCurrLine.Variable("Zone") = CStr(arField(0)) & "," & CStr(arLine(1)) & "," & CStr(arField(2)) & "," & CStr(arLine(3))														]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[						'Save Adjusted Position]]>
<![CDATA[
]]>
<![CDATA[						oCurrLine.Variable("Position") = CStr(arCurrLine(0)) & "," & CStr(arCurrLine(1)-clng(pHt)) & "," & CStr(arCurrLine(2)) & "," & CStr(arCurrLine(3)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[						If pNm>1 then]]>
<![CDATA[
]]>
<![CDATA[							If Ucase(FileMgr.GetFileName(oCurrLine.Variable("IMAGEFILE")))<>ucase(oCurPage.Variable(sMCCO & cstr(pNm))) then							]]>
<![CDATA[
]]>
<![CDATA[								If Trim(oCurPage.Variable(sMCCO & cstr(pNm)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[                                    oCurrLine.Variable("IMAGEFILE")=oCurPage.Variable(sMCCO & cstr(pNm))]]>
<![CDATA[
]]>
<![CDATA[	                            end if]]>
<![CDATA[
]]>
<![CDATA[    						End if]]>
<![CDATA[
]]>
<![CDATA[							oCurrLine.Variable("IMAGEHEIGHT")=oLine.ImageHeight]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[											]]>
<![CDATA[
]]>
<![CDATA[						'Create Sub Fields T/F]]>
<![CDATA[
]]>
<![CDATA[						If bCreateFields = "TRUE" Then Call oCurrLine.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						ErrorHandler("FindZoneLineItems Position 300")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						For k = 1 To (oCurrLine.NumOfChildren - Len(oCurrLine.text)) 																	]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							Set oSubRootChild = oCurrLine.GetChild(k-1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							If oSubRootChild.Variable(sPosName)<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[								arRoot = splitnumber(oSubRootChild.Variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[							Else]]>
<![CDATA[
]]>
<![CDATA[								arRoot = splitnumber(oSubRootChild.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[												]]>
<![CDATA[
]]>
<![CDATA[							hDiff = arRoot(3)-arRoot(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							'Adjust Zone Positions]]>
<![CDATA[
]]>
<![CDATA[							If arRoot(2)>arRoot(0) then    ]]>
<![CDATA[
]]>
<![CDATA[                                arRoot(0) = arRoot(0) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[							    arRoot(2) = arRoot(2) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[                            End if]]>
<![CDATA[
]]>
<![CDATA[                            arRoot(1) = arCurrLine(1) + (arRoot(1) - CLng(zTop))]]>
<![CDATA[
]]>
<![CDATA[							arRoot(3) = arRoot(1) + CLng(hDiff)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[							If arRoot(0)<clng(0) then arRoot(0)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[							If arRoot(2)<clng(0) then arRoot(2)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[  							'Save Adjusted Position]]>
<![CDATA[
]]>
<![CDATA[							oSubRootChild.Variable("Position") = CStr(arRoot(0)) & "," & CStr(arRoot(1)-clng(pHt)) & "," & CStr(arRoot(2)) & "," & CStr(arRoot(3)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							sPos = CStr(arRoot(0)) & "," & CStr(arWord(1)) & "," & CStr(arRoot(2)) & "," & CStr(arWord(3))]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							oSubRootChild.Variable("Zone") = sPos]]>
<![CDATA[
]]>
<![CDATA[							oSubRootChild.Status = 0]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[							If pNm>1 then oSubRootChild.Variable("IMAGEHEIGHT")=oLine.ImageHeight]]>
<![CDATA[
]]>
<![CDATA[						Next 'k											]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						nLastLine = i]]>
<![CDATA[
]]>
<![CDATA[						nLines = nLines + 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					Elseif nLines > 0 And i <> nLastLine Then ]]>
<![CDATA[
]]>
<![CDATA[						'2ND LINE+ LOGIC]]>
<![CDATA[
]]>
<![CDATA[						'Check if word is within the last LineItem's boundries. If yes then bypass creating a new lineitem.]]>
<![CDATA[
]]>
<![CDATA[						IRatio = IntersectRatio(arCurrLine, arWord)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						If IRatio=0 Then 	]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[							'Get Last Child of same type if oCurrLine is Nothing]]>
<![CDATA[
]]>
<![CDATA[							If oCurrLine is Nothing then Set oCurrLine = CurrentObj.GetChild(CurrentObj.NumOfChildren - Len(CurrentObj.Text)-1)]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							'Create Next Line & Index Name]]>
<![CDATA[
]]>
<![CDATA[							sBaseName = CurrentObj.SetupNode().GetRule(0).Name ]]>
<![CDATA[
]]>
<![CDATA[							Set oNextLine=CurrentObj.AddChild(3, sBaseName & CStr(nLines), -1)]]>
<![CDATA[
]]>
<![CDATA[							If oNextLine Is Nothing Then Exit For]]>
<![CDATA[
]]>
<![CDATA[							oNextLine.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[							oNextLine.Status = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							'Get Zone Position Info]]>
<![CDATA[
]]>
<![CDATA[							If oNextLine.variable(sPosName)<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine = splitnumber(oNextLine.variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[							ElseIf oNextLine.Variable("Position")<>"" then]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine = splitnumber(oNextLine.Variable("Position")) ]]>
<![CDATA[
]]>
<![CDATA[							Else]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine = splitnumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							'Calculate Zone Height]]>
<![CDATA[
]]>
<![CDATA[							zTop = arCurrLine(1)]]>
<![CDATA[
]]>
<![CDATA[							hDiff = arCurrLine(3)-arCurrLine(1)]]>
<![CDATA[
]]>
<![CDATA[							lDiff = arLine(3)-arLine(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							'Calculate % difference in height]]>
<![CDATA[
]]>
<![CDATA[							If hDiff>lDiff Then pDiff = lDiff/hDiff		]]>
<![CDATA[
]]>
<![CDATA[				 			If lDiff>hDiff Then pDiff = hDiff/lDiff]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							'Calculate local offset]]>
<![CDATA[
]]>
<![CDATA[							'Writelog("LOF%:'" & cint(abs(oLine.Left-arCurrLine(0))/(arCurrLine(2)-arCurrLine(0))*100) & "%'")]]>
<![CDATA[
]]>
<![CDATA[							'Writelog("CurXoff:'" & nXoffset & "' PercentXoff:'" & (oLine.Left-arCurrLine(0))& "'")]]>
<![CDATA[
]]>
<![CDATA[							If bLineAdj>cint(0) Then]]>
<![CDATA[
]]>
<![CDATA[								If cint(abs(oLine.Left-arCurrLine(0))/(arCurrLine(2)-arCurrLine(0))*100)<=bLineAdj then]]>
<![CDATA[
]]>
<![CDATA[									nXoffset = (oLine.Left-arCurrLine(0))]]>
<![CDATA[
]]>
<![CDATA[									Writelog("Line X offset:'" & nXoffset & "'")]]>
<![CDATA[
]]>
<![CDATA[								End if	]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							'Adjust Zone Positions]]>
<![CDATA[
]]>
<![CDATA[                            If arCurrLine(2)>arCurrLine(0) Then]]>
<![CDATA[
]]>
<![CDATA[    							arCurrLine(0) = arCurrLine(0) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[	                            arCurrLine(2) = arCurrLine(2) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[                            End if]]>
<![CDATA[
]]>
<![CDATA[    						arCurrLine(1) = arLine(1) 'Set Top of new line to current CCO line]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[							'Need to check zone height restrictions for 1 or 2+ lines-]]>
<![CDATA[
]]>
<![CDATA[							'i.e. are all subfields on same H plane or check line height vs Zone height as a percentage.]]>
<![CDATA[
]]>
<![CDATA[							If pDiff<.8 Then ]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine(3) = arCurrLine(1) + CLng(hdiff) 'Set Bottom of new line to current + zone height]]>
<![CDATA[
]]>
<![CDATA[							Else]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine(3) = arLine(3) ]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[							'Save Adjusted Position]]>
<![CDATA[
]]>
<![CDATA[							oNextLine.Variable("Position") = CStr(arCurrLine(0)) & "," & CStr(arCurrLine(1)-clng(pHt)) & "," & CStr(arCurrLine(2)) & "," & CStr(arCurrLine(3)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[							oNextLine.Variable("Zone") = CStr(arField(0)) & "," & CStr(arLine(1)) & "," & CStr(arField(2)) & "," & CStr(arLine(3))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[							If pNm>1 then]]>
<![CDATA[
]]>
<![CDATA[								If Ucase(FileMgr.GetFileName(oNextLine.Variable("IMAGEFILE")))<>ucase(oCurPage.Variable(sMCCO & cstr(pNm))) then]]>
<![CDATA[
]]>
<![CDATA[									If Trim(oCurPage.Variable(sMCCO & cstr(pNm)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[                                        oNextLine.Variable("IMAGEFILE")=oCurPage.Variable(sMCCO & cstr(pNm))]]>
<![CDATA[
]]>
<![CDATA[                                    end if]]>
<![CDATA[
]]>
<![CDATA[								End if]]>
<![CDATA[
]]>
<![CDATA[								oCurrLine.Variable("IMAGEHEIGHT")=oLine.ImageHeight]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[																]]>
<![CDATA[
]]>
<![CDATA[							If bCreateFields = "TRUE" Then Call oNextLine.CreateFields]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							ErrorHandler("FindZoneLineItems Position 400")	]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							For k = 1 To (oNextLine.NumOfChildren - Len(oNextLine.text))				]]>
<![CDATA[
]]>
<![CDATA[								If oCurrLine is Nothing Then Exit For]]>
<![CDATA[
]]>
<![CDATA[													]]>
<![CDATA[
]]>
<![CDATA[								Set oSubChildField = oNextLine.GetChild(k-1)]]>
<![CDATA[
]]>
<![CDATA[								Set oSubRootChild = oCurrLine.GetChild(k-1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[								If oSubRootchild Is Nothing Then Exit For]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								If oSubRootChild.Variable("Zone")<>"" Then]]>
<![CDATA[
]]>
<![CDATA[									arRoot = splitNumber(oSubRootChild.Variable("Zone"))]]>
<![CDATA[
]]>
<![CDATA[								Else]]>
<![CDATA[
]]>
<![CDATA[									arRoot = splitNumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[								End if									]]>
<![CDATA[
]]>
<![CDATA[															]]>
<![CDATA[
]]>
<![CDATA[								sPos = CStr(arRoot(0)) & "," & CStr(arWord(1)) & "," & CStr(arRoot(2)) & "," & CStr(arWord(3))]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[								arSubChildField = splitnumber(oSubChildField.Variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[																							]]>
<![CDATA[
]]>
<![CDATA[								If ubound(arSubChildField)=3 Then				]]>
<![CDATA[
]]>
<![CDATA[									hDiff = arSubChildField(3)-arSubChildField(1)]]>
<![CDATA[
]]>
<![CDATA[								Else]]>
<![CDATA[
]]>
<![CDATA[									arSubChildField = splitnumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[									hDiff = 0	]]>
<![CDATA[
]]>
<![CDATA[								End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[								'Adjust Zone Positions]]>
<![CDATA[
]]>
<![CDATA[                                If arSubChildField(2)>arSubChildField(0) then]]>
<![CDATA[
]]>
<![CDATA[								    arSubChildField(0) = arSubChildField(0) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[								    arSubChildField(2) = arSubChildField(2) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[                                End if]]>
<![CDATA[
]]>
<![CDATA[                                arSubChildField(1) = arCurrLine(1) + (arSubChildField(1) - CLng(zTop))]]>
<![CDATA[
]]>
<![CDATA[								arSubChildField(3) = arSubChildField(1) + CLng(hDiff)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[								If arSubChildField(0)<clng(0) then arSubChildField(0)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[								If arSubChildField(2)<clng(0) then arSubChildField(2)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[  								'Save Adjusted Position]]>
<![CDATA[
]]>
<![CDATA[								oSubChildField.Variable("Position") = CStr(arSubChildField(0)) & "," & CStr(arSubChildField(1)-clng(pHt)) & "," & CStr(arSubChildField(2)) & "," & CStr(arSubChildField(3)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								oSubChildField.Variable("Zone") = sPos]]>
<![CDATA[
]]>
<![CDATA[								oSubChildField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								If pNm>1 then oSubChildField.Variable("IMAGEHEIGHT")=oLine.ImageHeight]]>
<![CDATA[
]]>
<![CDATA[																]]>
<![CDATA[
]]>
<![CDATA[							Next 'k]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[							Set oCurrLine = oNextLine							]]>
<![CDATA[
]]>
<![CDATA[							nLastLine = i]]>
<![CDATA[
]]>
<![CDATA[							nLines = nLines + 1]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							Writelog(Space(5) & "WORD is in Previous Lineitem Area. Intersection Ratio=" & cint(IRatio*100)& "%")						]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					End If	]]>
<![CDATA[
]]>
<![CDATA[					'END of LINE CREATION SECTION		]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					Call ErrorHandler("FindZoneLineItems Position 500")]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'** PLACE CCO VALUE FOR WORD INTO oCurrLine FIELD IF THEY INTERSECT: **]]>
<![CDATA[
]]>
<![CDATA[					arZone = splitNumber(oCurrLine.Variable("Zone"))]]>
<![CDATA[
]]>
<![CDATA[					If IntersectRatio(arZone, arWord) > .25 Then]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						'IF FIELD ALREADY HAS A VALUE MERGE POSITION INFO WITH NEW INTERSECT & SEPARATE VALUE WITH SPACE CHARACTER							]]>
<![CDATA[
]]>
<![CDATA[						If Len(oCurrLine.Text) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[							Set cObj = oCurrLine.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[							bRes = cObj.AddValue(CLng(32),CLng(9))]]>
<![CDATA[
]]>
<![CDATA[							arFieldAdj=splitNumber(oCurrLine.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[							bNew = False]]>
<![CDATA[
]]>
<![CDATA[						Else ]]>
<![CDATA[
]]>
<![CDATA[							'FIRST VALUE FOR FIELD, POSITION INFO IS CURRENT CCO POSITION]]>
<![CDATA[
]]>
<![CDATA[							bNEW = True]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'ADD CURRENT WORD CHARACTERS TO oCurrLine FIELD]]>
<![CDATA[
]]>
<![CDATA[						For M = 1 To oWord.Count]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[							Set oChar = oWord.Item(M)]]>
<![CDATA[
]]>
<![CDATA[							arChar = SplitNumber(oChar.Left & "," & oChar.Top & "," & oChar.Right & "," & oChar.Bottom)								]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							'ADD CHARACTER TO FIELD IF IN ZONE AND FILLTYPE IS BY CHARACTER, OR ADD ALL CHARACTERS IF FILLTYPE IS BY WORD]]>
<![CDATA[
]]>
<![CDATA[							If (IntersectRatio(arZone, arChar)>.10 AND sFillType="2") or sFillType="1" Then ]]>
<![CDATA[
]]>
<![CDATA[								Set cObj = oCurrLine.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[								bRes = cObj.AddValue(CLng(Ascw(oWord.Item(M).value)),CLng(oWord.Item(M).Confidence))]]>
<![CDATA[
]]>
<![CDATA[								bRes = cObj.SetPosition(CLng(oChar.Left),CLng(oChar.Top)-clng(pHt),CLng(oChar.Right),CLng(oChar.Bottom)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[								arCharAdj = SplitNumber(oChar.Left & "," & oChar.Top-pHt & "," & oChar.Right & "," & oChar.Bottom-pHt)]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								'MERGE EXISTING POSITION INFO WITH NEW CHAR POS]]>
<![CDATA[
]]>
<![CDATA[								If bNew = True Then arFieldAdj = arCharAdj]]>
<![CDATA[
]]>
<![CDATA[								arFieldAdj=CombineRect(arCharAdj,arFieldAdj)]]>
<![CDATA[
]]>
<![CDATA[								oCurrLine.Variable("Position")= Join(arFieldAdj,",")]]>
<![CDATA[
]]>
<![CDATA[								bNew = False				]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[						Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					ErrorHandler("FindZoneLineItems Position 600")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					'INSERT CCO TEXT INTO SUBFIELDS ON CURRENT LINE]]>
<![CDATA[
]]>
<![CDATA[					For k = 1 To (oCurrLine.NumOfChildren - Len(oCurrLine.Text))]]>
<![CDATA[
]]>
<![CDATA[						Set oChildField = oCurrLine.GetChild(k-1)]]>
<![CDATA[
]]>
<![CDATA[						If oChildField Is Nothing Then Exit For]]>
<![CDATA[
]]>
<![CDATA[												]]>
<![CDATA[
]]>
<![CDATA[						arZone = splitNumber(oChildField.Variable("Zone"))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						'IF CURRENT SUB FIELD ZONE INTERSECTS THE CURRENT CCO WORD]]>
<![CDATA[
]]>
<![CDATA[						If IntersectRatio(arZone, arWord) > .25 Then]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[							'IF FIELD HAS A VALUE, MERGE POSITION INFO WITH NEW INTERSECT							]]>
<![CDATA[
]]>
<![CDATA[							If Len(oChildField.Text) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[								Set cObj = oChildField.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[								bRes = cObj.AddValue(CLng(32),CLng(9))]]>
<![CDATA[
]]>
<![CDATA[								arFieldAdj=splitNumber(oChildField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[								bNew = False]]>
<![CDATA[
]]>
<![CDATA[							Else ]]>
<![CDATA[
]]>
<![CDATA[								'FIRST VALUE FOR FIELD, POSITION INFO IS CURRENT CCO POSITION]]>
<![CDATA[
]]>
<![CDATA[								bNEW = True]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[															]]>
<![CDATA[
]]>
<![CDATA[							'ADD CHARACTERS TO CURRENT SUBFIELD]]>
<![CDATA[
]]>
<![CDATA[							For M = 1 To oWord.Count]]>
<![CDATA[
]]>
<![CDATA[								'If Err.Number<>0 then writelog("ERR num:" & err.number):Err.clear]]>
<![CDATA[
]]>
<![CDATA[								Set oChar = oWord.Item(M)]]>
<![CDATA[
]]>
<![CDATA[								arChar = SplitNumber(oChar.Left & "," & oChar.Top & "," & oChar.Right & "," & oChar.Bottom)								]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								'ADD CHARACTER TO FIELD IF IN ZONE]]>
<![CDATA[
]]>
<![CDATA[							    If (IntersectRatio(arZone, arChar)>.10 AND sFillType="2") or sFillType="1" Then ]]>
<![CDATA[
]]>
<![CDATA[									Set cObj = oChildField.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[									bRes = cObj.AddValue(CLng(Ascw(oWord.Item(M).value)),CLng(oWord.Item(M).Confidence))]]>
<![CDATA[
]]>
<![CDATA[		  							bRes = cObj.SetPosition(CLng(oChar.Left),CLng(oChar.Top)-clng(pHt),CLng(oChar.Right),CLng(oChar.Bottom)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[									arCharAdj = SplitNumber(oChar.Left & "," & oChar.Top-pHt & "," & oChar.Right & "," & oChar.Bottom-pHt)								]]>
<![CDATA[
]]>
<![CDATA[													]]>
<![CDATA[
]]>
<![CDATA[									'MERGE EXISTING POSITION INFO WITH NEW CHAR POS]]>
<![CDATA[
]]>
<![CDATA[									If bNew = True Then arFieldAdj = arCharAdj]]>
<![CDATA[
]]>
<![CDATA[									arFieldAdj=CombineRect(arCharAdj,arFieldAdj)]]>
<![CDATA[
]]>
<![CDATA[									oChildField.Variable("Position")= Join(arFieldAdj,",")]]>
<![CDATA[
]]>
<![CDATA[									bNew = False				]]>
<![CDATA[
]]>
<![CDATA[								End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							Next]]>
<![CDATA[
]]>
<![CDATA[											]]>
<![CDATA[
]]>
<![CDATA[						    ErrorHandler("FindZoneLineItems Position 700")		]]>
<![CDATA[
]]>
<![CDATA[                        Else]]>
<![CDATA[
]]>
<![CDATA[                            Writelog("IntersectionRatio was " & cstr(IntersectRatio(arZone, arWord)) & " for field " & ochildfield.id)					]]>
<![CDATA[
]]>
<![CDATA[						End If						]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					Next 'k]]>
<![CDATA[
]]>
<![CDATA[				End If	]]>
<![CDATA[
]]>
<![CDATA[			Next 'j]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oSubField = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oSubchildField = Nothing	]]>
<![CDATA[
]]>
<![CDATA[ 	Set oRootItem = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oSubRootChild = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set ochildfield = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oLine = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oWord = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurrLine = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FindZoneLineItems = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<af name="FindLineItems" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	FindLineItems = False]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	'Parse and Check Parameter Values]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Ucase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",,,,", ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  FindLineItems = FindZoneLineItems(aStrParam(0), aStrParam(1), aStrParam(2), aStrParam(3), aStrParam(4))	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="MCCOPositionAdjust" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim CurPgNm]]>
<![CDATA[
]]>
<![CDATA[	Dim AdjAmt]]>
<![CDATA[
]]>
<![CDATA[	Dim NextAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim oMultiPageParent]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oMultiPageParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  MCCOPositionAdjust=False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	While oMultiPageParent.ObjectType<>2 and oMultiPageParent.ObjectType>0]]>
<![CDATA[
]]>
<![CDATA[		Set oMultiPageParent = oMultiPageParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If oMultiPageParent.ObjectType=0 Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Parent Page found.") ]]>
<![CDATA[
]]>
<![CDATA[			MCCOPositionAdjust=False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurPgNm = ucase(FileMgr.GetFileName(CurrentObj.Variable("IMAGEFILE")))]]>
<![CDATA[
]]>
<![CDATA[	AdjAmt = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	NextAdj = oMultiPageParent.Variable(Ucase(CurPgNm))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("IMAGEHEIGHT:" & CurrentObj.Variable("IMAGEHEIGHT"))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check For Document ]]>
<![CDATA[
]]>
<![CDATA[	If NOT IsNumeric(NextAdj) then]]>
<![CDATA[
]]>
<![CDATA[		While oMultiPageParent.ObjectType>1 ]]>
<![CDATA[
]]>
<![CDATA[			Set oMultiPageParent = oMultiPageParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[			If oMultiPageParent.ObjectType=0 Then]]>
<![CDATA[
]]>
<![CDATA[				Writelog("No Parent Document found.") ]]>
<![CDATA[
]]>
<![CDATA[				MCCOPositionAdjust=False]]>
<![CDATA[
]]>
<![CDATA[				Set oMultiPageParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Wend ]]>
<![CDATA[
]]>
<![CDATA[		NextAdj = oMultiPageParent.Variable(Ucase(CurPgNm))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If trim(NextAdj) = "" then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Multipage Variables could be found.")]]>
<![CDATA[
]]>
<![CDATA[			Set oMultiPageParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not isnumeric(NextAdj) then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Multipage Variable must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[		Set oMultiPageParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start Object Image:" & CurPgNm & ". Start Adjustment is:" & clng(AdjAmt))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MCCOPositionAdjust =MCCOPositionAdjuster(oMultiPageParent, CurrentObj,CurPgNm, AdjAmt, NextAdj,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oMultiPageParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GetZoneText" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Clear]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call DCOFieldfromCCO(CurrentObj, CCO)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GetZoneText = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LoadBlockCCO" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	LoadBlockCCO = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileName ]]>
<![CDATA[
]]>
<![CDATA[	sFileName = CurrentObj.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim lbCCOCreator]]>
<![CDATA[
]]>
<![CDATA[	set lbCCOCreator = CreateObject("CCO._CCOCreator.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if FileMgr.FileExists(sFileName) then ]]>
<![CDATA[
]]>
<![CDATA[		set CCO = lbCCOCreator.load(sFileName)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Loading BlockCCO '" & sFileName & "' ")]]>
<![CDATA[
]]>
<![CDATA[		LoadBlockCCO = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("BlockCCO '" & sFileName & "' does not Exist.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 	Set lbCCOCreator = nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AnchorPage" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sName]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim RegExStr]]>
<![CDATA[
]]>
<![CDATA[	Dim nL, nW]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneCCO]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim znField]]>
<![CDATA[
]]>
<![CDATA[	Dim znWidth]]>
<![CDATA[
]]>
<![CDATA[	Dim znHeight ]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AnchorPage = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sName=CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AnchorPage " & sName)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nChildren = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For nChild = 0 to nChildren -1]]>
<![CDATA[
]]>
<![CDATA[		Set oField = CurrentObj.GetChild(nChild)]]>
<![CDATA[
]]>
<![CDATA[		Do While Not oField is Nothing		]]>
<![CDATA[
]]>
<![CDATA[			If oField Is Nothing Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			If Not left(oField.ID & Space(6),6) = "Anchor" Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			sWord=oField.Variable("Word" & sName)	]]>
<![CDATA[
]]>
<![CDATA[			If sWord="" Then Exit Do	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Anchor Word value : "  & sWord)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			sPosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[			arField=SplitNumber(oField.Variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[			If UBound(arField)<3 Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			znField=arField]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			znWidth = znField(2)-znField(0)		]]>
<![CDATA[
]]>
<![CDATA[			znHeight = znField(3)-znField(1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			'Search area left position]]>
<![CDATA[
]]>
<![CDATA[			znField(0) = znField(0)-(2*znWidth)]]>
<![CDATA[
]]>
<![CDATA[			If znField(0) < 0 then znField(0) = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Search area right position]]>
<![CDATA[
]]>
<![CDATA[			znField(2) = znField(2)+(2*znWidth)]]>
<![CDATA[
]]>
<![CDATA[			if znField(2) > CCO.Right then znField(2) = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Search area top position]]>
<![CDATA[
]]>
<![CDATA[			znField(1) = znField(1)-(4*znHeight)]]>
<![CDATA[
]]>
<![CDATA[			if znField(1) < 0 then znField(1) = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Search area bottom position]]>
<![CDATA[
]]>
<![CDATA[			znField(3) = znField(3)+(4*znHeight)]]>
<![CDATA[
]]>
<![CDATA[			if znField(3) > CCO.Bottom then znField(3) = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			Set zoneCCO = CCOCreator.AnalyzeBlock(oCurPage.Imagename,znField(0),znField(1),znField(2),znField(3))	]]>
<![CDATA[
]]>
<![CDATA[			Call GetBlockChars(zoneCCO, znField(0),znField(1),znField(2),znField(3))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			RegExStr = RegExBuild(bInteractive, bDebug, sWord)]]>
<![CDATA[
]]>
<![CDATA[			If not FindKey(bInter, bDebug, RegExStr) then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			nL=0]]>
<![CDATA[
]]>
<![CDATA[			nW=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Call CCO.GetCurrentPosition(nL, nW)]]>
<![CDATA[
]]>
<![CDATA[			Writelog("sName")]]>
<![CDATA[
]]>
<![CDATA[			Set oWord=CCO.Item(nL).Item(nW)]]>
<![CDATA[
]]>
<![CDATA[			If oWord Is Nothing Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			nXOffset=oWord.Left-arField(0)]]>
<![CDATA[
]]>
<![CDATA[			nYOffset=oWord.Top-arField(1)]]>
<![CDATA[
]]>
<![CDATA[			nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			writelog("X offset - " & CStr(nXOffset))]]>
<![CDATA[
]]>
<![CDATA[			writelog("Y offset - " & CStr(nYOffset))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Call ZoneChildren(CurrentObj, sPosName,0,nXOffset,nYOffset)]]>
<![CDATA[
]]>
<![CDATA[			AnchorPage = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		loop]]>
<![CDATA[
]]>
<![CDATA[	Next 'nChild]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("Anchor Value not found...loading raw Zone positions. (non adjusted)")]]>
<![CDATA[
]]>
<![CDATA[	Call ZoneChildren(CurrentObj, sPosName,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneImage_SaveAs" access="public" bInter="bInter" bDebug="bDebug" strParam="StrFileName">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	']]>
<![CDATA[
]]>
<![CDATA[	' 	Rule Manager Example: (Called on 'DETAILS' field)]]>
<![CDATA[
]]>
<![CDATA[	'		ZoneImage_SaveAs("SAMMY"+@TYPE+@DATE+JJJ) --> "..\SAMMYDETAILS243.tif" 		]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Dim oParentPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oDCImage]]>
<![CDATA[
]]>
<![CDATA[	Dim aCurrPos	]]>
<![CDATA[
]]>
<![CDATA[	Dim lx, ly, lw, lh]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDCImage= Nothing]]>
<![CDATA[
]]>
<![CDATA[	ZoneImage_SaveAs = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParentPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While oParentPage.ObjectType > 2 AND oParentPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParentPage=  oParentPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oParentPage.ImageName <> "" then ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Set oDCImage= CreateObject("DCIMAGE.DCImageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[		If oDCImage is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Unable to Create DCImage Object!")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		oDCImage.FileName = oParentPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[		If SetZoneImageName(bInter, bDebug, StrFileName) = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Zone Positions found: '" & sPosition & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		if sPosition = "" or sPosition = "0,0,0,0" or not(isnumeric(replace(sPosition,",",""))) then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Zone Position Information Found for Component '" & CurrentObj.ID & "', no area to save.")]]>
<![CDATA[
]]>
<![CDATA[			Set oDCImage= Nothing]]>
<![CDATA[
]]>
<![CDATA[			Exit Function ]]>
<![CDATA[
]]>
<![CDATA[		End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		aCurrPos = splitnumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		lx = clng(aCurrPos(0))]]>
<![CDATA[
]]>
<![CDATA[		ly = clng(aCurrPos(1))]]>
<![CDATA[
]]>
<![CDATA[		lw = clng(aCurrPos(2)-aCurrPos(0))]]>
<![CDATA[
]]>
<![CDATA[		lh = clng(aCurrPos(3)-aCurrPos(1))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		g_ZoneImageName = g_ZoneImageName & ".tif"]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not FileMgr.FolderExists(g_ZoneImageName) then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Parent folder Not found. Saving Image to Batch Directory.")]]>
<![CDATA[
]]>
<![CDATA[			g_ZoneImageName = Pilot.BatchDir & "\" & g_ZoneImageName]]>
<![CDATA[
]]>
<![CDATA[			Writelog("New full Path:'" & g_ZoneImageName & "'.")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		writelog("Saving X:" & lx & " Y:" & ly & " Width:" & lw & " Height:" & lh & " ImageName:" & g_ZoneImageName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		ZoneImage_SaveAs = oDCImage.SaveZone(lx,ly,lw,lh,g_ZoneImageName)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDCImage= Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AdjustZonesToImageOffset" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("AdjustZonesToImageOffset for " & CurrentObj.id)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AdjustZonesToImageOffset=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sPosName = "Position"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sOffSet=CurrentObj.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	if len(trim(sOffset))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		AdjustZonesToImageOffset = False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = (-1*aOffSet(0))]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = (-1*aOffSet(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offsets : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ZoneChildren(CurrentObj, sPosName, 0, clng(nXoffSet), clng(nYoffSet))]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetEOL" access="public" bInter="bInter" bDebug="bDebug" strParam="bParam">
	<g>
<![CDATA[
]]>
<![CDATA[	SetEOL = False]]>
<![CDATA[
]]>
<![CDATA[	g_SetEOL = bParam]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting End of Line character to: '" & bParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[	If Err.number = 0 then SetEOL = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetEOL_CRLF" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	SetEOL_CRLF = False]]>
<![CDATA[
]]>
<![CDATA[	g_SetEOL = cstr(Chrw(13) & Chrw(10))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting End of Line character to : Carrage Return Line Feed")]]>
<![CDATA[
]]>
<![CDATA[	If Err.number = 0 then SetEOL_CRLF = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindDataBlocks" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim tMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueTop]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueBtm]]>
<![CDATA[
]]>
<![CDATA[	Dim nLine, nWord, pLine]]>
<![CDATA[
]]>
<![CDATA[	Dim index, tindex, bindex]]>
<![CDATA[
]]>
<![CDATA[	Dim MatchCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ileft]]>
<![CDATA[
]]>
<![CDATA[	Dim iRight]]>
<![CDATA[
]]>
<![CDATA[	Dim iTop]]>
<![CDATA[
]]>
<![CDATA[	Dim iBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim sBasename]]>
<![CDATA[
]]>
<![CDATA[	Dim osubfield]]>
<![CDATA[
]]>
<![CDATA[	Dim iName ]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sLine, sWord, sLine2, sWord2]]>
<![CDATA[
]]>
<![CDATA[	Dim xM, bM, cM]]>
<![CDATA[
]]>
<![CDATA[	Dim tLineAdj, bLineAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim sMCCO	]]>
<![CDATA[
]]>
<![CDATA[	Dim nPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim tval]]>
<![CDATA[
]]>
<![CDATA[	Dim nHeight	]]>
<![CDATA[
]]>
<![CDATA[	Dim tLine,tWord]]>
<![CDATA[
]]>
<![CDATA[	Dim prevLine]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  FindDataBlocks = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	regEx.IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Set Extremes]]>
<![CDATA[
]]>
<![CDATA[	iTop = clng(CCO.Bottom)]]>
<![CDATA[
]]>
<![CDATA[	iLeft = clng(CCO.Right)]]>
<![CDATA[
]]>
<![CDATA[	iRight = clng(CCO.Left)]]>
<![CDATA[
]]>
<![CDATA[	iBottom = clng(CCO.Top)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find CCO Limits]]>
<![CDATA[
]]>
<![CDATA[	For cM = 1 to CCO.Count]]>
<![CDATA[
]]>
<![CDATA[		If iTop > clng(CCO.Item(cM).Top) Then iTop = clng(CCO.Item(cM).Top)]]>
<![CDATA[
]]>
<![CDATA[		If iLeft > clng(CCO.Item(cM).Left) Then iLeft = clng(CCO.Item(cM).Left)]]>
<![CDATA[
]]>
<![CDATA[		If iRight < clng(CCO.Item(cM).Right) Then iRight = clng(CCO.Item(cM).Right)]]>
<![CDATA[
]]>
<![CDATA[		If iBottom < clng(CCO.Item(cM).Bottom) Then iBottom = clng(CCO.Item(cM).Bottom)]]>
<![CDATA[
]]>
<![CDATA[	Next 'cM]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Get Child Base Name]]>
<![CDATA[
]]>
<![CDATA[	sBaseName = CurrentObj.SetupNode().GetRule(0).Name]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set	oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oPage.ObjectType>2 And Not(oPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Current Position limits]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)<>3 then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[        if sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)=3 then ]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = clng(arField(0))]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = clng(arField(1))]]>
<![CDATA[
]]>
<![CDATA[		arField(2) = clng(arField(2))]]>
<![CDATA[
]]>
<![CDATA[		arField(3) = clng(arField(3))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = arField(0)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = arField(1)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(2)>clng(0) then arField(2) = clng(arField(2))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(3)>clng(0) then arField(3) = clng(arField(3))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Establish Search Limits for ZEROED zone values]]>
<![CDATA[
]]>
<![CDATA[		If arField(0) <= clng(0) Then ]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = clng(iLeft)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If arField(1) <= clng(0) Then arField(1) = iTop]]>
<![CDATA[
]]>
<![CDATA[		If arField(2) > iRight Or arField(2) <= 0 Then arField(2) = iRight]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'Find Lowest zoneCCO Position]]>
<![CDATA[
]]>
<![CDATA[		If arField(3) > iBottom Or arField(3) <= clng(0) Then arField(3) = iBottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(0)>arField(2) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping left and right zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(0)]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = arField(2)]]>
<![CDATA[
]]>
<![CDATA[			arField(2) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(1)>arField(3) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping top and bottom zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(1)]]>
<![CDATA[
]]>
<![CDATA[			arField(1) = arField(3)]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		iLeft = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		iTop = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		iRight = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		arField=SplitNumber(cstr(iLeft & "," & iTop & "," & iRight & "," & iBottom))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Find Search Zone Text & Start Index]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Setup Start CCO Position.]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(sLine, sWord, sLine2, sWord2)]]>
<![CDATA[
]]>
<![CDATA[	If sLine=0 then sLine=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2=0 then sLine2=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord2=0 then sWord2=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2>=sLine then ]]>
<![CDATA[
]]>
<![CDATA[		sLine=sLine2]]>
<![CDATA[
]]>
<![CDATA[		sWord=sWord2		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start CCO Position: Line='" & sLine & "' Word='" & sWord & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.LocateLines(arField(1),arField(3),LTop,LBottom)]]>
<![CDATA[
]]>
<![CDATA[	If LTop = 0 or LBottom = 0 then ]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("No Recognition Characters in Search Area.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Adjust Search Area to Start CCO Position	]]>
<![CDATA[
]]>
<![CDATA[	If sLine>LTop and sLine<LBottom Then ]]>
<![CDATA[
]]>
<![CDATA[		LTop = sLine]]>
<![CDATA[
]]>
<![CDATA[		If CCO.item(LTop).Count > sWord Then ]]>
<![CDATA[
]]>
<![CDATA[		    sWord = sWord + 1]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[		    sLine = sLine + 1 ]]>
<![CDATA[
]]>
<![CDATA[			sWord = 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'GET START INDEX		           ]]>
<![CDATA[
]]>
<![CDATA[    StartIndex = CCO.LocateCharIndex(LTop,sWord)]]>
<![CDATA[
]]>
<![CDATA[   	    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Ascending Search from Line:'" & Ltop & "' Word:'" & sWord & "' to Line:'" & LBottom & "' Word:'" & CCO.Item(LBottom).count & "'")	]]>
<![CDATA[
]]>
<![CDATA[	'adjust search text for mid line word location]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sWord>1 and LTop<LBottom Then]]>
<![CDATA[
]]>
<![CDATA[	    For y = sWord to CCO.Item(LTop).Count]]>
<![CDATA[
]]>
<![CDATA[	        str = str & CCO.Item(LTop).Item(y).Value & Space(1)]]>
<![CDATA[
]]>
<![CDATA[	    Next 'y]]>
<![CDATA[
]]>
<![CDATA[	    str = Trim(str) & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[	    LTop = LTop + 1]]>
<![CDATA[
]]>
<![CDATA[        sValue = sValue & str]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[ 	  		]]>
<![CDATA[
]]>
<![CDATA[	For x = LTop to LBottom	]]>
<![CDATA[
]]>
<![CDATA[   			str = Trim(CCO.Item(x).Value) ]]>
<![CDATA[
]]>
<![CDATA[   			If x<CCO.Count then str = str & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   	        sValue = sValue & str]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Initialize MCCO Page Counter]]>
<![CDATA[
]]>
<![CDATA[	sMCCO=oPage.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[	If sMCCO<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = FileMgr.GetFileName(sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("MCCO file loaded: " & sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = sMCCO & "_"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oValueTop = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=1 Then oValueBtm = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Line Adjustments]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=2 Then tLineAdj = Trim(aStrParam(2))	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=3 Then bLineAdj = Trim(aStrParam(3))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Remove Plus sign (its a positive number anyway...)]]>
<![CDATA[
]]>
<![CDATA[	tLineAdj = replace(tLineAdj,"+","")]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = replace(bLineAdj,"+","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Check for numeric value	]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(tLineAdj) Then tLineadj = 0]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(bLineAdj) Then bLineadj = 0]]>
<![CDATA[
]]>
<![CDATA[	tLineadj = clng(tLineadj)]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = clng(bLineadj)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MatchCount = 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindDataBlocks = False]]>
<![CDATA[
]]>
<![CDATA[	modStrParamT = ""]]>
<![CDATA[
]]>
<![CDATA[	modStrParamB = ""]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Find Values: '" & oValueTop & "' to '" & oValueBtm & "'. ")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(oValueTop)>0 And len(oValueBtm)>0 Then ]]>
<![CDATA[
]]>
<![CDATA[		'We have a top & bottom value to search for]]>
<![CDATA[
]]>
<![CDATA[		'Note build RegEx 'OR' string implicitly here...]]>
<![CDATA[
]]>
<![CDATA[		amodStrParamT = Split(oValueTop&"|","|")]]>
<![CDATA[
]]>
<![CDATA[		amodStrParamB = Split(oValueBtm&"|","|")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 1")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		For T = 0 to ubound(amodStrParamT)-1]]>
<![CDATA[
]]>
<![CDATA[			modStrParamT = modStrParamT & RegExBuild(bInteractive, bDebug, amodStrParamT(T))]]>
<![CDATA[
]]>
<![CDATA[			If T < ubound(amodStrParamT)-1 then modStrParamT = modStrParamT & "|"]]>
<![CDATA[
]]>
<![CDATA[		Next 'T]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		For B = 0 to ubound(amodStrParamB)-1]]>
<![CDATA[
]]>
<![CDATA[			modStrParamB = modStrParamB & RegExBuild(bInteractive, bDebug, amodStrParamB(B))]]>
<![CDATA[
]]>
<![CDATA[			If B < ubound(amodStrParamB)-1 then modStrParamB = modStrParamB & "|"]]>
<![CDATA[
]]>
<![CDATA[		Next 'B]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'adding space here compensates for RegEx indexing being Zero based vs. CCO one based.]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = modStrParamT       ]]>
<![CDATA[
]]>
<![CDATA[		Set tMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'adding space here compensates for RegEx indexing being Zero based vs. CCO one based.]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = modStrParamB]]>
<![CDATA[
]]>
<![CDATA[		Set bMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("   Top Matches Count is :" & tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[		writelog("Bottom Matches Count is :" & bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[        'Set iBottom to 0]]>
<![CDATA[
]]>
<![CDATA[        iBottom = clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set tMatch = tMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(tMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				iTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[				nPage = CCO.Item(nLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight = CCO.Item(nLine).ImageHeight				]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				If tLineAdj<>clng(0) Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + tLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iTop = CCO.Item(nline+ tLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[						nPage= CCO.Item(nLine+ tLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[						nHeight= CCO.Item(nLine+ tLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				'check that iTop is Below (>) last calculated iBottom.]]>
<![CDATA[
]]>
<![CDATA[				If iTop>iBottom Then 				]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[					'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[                    'iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[					'tIndex = len(sValue) + StartIndex]]>
<![CDATA[
]]>
<![CDATA[                    tIndex = CCO.LocateCharIndex(CCO.Count,CCO.Item(CCO.Count).Count) 				]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					'CCO Line before Next Top Becomes default Bottom					]]>
<![CDATA[
]]>
<![CDATA[					If xM < tMatches.Count then ]]>
<![CDATA[
]]>
<![CDATA[						Set tMatch = tMatches(xM)]]>
<![CDATA[
]]>
<![CDATA[						tIndex = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[						If CCO.LocateChar(tIndex, nLine, nWord) Then iBottom = CCO.Item(nline-1).Bottom                                                             ]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					'Look For Bottom Word match between Top word spans]]>
<![CDATA[
]]>
<![CDATA[					For bM = 1 to (bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						Set bMatch = bMatches(bM-1)]]>
<![CDATA[
]]>
<![CDATA[						bIndex = bMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[						If (bIndex >= Index) And (bIndex <= tIndex) then]]>
<![CDATA[
]]>
<![CDATA[							If CCO.LocateChar(bIndex, nLine, nWord) Then ]]>
<![CDATA[
]]>
<![CDATA[								'Word Between span found]]>
<![CDATA[
]]>
<![CDATA[								iBottom = CCO.Item(nline).Bottom ]]>
<![CDATA[
]]>
<![CDATA[								WriteLog("Bottom Matched Value: '" & cstr(MatchedTextValue(bMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[								If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[									If CCO.Count >= (nLine + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[										Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[										iBottom = CCO.Item(nline + bLineAdj).Bottom]]>
<![CDATA[
]]>
<![CDATA[									End if]]>
<![CDATA[
]]>
<![CDATA[								End if]]>
<![CDATA[
]]>
<![CDATA[								Exit For]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					Next 'bM]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[						Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[						If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[							Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[							Exit for]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[						oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Position:" & 	oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[						'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[						If nPage>1 then]]>
<![CDATA[
]]>
<![CDATA[							If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[								If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[                                    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[                                end if]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[							oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[						End if		]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[						Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					bFound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	ElseIf len(oValueTop)>0 And len(oValueBtm)=0 Then]]>
<![CDATA[
]]>
<![CDATA[		'We have a top value to search for]]>
<![CDATA[
]]>
<![CDATA[		'modStrParamT = RegExBuild(bInteractive, bDebug, oValueTop)]]>
<![CDATA[
]]>
<![CDATA[		'Note build RegEx or string implicitly here...]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 2.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		amodStrParamT = Split(oValueTop&"|","|")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		For T = 0 to ubound(amodStrParamT)-1]]>
<![CDATA[
]]>
<![CDATA[			modStrParamT = modStrParamT & RegExBuild(bInteractive, bDebug, amodStrParamT(T))]]>
<![CDATA[
]]>
<![CDATA[			If T < ubound(amodStrParamT)-1 then modStrParamT = modStrParamT & "|"]]>
<![CDATA[
]]>
<![CDATA[		Next 'T]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = modStrParamT]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Set tMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Top Matches Count is :" & tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set tMatch = tMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(tMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				iTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[				nPage= CCO.Item(nLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight= CCO.Item(nLine).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				If tLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + tLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iTop = CCO.Item(nline+ tLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[						nPage= CCO.Item(nLine+ tLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[						nHeight= CCO.Item(nLine+ tLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[				iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				'CCO Line before next match becomes bottom, cannot be same line or above]]>
<![CDATA[
]]>
<![CDATA[				Do While xM < tMatches.Count]]>
<![CDATA[
]]>
<![CDATA[					Set tMatch = tMatches(xM)]]>
<![CDATA[
]]>
<![CDATA[					Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[					If CCO.LocateChar(Index, nLineb, nWord) Then ]]>
<![CDATA[
]]>
<![CDATA[						iBottom = CCO.Item(nlineb-1).Bottom]]>
<![CDATA[
]]>
<![CDATA[						If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[							If CCO.Count >= (nLineb - 1 + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[								Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[								iBottom = CCO.Item(nlineb - 1 + bLineAdj).Bottom							]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						If iBottom>iTop And nLineb>nLine Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[					End if	]]>
<![CDATA[
]]>
<![CDATA[					xM = xM + 1		]]>
<![CDATA[
]]>
<![CDATA[                    iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[					'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[				loop	 ]]>
<![CDATA[
]]>
<![CDATA[				'Wend]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[					If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[						Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[						Exit for]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Position:" & 	oSubField.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[					'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[					If nPage>1 then			]]>
<![CDATA[
]]>
<![CDATA[						If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                            If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[							    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[					        End if]]>
<![CDATA[
]]>
<![CDATA[                    	End if]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[					Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	ElseIf len(oValueTop)=0 And len(oValueBtm)>0 Then]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'We have a bottom value to search for ]]>
<![CDATA[
]]>
<![CDATA[		'modStrParamB = RegExBuild(bInteractive, bDebug, oValueBtm)]]>
<![CDATA[
]]>
<![CDATA[		'Note build RegEx or string implicitly here...]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 3")]]>
<![CDATA[
]]>
<![CDATA[		amodStrParamB = Split(oValueBtm&"|","|")]]>
<![CDATA[
]]>
<![CDATA[		Writelog("setup pattern")]]>
<![CDATA[
]]>
<![CDATA[		For B = 0 to ubound(amodStrParamB)-1]]>
<![CDATA[
]]>
<![CDATA[			modStrParamB = modStrParamB & RegExBuild(bInteractive, bDebug, amodStrParamB(B))]]>
<![CDATA[
]]>
<![CDATA[			If B < ubound(amodStrParamB)-1 then modStrParamB = modStrParamB & "|"]]>
<![CDATA[
]]>
<![CDATA[		Next 'B]]>
<![CDATA[
]]>
<![CDATA[		Writelog("set pattern")]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = modStrParamB]]>
<![CDATA[
]]>
<![CDATA[		Writelog("get matches")]]>
<![CDATA[
]]>
<![CDATA[		Set bMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Bottom Matches Count is :" & bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Start position is the Top of the current CCO Pointer location's Next Line - default is current line bottom ]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.GetCurrentPosition(tLine, tWord)]]>
<![CDATA[
]]>
<![CDATA[		If tLine<=1 and tWord<=1 then ]]>
<![CDATA[
]]>
<![CDATA[            iTop = CCO.Item(sLine).top]]>
<![CDATA[
]]>
<![CDATA[	    Else]]>
<![CDATA[
]]>
<![CDATA[            iTop = CCO.Item(sLine).bottom]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    	nPage= CCO.Item(sLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[		nHeight= CCO.Item(sLine).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Count>=sLine+1 and Not(tLine<=1 and tWord<=1) then ]]>
<![CDATA[
]]>
<![CDATA[			iTop = CCO.Item(sLine+1).Top			]]>
<![CDATA[
]]>
<![CDATA[			nPage= CCO.Item(sLine+1).ImageNum	]]>
<![CDATA[
]]>
<![CDATA[			nHeight= CCO.Item(sLine+1).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set bMatch = bMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(bMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = bMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			PrevLine=0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[                If PrevLine<nLine Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				    iBottom = CCO.Item(nline).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				    If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[					    If CCO.Count >= (nLine + bLineAdj) and (nline + bLineAdj>0) Then]]>
<![CDATA[
]]>
<![CDATA[						    Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						    iBottom = CCO.Item(nline + bLineAdj).Bottom]]>
<![CDATA[
]]>
<![CDATA[					    End if				 ]]>
<![CDATA[
]]>
<![CDATA[				    End if]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[				    if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[					    Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[					    If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[						    Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[						    Exit for]]>
<![CDATA[
]]>
<![CDATA[					    End if]]>
<![CDATA[
]]>
<![CDATA[    					]]>
<![CDATA[
]]>
<![CDATA[					    oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[					    oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[					    oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[					    oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[					    Writelog("Position:" & 	oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[					    'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[					    If nPage>1 then]]>
<![CDATA[
]]>
<![CDATA[						    If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[							    If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[                                    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[			                    end if]]>
<![CDATA[
]]>
<![CDATA[            			    End if]]>
<![CDATA[
]]>
<![CDATA[						    oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[					    End if	]]>
<![CDATA[
]]>
<![CDATA[    								]]>
<![CDATA[
]]>
<![CDATA[					    Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[					    Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[				    End if]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[				    'Next Line Top after Last Bottom Line becomes next Top - default is current bottom ]]>
<![CDATA[
]]>
<![CDATA[				    iTop = iBottom]]>
<![CDATA[
]]>
<![CDATA[                    If nLine+bLineAdj>CCO.Count Then nLine=CCO.Count-bLineAdj]]>
<![CDATA[
]]>
<![CDATA[				    nPage= CCO.Item(nLine+ bLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				    nHeight= CCO.Item(nLine + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[				    If (CCO.Count>=(nline+1+ bLineAdj)) Then ]]>
<![CDATA[
]]>
<![CDATA[					    iTop = CCO.Item(nline + 1 + bLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[					    nPage= CCO.Item(nLine + 1 + bLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[					    nHeight= CCO.Item(nLine + 1 + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					    If tLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[						    If CCO.Count >= (nLine + 1 + tLineAdj + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[							    Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[							    iTop = CCO.Item(nline + 1 + tLineAdj + bLineAdj).Top ]]>
<![CDATA[
]]>
<![CDATA[							    nPage= CCO.Item(nline + 1 + tLineAdj + bLineAdj).ImageNum ]]>
<![CDATA[
]]>
<![CDATA[							    nHeight= CCO.Item(nLine + 1 + tLineAdj + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[						    End if]]>
<![CDATA[
]]>
<![CDATA[					    End if				 ]]>
<![CDATA[
]]>
<![CDATA[				    End if]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[			    End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			    MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[            end if]]>
<![CDATA[
]]>
<![CDATA[            PrevLine=nLine]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		If Not(Pilot is Nothing)  And Not IsAlive(LogWindow) then Pilot.ChildrenChanged(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[		FindDataBlocks = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set bMatch = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set tMatch = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set bMatches = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set tMatches = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set ZoneCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindRegExBlocks" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim tMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueTop]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueBtm]]>
<![CDATA[
]]>
<![CDATA[	Dim nLine, nWord, pLine]]>
<![CDATA[
]]>
<![CDATA[	Dim index, tindex, bindex]]>
<![CDATA[
]]>
<![CDATA[	Dim MatchCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ileft]]>
<![CDATA[
]]>
<![CDATA[	Dim iRight]]>
<![CDATA[
]]>
<![CDATA[	Dim iTop]]>
<![CDATA[
]]>
<![CDATA[	Dim iBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim sBasename]]>
<![CDATA[
]]>
<![CDATA[	Dim osubfield]]>
<![CDATA[
]]>
<![CDATA[	Dim iName ]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sLine, sWord, sLine2, sWord2]]>
<![CDATA[
]]>
<![CDATA[	Dim xM, bM, cM]]>
<![CDATA[
]]>
<![CDATA[	Dim tLineAdj, bLineAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim sMCCO	]]>
<![CDATA[
]]>
<![CDATA[	Dim nPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim tval]]>
<![CDATA[
]]>
<![CDATA[	Dim nHeight	]]>
<![CDATA[
]]>
<![CDATA[	Dim tLine,tWord]]>
<![CDATA[
]]>
<![CDATA[    	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    FindRegExBlocks=FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	regEx.IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Set Extremes]]>
<![CDATA[
]]>
<![CDATA[	iTop = clng(CCO.Bottom)]]>
<![CDATA[
]]>
<![CDATA[	iLeft = clng(CCO.Right)]]>
<![CDATA[
]]>
<![CDATA[	iRight = clng(CCO.Left)]]>
<![CDATA[
]]>
<![CDATA[	iBottom = clng(CCO.Top)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    'Find CCO Limits]]>
<![CDATA[
]]>
<![CDATA[	For cM = 1 to CCO.Count]]>
<![CDATA[
]]>
<![CDATA[		If iTop > clng(CCO.Item(cM).Top) Then iTop = clng(CCO.Item(cM).Top)]]>
<![CDATA[
]]>
<![CDATA[		If iLeft > clng(CCO.Item(cM).Left) Then iLeft = clng(CCO.Item(cM).Left)]]>
<![CDATA[
]]>
<![CDATA[		If iRight < clng(CCO.Item(cM).Right) Then iRight = clng(CCO.Item(cM).Right)]]>
<![CDATA[
]]>
<![CDATA[		If iBottom < clng(CCO.Item(cM).Bottom) Then iBottom = clng(CCO.Item(cM).Bottom)]]>
<![CDATA[
]]>
<![CDATA[	Next 'cM]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Get Child Base Name]]>
<![CDATA[
]]>
<![CDATA[	sBaseName = CurrentObj.SetupNode().GetRule(0).Name]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set	oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oPage.ObjectType>2 And Not(oPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Current Position limits]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)<>3 then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[        if sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)=3 then ]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = clng(arField(0))]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = clng(arField(1))]]>
<![CDATA[
]]>
<![CDATA[		arField(2) = clng(arField(2))]]>
<![CDATA[
]]>
<![CDATA[		arField(3) = clng(arField(3))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = arField(0)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = arField(1)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(2)>clng(0) then arField(2) = clng(arField(2))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(3)>clng(0) then arField(3) = clng(arField(3))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Establish Search Limits for ZEROED zone values]]>
<![CDATA[
]]>
<![CDATA[		If arField(0) <= clng(0) Then ]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = clng(iLeft)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If arField(1) <= clng(0) Then arField(1) = iTop]]>
<![CDATA[
]]>
<![CDATA[		If arField(2) > iRight Or arField(2) <= 0 Then arField(2) = iRight]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'Find Lowest zoneCCO Position]]>
<![CDATA[
]]>
<![CDATA[		If arField(3) > iBottom Or arField(3) <= clng(0) Then arField(3) = iBottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(0)>arField(2) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping left and right zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(0)]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = arField(2)]]>
<![CDATA[
]]>
<![CDATA[			arField(2) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(1)>arField(3) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping top and bottom zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(1)]]>
<![CDATA[
]]>
<![CDATA[			arField(1) = arField(3)]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		iLeft = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		iTop = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		iRight = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		arField=SplitNumber(cstr(iLeft & "," & iTop & "," & iRight & "," & iBottom))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	    'Find Search Zone Text & Start Index]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Setup Start CCO Position.]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(sLine, sWord, sLine2, sWord2)]]>
<![CDATA[
]]>
<![CDATA[	If sLine=0 then sLine=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2=0 then sLine2=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord2=0 then sWord2=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2>=sLine then ]]>
<![CDATA[
]]>
<![CDATA[		sLine=sLine2]]>
<![CDATA[
]]>
<![CDATA[		sWord=sWord2		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start CCO Position: Line='" & sLine & "' Word='" & sWord & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.LocateLines(arField(1),arField(3),LTop,LBottom)]]>
<![CDATA[
]]>
<![CDATA[	If LTop = 0 or LBottom = 0 then ]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("No Recognition Characters in Search Area.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Adjust Search Area to Start CCO Position	]]>
<![CDATA[
]]>
<![CDATA[	If sLine>LTop and sLine<LBottom Then ]]>
<![CDATA[
]]>
<![CDATA[		LTop = sLine]]>
<![CDATA[
]]>
<![CDATA[		If CCO.item(LTop).Count > sWord Then ]]>
<![CDATA[
]]>
<![CDATA[		    sWord = sWord + 1]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[		    sLine = sLine + 1 ]]>
<![CDATA[
]]>
<![CDATA[			sWord = 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    'GET START INDEX		           ]]>
<![CDATA[
]]>
<![CDATA[    StartIndex = CCO.LocateCharIndex(LTop,sWord)]]>
<![CDATA[
]]>
<![CDATA[    	    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Ascending Search from Line:'" & Ltop & "' Word:'" & sWord & "' to Line:'" & LBottom & "' Word:'" & CCO.Item(LBottom).count & "'")	]]>
<![CDATA[
]]>
<![CDATA[	'adjust search text for mid line word location]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sWord>1 and LTop<LBottom Then]]>
<![CDATA[
]]>
<![CDATA[	    For y = sWord to CCO.Item(LTop).Count]]>
<![CDATA[
]]>
<![CDATA[	        str = str & CCO.Item(LTop).Item(y).Value & Space(1)]]>
<![CDATA[
]]>
<![CDATA[	    Next 'y]]>
<![CDATA[
]]>
<![CDATA[	    str = Trim(str) & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[	    LTop = LTop + 1]]>
<![CDATA[
]]>
<![CDATA[        sValue = sValue & str]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	    	  		]]>
<![CDATA[
]]>
<![CDATA[   	For x = LTop to LBottom	]]>
<![CDATA[
]]>
<![CDATA[   			str = Trim(CCO.Item(x).Value) ]]>
<![CDATA[
]]>
<![CDATA[   			If x<CCO.Count then str = str & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   	        sValue = sValue & str]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Initialize MCCO Page Counter]]>
<![CDATA[
]]>
<![CDATA[	sMCCO=oPage.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[	If sMCCO<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = FileMgr.GetFileName(sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("MCCO file loaded: " & sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = sMCCO & "_"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oValueTop = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=1 Then oValueBtm = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Line Adjustments]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=2 Then tLineAdj = Trim(aStrParam(2))	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=3 Then bLineAdj = Trim(aStrParam(3))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Remove Plus sign (its a positive number anyway...)]]>
<![CDATA[
]]>
<![CDATA[	tLineAdj = replace(tLineAdj,"+","")]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = replace(bLineAdj,"+","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Check for numeric value	]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(tLineAdj) Then tLineadj = 0]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(bLineAdj) Then bLineadj = 0]]>
<![CDATA[
]]>
<![CDATA[	tLineadj = clng(tLineadj)]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = clng(bLineadj)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MatchCount = 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindRegExblocks = False]]>
<![CDATA[
]]>
<![CDATA[	modStrParamT = ""]]>
<![CDATA[
]]>
<![CDATA[	modStrParamB = ""]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Find Values: '" & oValueTop & "' to '" & oValueBtm & "'. ")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(oValueTop)>0 And len(oValueBtm)>0 Then ]]>
<![CDATA[
]]>
<![CDATA[		'We have a top & bottom value to search for]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 1")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = oValueTop]]>
<![CDATA[
]]>
<![CDATA[		Set tMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = oValueBtm]]>
<![CDATA[
]]>
<![CDATA[		Set bMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Top Matches Count is :" & tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[		writelog("Bottom Matches Count is :" & bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[        'Set iBottom to 0]]>
<![CDATA[
]]>
<![CDATA[        iBottom = clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set tMatch = tMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(tMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				iTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[				nPage = CCO.Item(nLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight = CCO.Item(nLine).ImageHeight				]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				If tLineAdj<>clng(0) Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + tLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iTop = CCO.Item(nline+ tLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[						nPage= CCO.Item(nLine+ tLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[						nHeight= CCO.Item(nLine+ tLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				'check that iTop is Below (>) last calculated iBottom.]]>
<![CDATA[
]]>
<![CDATA[				If iTop>iBottom Then 				]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[                    tIndex = CCO.LocateCharIndex(CCO.count,CCO.Item(CCO.Count).Count)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					'CCO Line before Next Top Becomes default Bottom					]]>
<![CDATA[
]]>
<![CDATA[					If xM < tMatches.Count then ]]>
<![CDATA[
]]>
<![CDATA[						Set tMatch = tMatches(xM)]]>
<![CDATA[
]]>
<![CDATA[						tIndex = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[						If CCO.LocateChar(tIndex, nLine, nWord) Then iBottom = CCO.Item(nline-1).Bottom]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					'Look For Bottom Word match between Top word spans]]>
<![CDATA[
]]>
<![CDATA[					For bM = 1 to (bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						Set bMatch = bMatches(bM-1)]]>
<![CDATA[
]]>
<![CDATA[						bIndex = bMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[						If (bIndex >= Index) And (bIndex <= tIndex) then]]>
<![CDATA[
]]>
<![CDATA[							If CCO.LocateChar(bIndex, nLine, nWord) Then ]]>
<![CDATA[
]]>
<![CDATA[								'Word Between span found]]>
<![CDATA[
]]>
<![CDATA[								iBottom = CCO.Item(nline).Bottom ]]>
<![CDATA[
]]>
<![CDATA[								WriteLog("Bottom Matched Value: '" & cstr(MatchedTextValue(bMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[								If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[									If CCO.Count >= (nLine + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[										Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[										iBottom = CCO.Item(nline + bLineAdj).Bottom]]>
<![CDATA[
]]>
<![CDATA[									End if]]>
<![CDATA[
]]>
<![CDATA[								End if]]>
<![CDATA[
]]>
<![CDATA[								Exit For]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					Next 'bM]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[						Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[						If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[							Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[							Exit for]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[						oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Position:" & 	oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[						'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[						If nPage>1 then]]>
<![CDATA[
]]>
<![CDATA[							If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                                If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[								    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[                                end if]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[							oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[						End if		]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[						Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					bFound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	ElseIf len(oValueTop)>0 And len(oValueBtm)=0 Then]]>
<![CDATA[
]]>
<![CDATA[		'We have a top value to search for]]>
<![CDATA[
]]>
<![CDATA[		'modStrParamT = RegExBuild(bInteractive, bDebug, oValueTop)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 2.1")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = oValueTop]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Set tMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Top Matches Count is :" & tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set tMatch = tMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(tMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				iTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[				nPage= CCO.Item(nLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight= CCO.Item(nLine).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				If tLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + tLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iTop = CCO.Item(nline+ tLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[						nPage= CCO.Item(nLine+ tLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[						nHeight= CCO.Item(nLine+ tLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[				iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				'CCO Line before next match becomes bottom, cannot be same line or above]]>
<![CDATA[
]]>
<![CDATA[				Do While xM < tMatches.Count]]>
<![CDATA[
]]>
<![CDATA[					Set tMatch = tMatches(xM)]]>
<![CDATA[
]]>
<![CDATA[					Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[					If CCO.LocateChar(Index, nLineb, nWord) Then ]]>
<![CDATA[
]]>
<![CDATA[						iBottom = CCO.Item(nlineb-1).Bottom]]>
<![CDATA[
]]>
<![CDATA[						If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[							If CCO.Count >= (nLineb - 1 + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[								Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[								iBottom = CCO.Item(nlineb - 1 + bLineAdj).Bottom							]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						If iBottom>iTop And nLineb>nLine Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[					End if	]]>
<![CDATA[
]]>
<![CDATA[					xM = xM + 1		]]>
<![CDATA[
]]>
<![CDATA[					'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[                    iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[				loop	 ]]>
<![CDATA[
]]>
<![CDATA[				'Wend]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[					If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[						Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[						Exit for]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Position:" & 	oSubField.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[					'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[					If nPage>1 then			]]>
<![CDATA[
]]>
<![CDATA[						If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                            If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[    							oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[                            end if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[					Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	ElseIf len(oValueTop)=0 And len(oValueBtm)>0 Then]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'We have a bottom value to search for ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 3")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = oValueBtm]]>
<![CDATA[
]]>
<![CDATA[		Writelog("get matches")]]>
<![CDATA[
]]>
<![CDATA[		Set bMatches = regEx.Execute(Space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Bottom Matches Count is :" & bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Start position is the Top of the current CCO Pointer location's Next Line - default is current line bottom]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.GetCurrentPosition(tLine, tWord)]]>
<![CDATA[
]]>
<![CDATA[		If tLine<=1 and tWord<=1 then ]]>
<![CDATA[
]]>
<![CDATA[            iTop = CCO.Item(sLine).top]]>
<![CDATA[
]]>
<![CDATA[	    Else]]>
<![CDATA[
]]>
<![CDATA[            iTop = CCO.Item(sLine).bottom]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        pLine=0]]>
<![CDATA[
]]>
<![CDATA[		nPage= CCO.Item(sLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[		nHeight= CCO.Item(sLine).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Count>=sLine+1  and Not(tLine<=1 and tWord<=1) then ]]>
<![CDATA[
]]>
<![CDATA[			iTop = CCO.Item(sLine+1).Top			]]>
<![CDATA[
]]>
<![CDATA[			nPage= CCO.Item(sLine+1).ImageNum	]]>
<![CDATA[
]]>
<![CDATA[			nHeight= CCO.Item(sLine+1).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set bMatch = bMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			Index = bMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index-1, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				    ]]>
<![CDATA[
]]>
<![CDATA[				iBottom = CCO.Item(nline).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + bLineAdj) and (nLine+bLineAdj>0) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iBottom = CCO.Item(nline + bLineAdj).Bottom]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				if arField(1)<=itop and arField(3)>=itop and pLine<nLine then]]>
<![CDATA[
]]>
<![CDATA[                    WriteLog("Matched Value: '" & cstr(MatchedTextValue(bMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[					If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[						Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[						Exit for]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Position:" & 	oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[					'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[					If nPage>1 then]]>
<![CDATA[
]]>
<![CDATA[						If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                            If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[    							oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[                    	    end if]]>
<![CDATA[
]]>
<![CDATA[					    End if]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[					End if	]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[					Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[                                   ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				'Next Line Top after Last Bottom Line becomes next Top - default is current bottom ]]>
<![CDATA[
]]>
<![CDATA[                pLine=nLine]]>
<![CDATA[
]]>
<![CDATA[				iTop = iBottom]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                If nLine+bLineAdj>CCO.Count Then nLine=CCO.Count-bLineAdj]]>
<![CDATA[
]]>
<![CDATA[    			           	]]>
<![CDATA[
]]>
<![CDATA[                nPage= CCO.Item(nLine+ bLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[	    		nHeight= CCO.Item(nLine + bLineAdj).ImageHeight	]]>
<![CDATA[
]]>
<![CDATA[		        ]]>
<![CDATA[
]]>
<![CDATA[				If (CCO.Count>=(nline+1+ bLineAdj)) Then ]]>
<![CDATA[
]]>
<![CDATA[					iTop = CCO.Item(nline + 1 + bLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[                    nPage= CCO.Item(nLine + 1 + bLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[					nHeight= CCO.Item(nLine + 1 + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					If tLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[						If CCO.Count >= (nLine + 1 + tLineAdj + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[							Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[							iTop = CCO.Item(nline + 1 + tLineAdj + bLineAdj).Top ]]>
<![CDATA[
]]>
<![CDATA[                            nPage= CCO.Item(nline + 1 + tLineAdj + bLineAdj).ImageNum ]]>
<![CDATA[
]]>
<![CDATA[							nHeight= CCO.Item(nLine + 1 + tLineAdj + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		If Not(Pilot is Nothing) And Not IsAlive(LogWindow) then Pilot.ChildrenChanged(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[		FindRegExblocks = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set bMatch = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set tMatch = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set bMatches = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set tMatches = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set ZoneCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CalculateLocalOffset" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CalculateLocalOffset=False]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set	oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oPage.ObjectType>2 And Not(oPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sName=oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	If len(sName)=0 then Writelog("No fingerprint ID for this Image found. SetupDCO zone information will not be loaded.")]]>
<![CDATA[
]]>
<![CDATA[	sPosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ReadZones for " & sPosName)]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Setup zone position]]>
<![CDATA[
]]>
<![CDATA[	sZonePos=CurrentObj.Variable(sPosName)]]>
<![CDATA[
]]>
<![CDATA[	If sZonePos = "" or sZonePos = "0,0,0,0" or not(isnumeric(replace(sZonePos,",",""))) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Setup Zone Position Information Found.")		]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aZonePos = splitnumber(sZonePos)]]>
<![CDATA[
]]>
<![CDATA[	Zx = clng(aZonePos(0))]]>
<![CDATA[
]]>
<![CDATA[	Zy = clng(aZonePos(1))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Find current component position	]]>
<![CDATA[
]]>
<![CDATA[	sPosition=CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[	If sPosition = "" or sPosition = "0,0,0,0" or not(isnumeric(replace(sPosition,",",""))) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Committed Component Position Information Found. Checking CCO Position.")	]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aCurrPos = splitnumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Cx = clng(aCurrPos(0))]]>
<![CDATA[
]]>
<![CDATA[	Cy = clng(aCurrPos(1))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Calculate Local Offset(s)]]>
<![CDATA[
]]>
<![CDATA[	nXoffSet = -1*(Cx-Zx)	]]>
<![CDATA[
]]>
<![CDATA[	nYoffSet = -1*(Cy-Zy)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Instr(ucase(StrParam),"X")=0 Then nXoffSet = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Instr(ucase(StrParam),"Y")=0 Then nYoffSet = clng(0)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offset(s) : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Parent.Variable("Image_Offset") = cstr(nXoffSet) & "," & cstr(nYoffSet)]]>
<![CDATA[
]]>
<![CDATA[	CalculateLocalOffset=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="InheritParentPosition" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim sType]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	InheritParentPosition=False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Current Position " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Search for specified Parent]]>
<![CDATA[
]]>
<![CDATA[	StrParam=Trim(StrParam)	]]>
<![CDATA[
]]>
<![CDATA[	While oParent.Type<>StrParam and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oParent.Type=StrParam then]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[		If ubound(arField)=3 then ]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.Variable("Position")=sPosition]]>
<![CDATA[
]]>
<![CDATA[			If oParent.Variable("IMAGEFILE")<>CurrentObj.Variable("IMAGEFILE") then]]>
<![CDATA[
]]>
<![CDATA[                If Trim(oParent.Variable("IMAGEFILE"))<>"" then]]>
<![CDATA[
]]>
<![CDATA[    				CurrentObj.Variable("IMAGEFILE")=oParent.Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[	            end if]]>
<![CDATA[
]]>
<![CDATA[    		End if]]>
<![CDATA[
]]>
<![CDATA[			InheritParentPosition=true]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid Position information found.")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CreateBlockCCO" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oRootPage]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CreateBlockCCO = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oRootPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While oRootPage.ObjectType > 2 And Not(oRootPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oRootPage = oRootPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sPosition = currentObj.variable("Position")]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set CCO = CCOCreator.AnalyzeBlock(oRootPage.Imagename,arField(0),arField(1),arField(2),arField(3))	]]>
<![CDATA[
]]>
<![CDATA[	Call GetBlockChars(CCO, arField(0),arField(1),arField(2),arField(3))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Err.Number=0 then CreateBlockCCO = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindBlocks_WhiteSpace" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim tMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueTop]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueBtm]]>
<![CDATA[
]]>
<![CDATA[	Dim nLine, nWord, pLine]]>
<![CDATA[
]]>
<![CDATA[	Dim index, tindex, bindex]]>
<![CDATA[
]]>
<![CDATA[	Dim MatchCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ileft]]>
<![CDATA[
]]>
<![CDATA[	Dim iRight]]>
<![CDATA[
]]>
<![CDATA[	Dim iTop]]>
<![CDATA[
]]>
<![CDATA[	Dim iBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim sBasename]]>
<![CDATA[
]]>
<![CDATA[	Dim osubfield]]>
<![CDATA[
]]>
<![CDATA[	Dim iName ]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sLine, sWord, sLine2, sWord2]]>
<![CDATA[
]]>
<![CDATA[	Dim xM, bM, cM]]>
<![CDATA[
]]>
<![CDATA[	Dim tLineAdj, bLineAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim sMCCO	]]>
<![CDATA[
]]>
<![CDATA[	Dim nPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim tval]]>
<![CDATA[
]]>
<![CDATA[	Dim nHeight	]]>
<![CDATA[
]]>
<![CDATA[	Dim tLine,tWord]]>
<![CDATA[
]]>
<![CDATA[	Dim prevLine]]>
<![CDATA[
]]>
<![CDATA[  Dim oSetupNode]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    FindBlocks_WhiteSpace = FALSE]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(CCO)=True then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CCO.Count=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Empty CCO is loaded.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Set Extremes]]>
<![CDATA[
]]>
<![CDATA[	iTop = clng(CCO.Bottom)]]>
<![CDATA[
]]>
<![CDATA[	iLeft = clng(CCO.Right)]]>
<![CDATA[
]]>
<![CDATA[	iRight = clng(CCO.Left)]]>
<![CDATA[
]]>
<![CDATA[	iBottom = clng(CCO.Top)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find CCO Limits]]>
<![CDATA[
]]>
<![CDATA[	For cM = 1 to CCO.Count]]>
<![CDATA[
]]>
<![CDATA[		If iTop > clng(CCO.Item(cM).Top) Then iTop = clng(CCO.Item(cM).Top)]]>
<![CDATA[
]]>
<![CDATA[		If iLeft > clng(CCO.Item(cM).Left) Then iLeft = clng(CCO.Item(cM).Left)]]>
<![CDATA[
]]>
<![CDATA[		If iRight < clng(CCO.Item(cM).Right) Then iRight = clng(CCO.Item(cM).Right)]]>
<![CDATA[
]]>
<![CDATA[		If iBottom < clng(CCO.Item(cM).Bottom) Then iBottom = clng(CCO.Item(cM).Bottom)]]>
<![CDATA[
]]>
<![CDATA[	Next 'cM]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Get Child Base Name]]>
<![CDATA[
]]>
<![CDATA[	Set oSetupNode = CurrentObj.SetupNode()]]>
<![CDATA[
]]>
<![CDATA[  If oSetupNode is Nothing then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Field Setup Node not found. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If oSetupNode.NumOfRules<>1 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Subfields exists in the setup DCO for this field. Action requires a Parent/Child field relationship. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sBaseName = oSetupNode.GetRule(0).Name]]>
<![CDATA[
]]>
<![CDATA[	Set oSetupNode = Nothing	]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Set	oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oPage.ObjectType>2 And Not(oPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Current Position limits]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)<>3 then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[        if sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)=3 then ]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = clng(arField(0))]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = clng(arField(1))]]>
<![CDATA[
]]>
<![CDATA[		arField(2) = clng(arField(2))]]>
<![CDATA[
]]>
<![CDATA[		arField(3) = clng(arField(3))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = arField(0)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = arField(1)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(2)>clng(0) then arField(2) = clng(arField(2))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(3)>clng(0) then arField(3) = clng(arField(3))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Establish Search Limits for ZEROED zone values]]>
<![CDATA[
]]>
<![CDATA[		If arField(0) <= clng(0) Then ]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = clng(iLeft)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If arField(1) <= clng(0) Then arField(1) = iTop]]>
<![CDATA[
]]>
<![CDATA[		If arField(2) > iRight Or arField(2) <= 0 Then arField(2) = iRight]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'Find Lowest zoneCCO Position]]>
<![CDATA[
]]>
<![CDATA[		If arField(3) > iBottom Or arField(3) <= clng(0) Then arField(3) = iBottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(0)>arField(2) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping left and right zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(0)]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = arField(2)]]>
<![CDATA[
]]>
<![CDATA[			arField(2) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(1)>arField(3) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping top and bottom zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(1)]]>
<![CDATA[
]]>
<![CDATA[			arField(1) = arField(3)]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		iLeft = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		iTop = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		iRight = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		arField=SplitNumber(cstr(iLeft & "," & iTop & "," & iRight & "," & iBottom))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Find Search Zone Text & Start Index]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Setup Start CCO Position.]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(sLine, sWord, sLine2, sWord2)]]>
<![CDATA[
]]>
<![CDATA[	If sLine=0 then sLine=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2=0 then sLine2=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord2=0 then sWord2=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2>=sLine then ]]>
<![CDATA[
]]>
<![CDATA[		sLine=sLine2]]>
<![CDATA[
]]>
<![CDATA[		sWord=sWord2		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start CCO Position: Line='" & sLine & "' Word='" & sWord & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.LocateLines(arField(1),arField(3),LTop,LBottom)]]>
<![CDATA[
]]>
<![CDATA[	If LTop = 0 or LBottom = 0 then ]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("No Recognition Characters in Search Area.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Adjust Search Area to Start CCO Position	]]>
<![CDATA[
]]>
<![CDATA[	If sLine>LTop and sLine<LBottom Then ]]>
<![CDATA[
]]>
<![CDATA[		LTop = sLine]]>
<![CDATA[
]]>
<![CDATA[		If CCO.item(LTop).Count > sWord Then ]]>
<![CDATA[
]]>
<![CDATA[		    sWord = sWord + 1]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[		    sLine = sLine + 1 ]]>
<![CDATA[
]]>
<![CDATA[			sWord = 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[    	    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Ascending Search from Line:'" & Ltop & "' Word:'" & sWord & "' to Line:'" & LBottom & "' Word:'" & CCO.Item(LBottom).count & "'")	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Initialize MCCO Page Counter]]>
<![CDATA[
]]>
<![CDATA[	sMCCO=oPage.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[	If sMCCO<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = FileMgr.GetFileName(sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("MCCO file loaded: " & sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = sMCCO & "_"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    'Check Parameter	]]>
<![CDATA[
]]>
<![CDATA[	nWhiteSpace = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    If Not isnumeric(nWhiteSpace) or len(nWhiteSpace)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be a Number.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MatchCount = 1]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Divide by Whitespace '" & nWhiteSpace & "' pixels.") ]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[    Dim Blocktop]]>
<![CDATA[
]]>
<![CDATA[    Dim BlockBottom]]>
<![CDATA[
]]>
<![CDATA[    Dim bBlock]]>
<![CDATA[
]]>
<![CDATA[    dim nAvg]]>
<![CDATA[
]]>
<![CDATA[    Dim nCount]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    BlockTop=0]]>
<![CDATA[
]]>
<![CDATA[    BlockBottom=0						]]>
<![CDATA[
]]>
<![CDATA[    bBlock=False	]]>
<![CDATA[
]]>
<![CDATA[    nAvg=0]]>
<![CDATA[
]]>
<![CDATA[    ncount=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    For nLine = Ltop to LBottom]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[        iThisTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[	    iThisBottom = CCO.Item(nLine).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If nLine = CCO.Count then]]>
<![CDATA[
]]>
<![CDATA[            iNextTop = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[            iNextTop = CCO.Item(nline+1).Top]]>
<![CDATA[
]]>
<![CDATA[	        iNextBottom = CCO.Item(nLine+1).Bottom]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        'Calc Avg Line Height (only if below param of MAX height)]]>
<![CDATA[
]]>
<![CDATA[        If clng(iThisBottom-iThisTop)<=clng(nWhiteSpace) then]]>
<![CDATA[
]]>
<![CDATA[            nAvg = clng(nAvg) + clng(iThisBottom-iThisTop)]]>
<![CDATA[
]]>
<![CDATA[            ncount=ncount+1]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[            If clng(nAvg)=clng(0) and clng(nWhiteSpace)>clng(0) then ]]>
<![CDATA[
]]>
<![CDATA[                nAvg=Clng(nWhiteSpace)]]>
<![CDATA[
]]>
<![CDATA[                nCount=1]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        cAvg = clng(nAvg/ncount) ]]>
<![CDATA[
]]>
<![CDATA[        Writelog(cstr(nLine) & " to " & nLine+1 & " : " & cstr(iNextTop-iThisBottom) & "  Avg h '" & cstr(cAvg) & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If clng(iNextTop-iThisBottom)>=clng(nWhitespace) Then        ]]>
<![CDATA[
]]>
<![CDATA[            'WhiteSpaceFound!]]>
<![CDATA[
]]>
<![CDATA[            If BlockTop=0 then ]]>
<![CDATA[
]]>
<![CDATA[                BlockTop=nLine+1]]>
<![CDATA[
]]>
<![CDATA[                Writelog("First Top Set to line " & BlockTop)]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[                BlockBottom=nLine]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Creating Block Line " & BlockTop & " to " & BlockBottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[                nPage= CCO.Item(BlockTop).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight= CCO.Item(BlockTop).ImageHeight		]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[                'CREATE BLOCK         ]]>
<![CDATA[
]]>
<![CDATA[				Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[				If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[					Exit for]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[				oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[				oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[				oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(CCO.Item(BlockTop).Top) & "," & cstr(iRight) & "," & cstr(CCO.Item(BlockBottom).Bottom)]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Position:" & 	oSubField.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[				If nPage>1 then			]]>
<![CDATA[
]]>
<![CDATA[					If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                        If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[						    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[				        End if]]>
<![CDATA[
]]>
<![CDATA[                	End if]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[				End if				]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[				Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[				Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[                MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[                BlockTop=BlockBottom+1]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Top Of Next Block is " & BlockTop)]]>
<![CDATA[
]]>
<![CDATA[                bFound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[			 ]]>
<![CDATA[
]]>
<![CDATA[	Next 'CCO line]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		If Not(Pilot is Nothing)  And Not IsAlive(LogWindow) then Pilot.ChildrenChanged(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[		FindBlocks_WhiteSpace = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set ZoneCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<f name="MergeZones" access="public">
	<p name="SmartParameters">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	   Dim sRect]]>
<![CDATA[
]]>
<![CDATA[     Dim arField]]>
<![CDATA[
]]>
<![CDATA[     Dim bZero]]>
<![CDATA[
]]>
<![CDATA[     Dim aParams]]>
<![CDATA[
]]>
<![CDATA[     Dim posCurObj]]>
<![CDATA[
]]>
<![CDATA[     Dim oNode]]>
<![CDATA[
]]>
<![CDATA[     Dim arMerged]]>
<![CDATA[
]]>
<![CDATA[     Dim sCurRect]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[     On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[     MergeZones=TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     'Array of SmartParameters]]>
<![CDATA[
]]>
<![CDATA[     aParams=Split(Trim(SmartParameters)&",", ",")]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[     'Check for Valid Calling Position]]>
<![CDATA[
]]>
<![CDATA[     sCurRect=Trim(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[     If len(sCurRect)=0 then sCurRect="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[     arMerged=SplitNumber(sCurRect)]]>
<![CDATA[
]]>
<![CDATA[     arMergedZone=arMerged]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[     If UBound(arMerged)<3 Then  ]]>
<![CDATA[
]]>
<![CDATA[  	  Writelog("Calling object has invalid position value:'" & sCurRect & "'")]]>
<![CDATA[
]]>
<![CDATA[        MergeZones=False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[     End if    ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Start Position='" & sCurRect )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     For i = 0 to (ubound(aParams)-1)]]>
<![CDATA[
]]>
<![CDATA[       bZero=True ]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[       Set oNode=DCONav(aParams(i))]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[       If Not IsAlive(oNode) then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("SmartParameter:'" & aParams(i) & "' could not find the requested node. The Position for this node will not be Merged.")]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          'Check for Valid Position]]>
<![CDATA[
]]>
<![CDATA[          sRect=oNode.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("Position:'" & sRect & "'") 	]]>
<![CDATA[
]]>
<![CDATA[   	    arField=SplitNumber(sRect)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          If UBound(arField)=3 Then  ]]>
<![CDATA[
]]>
<![CDATA[  	        If arField(0)>0 or arField(1)>0 or arField(2)=0 or arField(3)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[              	bZero=False]]>
<![CDATA[
]]>
<![CDATA[              End if]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          If bZero=True then]]>
<![CDATA[
]]>
<![CDATA[             Writelog("Position for node '" & oNode.ID & "' is not complete or ZERO (0,0,0,0). The Position for this node will not be Merged.")]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[             If sCurRect="0,0,0,0" Then ]]>
<![CDATA[
]]>
<![CDATA[                'If calling field is zero then set zone to first 'merged' zone]]>
<![CDATA[
]]>
<![CDATA[                sCurRect=sRect]]>
<![CDATA[
]]>
<![CDATA[                arMergedZone=arField]]>
<![CDATA[
]]>
<![CDATA[             Else]]>
<![CDATA[
]]>
<![CDATA[               'merge zone]]>
<![CDATA[
]]>
<![CDATA[               arMergedzone = CombineRect(arMergedzone,arField)]]>
<![CDATA[
]]>
<![CDATA[             End if]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[       End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     CurrentObj.variable("Position")=arMergedzone(0)& "," & arMergedzone(1) & "," & arMergedzone(2) & "," & arMergedzone(3)]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("New Position='" & CurrentObj.variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Function MergeZones")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="PadZone" access="public">
	<p name="SmartParameters">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Dim aParams]]>
<![CDATA[
]]>
<![CDATA[      Dim L,T,R,B]]>
<![CDATA[
]]>
<![CDATA[	    Dim arPaddedRect]]>
<![CDATA[
]]>
<![CDATA[	    Dim arRect]]>
<![CDATA[
]]>
<![CDATA[      Dim sRect ]]>
<![CDATA[
]]>
<![CDATA[	    Dim nParams]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    	PadZone=TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     'Check for Valid Calling Position]]>
<![CDATA[
]]>
<![CDATA[     sRect=Trim(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[     If len(sRect)=0 then sRect="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[     arRect=SplitNumber(sRect)]]>
<![CDATA[
]]>
<![CDATA[     arPaddedRect=arRect]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[     If UBound(arRect)<3 Then  ]]>
<![CDATA[
]]>
<![CDATA[  	  Writelog("Calling object has invalid position value:'" & sRect & "'")]]>
<![CDATA[
]]>
<![CDATA[        PadZone=False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[     End if    ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[	   If len(Trim(SmartParameters))=0 then]]>
<![CDATA[
]]>
<![CDATA[	      Writelog("No parameters value found. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[	      PadZone=False]]>
<![CDATA[
]]>
<![CDATA[	      Exit Function]]>
<![CDATA[
]]>
<![CDATA[	   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Start Position='" & sRect )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Array of Parameters]]>
<![CDATA[
]]>
<![CDATA[      aParams=Split(Trim(SmartParameters)&",", ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nParams=cstr((Ubound(aParams)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Select Case nParams]]>
<![CDATA[
]]>
<![CDATA[		Case "1"]]>
<![CDATA[
]]>
<![CDATA[		'One parameter - pad all LTRB by this value (i.e. expand if positive)]]>
<![CDATA[
]]>
<![CDATA[               L=MetaWord(aParams(0))]]>
<![CDATA[
]]>
<![CDATA[               T=L]]>
<![CDATA[
]]>
<![CDATA[               R=L]]>
<![CDATA[
]]>
<![CDATA[               B=L]]>
<![CDATA[
]]>
<![CDATA[               Writelog("Number of Parameters '1'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Case "2"]]>
<![CDATA[
]]>
<![CDATA[		'Two parameter - pad as X,Y (X: apply to L & R, Y: apply to T & B)]]>
<![CDATA[
]]>
<![CDATA[               L=MetaWord(aParams(0))]]>
<![CDATA[
]]>
<![CDATA[               T=MetaWord(aParams(1))]]>
<![CDATA[
]]>
<![CDATA[               R=L]]>
<![CDATA[
]]>
<![CDATA[               B=T]]>
<![CDATA[
]]>
<![CDATA[               Writelog("Number of Parameters '2'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Case "3","4"]]>
<![CDATA[
]]>
<![CDATA[		'Multi parameter - pad as L,T,R,B : missing values will be treated as zero.]]>
<![CDATA[
]]>
<![CDATA[               L=MetaWord(aParams(0))]]>
<![CDATA[
]]>
<![CDATA[               T=MetaWord(aParams(1))]]>
<![CDATA[
]]>
<![CDATA[               R=MetaWord(aParams(2))]]>
<![CDATA[
]]>
<![CDATA[               B=MetaWord(aParams(3))]]>
<![CDATA[
]]>
<![CDATA[               Writelog("Number of Parameters '3'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Case Else]]>
<![CDATA[
]]>
<![CDATA[		'More than 4]]>
<![CDATA[
]]>
<![CDATA[		   Writelog("Invalid Number of Parameters:'" & nParams & "'. Expecting 1-4")]]>
<![CDATA[
]]>
<![CDATA[		   PadZone=False]]>
<![CDATA[
]]>
<![CDATA[	         Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If len(Trim(L))=0 then L=0]]>
<![CDATA[
]]>
<![CDATA[	If len(Trim(T))=0 then T=0]]>
<![CDATA[
]]>
<![CDATA[	If len(Trim(R))=0 then R=0]]>
<![CDATA[
]]>
<![CDATA[	If len(Trim(B))=0 then B=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(IsNumeric(L)) or Not(IsNumeric(T)) or Not(IsNumeric(R)) or Not(IsNumeric(B)) then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Non Numeric Pad Value. Exiting")]]>
<![CDATA[
]]>
<![CDATA[		PadZone=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      arPaddedRect = PadRect(arRect,L,T,R,B)]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.variable("Position")=arPaddedRect(0)& "," & arPaddedRect(1) & "," & arPaddedRect(2) & "," & arPaddedRect(3)]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("New Position='" & CurrentObj.variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[      Call ErrorHandler("Function PadZone")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'************************************************************
' help.xml for Zones 

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
' Version 8.1.0.39
' Updated 05/23/2011 RFerin
'   32032 Converted RRX file to DLL.
'
' Version 8.1.0.40
' Updated 6/3/2011 PHofle
' * Changed Help for action 'MCCOPositionAdjust'. SPR 32266
'
'************************************************************
]]>
  
<ref id="PopulateZNField" >
  <ap>None.</ap>
  <h>
    This action populates the field value with the full-page recognition results 
    (in the CCO) that fall within the field's zone boundaries.<br/><br/>
    
    This action should be used with fields such as the <i>Invoices</i> application’s 
    <i>Total</i> or <i>Number</i> field.
    <e>
      <b>PopulateZNField()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="PopulateZNLineItemField" >
  <ap>None.</ap>
  <h>
    Populates the fingerprint’s Data file with the recognized value contained inside 
    the zone of a child Field object of a LINEITEM parent field. This action should 
    only be used with sub-fields of the <i>LINEITEM </i>field - ItemID, ItemDesc, 
    Quantity, Price in the <i>Invoices</i> application.
    <e>
      <b>PopulateZNLineItemField()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the bound Field object is the child of a parent Field object - and if 
    a fingerprint’s .cco file containing block information can be found. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="RegisterPage" >
  <ap>None.</ap>
  <h>
    RegisterPage adjusts the y positions of special fields to 'dial in' zones to the current
    fingerprint's word locations. Searches the calling page object for run time field names beginning
    with the word 'Anchor' (case sensitive). Of these fields a search is performed for variables named
    'Word' followed by the calling fingerprint ID (example: 'Word555').  The value of the variable
    retrieved is search for in the current pages CCO, and if found the field's
    zone position is 'y' axis adjusted for any word 'drift' for the given field value.
    <e>
      <b>RegisterPage()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ScanDetails" >
  <ap>None.</ap>
  <h>
    Searches the DETAILS Field object’s zone for instances of a LINEITEM Field object.
    Captures the data in the rows of a Line Item table, row by row.<br/><br/>
    
    This action will capture all potential LINEITEM rows within the parent DETAILS field – 
    even rows that may not fit your criteria for content.<br/><br/>
    
    Note: You will need to run additional RuleSets to delete ineligible Line Items.
    (In the <i>Invoices</i> application, these are the <b>Clean</b> and <b>Filter</b> RuleSets.)
    <e>
      <b>ScanDetails()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the bound<b>Field</b>object contains lines of data. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="ScanDetailsByLines" >
  <ap>Number of lines in each lineitem.</ap>
  <h>
    Searches the DETAILS Field object’s zone for instances of a LINEITEM Field object.  
    Captures the data based on the number of lines (parameter) in a Line Item table, row by row.<br/><br/>
    
    This action will capture all potential LINEITEM rows (consisting of 2 lines each) 
    within the parent DETAILS field – even rows that may not fit your criteria for content.<br/><br/>
    
    Note: You will need to run additional RuleSets to delete ineligible Line Items. 
    (In the <i>Invoices</i> application, these are the <b>Clean</b> and <b>Filter </b>RuleSets.)

    <e>
      <b>ScanDetailsByLines("2")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the bound<b>Field</b>object contains lines of data. Otherwise, <b>False.</b>
  </ret>  
</ref>
  
<ref id="ScanDetailsByVSpace" >
  <ap>Number of vertical pixels in each lineitem.</ap>
  <h>
    Searches the DETAILS Field object’s zone for instances of a LINEITEM Field object.
    Captures the data based on the number of vertical pixels(parameter) in a Line Item table, row by row.
    <e>
      <b>ScanDetailsByLines("45")</b><br/><br/>
      
      This action will capture all potential LINEITEM rows (consisting of 45 pixels lines each) 
      within the parent DETAILS field – even rows that may not
      fit your criteria for content. <br/><br/>
      
      Note: You will need to run additional RuleSets to delete ineligible Line Items.
      (In the <i>Invoices</i> application, these are the <b>Clean</b> and <b>Filter </b>RuleSets.)
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the bound<b>Field</b>object contains lines of data. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="ScanLineItem" >
  <ap>None.</ap>
  <h>
    This action will capture each sub-field within the <i>parent</i> LINEITEM row.
    <e>
      <b>ScanLineItem()</b>      
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneTOP_UpperBound" >
  <ap>None.</ap>  
  <h>
    This action is helpful when experience shows that a certain number of values in 
    this field will be measurably shorter than the zone's height. A follow-up 
    <b>Locate</b> rule with this action will find those values.
    <e>
      <b>ZoneTOP_UpperBound()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneTOP_LowerBound" >
  <ap>None.</ap>  
  <h>
    This action uses the upper boundary of the current field's <b>zone</b> to indicate the bottom of 
    the field's <b>word.</b><br/><br/>
    
    <b><i>Important!</i></b>This action can expand or contract the zone's height, depending on the placement 
    of the word's lower boundary within the current page.<br/>
   <e>
     ZoneTOP_LowerBound()<br/>
     <br/>
     If you find that an unacceptably high percentage of values for a particular field are entered 
     a line too high, consider the use of this action in a follow-up <b>Locate</b> rule to search for 
     the misplaced value.
   </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneBOTTOM_UpperBound" >
  <ap>None.</ap>
  <h>
    Uses the lower boundary of the current field's ZONE to specify the top of the field's WORD. 
    This can result in a taller or shorter word, depending on the location of the zone's lower boundary.
    <e>
      ZoneBOTTOM_UpperBound()<br/>
      <br/>
      This action is helpful when experience shows that a certain number of values 
      in this field extend beyond the word's upper liimit. A follow-up <b>Locate</b>
      rule with this action can find those values.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneBOTTOM_LowerBound" >
  <ap>None.</ap>
  <h>
    Uses the lower boundary of the current field's ZONE to specify the bottom of 
    the field's WORD. This can result in a taller or shorter word, depending on the 
    location of the zone's boundary.
    <e>
      <b>ZoneBOTTOM_LowerBound()</b><br/>
      <br/>
      If you find that an unacceptably high percentage of values for a particular field 
      are entered a line too high, consider the use of this action in a follow-up <b>Locate</b>
      rule to search for the misplaced value.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneLEFT_LeftBound" >
  <ap>None.</ap>
  <h>
    Uses the left boundary of the current field’s WORD to define the left edge of the field’s ZONE.  
    This extends the zone’s width to accommodate the current word.
    <e>
      <b>ZoneLEFT_LeftBound()</b><br/>
      <br/>
      If the field's <i>recognized</i>values occasionally reach beyond the zone's limits, 
      use this action to expand the zone appropriately.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneLEFT_RightBound" >
  <ap>None.</ap>
  <h>
    Uses the right boundary of the current field’s WORD to designate the left edge of the field’s ZONE. 
    This extends the zone’s width to accommodate the current word.
    <e>
      <b>ZoneLEFT_RightBound()</b><br/>
      <br/>
      <b><i>Note:</i></b> The image of a field is often larger than the field's zone, 
      and almost always larger than the field's word.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneRIGHT_LeftBound" >
  <ap>None.</ap>
  <h>
    Uses the left boundary of the current field’s WORD to designate the right edge of the field’s ZONE.
    Note: This action also excludes the word from the zone.
    <e>
      <b>ZoneRight_LeftBound()</b><br/>
      <br/>
      This action can clean the zone by eliminating the word it contains.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneRIGHT_RightBound" >
  <ap>None.</ap>
  <h>
    Uses the right boundary of the current field’s WORD to designate the right edge of the field’s ZONE.<br/><br/>
    This is a convenient action if you find that a certain percentage of 
    the field's entered values extend beyond, to the zone's right edge.
    <e>
      <b>ZoneRIGHT_RightBound()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneRIGHT_ImageRight" >
  <ap>None.</ap>
  <h>
    Uses the right boundary of the current field’s IMAGE to define the right edge of 
    the field’s ZONE. This can extend or contract the zone’s width, depending on the 
    placement of the image’s right side.<br/><br/>
    
    <b><i>Note:</i></b>A field's image is often larger than the field's zone, and
    almost always larger than the field's word.
  <e>
    <b>ZoneRight_ImageRight()</b>
  </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneLEFT_ImageLeft" >
  <ap>None.</ap>  
  <h>
    Uses the left boundary of the current field’s IMAGE to define the left edge of the field’s ZONE.  
    This can extend or contract the zone’s width, depending on the placement of the image’s left side.<br/><br/>
    
    <b><i>Note:</i></b> A field's image is often larger than a field's zone, 
    and almost always larger than the field's word.
  <e>
    <b>ZoneLEFT_ImageLeft()</b>
  </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneBOTTOM_ImageBottom" >
  <ap>None.</ap>
  <h>
    Uses the bottom boundary of the current field’s IMAGE to define the bottom edge of the field’s ZONE.<br/>
    <br/>
    <b><i>Note:</i></b> A field's image is often larger than a field's zone, 
    and almost always larger than the field's word.
  <e>
      <b>ZoneBOTTOM_ImageBottom()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneTOP_ImageTop" >
  <ap>None.</ap>
  <h>
    Uses the upper boundary of the current field’s IMAGE to designate the top edge of the field’s ZONE.
    This can extend or contract the zone’s width, depending on the placement of the image’s left side
    <e>
      <b>ZoneTOP_ImageTop()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="ReadZones" >
  <ap>None.</ap>  
  <h>
    Loads position information for each node in the calling object and it's children. Pre-adjusts 
    these values based on offset information stored in an 'Image_Offset' variable at any node level.<br/>
    Position information is based on the setup DCO position for the parent page's fingerprint ID.<br/> 
    The offset value is applied to all child objects of a node where an 'Image_Offset' variable is found; 
    unless overwritten by a child node also having an Image_Offset value to apply.
  </h>
  <lvl>Page or Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="LoadZones" >
  <ap>Fingerprint ID.</ap>
  <h>
    Loads position information for each node in the calling object and children. Pre-adjusts these
    values based on offset information stored in an 'Image_Offset' variable at any node level.<br/>
    Position information is based on the setup DCO position for the fingerprint ID passed as a parameter.<br/>
    The offset value is applied to all child objects of a node where an 'Image_Offset' variable is found;
    unless overwritten by a child node also having an Image_Offset value to apply.
  </h>
  <lvl>Page or Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>

<ref id="FindZoneLineItems" >
  <ap>
    1. True or False<br/>
    <i>True</i> if the action is to create Line-item fields and their sub-fields.<br/><i>False</i> if
    the action is to create Line-item fields only.<br/>
    <br/>
    2. True or False (OPTIONAL: defaults to True)<br/>
    <i>True</i> if the action is to Analyze the calling zone and create a temporary CCO based on the
    zone contents only for the search.<br/>
    <i>False</i> if the action is to use the existing CCO.<br/>
    <br/>
    3. 1 or 2 (OPTIONAL: Fill Sub fields option - defaults to 1)<br/>
    1 - fill by CCO word; if the CCO words overlap by a certain intersection value then fill sub
    field with its value. Also has sub setting of a colon followed by a group words value. i.e.
    "1:1.5" (treat words 1.5 character spaces apart or closer as one word)<br/>
    2 - fill by CCO character; if the CCO characters overlap by a certain intersection value then
    fill sub field with the character value.<br/><br/>
    4. 0 to 100 (OPTIONAL: Percent offset adjustment - defaults to 0)<br/>
    Moderates the flexibility for the left offset based on the overall length of the line. Use larger
    values for shorter line items.<br/><br/>
    5. .01 to .99 (OPTIONAL: Intersection Ratio - defaults to .25)<br/>
    Changes the intersection ratio of Words and Lines used to determine creation and value of Lineitems
    and their subfields.<br/>
  </ap>
  <h>
    Uses settings for a previously-established zone covering a block of Line Item Detail, 
    and zones for individual Line Items, to assemble a portion of the current page, limited to Line Item Detail.
    <e>
      FindLineItems("True","","","","")<br/><br/>This action retrieves zonal information from the fingerprint
      about a block of Line Item Detail, individual rows, and their fields and sub-fields.
      <br/><br/>
      The action applies this data to a full-length current page as it constructs a separate fingerprint
      containing just Line Item Detail
    </e>
  </h>
  <lvl>
    Field level.
  </lvl>
  <ret>
    <b>False</b> if there is no zone or position information for the Line Item block and its sub-fields,
    or if the parent block does not contain Line Item children. Otherwise, <B>True.</B>
  </ret>
</ref>

<ref id="FindLineItems">
  <ap>
    5 comma separated parameters.  See the help for FindZoneLineItems for details.    
  </ap>
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by FindZoneLineItems.
  </h>
  <see>FindZoneLineItems</see>
</ref>
  
<ref id="MCCOPositionAdjust">
  <ap>None.</ap>
  <h>
    <b>MCCOPositionAdjust</b>is an important action for applications using merged multiple
    page documents. It normalizes position coordinates populated to the DCO when the data is
    generated from a document using a merged CCO. The coordinates are adjusted relative to 
    the page and also sets the DCO ImageFile property to the name of the TIFF that the data was 
    found on.<br/><br/>
    
    Used in conjunction with action <b>MergeCCO_ByType</b> in the <b>Autodoc</b> library.<br/>
    <br/>
    <e>
      <b>MCCOPositionAdjust()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the current document does not consist of more than one source page. 
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="GetZoneText" qi="Retrieves the text in a zoned object of the current page.">
  <ap>None.</ap>
  <h>
    Retrieves the text in a zoned object of the current page.
    <e>
      <b>GetZoneText()</b><br/>
      <br/>
      This action assumes that you have established zone parameters for this <b>Field</b>
      object of the Document Hierarchy.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="LoadBlockCCO" qi="Loads the CCOBlock set up by a previous CreateBlockCCO action. That action assigns the block's location to the current Page object's CCOBlock variable.">
  <ap>None.</ap>
  <lvl>Page level.</lvl>
  <ret>False if the block cannot be found. Otherwise, True.</ret>
  <h>
    Loads the CCOBlock set up by a previous CreateBlockCCO action. That action assigns
    the block's location to the current Page object's CCOBlock variable.
    <e>
      CreateBlockCCO()<br/>
      <b>LoadBlock()</b>
    </e>
  </h>
</ref>
  
<ref id="AnchorPage" qi="Finds the Anchor field on a source page, and uses the Anchor field's coordinates to locate and offset the page's other zoned fields.">
  <ap>None.</ap>
  <h>
    Finds the Anchor field on a source page, and uses the Anchor field's coordinates to locate and offset the page's other zoned fields.
    <e>AnchorPage()</e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the action cannot find the page's Anchor field. Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="ZoneImage_SaveAs" qi="Saves the current Objects Zone area of an image as a separate Image file.">
  <ap>
    A string that defines the file name.<br/><br/>
    You can use these options to format the file name:<br/><br/>

    <b>+@BATCHID</b>   Adds the BatchID to the Zone Image File Name<br/>
    <b>+@ID</b>   Adds the Object ID to the Zone Image File Name"<br/>
    <b>+@STATUS</b>   Adds the Object Status to the Zone Image File Name<br/>
    <b>+@TYPE</b>   Adds the Object Type to Zone Image File Name<br/>
    <b>+@DATE+mm/dd/yyyy</b>   Adds a Date Stamp to the Zone Image File Name - the required trailing date format argument shows as the default, also '+*' can be used<br/>
    <b>+@TIME+HH:MM:SS</b>    Adds a Time Stamp Value to the Zone Image File Name name	- the required trailing time format argument shows as the default, also '+*' can be used<br/>
    <b>+@VALUE</b>   Adds Object Text to Zone Image File Name<br/>
    <b>+#name</b>   Appends the value of a child name to the Image File Name<br/><br/><b>Note:</b>+#name` appends the value of child name to the image name.
  </ap>

  <h>
    Saves the current Objects Zone area of an image as a separate Image file. 
    The Zone Image file is always placed in the Batches directory; saving to the 
    current page will create a multi-page TIFF file with the additional image as its zone.
    <e>
      <b>ZoneImage_SaveAs("SAMMY+@TYPE+@DATE+JJJ")</b><br/><br/>
      As part of a rule bound to the <i>Details</i> <b>Field</b> object 
      of the Document Hierarchy, the action produces this Image File Name: "...\SAMMYDETAILS243.tif"
    </e>
  </h>
  <lvl>Page or Field level.</lvl>
  <ret>
    <b>False</b> if an image cannot be saved. Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="AdjustZonesToImageOffset" qi="Offsets fields on the current image in response to zone criteria in the CCO file of the source page - after the image has been offset.">
  <ap>None.</ap>
  <h>
    Offsets fields on the current image in response to zone criteria in the CCO 
    file of the source page - after the image has been offset.
    <e>AdjustZonesToImageOffset()</e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the action cannot locate the CCO file of the current page. Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="SetEOL" qi="Sets the End of Line character that will be used to separate data from a zone with multiple lines of text. If this action is not used, the default character is a space.">
  <ap>The End of Line separator character.</ap>
  <h>
    Sets the End of Line character that will be used to separate data from a zone 
    with multiple lines of text. If this action is not used, the default character is a space.
    <e>
      <b>SetEOL("|")</b><br/>
      <br/>
      This example sets the End of Line character to the ‘|’ (pipe) character.  
      A capture zone with two lines of text will have the captured value separated 
      by this new character.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="SetEOL_CRLF" qi="Sets the End Of Line character that will be used to separate data from a zone with multiple lines of text.">
  <ap>None.</ap>
  <h>
    Sets the “End Of Line” character that will be used to separate data 
    from a zone with multiple lines of text to the carriage return and 
    Line Feed characters:  ASCII values 13 and 10.
    <e>
      <b>SetEOL_Crlf()</b><br/>
      <br/>
      This sets the End of Line character to the Carriage Return and Line 
      Feed characters.  A capture zone with two lines of text will have 
      the captured value separated by these characters.
    </e>
  </h>
  <lvl>All</lvl>
  <ret>Always True</ret>
</ref>
  
<ref id="FindDataBlocks" qi="Uses Start and End key words to find blocks of data within the current source page.">
  <ap>Key word Start Value, and its End Value.</ap>
  <h>
    Uses Start and End key words to find blocks of data within the current source page. Returns each block's position assigned to a series of repeating fields based on the first child field of the calling object.
    If the page's Fingerprint file (.cco) has a Line position be sure to use action 'GoFirstLine()' to set the Line position to the first word on the first line in the current zone.
    <e>
      <b>GoFirstLine()</b><br/>
      <b>FindDataBlocks("FROM,THRU")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if the action can locate the Data block indicated by the parameter. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="FindRegExBlocks" qi="Uses a Regular Expression to find blocks of data within the current source page. Returns each block's position assigned to a series of repeating fields based on the first child field of the calling object.">
  <ap>
    Regular Expression that contains the data block's Start Value, and its End Value. Parameter is a two part comma separated value of the Values to look for in the current CCO<br/><br/>
    
    1)StartValue<br/>
    2)EndValue<br/><br/>
    
    Start and End value's can be Adjusted up or down by xLines using the 3rd (adj top)
    and 4th (adj bottom) CSV positions.
  </ap>
  <h>
    Uses a Regular Expression to find blocks of data within the current source page. 
    Returns each block's position assigned to a series of repeating fields based 
    on the first child field of the calling object.
    Note: Locate.rra is required for this Action
    <e>
      <b>FindRegExBlocks("/bFROM/b,/bTHRU/b")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if the action can locate the Data block indicated by the parameter. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="CalculateLocalOffset" qi="Calculates the X and/or Y offset amount for the calling field.">
  <ap>
    X and/or Y<br/><br/>
    The action uses these parameters to calculate a new parent page Image_Offset 
    value by comparing the fingerprint zone for the calling field against the current field zone.
  </ap>
  <h>
    Calculates the X and/or Y offset amount for the calling field.
    <e>
      <b>CalculateLocalOffset("XY")</b>
    </e>
  </h>
  <lvl>Field only.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="InheritParentPosition" qi="Provides the bound child object of the Document Hierarchy with the zone parameters of a parent object identified by the parameter.">
  <ap>
    Case-senstive string value of the parent object's name. <i>Details</i>, 
    for example, is the name of a parent <b>Field</b> object in the 
    <i>Invoices</i> application. If the bound object is <i>LINEITEM</i>, 
    the action will provide this child object with the zone parameters of the parent.
  </ap>
  <h>
    Provides the bound child object of the Document Hierarchy with the zone 
    parameters of a parent object identified by the parameter.
    <e>
      <b>InheritParentPosition("Details")</b>
    </e>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the action cannot locate the parent field. Otherwise, <b>True.</b>
  </ret>
</h>
</ref>
  
<ref id="CreateBlockCCO" qi="Creates a temporary in memory CCO object, containing only the words and lines in the calling fields zone position - using the source page's CCO file.">
  <ap>None.</ap>  
  <h>
    Useful when searching images where the data is located asymmetrically across the page. Using this
    action focuses the CCO to only look at the words and lines within the defining zone for all future
    searches for this page.<br/>
    This does not affect the run time CCO. Reloading the page will reload the CCO bound to the page, 
    releasing this temporary CCO.
    <e>
      <b>CreateBlockCCO()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="FindBlocks_WhiteSpace" strParam="Strparam" qi="Uses a vertical white space (pixels) to find blocks of data within the current source page. Returns each block's position assigned to a series of repeating fields based on the first child field of the calling object.">
  <ap>A single parameter indicating the number of pixel between lines.</ap>
  <h>
    Creates a child field with the position of each zone divided out of the calling page's CCO.
    <e>
      <b>FindBlocks_WhiteSpace("27")</b>
    </e>
  </h>
  <lvl>Field having 1 child field.</lvl>
  <ret>
    <b>False</b> if the action cannot divide create any child field/zones. Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="MergeZones" qi="Merges the zone from calling field with zone of dco fields passed as smartparameters.">
    <ap>A CSV of SmartParameter strings indicating the DCO fields to merge zones with.</ap>
    <h>
      Merges calling field's position with each passed dco position.
      <e>
        <b>MergeZones("@P\5PAddTel,@P\5PAddZip,@P\2PatName")</b>
      </e>
    </h>
    <lvl>Field</lvl>
    <ret>
      <b>False</b> if the calling field does not have a valid non zero position. Otherwise, <b>True.</b>
    </ret>
</ref>
  
<ref id="PadZone" qi="Pads the zone by the value passed. Number of CSV passed values varies padding value by vector.">
    <ap>A CSV of SmartParameter strings indicating the pixels value to pad the calling field by.</ap>
    <h>
      Pads calling field's position with each value passed. Number of passed values varies padding vector as follows:<br/>
      1) Pads Left, Top, Right, and Bottom by this value (i.e. expand if positive)<br/>
      2) Pads as X,Y (X: pad to Left and Right, Y: pad to Top and Bottom)<br/>
      3) Pads as Left, Top, Right, and Bottom. (missing values will be treated as zero).
      4) Pads as Left, Top, Right, and Bottom.
      <e>
        <b>PadZone("15")</b> Pads 15 pixels to the Left, Right, Top and Bottom position.<br/>
        <b>PadZone("5,10")</b> Pads 5 pixels to the Left and Right position, and 10 to the Top and Bottom position.<br/>
        <b>PadZone("-5,0,12,25")</b> Pads -5 pixels to the Left, 0 to the Right, 12 to the Top and 25 to the Bottom position.<br/>
      </e>
    </h>
    <lvl>Field</lvl>
    <ret>
      <b>False</b> if the calling field does not have a valid non zero position.<br/>
      <b>False</b> if there are zero or more than four CSV parameters.<br/>
      <b>False</b> if the SmartParameter value returns as a non-numeric.<br/>
      Otherwise, <b>True.</b>
    </ret>
</ref>
</help></rrx>
</rrx4all></rrxdescription>